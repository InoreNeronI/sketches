{"mappings":"","sources":["src/pacman/index.js"],"sourcesContent":["let fontRegular;\n\nfunction preload() {\n  fontRegular = loadFont('../assets/Creepster-Regular.ttf');\n}\n\nfunction setup() {\n  background(100);\n  Z = 40;\n  T = 15;\n  pacx = 11 * Z;\n  pacy = 16 * Z;\n  pacmx = 0;\n  pacmy = 0;\n  pacd = 0;\n  wacn = 0;\n  score = 0;\n  GT = [14, 16, 18, 20];\n  ghostx = [9 * Z, 10 * Z, 11 * Z, 12 * Z];\n  ghosty = [10 * Z, 10 * Z, 10 * Z, 10 * Z];\n  ghostmx = [1, -1, 0, 0];\n  ghostmy = [0, 0, 0, 0];\n  ghoststate = [0, 0, 0, 0];\n  colorMode(HSB, 256);\n  ghostcol = [color(0o0, 200, 255), color(220, 125, 255), color(120, 200, 255), color(20, 150, 255)];\n  colorMode(RGB, 256);\n  powerpellet = 0;\n  pacstate = 0;\n  life = 0;\n\n  levelstring = [\n    '11111111111111111111111',\n    '1          1          1',\n    '1+111 1111 1 1111 111+1',\n    '1 111 1111 1 1111 111 1',\n    '1                     1',\n    '1 111 1 1111111 1 111 1',\n    '1     1    1    1     1',\n    '11111 1111 1 1111 11111',\n    '----1 1         1 1----',\n    '11111 1 111-111 1 11111',\n    '        1-----1        ',\n    '11111 1 1111111 1 11111',\n    '----1 1         1 1----',\n    '11111 1 1111111 1 11111',\n    '1         -1-         1',\n    '1 111 1111-1-1111 111 1',\n    '1+  1   -------   1  +1',\n    '111 1 1 1111111 1 1 111',\n    '1     1    1    1     1',\n    '1 11111111 1 11111111 1',\n    '1                     1',\n    '11111111111111111111111',\n  ];\n  w = 23;\n  h = 22;\n  lvlw = w * Z;\n  lvlh = h * Z;\n  windowWidth = lvlw;\n  windowHeight = lvlh;\n  const myCanvas = createCanvas(windowWidth, windowHeight);\n  myCanvas.parent('Pacman');\n\n  aap = [];\n  for (i = 0; i < w * h; i++) aap.push(getlevel((i % w) * Z, Z * floor(i / w)) == '1' ? -1 : 0);\n}\n\nfunction getlevel(x, y) {\n  var nstr = levelstring[floor(y / Z)];\n  return nstr.charAt(floor(x / Z));\n}\n\nfunction setlevel(x, y, v) {\n  var nstr = levelstring[floor(y / Z)];\n  levelstring[floor(y / Z)] = nstr.substr(0, floor(x / Z)) + v + nstr.substr(floor(x / Z) + 1, 99);\n}\n\nfunction astar(x2, y2, x1, y1) {\n  var aa = aap.slice(0);\n  var q = [x1, y1];\n  //i = 0\n  while (true) {\n    var x = q.shift();\n    var y = q.shift();\n    if (aa[x + y * w] == 0) {\n      if (abs(x - x2) + abs(y - y2) < 2) {\n        //ellipse(x*Z+Z/2,y*Z+Z/2,Z/4)\n        return atan2(y - y2, x - x2);\n      }\n      aa[x + y * w] = 1;\n      //text(i++,x*Z+Z/2,y*Z+Z/2)\n      q.push(x - 1, y, x + 1, y, x, y - 1, x, y + 1);\n    }\n  }\n}\n\nfunction draw() {\n  background(color(32, 32, 64));\n\n  for (y = 0; y < 22; y++) {\n    nstr = levelstring[y];\n    for (x = 0; x < 23; x++)\n      if (aap[x + y * w] == -1) {\n        fill(color(64, 64, 255));\n        rect(x * Z, y * Z, Z, Z);\n      } else if (nstr.charAt(x) == ' ') {\n        fill(color(255, 255, 190));\n        ellipse(x * Z + Z / 2, y * Z + Z / 2, Z / 4);\n      } else if (nstr.charAt(x) == '+') {\n        fill(color(255, 255, 0));\n        ellipse(x * Z + Z / 2, y * Z + Z / 2, Z / 2);\n      }\n  }\n\n  if ((pacx % Z < Z / T && pacy % Z < Z / T) || (pacmx == 0 && pacmy == 0)) {\n    if (getlevel(pacx, pacy) == ' ') score++;\n    if (getlevel(pacx, pacy) == '+') powerpellet = 500;\n    if (pacx >= 0) setlevel(pacx, pacy, '-');\n    pacx = (pacx + lvlw) % lvlw;\n    if (getlevel(pacx, pacy) == ' ') score++;\n    if (pacx >= 0) setlevel(pacx, pacy, '-');\n\n    if (keyIsDown(LEFT_ARROW)) {\n      pacmy = 0;\n      pacmx = -Z / T;\n      pacd = PI;\n    }\n    if (keyIsDown(RIGHT_ARROW)) {\n      pacmy = 0;\n      pacmx = Z / T;\n      pacd = 0;\n    }\n    if (keyIsDown(UP_ARROW)) {\n      pacmy = -Z / T;\n      pacmx = 0;\n      pacd = PI / 2;\n    }\n    if (keyIsDown(DOWN_ARROW)) {\n      pacmy = Z / T;\n      pacmx = 0;\n      pacd = (PI * 3) / 2;\n    }\n\n    x = pacx + pacmx * T;\n    y = pacy + pacmy * T;\n    if (getlevel(x, y) == '1') {\n      pacmx = 0;\n      pacmy = 0;\n    }\n  }\n\n  powerpellet--;\n\n  for (i = 0; i < 4; i++) {\n    if (ghoststate[i] == 1) {\n      for (ix = -1; ix < 2; ix += 2) {\n        fill(color(255));\n        stroke(color(0));\n        ellipse(ghostx[i] + Z / 2 + ix * 8, ghosty[i] + Z / 2, 12);\n        fill(color(0));\n        ellipse(ghostx[i] + Z / 2 + ix * 8 + 3 * ghostmx[i], ghosty[i] + Z / 2 + 3 * ghostmy[i] + 1, 4);\n      }\n\n      if (pacstate == 0) {\n        it = 0;\n        pmx = ghostmx[i];\n        pmy = ghostmy[i];\n        if ((ghostx[i] % Z < Z / GT[i] && ghosty[i] % Z < Z / GT[i]) || (ghostmx[i] == 0 && ghostmy[i] == 0)) {\n          d = astar(floor(ghostx[i] / Z), floor(ghosty[i] / Z), 11, 10);\n          ghostmx[i] = cos(d);\n          ghostmy[i] = sin(d);\n          if (dist(ghostx[i], ghosty[i], 11 * Z, 10 * Z) < 10) ghoststate[i]++;\n        }\n        ghostx[i] += (ghostmx[i] * Z) / GT[i];\n        ghosty[i] += (ghostmy[i] * Z) / GT[i];\n      }\n    } else {\n      noStroke();\n      fill((powerpellet > 0 && powerpellet % 20 > 10) || powerpellet > 100 ? color(0, 0, 255) : ghostcol[i]);\n      ellipse(ghostx[i] + Z / 2, ghosty[i] + Z / 2, Z - 4);\n      rect(ghostx[i] + 2, ghosty[i] + Z / 2, Z - 4, Z / 2);\n      for (ix = -1; ix < 2; ix += 2) {\n        fill(color(255));\n        stroke(color(0));\n        ellipse(ghostx[i] + Z / 2 + ix * 8, ghosty[i] + Z / 2, 12);\n        fill(color(0));\n        ellipse(ghostx[i] + Z / 2 + ix * 8 + 3 * ghostmx[i], ghosty[i] + Z / 2 + 3 * ghostmy[i] + 1, 4);\n      }\n\n      if (ghoststate[i] > 0) {\n        ghoststate[i]++;\n        if (ghoststate[i] > 200) ghoststate[i] = 0;\n        while (\n          (ghostx[i] % Z < Z / GT[i] && ghosty[i] % Z < Z / GT[i] && (it++ == 0 || random() < 0.25)) ||\n          (ghostmx[i] == 0 && ghostmy[i] == 0)\n        ) {\n          ghostmx[i] = random() < 0.5 ? 1 : -1;\n          x = ghostx[i] + ghostmx[i] * Z;\n          y = ghosty[i] + ghostmy[i] * Z;\n          if (getlevel(x, y) == '1') {\n            ghostmx[i] = 0;\n            ghostmy[i] = 0;\n          }\n        }\n      } else if (pacstate == 0) {\n        it = 0;\n        pmx = ghostmx[i];\n        pmy = ghostmy[i];\n        while (\n          (ghostx[i] % Z < Z / GT[i] && ghosty[i] % Z < Z / GT[i] && (it++ == 0 || random() < 0.25)) ||\n          (ghostmx[i] == 0 && ghostmy[i] == 0)\n        ) {\n          ghostmx[i] = 0;\n          ghostmy[i] = 0;\n          ghostx[i] = (ghostx[i] + lvlw) % lvlw; // ; ghosty[i] = round((ghosty[i]+lvlw) % lvlw)\n          if (random() < 0.4) {\n            d = astar(floor(ghostx[i] / Z), floor(ghosty[i] / Z), min(w - 1, round(pacx / Z)), round(pacy / Z));\n            if (powerpellet > 0) d += PI;\n            ghostmx[i] = cos(d);\n            ghostmy[i] = sin(d);\n          } else if (random() < 0.5) {\n            ghostmx[i] = pmx;\n            ghostmy[i] = pmy;\n          } else if (random() < 0.5) {\n            ghostmx[i] = random() < 0.5 ? 1 : -1;\n          } else {\n            ghostmy[i] = random() < 0.5 ? 1 : -1;\n          }\n          x = ghostx[i] + ghostmx[i] * Z;\n          y = ghosty[i] + ghostmy[i] * Z;\n          if (getlevel(x, y) == '1') {\n            ghostmx[i] = 0;\n            ghostmy[i] = 0;\n          }\n        }\n        ghostx[i] += (ghostmx[i] * Z) / GT[i];\n        ghosty[i] += (ghostmy[i] * Z) / GT[i];\n\n        if (dist(ghostx[i], ghosty[i], pacx, pacy) < Z) {\n          if (powerpellet > -10) {\n            ghoststate[i] = 1;\n          } else {\n            pacstate = 1;\n          }\n        }\n      }\n    }\n  }\n\n  if (pacstate == 0) {\n    pacx += pacmx;\n    pacy += pacmy;\n    if (pacmx != 0 || pacmy != 0) wacn += 0.5;\n    else wacn = 3;\n    wac = (abs((wacn % 10) - 5) * PI) / 12;\n\n    fill(color(255, 255, 0));\n    noStroke();\n    beginShape(TRIANGLE_FAN);\n    vertex(pacx + Z / 2, pacy + Z / 2);\n    for (d = pacd + wac; d < pacd - wac + PI * 2; d += PI / 12) {\n      vertex(pacx + Z / 2 + (Z / 2) * cos(d), pacy + Z / 2 - (Z / 2) * sin(d));\n    }\n    endShape();\n  } else {\n    fill(color(255, 255, 0));\n    noStroke();\n    beginShape(TRIANGLE_FAN);\n    vertex(pacx + Z / 2, pacy + Z / 2);\n    for (d = PI / 2 + (pacstate * PI) / 100; d < (PI * 5) / 2 - (pacstate * PI) / 100; d += PI / 20) {\n      vertex(pacx + Z / 2 + (Z / 2) * cos(d), pacy + Z / 2 - (Z / 2) * sin(d));\n    }\n    endShape();\n\n    if (pacstate++ > 100) {\n      pacx = 11 * Z;\n      pacy = 16 * Z;\n      pacmx = 0;\n      pacmy = 0;\n      pacd = 0;\n      wacn = 0;\n      pacstate = 0;\n      life--;\n      ghostx = [9 * Z, 10 * Z, 11 * Z, 12 * Z];\n      ghosty = [10 * Z, 10 * Z, 10 * Z, 10 * Z];\n    }\n  }\n\n  textFont(fontRegular);\n  text('Score: ' + score, 50, 25);\n  //; stroke(color(255))\n  //if (getlevel(mouseX,mouseY) != '1')\n  //{d = astar(floor(mouseX/Z),floor(mouseY/Z),floor(pacx/Z),floor(pacy/Z)) ; line(mouseX,mouseY,mouseX+50*cos(d),mouseY+50*sin(d))}\n}\n"],"names":[],"version":3,"file":"index.1ace4318.js.map"}