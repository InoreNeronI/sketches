{"mappings":"ACeA,sBAAwB,CAAA,EAGxB,SAAS,gBAAgB,CAAC,cAAe,AAAC,GAAU,EAAM,cAAc,IAKxE,MAAM,EAAS,CACb,KAAM,CACJ,KAAM,OACN,MAAO,oBACP,KAAM,eACN,WAAY,eACZ,IAAK,eACL,KAAM,cACR,EACA,OAAQ,CACN,KAAM,SACN,MAAO,qBACP,KAAM,eACN,WAAY,eACZ,IAAK,eACL,KAAM,cACR,EACA,SAAU,CACR,KAAM,WACN,MAAO,sBACP,KAAM,eACN,WAAY,eACZ,IAAK,eACL,KAAM,2BACR,EACA,KAAM,CACJ,KAAM,OACN,MAAO,qBACP,KAAM,eACN,WAAY,eACZ,IAAK,eACL,KAAM,cACR,EACA,QAAS,CACP,KAAM,UACN,MAAO,mBACP,KAAM,eACN,WAAY,eACZ,IAAK,KACL,KAAM,cACR,EACA,MAAO,CACL,KAAM,QACN,MAAO,cACP,KAAM,eACN,WAAY,eACZ,IAAK,eACL,KAAM,cACR,CACF,EAKA,IAAI,EAAW,KAAK,KAAK,CAAC,aAAa,OAAO,CAAC,cAAgB,CAAA,EAK3D,EAAQ,OAAO,YAAY,CAAC,OAAO,CAAC,SAAW,OACnD,OAAO,YAAY,CAAC,OAAO,CAAC,YAAa,CAAM,CAAC,EAAM,CAAC,IAAO,EAE9C,CAAM,CAAC,EAAM,CAAC,IAAO,CACf,CAAM,CAAC,EAAM,CAAC,UAAa,CAClC,CAAM,CAAC,EAAM,CAAC,GAAM,CACnB,CAAM,CAAC,EAAM,CAAC,IAAO,CAKjC,GAAU,CAAA,AADA,CAAC,KAAM,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAM,AACvD,CAAC,EAAE,CAAG,EAA3B,EAaA,OAAO,YAAY,CAAC,OAAO,CAAC,QAAS,CAAM,CAAC,EAAM,CAAC,KAAQ,EAK3D,IAAI,EAAW,CACb,MAAO,CAEL,QAAS,EACT,KAAM,EACN,MAAO,EACT,EACA,KAAM,CACJ,WAAY,EACd,CACF,EAOA,OAFY,aAAa,OAAO,CAAC,UAG/B,IAAK,WACH,EAAS,KAAK,CAAG,CACf,QAAS,EACT,KAAM,EACN,MAAO,EACT,EACA,KACF,KAAK,eACH,EAAS,KAAK,CAAG,CACf,QAAS,GACT,KAAM,GACN,MAAO,EACT,EACA,KACF,KAAK,SACH,EAAS,KAAK,CAAG,CACf,QAAS,GACT,KAAM,GACN,MAAO,EACT,EACA,KACF,KAAK,SACH,EAAS,KAAK,CAAG,CACf,QAAS,KACT,KAAM,KACN,MAAO,IACT,CAEJ,CAMiB,EAAS,IAAI,CAAC,UAAU,CAC3B,EAAS,KAAK,CAAC,OAAO,CACzB,EAAS,KAAK,CAAC,IAAI,CAWX,EAAS,KAAK,CAAC,KAAK","sources":["<anon>","src/emoji-minesweeper/emojiMinesweeper.js"],"sourcesContent":["/*\n *  Emoji Minesweeper\n *  Copyright (c) 2024 Michael Kolesidis\n *  GNU Affero General Public License v3.0\n *\n * minesweeperEmoji.js contains the game functionality,\n * everything that happens inside the game's board. It\n * also handles the update of the stats accordingly.\n */ /**\n * Basics\n */ // Disable the Friendly Error System\n// (not used in the minified version of P5.js)\ndisableFriendlyErrors = true;\n// Prevent right mouse click from opening browser context menu in order to be able to flag\ndocument.addEventListener(\"contextmenu\", (event)=>event.preventDefault());\n// Canvas\nlet cnv; // The canvas element that will contain the game\nconst themes = {\n    mine: {\n        name: \"mine\",\n        title: \"Emoji Minesweeper\",\n        mine: \"\\uD83D\\uDCA3\",\n        detonation: \"\\uD83D\\uDCA5\",\n        won: \"\\uD83D\\uDE04\",\n        lost: \"\\uD83D\\uDE35\"\n    },\n    flower: {\n        name: \"flower\",\n        title: \"Emoji Flower Field\",\n        mine: \"\\uD83C\\uDF3A\",\n        detonation: \"\\uD83D\\uDC1B\",\n        won: \"\\uD83D\\uDE0A\",\n        lost: \"\\uD83D\\uDE14\"\n    },\n    mushroom: {\n        name: \"mushroom\",\n        title: \"Emoji Shroom Picker\",\n        mine: \"\\uD83C\\uDF44\",\n        detonation: \"\\uD83E\\uDD84\",\n        won: \"\\uD83D\\uDE0E\",\n        lost: \"\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB\"\n    },\n    bear: {\n        name: \"bear\",\n        title: \"Emoji Bearspotting\",\n        mine: \"\\uD83D\\uDC3B\",\n        detonation: \"\\uD83D\\uDC3E\",\n        won: \"\\uD83C\\uDF33\",\n        lost: \"\\uD83E\\uDEB5\"\n    },\n    octopus: {\n        name: \"octopus\",\n        title: \"Emoji Seasweeper\",\n        mine: \"\\uD83D\\uDC19\",\n        detonation: \"\\uD83C\\uDF0A\",\n        won: \"\\u26F5\\uFE0F\",\n        lost: \"\\uD83E\\uDD88\"\n    },\n    japan: {\n        name: \"japan\",\n        title: \"\\u7D75\\u6587\\u5B57\\u30DE\\u30A4\\u30F3\\u30B9\\u30A4\\u30FC\\u30D1\\u30FC\",\n        mine: \"\\uD83C\\uDFEF\",\n        detonation: \"\\uD83D\\uDC7A\",\n        won: \"\\uD83C\\uDF38\",\n        lost: \"\\uD83C\\uDE32\"\n    }\n};\n/**\n * Dark Mode\n */ let darkMode = JSON.parse(localStorage.getItem(\"darkMode\")) ?? false;\n/**\n * Emojis\n */ let theme = window.localStorage.getItem(\"skin\") ?? \"mine\";\nwindow.localStorage.setItem(\"mainEmoji\", themes[theme][\"mine\"]);\nlet mineEmoji = themes[theme][\"mine\"];\nlet detonationEmoji = themes[theme][\"detonation\"];\nlet wonEmoji = themes[theme][\"won\"];\nlet lostEmoji = themes[theme][\"lost\"];\n// Emojis\nconst CLOSED = darkMode ? \"\\u2B1B\" : \"\\uD83D\\uDD32\";\nlet NUMBERS = [\n    \"\\u2B1C\\uFE0F\",\n    \"1\\uFE0F\\u20E3\",\n    \"2\\uFE0F\\u20E3\",\n    \"3\\uFE0F\\u20E3\",\n    \"4\\uFE0F\\u20E3\",\n    \"5\\uFE0F\\u20E3\",\n    \"6\\uFE0F\\u20E3\",\n    \"7\\uFE0F\\u20E3\",\n    \"8\\uFE0F\\u20E3\"\n];\nif (darkMode) NUMBERS[0] = \"\";\nconst FLAG = \"\\uD83D\\uDEA9\";\nlet DETONATION = detonationEmoji;\nlet MINE = mineEmoji;\nconst WRONG = \"\\u274C\";\nlet WON = wonEmoji;\nlet LOST = lostEmoji;\nconst TIMER = \"\\u231B\";\nconst MOVES = \"\\uD83E\\uDDEE\";\n/**\n * Title\n */ window.localStorage.setItem(\"title\", themes[theme][\"title\"]);\n/**\n * Settings\n */ let settings = {\n    level: {\n        // to be overridden by localStorage\n        columns: 9,\n        rows: 9,\n        mines: 10\n    },\n    size: {\n        squareSize: 32\n    }\n};\n/**\n * Level\n */ let level = localStorage.getItem(\"level\");\nswitch(level){\n    case \"beginner\":\n        settings.level = {\n            columns: 9,\n            rows: 9,\n            mines: 10\n        };\n        break;\n    case \"intermediate\":\n        settings.level = {\n            columns: 16,\n            rows: 16,\n            mines: 40\n        };\n        break;\n    case \"expert\":\n        settings.level = {\n            columns: 30,\n            rows: 16,\n            mines: 99\n        };\n        break;\n    case \"custom\":\n        settings.level = {\n            columns: null,\n            rows: null,\n            mines: null\n        };\n        break;\n}\n/**\n * Board dimensions and number of mines\n */ let squares = []; // Array to hold all the square objects\nlet squareSize = settings.size.squareSize; // The size (in pixels of each square)\nlet columns = settings.level.columns; // The number of columns in the board\nlet rows = settings.level.rows; // The number of rows in the board\nlet numberOfSquares = rows * columns;\nlet sizeError = squareSize * 0.175; // On Windows and on Linux if error is not added to size,\n// the left and bottom borders are not totally visible -\n// on Mac it works fine even without the error\nlet boardSize = {\n    width: squareSize * columns + sizeError,\n    height: squareSize * rows + sizeError\n};\nlet initialMines = settings.level.mines; // Used by the mine indicator\nlet numberOfMines = initialMines; // Used to calculate mines to be allocated to squares\nlet squareCounter = 0; // The unique identifier of each square\nlet minedSquares = []; // A array containing the unique identifiers of all the squares that will contain mines\nlet flaggedSquares = 0;\nlet moves = 0; // total number of moves (left and right clicks on active squares)\nlet startTime = null; // used to calculate time\nlet gameFinished = false;\nlet newBestMoves = false; // used when the player has made a new best moves record\nlet newBestTime = false; // used when the player has made a new best time\n/**\n * Mine allocation\n */ function allocateMines() {\n    while(numberOfMines > 0){\n        let targetSquare = Math.floor(Math.random() * numberOfSquares);\n        if (!minedSquares.includes(targetSquare)) {\n            minedSquares.push(targetSquare);\n            numberOfMines -= 1;\n        }\n    }\n}\nfunction generateSquares() {\n    for(let i = 0; i < columns; i++)for(let j = 0; j < rows; j++){\n        let newSquare = new Square(i, j, squareCounter);\n        squareCounter += 1;\n        // Check whether square includes mine\n        if (minedSquares.includes(newSquare.num)) newSquare.mine = true;\n        squares.push(newSquare);\n    }\n}\n// Calculate mines around each square\nfunction calculateMines() {\n    squares.forEach((s)=>{\n        // Find squares touching each square\n        let neighbors = getNeighbors(s);\n        let reducer = (accumulator, currentValue)=>accumulator + currentValue;\n        s.minesAround = neighbors.map((n)=>n.mine).reduce(reducer); // Add all mine values to find total\n    });\n}\n// Time indicator\nlet timePassed = 0;\nlet stopTimer = false;\nconst startTimer = ()=>{\n    setInterval(()=>{\n        if (stopTimer) return;\n        timePassed += 1;\n    }, 1000);\n};\n/**\n * Setup\n */ function setup() {\n    darkMode ? background(25) : background(255);\n    cnv = createCanvas(boardSize.width, boardSize.height + squareSize * 0.75);\n    cnv.parent(\"EmojiMinesweeper\");\n    textSize(squareSize - squareSize * 0.05); // On Mac \"squareSize - 1\" works better, on Windows \"squareSize - 6\"\n    allocateMines();\n    generateSquares();\n    calculateMines();\n}\n/**\n * Draw\n */ function draw() {\n    darkMode ? background(25) : background(255);\n    if (navigator.userAgent.includes(\"Firefox\")) translate(squareSize / 10, 0);\n    translate(-squareSize * 0.075, squareSize - squareSize * 0.075);\n    squares.forEach(function(s) {\n        s.draw();\n    });\n    // Show mines and flagged squares indicators\n    textSize(squareSize * 0.6);\n    textStyle(BOLD);\n    // Mine indicator\n    if (flaggedSquares > initialMines) fill(248, 49, 47);\n    else darkMode ? fill(225) : fill(35);\n    text(MINE, squareSize * 0.125, boardSize.height - squareSize * 0.275);\n    text(nf(Math.max(initialMines - flaggedSquares, 0), 3), squareSize, boardSize.height - squareSize * 0.25);\n    // Moves indicator\n    darkMode ? fill(225) : fill(35);\n    text(MOVES, width / 2 - squareSize * 1.975 + squareSize * 0.99, boardSize.height - squareSize * 0.275);\n    if (newBestMoves) fill(255, 176, 46);\n    text(nf(moves, 3), width / 2 - squareSize * 1.975 + 2 * squareSize * 0.99, boardSize.height - squareSize * 0.275);\n    // Time indicator\n    darkMode ? fill(225) : fill(35);\n    text(TIMER, width - squareSize * 1.975, boardSize.height - squareSize * 0.275);\n    if (newBestTime) fill(255, 176, 46);\n    text(nf(timePassed, 3), width - squareSize * 1.1, boardSize.height - squareSize * 0.25);\n    textSize(squareSize - squareSize * 0.05);\n}\n// Get neighbors\nfunction getNeighbors(square) {\n    return squares.filter((n)=>{\n        return n.i >= square.i - 1 && n.i <= square.i + 1 && n.j >= square.j - 1 && n.j <= square.j + 1;\n    });\n}\n/**\n * Mouse Action Handling\n */ let isFirstClick = true;\nlet mineReallocated = false;\n// What happens every time the player clicks on a square\nfunction openSquare(square) {\n    // Make sure first click is not on a mine\n    if (isFirstClick) {\n        startTimer();\n        startTime = new Date();\n        // Update local storage\n        if (window.location.hash === \"\") {\n            let played;\n            switch(level){\n                case \"beginner\":\n                    played = parseInt(localStorage.getItem(\"beginnerPlayed\"));\n                    played += 1;\n                    localStorage.setItem(\"beginnerPlayed\", played);\n                    break;\n                case \"intermediate\":\n                    played = parseInt(localStorage.getItem(\"intermediatePlayed\"));\n                    played += 1;\n                    localStorage.setItem(\"intermediatePlayed\", played);\n                    break;\n                case \"expert\":\n                    played = parseInt(localStorage.getItem(\"expertPlayed\"));\n                    played += 1;\n                    localStorage.setItem(\"expertPlayed\", played);\n                    break;\n            }\n        }\n        if (square.mine) {\n            square.mine = false;\n            const originalSquareNum = square.num;\n            while(!mineReallocated){\n                let num = Math.floor(Math.random() * numberOfSquares);\n                if (num !== originalSquareNum) {\n                    if (!squares[num].mine) {\n                        squares[num].mine = true;\n                        mineReallocated = true;\n                    }\n                }\n            }\n        }\n        isFirstClick = false;\n        calculateMines();\n        squares.forEach(function(s) {\n            s.draw();\n        });\n    }\n    // Open square\n    square.opened = true;\n    square.clicked = true;\n    if (square.mine) {\n        // End game\n        squares.forEach((s)=>{\n            s.opened = true;\n        });\n        noLoop();\n        return;\n    }\n    if (square.minesAround == 0) {\n        // Recursively open neighbors\n        let neighbors = getNeighbors(square);\n        neighbors.forEach((s)=>{\n            if (!s.opened) {\n                openSquare(s);\n                if (s.flagged) {\n                    s.flagged = false;\n                    flaggedSquares -= 1;\n                }\n            }\n        });\n    }\n}\nfunction mousePressed() {\n    // Disable click if modal is open\n    if (JSON.parse(localStorage.getItem(\"modalOpen\")) === true) return;\n    // Flags\n    if (mouseButton === RIGHT || JSON.parse(localStorage.getItem(\"flagMode\"))) {\n        // Find the square the player clicked on\n        let square = squares.find((s)=>{\n            return s.x < mouseX && s.x + squareSize > mouseX && s.y < mouseY && s.y + squareSize > mouseY;\n        });\n        if (square) // Prevent opened squares from being flagged\n        {\n            if (!square.opened) {\n                if (!square.flagged) {\n                    flaggedSquares += 1;\n                    moves += 1;\n                    addMove();\n                } else {\n                    flaggedSquares -= 1;\n                    moves += 1;\n                    addMove();\n                }\n                square.flagged = !square.flagged;\n            }\n        }\n    }\n    // Find the square pressed on\n    if (mouseButton === LEFT && !JSON.parse(localStorage.getItem(\"flagMode\"))) {\n        if (!gameFinished) {\n            let square = squares.find((s)=>{\n                return s.x < mouseX && s.x + squareSize > mouseX && s.y < mouseY && s.y + squareSize > mouseY;\n            });\n            if (square) {\n                if (square.flagged || square.opened) return; // Do not allow opening when flagged\n                openSquare(square);\n                moves += 1;\n                addMove();\n                if (square.mine) {\n                    if (!gameFinished) {\n                        gameLost();\n                        gameEnded();\n                    }\n                } else {\n                    // Check if the game has been won\n                    let squaresLeft = squares.filter((s)=>{\n                        return !s.mine && !s.opened;\n                    }).length;\n                    if (squaresLeft == 0) {\n                        if (!gameFinished) {\n                            gameWon();\n                            gameEnded();\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n/**\n * Endgame\n */ // Handle end\nfunction gameEnded() {\n    gameFinished = true;\n    if (window.location.hash === \"\") {\n        calculateWinPercentage();\n        let totalTime;\n        switch(level){\n            case \"beginner\":\n                totalTime = parseInt(localStorage.getItem(\"beginnerTotalTime\"));\n                totalTime += timePassed;\n                localStorage.setItem(\"beginnerTotalTime\", totalTime);\n                break;\n            case \"intermediate\":\n                totalTime = parseInt(localStorage.getItem(\"intermediateTotalTime\"));\n                totalTime += timePassed;\n                localStorage.setItem(\"intermediateTotalTime\", totalTime);\n                break;\n            case \"expert\":\n                totalTime = parseInt(localStorage.getItem(\"expertTotalTime\"));\n                totalTime += timePassed;\n                localStorage.setItem(\"expertTotalTime\", totalTime);\n                break;\n        }\n    }\n}\n// Handle win\nfunction gameWon() {\n    NUMBERS[0] = WON;\n    squares.forEach(function(s) {\n        s.opened = true;\n    });\n    // Update local storage\n    // Won Data\n    if (window.location.hash === \"\") {\n        let won;\n        switch(level){\n            case \"beginner\":\n                won = parseInt(localStorage.getItem(\"beginnerWon\"));\n                won += 1;\n                localStorage.setItem(\"beginnerWon\", won);\n                break;\n            case \"intermediate\":\n                won = parseInt(localStorage.getItem(\"intermediateWon\"));\n                won += 1;\n                localStorage.setItem(\"intermediateWon\", won);\n                break;\n            case \"expert\":\n                won = parseInt(localStorage.getItem(\"expertWon\"));\n                won += 1;\n                localStorage.setItem(\"expertWon\", won);\n                break;\n        }\n        // Moves Data\n        let bestMoves;\n        switch(level){\n            case \"beginner\":\n                bestMoves = Number(localStorage.getItem(\"beginnerBestMoves\"));\n                break;\n            case \"intermediate\":\n                bestMoves = Number(localStorage.getItem(\"intermediateBestMoves\"));\n                break;\n            case \"expert\":\n                bestMoves = Number(localStorage.getItem(\"expertBestMoves\"));\n                break;\n        }\n        if (bestMoves === 0) switch(level){\n            case \"beginner\":\n                localStorage.setItem(\"beginnerBestMoves\", moves);\n                break;\n            case \"intermediate\":\n                localStorage.setItem(\"intermediateBestMoves\", moves);\n                break;\n            case \"expert\":\n                localStorage.setItem(\"expertBestMoves\", moves);\n                break;\n        }\n        else if (moves < bestMoves) {\n            NUMBERS[0] = \"\\uD83E\\uDD73\";\n            newBestMoves = true;\n            switch(level){\n                case \"beginner\":\n                    localStorage.setItem(\"beginnerBestMoves\", moves);\n                    break;\n                case \"intermediate\":\n                    localStorage.setItem(\"intermediateBestMoves\", moves);\n                    break;\n                case \"expert\":\n                    localStorage.setItem(\"expertBestMoves\", moves);\n                    break;\n            }\n            localStorage.setItem(\"newBestMoves\", \"true\");\n        }\n        // Time Data\n        const endTime = new Date();\n        let time = (endTime - startTime) / 1000; //initially in milliseconds, divide by 1000 for seconds\n        let bestTime;\n        switch(level){\n            case \"beginner\":\n                bestTime = Number(localStorage.getItem(\"beginnerBestTime\"));\n                break;\n            case \"intermediate\":\n                bestTime = Number(localStorage.getItem(\"intermediateBestTime\"));\n                break;\n            case \"expert\":\n                bestTime = Number(localStorage.getItem(\"expertBestTime\"));\n                break;\n        }\n        if (bestTime === 0) switch(level){\n            case \"beginner\":\n                localStorage.setItem(\"beginnerBestTime\", time);\n                break;\n            case \"intermediate\":\n                localStorage.setItem(\"intermediateBestTime\", time);\n                break;\n            case \"expert\":\n                localStorage.setItem(\"expertBestTime\", time);\n                break;\n        }\n        else if (time < bestTime) {\n            NUMBERS[0] = \"\\uD83E\\uDD73\";\n            newBestTime = true;\n            switch(level){\n                case \"beginner\":\n                    localStorage.setItem(\"beginnerBestTime\", time);\n                    break;\n                case \"intermediate\":\n                    localStorage.setItem(\"intermediateBestTime\", time);\n                    break;\n                case \"expert\":\n                    localStorage.setItem(\"expertBestTime\", time);\n                    break;\n            }\n            localStorage.setItem(\"newBestTime\", \"true\");\n        }\n    }\n    stopTimer = true;\n}\n// handle loss\nfunction gameLost() {\n    NUMBERS[0] = LOST;\n    squares.forEach(function(s) {\n        s.opened = true;\n    });\n    const endTime = new Date();\n    let time = endTime - startTime; //in ms\n    time = time / 1000;\n    stopTimer = true;\n}\n// Add move to total moves\nfunction addMove() {\n    let totalMoves;\n    switch(level){\n        case \"beginner\":\n            totalMoves = parseInt(localStorage.getItem(\"beginnerTotalMoves\"));\n            totalMoves += 1;\n            localStorage.setItem(\"beginnerTotalMoves\", totalMoves);\n            break;\n        case \"intermediate\":\n            totalMoves = parseInt(localStorage.getItem(\"intermediateTotalMoves\"));\n            totalMoves += 1;\n            localStorage.setItem(\"intermediateTotalMoves\", totalMoves);\n            break;\n        case \"expert\":\n            totalMoves = parseInt(localStorage.getItem(\"expertTotalMoves\"));\n            totalMoves += 1;\n            localStorage.setItem(\"expertTotalMoves\", totalMoves);\n            break;\n    }\n}\n// Calculate percentage of wins / total games played\nfunction calculateWinPercentage() {\n    if (window.location.hash === \"\") {\n        let played, won;\n        switch(level){\n            case \"beginner\":\n                played = parseInt(localStorage.getItem(\"beginnerPlayed\"));\n                won = parseInt(localStorage.getItem(\"beginnerWon\"));\n                break;\n            case \"intermediate\":\n                played = parseInt(localStorage.getItem(\"intermediatePlayed\"));\n                won = parseInt(localStorage.getItem(\"intermediateWon\"));\n                break;\n            case \"expert\":\n                played = parseInt(localStorage.getItem(\"expertPlayed\"));\n                won = parseInt(localStorage.getItem(\"expertWon\"));\n                break;\n        }\n        let winPercentage = null;\n        if (played !== 0) winPercentage = won / played;\n        if (winPercentage !== null) // Update local storage\n        switch(level){\n            case \"beginner\":\n                window.localStorage.setItem(\"beginnerWinPercentage\", winPercentage);\n                break;\n            case \"intermediate\":\n                window.localStorage.setItem(\"intermediateWinPercentage\", winPercentage);\n                break;\n            case \"expert\":\n                window.localStorage.setItem(\"expertWinPercentage\", winPercentage);\n                break;\n        }\n    }\n}\n/**\n * Keyboard Action Handling\n */ function keyPressed() {\n    // Set Level\n    if (keyCode === 49 || keyCode === 97) {\n        if (level !== \"beginner\") {\n            localStorage.setItem(\"level\", \"beginner\");\n            window.location.reload();\n        }\n    }\n    if (keyCode === 50 || keyCode === 98) {\n        if (level !== \"intermediate\") {\n            localStorage.setItem(\"level\", \"intermediate\");\n            window.location.reload();\n        }\n    }\n    if (keyCode === 51 || keyCode === 99) {\n        if (level !== \"expert\") {\n            localStorage.setItem(\"level\", \"expert\");\n            window.location.reload();\n        }\n    }\n    // New Game\n    if (keyCode === 78) window.location.reload();\n}\n\n//# sourceMappingURL=index.51f6c6cc.js.map\n","/*\n *  Emoji Minesweeper\n *  Copyright (c) 2024 Michael Kolesidis\n *  GNU Affero General Public License v3.0\n *\n * minesweeperEmoji.js contains the game functionality,\n * everything that happens inside the game's board. It\n * also handles the update of the stats accordingly.\n */\n\n/**\n * Basics\n */\n// Disable the Friendly Error System\n// (not used in the minified version of P5.js)\ndisableFriendlyErrors = true;\n\n// Prevent right mouse click from opening browser context menu in order to be able to flag\ndocument.addEventListener('contextmenu', (event) => event.preventDefault());\n\n// Canvas\nlet cnv; // The canvas element that will contain the game\n\nconst themes = {\n  mine: {\n    name: 'mine',\n    title: 'Emoji Minesweeper',\n    mine: 'ðŸ’£',\n    detonation: 'ðŸ’¥',\n    won: 'ðŸ˜„',\n    lost: 'ðŸ˜µ',\n  },\n  flower: {\n    name: 'flower',\n    title: 'Emoji Flower Field',\n    mine: 'ðŸŒº',\n    detonation: 'ðŸ›',\n    won: 'ðŸ˜Š',\n    lost: 'ðŸ˜”',\n  },\n  mushroom: {\n    name: 'mushroom',\n    title: 'Emoji Shroom Picker',\n    mine: 'ðŸ„',\n    detonation: 'ðŸ¦„',\n    won: 'ðŸ˜Ž',\n    lost: 'ðŸ˜µâ€ðŸ’«',\n  },\n  bear: {\n    name: 'bear',\n    title: 'Emoji Bearspotting',\n    mine: 'ðŸ»',\n    detonation: 'ðŸ¾',\n    won: 'ðŸŒ³',\n    lost: 'ðŸªµ',\n  },\n  octopus: {\n    name: 'octopus',\n    title: 'Emoji Seasweeper',\n    mine: 'ðŸ™',\n    detonation: 'ðŸŒŠ',\n    won: 'â›µï¸',\n    lost: 'ðŸ¦ˆ',\n  },\n  japan: {\n    name: 'japan',\n    title: 'çµµæ–‡å­—ãƒžã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼',\n    mine: 'ðŸ¯',\n    detonation: 'ðŸ‘º',\n    won: 'ðŸŒ¸',\n    lost: 'ðŸˆ²',\n  },\n};\n\n/**\n * Dark Mode\n */\nlet darkMode = JSON.parse(localStorage.getItem('darkMode')) ?? false;\n\n/**\n * Emojis\n */\nlet theme = window.localStorage.getItem('skin') ?? 'mine';\nwindow.localStorage.setItem('mainEmoji', themes[theme]['mine']);\n\nlet mineEmoji = themes[theme]['mine'];\nlet detonationEmoji = themes[theme]['detonation'];\nlet wonEmoji = themes[theme]['won'];\nlet lostEmoji = themes[theme]['lost'];\n\n// Emojis\nconst CLOSED = darkMode ? 'â¬›' : 'ðŸ”²';\nlet NUMBERS = ['â¬œï¸', '1ï¸âƒ£', '2ï¸âƒ£', '3ï¸âƒ£', '4ï¸âƒ£', '5ï¸âƒ£', '6ï¸âƒ£', '7ï¸âƒ£', '8ï¸âƒ£'];\nif (darkMode) NUMBERS[0] = '';\nconst FLAG = 'ðŸš©';\nlet DETONATION = detonationEmoji;\nlet MINE = mineEmoji;\nconst WRONG = 'âŒ';\nlet WON = wonEmoji;\nlet LOST = lostEmoji;\nconst TIMER = 'âŒ›';\nconst MOVES = 'ðŸ§®';\n\n/**\n * Title\n */\nwindow.localStorage.setItem('title', themes[theme]['title']);\n\n/**\n * Settings\n */\nlet settings = {\n  level: {\n    // to be overridden by localStorage\n    columns: 9,\n    rows: 9,\n    mines: 10,\n  },\n  size: {\n    squareSize: 32,\n  },\n};\n\n/**\n * Level\n */\nlet level = localStorage.getItem('level');\n\nswitch (level) {\n  case 'beginner':\n    settings.level = {\n      columns: 9,\n      rows: 9,\n      mines: 10,\n    };\n    break;\n  case 'intermediate':\n    settings.level = {\n      columns: 16,\n      rows: 16,\n      mines: 40,\n    };\n    break;\n  case 'expert':\n    settings.level = {\n      columns: 30,\n      rows: 16,\n      mines: 99,\n    };\n    break;\n  case 'custom':\n    settings.level = {\n      columns: null,\n      rows: null,\n      mines: null,\n    };\n    break;\n}\n\n/**\n * Board dimensions and number of mines\n */\nlet squares = []; // Array to hold all the square objects\nlet squareSize = settings.size.squareSize; // The size (in pixels of each square)\nlet columns = settings.level.columns; // The number of columns in the board\nlet rows = settings.level.rows; // The number of rows in the board\nlet numberOfSquares = rows * columns;\nlet sizeError = squareSize * 0.175; // On Windows and on Linux if error is not added to size,\n// the left and bottom borders are not totally visible -\n// on Mac it works fine even without the error\n\nlet boardSize = {\n  width: squareSize * columns + sizeError,\n  height: squareSize * rows + sizeError,\n};\n\nlet initialMines = settings.level.mines; // Used by the mine indicator\nlet numberOfMines = initialMines; // Used to calculate mines to be allocated to squares\nlet squareCounter = 0; // The unique identifier of each square\nlet minedSquares = []; // A array containing the unique identifiers of all the squares that will contain mines\n\nlet flaggedSquares = 0;\nlet moves = 0; // total number of moves (left and right clicks on active squares)\nlet startTime = null; // used to calculate time\nlet gameFinished = false;\nlet newBestMoves = false; // used when the player has made a new best moves record\nlet newBestTime = false; // used when the player has made a new best time\n\n/**\n * Mine allocation\n */\nfunction allocateMines() {\n  while (numberOfMines > 0) {\n    let targetSquare = Math.floor(Math.random() * numberOfSquares);\n    if (!minedSquares.includes(targetSquare)) {\n      minedSquares.push(targetSquare);\n      numberOfMines -= 1;\n    }\n  }\n}\n\nfunction generateSquares() {\n  for (let i = 0; i < columns; i++) {\n    for (let j = 0; j < rows; j++) {\n      let newSquare = new Square(i, j, squareCounter);\n      squareCounter += 1;\n\n      // Check whether square includes mine\n      if (minedSquares.includes(newSquare.num)) {\n        newSquare.mine = true;\n      }\n      squares.push(newSquare);\n    }\n  }\n}\n\n// Calculate mines around each square\nfunction calculateMines() {\n  squares.forEach((s) => {\n    // Find squares touching each square\n    let neighbors = getNeighbors(s);\n    let reducer = (accumulator, currentValue) => accumulator + currentValue;\n    s.minesAround = neighbors.map((n) => n.mine).reduce(reducer); // Add all mine values to find total\n  });\n}\n\n// Time indicator\nlet timePassed = 0;\nlet stopTimer = false;\n\nconst startTimer = () => {\n  setInterval(() => {\n    if (stopTimer) {\n      return;\n    }\n    timePassed += 1;\n  }, 1000);\n};\n\n/**\n * Setup\n */\nfunction setup() {\n  darkMode ? background(25) : background(255);\n  cnv = createCanvas(\n    boardSize.width,\n    boardSize.height + squareSize * 0.75, // Added extra space for the mines and flagged squares indicators\n  );\n  cnv.parent('EmojiMinesweeper');\n  textSize(squareSize - squareSize * 0.05); // On Mac \"squareSize - 1\" works better, on Windows \"squareSize - 6\"\n\n  allocateMines();\n  generateSquares();\n  calculateMines();\n}\n\n/**\n * Draw\n */\nfunction draw() {\n  darkMode ? background(25) : background(255);\n\n  if (navigator.userAgent.includes('Firefox')) {\n    translate(squareSize / 10, 0);\n  }\n\n  translate(-squareSize * 0.075, squareSize - squareSize * 0.075);\n  squares.forEach(function (s) {\n    s.draw();\n  });\n\n  // Show mines and flagged squares indicators\n  textSize(squareSize * 0.6);\n  textStyle(BOLD);\n\n  // Mine indicator\n  if (flaggedSquares > initialMines) {\n    fill(248, 49, 47);\n  } else {\n    darkMode ? fill(225) : fill(35);\n  }\n  text(MINE, squareSize * 0.125, boardSize.height - squareSize * 0.275);\n  text(nf(Math.max(initialMines - flaggedSquares, 0), 3), squareSize, boardSize.height - squareSize * 0.25);\n\n  // Moves indicator\n  darkMode ? fill(225) : fill(35);\n  text(MOVES, width / 2 - squareSize * 1.975 + squareSize * 0.99, boardSize.height - squareSize * 0.275);\n  if (newBestMoves) {\n    fill(255, 176, 46);\n  }\n  text(nf(moves, 3), width / 2 - squareSize * 1.975 + 2 * squareSize * 0.99, boardSize.height - squareSize * 0.275);\n\n  // Time indicator\n  darkMode ? fill(225) : fill(35);\n\n  text(TIMER, width - squareSize * 1.975, boardSize.height - squareSize * 0.275);\n  if (newBestTime) {\n    fill(255, 176, 46);\n  }\n  text(nf(timePassed, 3), width - squareSize * 1.1, boardSize.height - squareSize * 0.25);\n  textSize(squareSize - squareSize * 0.05);\n}\n\n// Get neighbors\nfunction getNeighbors(square) {\n  return squares.filter((n) => {\n    return n.i >= square.i - 1 && n.i <= square.i + 1 && n.j >= square.j - 1 && n.j <= square.j + 1;\n  });\n}\n\n/**\n * Mouse Action Handling\n */\nlet isFirstClick = true;\nlet mineReallocated = false;\n\n// What happens every time the player clicks on a square\nfunction openSquare(square) {\n  // Make sure first click is not on a mine\n  if (isFirstClick) {\n    startTimer();\n    startTime = new Date();\n\n    // Update local storage\n    if (window.location.hash === '') {\n      let played;\n      switch (level) {\n        case 'beginner':\n          played = parseInt(localStorage.getItem('beginnerPlayed'));\n          played += 1;\n          localStorage.setItem('beginnerPlayed', played);\n          break;\n        case 'intermediate':\n          played = parseInt(localStorage.getItem('intermediatePlayed'));\n          played += 1;\n          localStorage.setItem('intermediatePlayed', played);\n          break;\n        case 'expert':\n          played = parseInt(localStorage.getItem('expertPlayed'));\n          played += 1;\n          localStorage.setItem('expertPlayed', played);\n          break;\n      }\n    }\n\n    if (square.mine) {\n      square.mine = false;\n      const originalSquareNum = square.num;\n\n      while (!mineReallocated) {\n        let num = Math.floor(Math.random() * numberOfSquares);\n        if (num !== originalSquareNum) {\n          if (!squares[num].mine) {\n            squares[num].mine = true;\n            mineReallocated = true;\n          }\n        }\n      }\n    }\n    isFirstClick = false;\n\n    calculateMines();\n    squares.forEach(function (s) {\n      s.draw();\n    });\n  }\n\n  // Open square\n  square.opened = true;\n  square.clicked = true;\n  if (square.mine) {\n    // End game\n    squares.forEach((s) => {\n      s.opened = true;\n    });\n    noLoop();\n    return;\n  }\n  if (square.minesAround == 0) {\n    // Recursively open neighbors\n    let neighbors = getNeighbors(square);\n    neighbors.forEach((s) => {\n      if (!s.opened) {\n        openSquare(s);\n        if (s.flagged) {\n          s.flagged = false;\n          flaggedSquares -= 1;\n        }\n      }\n    });\n  }\n}\n\nfunction mousePressed() {\n  // Disable click if modal is open\n  if (JSON.parse(localStorage.getItem('modalOpen')) === true) {\n    return;\n  }\n  // Flags\n  if (mouseButton === RIGHT || JSON.parse(localStorage.getItem('flagMode'))) {\n    // Find the square the player clicked on\n    let square = squares.find((s) => {\n      return s.x < mouseX && s.x + squareSize > mouseX && s.y < mouseY && s.y + squareSize > mouseY;\n    });\n    if (square) {\n      // Prevent opened squares from being flagged\n      if (!square.opened) {\n        if (!square.flagged) {\n          flaggedSquares += 1;\n          moves += 1;\n          addMove();\n        } else {\n          flaggedSquares -= 1;\n          moves += 1;\n          addMove();\n        }\n        square.flagged = !square.flagged;\n      }\n    }\n  }\n\n  // Find the square pressed on\n  if (mouseButton === LEFT && !JSON.parse(localStorage.getItem('flagMode'))) {\n    if (!gameFinished) {\n      let square = squares.find((s) => {\n        return s.x < mouseX && s.x + squareSize > mouseX && s.y < mouseY && s.y + squareSize > mouseY;\n      });\n      if (square) {\n        if (square.flagged || square.opened) {\n          return; // Do not allow opening when flagged\n        }\n        openSquare(square);\n        moves += 1;\n        addMove();\n        if (square.mine) {\n          if (!gameFinished) {\n            gameLost();\n            gameEnded();\n          }\n        } else {\n          // Check if the game has been won\n          let squaresLeft = squares.filter((s) => {\n            return !s.mine && !s.opened;\n          }).length;\n          if (squaresLeft == 0) {\n            if (!gameFinished) {\n              gameWon();\n              gameEnded();\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Endgame\n */\n// Handle end\nfunction gameEnded() {\n  gameFinished = true;\n  if (window.location.hash === '') {\n    calculateWinPercentage();\n\n    let totalTime;\n    switch (level) {\n      case 'beginner':\n        totalTime = parseInt(localStorage.getItem('beginnerTotalTime'));\n        totalTime += timePassed;\n        localStorage.setItem('beginnerTotalTime', totalTime);\n        break;\n      case 'intermediate':\n        totalTime = parseInt(localStorage.getItem('intermediateTotalTime'));\n        totalTime += timePassed;\n        localStorage.setItem('intermediateTotalTime', totalTime);\n        break;\n      case 'expert':\n        totalTime = parseInt(localStorage.getItem('expertTotalTime'));\n        totalTime += timePassed;\n        localStorage.setItem('expertTotalTime', totalTime);\n        break;\n    }\n  }\n}\n\n// Handle win\nfunction gameWon() {\n  NUMBERS[0] = WON;\n  squares.forEach(function (s) {\n    s.opened = true;\n  });\n\n  // Update local storage\n  // Won Data\n  if (window.location.hash === '') {\n    let won;\n    switch (level) {\n      case 'beginner':\n        won = parseInt(localStorage.getItem('beginnerWon'));\n        won += 1;\n        localStorage.setItem('beginnerWon', won);\n        break;\n      case 'intermediate':\n        won = parseInt(localStorage.getItem('intermediateWon'));\n        won += 1;\n        localStorage.setItem('intermediateWon', won);\n        break;\n      case 'expert':\n        won = parseInt(localStorage.getItem('expertWon'));\n        won += 1;\n        localStorage.setItem('expertWon', won);\n        break;\n    }\n\n    // Moves Data\n    let bestMoves;\n    switch (level) {\n      case 'beginner':\n        bestMoves = Number(localStorage.getItem('beginnerBestMoves'));\n        break;\n      case 'intermediate':\n        bestMoves = Number(localStorage.getItem('intermediateBestMoves'));\n        break;\n      case 'expert':\n        bestMoves = Number(localStorage.getItem('expertBestMoves'));\n        break;\n    }\n\n    if (bestMoves === 0) {\n      switch (level) {\n        case 'beginner':\n          localStorage.setItem('beginnerBestMoves', moves);\n          break;\n        case 'intermediate':\n          localStorage.setItem('intermediateBestMoves', moves);\n          break;\n        case 'expert':\n          localStorage.setItem('expertBestMoves', moves);\n          break;\n      }\n    } else {\n      if (moves < bestMoves) {\n        NUMBERS[0] = 'ðŸ¥³';\n        newBestMoves = true;\n        switch (level) {\n          case 'beginner':\n            localStorage.setItem('beginnerBestMoves', moves);\n            break;\n          case 'intermediate':\n            localStorage.setItem('intermediateBestMoves', moves);\n            break;\n          case 'expert':\n            localStorage.setItem('expertBestMoves', moves);\n            break;\n        }\n        localStorage.setItem('newBestMoves', 'true');\n      }\n    }\n\n    // Time Data\n    const endTime = new Date();\n    let time = (endTime - startTime) / 1000; //initially in milliseconds, divide by 1000 for seconds\n\n    let bestTime;\n    switch (level) {\n      case 'beginner':\n        bestTime = Number(localStorage.getItem('beginnerBestTime'));\n        break;\n      case 'intermediate':\n        bestTime = Number(localStorage.getItem('intermediateBestTime'));\n        break;\n      case 'expert':\n        bestTime = Number(localStorage.getItem('expertBestTime'));\n        break;\n    }\n\n    if (bestTime === 0) {\n      switch (level) {\n        case 'beginner':\n          localStorage.setItem('beginnerBestTime', time);\n          break;\n        case 'intermediate':\n          localStorage.setItem('intermediateBestTime', time);\n          break;\n        case 'expert':\n          localStorage.setItem('expertBestTime', time);\n          break;\n      }\n    } else {\n      if (time < bestTime) {\n        NUMBERS[0] = 'ðŸ¥³';\n        newBestTime = true;\n        switch (level) {\n          case 'beginner':\n            localStorage.setItem('beginnerBestTime', time);\n            break;\n          case 'intermediate':\n            localStorage.setItem('intermediateBestTime', time);\n            break;\n          case 'expert':\n            localStorage.setItem('expertBestTime', time);\n            break;\n        }\n        localStorage.setItem('newBestTime', 'true');\n      }\n    }\n  }\n  stopTimer = true;\n}\n\n// handle loss\nfunction gameLost() {\n  NUMBERS[0] = LOST;\n  squares.forEach(function (s) {\n    s.opened = true;\n  });\n\n  const endTime = new Date();\n  let time = endTime - startTime; //in ms\n  time = time / 1000;\n  stopTimer = true;\n}\n\n// Add move to total moves\nfunction addMove() {\n  let totalMoves;\n  switch (level) {\n    case 'beginner':\n      totalMoves = parseInt(localStorage.getItem('beginnerTotalMoves'));\n      totalMoves += 1;\n      localStorage.setItem('beginnerTotalMoves', totalMoves);\n      break;\n    case 'intermediate':\n      totalMoves = parseInt(localStorage.getItem('intermediateTotalMoves'));\n      totalMoves += 1;\n      localStorage.setItem('intermediateTotalMoves', totalMoves);\n      break;\n    case 'expert':\n      totalMoves = parseInt(localStorage.getItem('expertTotalMoves'));\n      totalMoves += 1;\n      localStorage.setItem('expertTotalMoves', totalMoves);\n      break;\n  }\n}\n\n// Calculate percentage of wins / total games played\nfunction calculateWinPercentage() {\n  if (window.location.hash === '') {\n    let played, won;\n    switch (level) {\n      case 'beginner':\n        played = parseInt(localStorage.getItem('beginnerPlayed'));\n        won = parseInt(localStorage.getItem('beginnerWon'));\n        break;\n      case 'intermediate':\n        played = parseInt(localStorage.getItem('intermediatePlayed'));\n        won = parseInt(localStorage.getItem('intermediateWon'));\n        break;\n      case 'expert':\n        played = parseInt(localStorage.getItem('expertPlayed'));\n        won = parseInt(localStorage.getItem('expertWon'));\n        break;\n    }\n    let winPercentage = null;\n\n    if (played !== 0) {\n      winPercentage = won / played;\n    }\n\n    if (winPercentage !== null) {\n      // Update local storage\n      switch (level) {\n        case 'beginner':\n          window.localStorage.setItem('beginnerWinPercentage', winPercentage);\n          break;\n        case 'intermediate':\n          window.localStorage.setItem('intermediateWinPercentage', winPercentage);\n          break;\n        case 'expert':\n          window.localStorage.setItem('expertWinPercentage', winPercentage);\n          break;\n      }\n    }\n  }\n}\n\n/**\n * Keyboard Action Handling\n */\nfunction keyPressed() {\n  // Set Level\n  if (keyCode === 49 || keyCode === 97) {\n    if (level !== 'beginner') {\n      localStorage.setItem('level', 'beginner');\n      window.location.reload();\n    }\n  }\n  if (keyCode === 50 || keyCode === 98) {\n    if (level !== 'intermediate') {\n      localStorage.setItem('level', 'intermediate');\n      window.location.reload();\n    }\n  }\n  if (keyCode === 51 || keyCode === 99) {\n    if (level !== 'expert') {\n      localStorage.setItem('level', 'expert');\n      window.location.reload();\n    }\n  }\n\n  // New Game\n  if (keyCode === 78) {\n    window.location.reload();\n  }\n}\n"],"names":["disableFriendlyErrors","document","addEventListener","event","preventDefault","themes","mine","name","title","detonation","won","lost","flower","mushroom","bear","octopus","japan","darkMode","JSON","parse","localStorage","getItem","theme","window","setItem","NUMBERS","settings","level","columns","rows","mines","size","squareSize"],"version":3,"file":"index.51f6c6cc.js.map"}