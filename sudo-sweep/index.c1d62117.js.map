{"mappings":"","sources":["src/sudo-sweep/Minesweeper.js"],"sourcesContent":["class Minesweeper {\n  constructor(x, y, w, h, subw, subh, font) {\n    this.x = x;\n    this.y = y;\n    this.w = w;\n    this.h = h;\n    this.subw = subw;\n    this.subh = subh;\n    this.size = w * h;\n    this.subsize = subw * subh;\n\n    this.grid;\n    this.visibility = [...Array(this.size * this.subw)].map((e) => Array(this.size * this.subw));\n    this.flagged = [...Array(this.size * this.subw)].map((e) => Array(this.size * this.subw));\n    this.exploded = false;\n    this.font = font;\n  }\n\n  setMines(sudoku) {\n    let grid = [...Array(this.size * this.subw)].map((e) => Array(8));\n\n    for (let i = 0; i < this.size; i++) {\n      for (let j = 0; j < this.size; j++) {\n        let mines = this.createMines(sudoku[i][j]);\n        grid = this.placeMines(grid, mines, i, j);\n      }\n    }\n    grid = this.getClues(grid);\n\n    this.grid = grid;\n  }\n\n  createMines(n) {\n    n -= 1; // modded for 0-8 instead of 1-9\n\n    let places = [];\n\n    for (let i = 0; i < this.subsize; i++) {\n      if (i < n) {\n        places.push('⁕');\n      } else {\n        places.push('');\n      }\n    }\n    return shuffle(places);\n  }\n\n  placeMines(grid, mines, x, y) {\n    for (let i = 0; i < this.subw; i++) {\n      for (let j = 0; j < this.subh; j++) {\n        const x2 = x * this.subw + i;\n        const y2 = y * this.subh + j;\n\n        grid[x2][y2] = mines[j * this.subw + i];\n      }\n    }\n    return grid;\n  }\n\n  getClues(grid) {\n    for (let i = 0; i < this.size * this.subw; i++) {\n      for (let j = 0; j < this.size * this.subh; j++) {\n        if (grid[i][j] === '⁕') {\n          continue;\n        }\n        const neighbours = this.getNeighbours(grid, i, j);\n\n        if (neighbours != 0) {\n          grid[i][j] = neighbours;\n        }\n      }\n    }\n    return grid;\n  }\n\n  getNeighbours(grid, x, y) {\n    let neighbours = 0;\n\n    for (let i = x - 1; i <= x + 1; i++) {\n      for (let j = y - 1; j <= y + 1; j++) {\n        if (i === x && j === y) {\n          continue;\n        }\n        if (i < 0 || i >= this.size * this.subw || j < 0 || j >= this.size * this.subh) {\n          continue;\n        }\n        if (grid[i][j] === '⁕') {\n          neighbours += 1;\n        }\n      }\n    }\n    return neighbours;\n  }\n\n  draw(x, y) {\n    push();\n    translate(this.x, this.y);\n\n    const cellSize = 60 / this.subw;\n\n    for (let i = 0; i < this.size * this.subw; i++) {\n      for (let j = 0; j < this.size * this.subh; j++) {\n        const x = i * cellSize;\n        const y = (j * 60) / this.subh;\n        const number = this.grid[i][j];\n\n        if (this.visibility[i][j] && !(this.flagged[i][j] && number === '⁕')) {\n          fill('#DBEBE9');\n        } else {\n          fill(white);\n        }\n        stroke(dark);\n        strokeWeight(1);\n        rect(x, y, cellSize, 60 / this.subh);\n\n        noStroke();\n        textAlign(CENTER, CENTER);\n        textFont(this.font);\n\n        if (number === '⁕') {\n          fill(dark);\n          textSize(cellSize);\n        } else {\n          fill(dark);\n          textSize(cellSize * 0.75);\n        }\n        if (this.flagged[i][j] && !(this.visibility[i][j] && number != '⁕')) {\n          fill(mid);\n          textSize(cellSize * 0.75);\n          text('?', x + cellSize / 2, y + 60 / this.subh / 2 + 2);\n        } else if (this.visibility[i][j]) {\n          if (number === '⁕') {\n            text('*', x + cellSize / 2, y + 60 / this.subh / 2 + 2);\n          } else {\n            text(number, x + cellSize / 2, y + 60 / this.subh / 2 + 2);\n          }\n        }\n      }\n    }\n    this.drawGuidelines(cellSize);\n    pop();\n  }\n\n  drawGuidelines(cellSize) {\n    cellSize *= this.subw;\n\n    for (let i = 0; i < this.size; i++) {\n      for (let j = 0; j < this.size; j++) {\n        const x = i * cellSize;\n        const y = j * cellSize;\n\n        noFill();\n        stroke(mid);\n        strokeWeight(3);\n        rect(x, y, cellSize, cellSize);\n      }\n    }\n    noFill();\n    stroke(dark);\n    strokeWeight(4);\n\n    rect(0, 0, cellSize * this.size, cellSize * this.size);\n    rect(cellSize * this.w, 0, cellSize * this.w, cellSize * this.size);\n    rect(0, cellSize * this.h, cellSize * this.size, cellSize * this.h);\n  }\n\n  clicked(x, y) {\n    x -= this.x;\n    y -= this.y;\n\n    let cellSize = 60 / this.subw;\n\n    for (let i = 0; i < this.size * this.subw; i++) {\n      for (let j = 0; j < this.size * this.subh; j++) {\n        if (x > i * cellSize && x < i * cellSize + cellSize) {\n          if (y > (j * 60) / this.subh && y < (j * 60) / this.subh + 60 / this.subh) {\n            if (startTime === '') {\n              startTime = new Date();\n              startTime = startTime.getTime();\n            }\n            if (mouseButton === LEFT && !this.flagged[i][j]) {\n              if (this.grid[i][j] === '⁕') {\n                this.explode();\n                lose = true;\n              } else if (this.grid[i][j] === '') {\n                this.visibility[i][j] = true;\n                this.freeNeighbours(i, j);\n              } else {\n                this.visibility[i][j] = true;\n              }\n            } else if (mouseButton != LEFT && !this.visibility[i][j]) {\n              this.flagged[i][j] = !this.flagged[i][j];\n            }\n            if (mouseButton === LEFT) {\n              this.chord(i, j);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  explode() {\n    for (let i = 0; i < this.size * this.subw; i++) {\n      for (let j = 0; j < this.size * this.subh; j++) {\n        this.visibility[i][j] = true;\n        this.exploded = true;\n      }\n    }\n  }\n\n  freeNeighbours(x, y) {\n    for (let i = x - 1; i <= x + 1; i++) {\n      for (let j = y - 1; j <= y + 1; j++) {\n        if (i === x && j === y) {\n          continue;\n        } else if (i < 0 || j < 0 || i >= this.size * this.subw || j >= this.size * this.subh) {\n          continue;\n        }\n        if (!this.visibility[i][j]) {\n          this.visibility[i][j] = true;\n\n          if (this.grid[i][j] === '') {\n            this.freeNeighbours(i, j);\n          }\n        }\n      }\n    }\n  }\n\n  chord(i, j) {\n    if (this.flaggedNeighbours(i, j) === this.grid[i][j]) {\n      this.chordNeighbours(i, j);\n    }\n  }\n\n  flaggedNeighbours(x, y) {\n    let neighbours = 0;\n\n    for (let i = x - 1; i <= x + 1; i++) {\n      for (let j = y - 1; j <= y + 1; j++) {\n        if (i === x && j === y) {\n          continue;\n        }\n        if (i < 0 || i >= this.size * this.subw || j < 0 || j >= this.size * this.subh) {\n          continue;\n        }\n        if (this.flagged[i][j] && !this.visibility[i][j]) {\n          neighbours += 1;\n        }\n      }\n    }\n    return neighbours;\n  }\n\n  chordNeighbours(x, y) {\n    for (let i = x - 1; i <= x + 1; i++) {\n      for (let j = y - 1; j <= y + 1; j++) {\n        if (i >= 0 && j >= 0 && i < this.size * this.subw && j < this.size * this.subh) {\n          if (this.flagged[i][j]) {\n            // continue;\n          } else if (this.grid[i][j] === '⁕') {\n            this.explode();\n          } else if (this.grid[i][j] === '') {\n            this.visibility[i][j] = true;\n            this.freeNeighbours(i, j);\n          } else {\n            this.visibility[i][j] = true;\n          }\n        }\n      }\n    }\n  }\n\n  validate() {\n    if (this.exploded) {\n      return false;\n    }\n    for (let i = 0; i < this.size * this.subw; i++) {\n      for (let j = 0; j < this.size * this.subh; j++) {\n        if (!this.visibility[i][j] && this.grid[i][j] !== '⁕') {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n}\n"],"names":[],"version":3,"file":"index.c1d62117.js.map"}