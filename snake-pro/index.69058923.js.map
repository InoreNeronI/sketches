{"mappings":"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","sources":["src/snake-pro/src/hamiltonian.js"],"sourcesContent":["const Hamiltonian = (findDestroyerStepLimit = 100, findConnectorStepLimit = 100, findConnectorIterLimit = 1000, updateLimit = 30) => {\n  const hm = {};\n\n  hm.getAction = (node, state = null) => {\n    if (hm.isHamiltonianCycle) {\n      return hm.policy[node.x][node.y];\n    } else return hm.spAgent.getAction(node);\n  };\n\n  hm.update = (state) => {\n    let updated = false;\n    if (hm.graph == null) {\n      // Init Graph\n      hm.graph = fnHamiltonian.buildCycle(\n        state.nx,\n        state.ny,\n        state.walls,\n        hm.findDestroyerStepLimit,\n        hm.findConnectorStepLimit,\n        hm.findConnectorIterLimit,\n      );\n      hm.isHamiltonianCycle = fnHamiltonian.isHamiltonianCycle(hm.graph);\n      updated = true;\n    } else if (!hm.isHamiltonianCycle) {\n      // Continue to search for a Hamiltonian Cycle\n      // TODO: Improve iteration efficiency\n      // Possibly get Sets of separate cycles in the graph, and only iterate on the edges of cycles that neighbor other edges,\n      // from smallest cycles\n      fnHamiltonian.invertConnectorPaths(hm.graph, 100, 1000);\n      hm.isHamiltonianCycle = fnHamiltonian.isHamiltonianCycle(hm.graph);\n      updated = true;\n    }\n\n    if (updated) {\n      if (hm.isHamiltonianCycle) {\n        hm.path = fnHamiltonian.buildPath(hm.graph);\n        hm.pathNodeIndex = NodeMap();\n        hm.path.forEach((vx, i) => hm.pathNodeIndex.set(vx, i));\n        hm.policy = fnHamiltonian.buildPolicy(hm.path, hm.graph.length, hm.graph[0].length);\n      } else {\n        // If not Cycle, then use Shortest Path agent\n        hm.spAgent.update(state, state.apple);\n        // Attempt to find a path in the given graph up to updateLimit times,\n        // beyond that, just re-init and try with a different graph\n        hm.updateCount++;\n        if (hm.updateCount >= hm.updateLimit) {\n          hm.reset();\n          hm.update(state);\n        }\n      }\n    }\n  };\n\n  hm.reset = () => {\n    hm.spAgent = ShortestPath();\n    hm.graph = null;\n    hm.isHamiltonianCycle = false;\n    hm.path = null;\n    hm.pathNodeIndex = null;\n    hm.policy = null;\n    hm.updateCount = 0;\n  };\n\n  hm.findDestroyerStepLimit = findDestroyerStepLimit;\n  hm.findConnectorStepLimit = findConnectorStepLimit;\n  hm.findConnectorIterLimit = findConnectorIterLimit;\n  hm.updateLimit = updateLimit;\n  hm.reset();\n\n  return hm;\n};\n\n// https://springerplus.springeropen.com/articles/10.1186/s40064-016-2746-8\nfnHamiltonian = {\n  /**\n   * Returns a graph initialized to the given dimensions.\n   * Will attempt to find a hamiltonian cycle while adhering to the given limits.\n   */\n  buildCycle: (nx, ny, exclusions = NodeSet(), findDestroyerStepLimit = 0, findConnectorStepLimit = 100, findConnectorIterLimit = 100) => {\n    let graph = fnHamiltonian.mkGraph(nx, ny);\n    fnHamiltonian.processExclusions(graph, exclusions);\n    fnHamiltonian.runDeletion(graph);\n    fnHamiltonian.getDestroyerPaths(graph, findDestroyerStepLimit).forEach((p) => fnHamiltonian.invertPath(p));\n    fnHamiltonian.invertConnectorPaths(graph, findConnectorStepLimit, findConnectorIterLimit);\n    return graph;\n  },\n\n  /**\n   * Deletes all edges for the vertices given in the exclusions Set\n   */\n  processExclusions: (graph, exclusions) => {\n    exclusions.lookup.forEach((node) => {\n      game.DIRECTIONS.forEach((d) => graph[node.x][node.y].deleteEdge(d));\n    });\n  },\n\n  /**\n   * Returns an array containing the vertex progression for the hamiltonian cycle\n   */\n  buildPath: (graph) => {\n    let start = null;\n    // Check that all vertices are valid\n    for (let i = 0; i < graph.length; i++) {\n      for (let j = 0; j < graph[i].length; j++) {\n        if (start == null && graph[i][j].nEdges != 0) {\n          start = graph[i][j];\n          break;\n        }\n      }\n    }\n\n    // Build Path\n    let path = [start];\n    let prevDir = start.getMove();\n    let current = start.getNeighbor(prevDir);\n    while (current != start && current != null && path.length < graph.length * graph[0].length) {\n      path.push(current);\n      prevDir = current.getMove(game.DIR_OPPOSITES.get(prevDir));\n      if (prevDir == null) break; // A dead end has been hit\n      current = current.getNeighbor(prevDir);\n    }\n\n    if (current == start) path.push(current);\n\n    return path;\n  },\n\n  /**\n   * Returns a 2D matrix with directions to follow on each node based on the given path\n   */\n  buildPolicy: (path, nx, ny) => {\n    let policy = Array.from(Array(nx), (_) => Array.from(Array(ny), (_) => null));\n    for (let i = 0; i < path.length - 1; i++) {\n      const srcVx = path[i];\n      const nextVx = path[i + 1];\n      policy[srcVx.x][srcVx.y] = nextVx.sub(srcVx);\n    }\n    return policy;\n  },\n\n  /**\n   * Child class of Node that also includes methods for tracking and modifying its edges\n   */\n  Vertex: (x, y, graph) => {\n    const vx = Node(x, y);\n    vx.graph = graph;\n    vx.edges = NodeMap();\n    game.DIRECTIONS.forEach((dir) => vx.edges.set(dir, 1));\n    vx.nEdges = game.DIRECTIONS.length;\n\n    // Set Edge to a specific value\n    vx.setEdge = (dir, value) => {\n      if (value > 0 && vx.edges.get(dir) <= 0) vx.nEdges++;\n      else if (value <= 0 && vx.edges.get(dir) > 0) vx.nEdges--;\n      vx.edges.set(dir, value);\n    };\n\n    // Returns the value of an end in a given direction\n    vx.getEdge = (dir) => vx.edges.get(dir);\n\n    // Invert the value of an edge between 0 and 1 (also affects its neighbor)\n    // Has no effect on values less than 0\n    vx.invertEdge = (dir) => {\n      if (vx.getEdge(dir) >= 0) {\n        vx.setEdge(dir, vx.getEdge(dir) > 0 ? 0 : 1);\n        vx.getNeighbor(dir).setEdge(game.DIR_OPPOSITES.get(dir), vx.getEdge(dir));\n      }\n    };\n\n    // Delete this edge by setting its value to -1 (also affects its neighbor)\n    vx.deleteEdge = (dir) => {\n      if (vx.getEdge(dir) >= -1) {\n        vx.setEdge(dir, -1);\n        const neighbor = vx.getNeighbor(dir);\n        if (neighbor != null) neighbor.setEdge(game.DIR_OPPOSITES.get(dir), vx.getEdge(dir));\n      }\n    };\n\n    // Returns the neighboring Vertex in a given direction\n    vx.getNeighbor = (dir) => {\n      const node = vx.sum(dir);\n      return node.inBounds(vx.graph.length, vx.graph[0].length) ? vx.graph[node.x][node.y] : null;\n    };\n\n    // Returns the first direction to move in from the vertex\n    vx.getMove = (exDir = null) => {\n      for (let i = 0; i < game.DIRECTIONS.length; i++) {\n        if (vx.getEdge(game.DIRECTIONS[i]) > 0 && (exDir == null ? true : !game.DIRECTIONS[i].eq(exDir))) {\n          return game.DIRECTIONS[i];\n        }\n      }\n      return null;\n    };\n\n    return vx;\n  },\n\n  /**\n   * Returns a graph of width nx and height ny where all vertexes are connected to their\n   * North, South, East and West neighbors (except at the 4 sides of the graph)\n   */\n  mkGraph: (nx, ny) => {\n    const graph = Array.from(Array(nx), (_) => Array.from(Array(ny), (_) => null));\n    // 1 for edge, 0 for deleted edge, -1 for no edge\n    for (let i = 0; i < graph.length; i++) {\n      for (let j = 0; j < graph[i].length; j++) {\n        graph[i][j] = fnHamiltonian.Vertex(i, j, graph);\n        // No edges at the ends of the graph\n        if (i == 0) graph[i][j].deleteEdge(game.WEST);\n        else if (i == graph.length - 1) graph[i][j].deleteEdge(game.EAST);\n        if (j == 0) graph[i][j].deleteEdge(game.NORTH);\n        else if (j == graph[i].length - 1) graph[i][j].deleteEdge(game.SOUTH);\n      }\n    }\n    return graph;\n  },\n\n  /**\n   * Randomly delete surplus edges in place from each vertex until there are none remaining\n   */\n  runDeletion: (graph) => {\n    for (let i = 0; i < graph.length; i++) {\n      for (let j = 0; j < graph[i].length; j++) {\n        // In vertex[i,j],\n        const vx = graph[i][j];\n        const ord = game.DIRECTIONS.concat();\n        utils.shuffle(ord);\n        // Evaluate edges in random order,\n        for (let k = 0; k < ord.length; k++) {\n          // no point looping if their at minimum number\n          if (vx.nEdges <= 2) break;\n          // If there are more than 2 edges and the current edge has not been deleted\n          // and will not cause its neighbor to end up with less than 2 edges as well,\n          else if (vx.getEdge(ord[k]) > 0 && vx.getNeighbor(ord[k]).nEdges > 2) {\n            // Delete the current edge\n            vx.invertEdge(ord[k]);\n          }\n        }\n      }\n    }\n  },\n\n  /**\n   * Returns a NodeSet of all vertices with more than 2 edges remaining\n   */\n  getRemainders: (graph) => {\n    const rems = NodeSet();\n    for (let i = 0; i < graph.length; i++) {\n      for (let j = 0; j < graph[i].length; j++) {\n        if (graph[i][j].nEdges > 2) rems.addNode(graph[i][j]);\n      }\n    }\n    return rems;\n  },\n\n  /**\n   * Object used to track the progress of a path, used in findDestroyer()\n   */\n  PathNode: (vertex, parent) => {\n    const dn = {};\n\n    dn.vertex = vertex;\n    dn.parent = parent;\n    dn.dirToParent = parent == null ? null : parent.vertex.sub(dn.vertex);\n    dn.length = parent == null ? 1 : parent.length + 1;\n    dn.pathVertices = parent == null ? NodeSet() : dn.parent.pathVertices.copy();\n    dn.pathVertices.addNode(dn.vertex);\n    // These only works assuming nodes are added to the path correctly\n    dn.isDestroyer =\n      dn.length >= 4 &&\n      dn.length % 2 == 0 &&\n      dn.vertex.getEdge(dn.dirToParent) == 1 &&\n      dn.parent.vertex.getEdge(dn.parent.dirToParent) == 0;\n    dn.isAltEdge = dn.length < 3 ? false : dn.vertex.getEdge(dn.dirToParent) != dn.parent.vertex.getEdge(dn.parent.dirToParent);\n    dn.isEvenAltEdge = dn.isAltEdge && dn.length % 2 == 1;\n\n    dn.toPath = () => {\n      const path = [];\n      for (c = dn; c != null; c = c.parent) {\n        path.push(c.vertex);\n      }\n      return path;\n    };\n\n    return dn;\n  },\n\n  /**\n   * Breadth first search, can produce cycle unless prohibited in pathCriteria\n   */\n  _find: (graph, start, goals, stepLimit = 0, pathCriteria = () => true, goalCriteria = () => true) => {\n    const continuePath = (current, dir) => {\n      const neighbor = current.vertex.getNeighbor(dir);\n      // If the next vertex is not already part of the path (unless it is the start node), and meets path criteria\n      return neighbor != null && (neighbor == start || !current.pathVertices.hasNode(neighbor)) && pathCriteria(current, dir);\n    };\n    // Start BFS\n    const open = [fnHamiltonian.PathNode(start, null)];\n    let steps = 0;\n    let current = null;\n    while ((stepLimit <= 0 || steps < stepLimit) && open.length > 0 && goals.size() > 0) {\n      current = open.shift();\n      if (goals.hasNode(current.vertex) && goalCriteria(current)) {\n        goals.deleteNode(current.vertex);\n        return current.toPath();\n      }\n      // For each direction from this vertex,\n      game.DIRECTIONS.forEach((dir) => {\n        // Excluding the direction to the parent, add to open if meets criteria.\n        if (current.parent == null || !dir.eq(current.dirToParent)) {\n          if (continuePath(current, dir)) {\n            const node = current.vertex.sum(dir);\n            open.push(fnHamiltonian.PathNode(graph[node.x][node.y], current));\n          }\n        }\n      });\n      steps++;\n    }\n\n    return [start];\n  },\n\n  /**\n   * Returns the shortest Connector cycle for a given starting node.\n   * This mutates the goals object by deleting the vertices that are part of the path.\n   */\n  findConnector: (graph, start, goals, stepLimit = 100) => {\n    //\n    const pathCriteria = (current, dir) => {\n      return current.length < 3 || (current.isAltEdge && current.vertex.getEdge(current.dirToParent) != current.vertex.getEdge(dir));\n    };\n    const goalCriteria = (current) => current.isEvenAltEdge;\n    return fnHamiltonian._find(graph, start, goals, stepLimit, pathCriteria, goalCriteria);\n  },\n\n  /**\n   * Randomly selects a vertex to search for a connector cycle, if one is found, it will invert it.\n   * This is done until the iteration limit is hit or a hamiltonian cycle is found.\n   */\n  invertConnectorPaths: (graph, stepLimit = 0, iterationLimit = 100) => {\n    for (let i = 0; i < iterationLimit; i++) {\n      const start = graph[utils.randInt(0, graph.length - 1)][utils.randInt(0, graph[0].length - 1)];\n      const goals = NodeSet();\n      goals.addNode(start);\n      fnHamiltonian.invertPath(fnHamiltonian.findConnector(graph, start, goals, stepLimit));\n      if (fnHamiltonian.isHamiltonianCycle(graph)) break;\n    }\n  },\n\n  /**\n   * Returns the shortest Destroyer path found between start and any one of the goals.\n   * This mutates the goals object by deleting the vertices that are part of the path.\n   */\n  findDestroyer: (graph, start, goals, stepLimit = 0) => {\n    const pathCriteria = (current, dir) => {\n      // If below minimum length, check if it is alternating in the right way\n      return (\n        (current.length == 1 && current.vertex.getEdge(dir) == 1) ||\n        (current.length == 2 && current.vertex.getEdge(current.dirToParent) == 1 && current.vertex.getEdge(dir) == 0) ||\n        (current.length == 3 && current.vertex.getEdge(current.dirToParent) == 0 && current.vertex.getEdge(dir) == 1) ||\n        // If isDestroyer and the next edge has been deleted\n        (current.length >= 4 && current.isDestroyer && current.vertex.getEdge(dir) == 0) ||\n        // If not destroyer, parent isDestroyer and the next edge exists\n        (current.length >= 4 && !current.isDestroyer && current.parent.isDestroyer && current.vertex.getEdge(dir) == 1)\n      );\n    };\n    goals.deleteNode(start);\n    return fnHamiltonian._find(graph, start, goals, stepLimit, pathCriteria);\n  },\n\n  /**\n   * Returns an array of destroyer paths in a given graph.\n   * These paths start and end at remainder nodes (more than 2 edges).\n   */\n  getDestroyerPaths: (graph, stepLimit = 0) => {\n    const remainders = fnHamiltonian.getRemainders(graph);\n    const remCopy = remainders.copy();\n    const paths = [];\n    remainders.lookup.forEach((vx) => {\n      if (remCopy.hasNode(vx)) paths.push(fnHamiltonian.findDestroyer(graph, vx, remCopy, stepLimit));\n    });\n    return paths;\n  },\n\n  /**\n   * Inverts all edges in the path, 10101 becomes 01010\n   * When used on a destroyer path where the start and end vertices have 3 edges each,\n   * It will reduce them both down to 2 edges while maintaining the same number of edges for\n   * all other vertices in the path.\n   */\n  invertPath: (path) => {\n    path.forEach((vx, i) => {\n      if (i < path.length - 1) {\n        const dir = path[i + 1].sub(vx);\n        vx.invertEdge(dir);\n      }\n    });\n  },\n\n  /**\n   * Returns true if the graph contains a Hamiltonian cycle\n   */\n  isHamiltonianCycle: (graph) => {\n    const exclusions = NodeSet();\n    const pathVertices = NodeSet();\n    let start = null;\n    // Check that all vertices are valid\n    for (let i = 0; i < graph.length; i++) {\n      for (let j = 0; j < graph[i].length; j++) {\n        // No edges means it is deliberately excluded from the path\n        if (graph[i][j].nEdges == 0) exclusions.addNode(graph[i][j]);\n        // Must only have 2 edges\n        else if (graph[i][j].nEdges != 2) return false;\n        else if (start == null) start = graph[i][j];\n      }\n    }\n\n    // Go through the path and check if it is a Hamiltonian Cycle\n    pathVertices.addNode(start);\n    let prevDir = start.getMove();\n    let current = start.getNeighbor(prevDir);\n    while (!pathVertices.hasNode(current) && !exclusions.hasNode(current)) {\n      pathVertices.addNode(current);\n      prevDir = current.getMove(game.DIR_OPPOSITES.get(prevDir));\n      current = current.getNeighbor(prevDir);\n      if (current == null) break;\n    }\n\n    const nVx = pathVertices.size() + exclusions.size();\n    const nGraphVx = graph.length * graph[0].length;\n    return current != null && current == start && nVx == nGraphVx;\n  },\n\n  /**\n   * Returns a string representation of the given graph\n   */\n  toString: (graph) => {\n    let string = '';\n    // Rows first and then Columns\n    for (let j = 0; j < graph[0].length; j++) {\n      for (let i = 0; i < graph.length; i++) {\n        for (let k = 0; k < game.DIRECTIONS.length; k++) {\n          const v = graph[i][j].getEdge(game.DIRECTIONS[k]);\n          if (v == 1) string += game.DIR_SYMBOLS.get(game.DIRECTIONS[k]);\n          else string += ' ';\n        }\n        string += ', ';\n      }\n      string += '\\n';\n    }\n    return string;\n  },\n};\n"],"names":[],"version":3,"file":"index.69058923.js.map"}