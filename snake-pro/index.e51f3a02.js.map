{"mappings":"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","sources":["<anon>","src/snake-pro/src/game.js"],"sourcesContent":["/**\n * This is the object used for each snake segment and apple\n * It contains its integer grid location, as well as some useful methods\n */ const Node = (x, y)=>{\n    const node = {};\n    node.x = x;\n    node.y = y;\n    /**\n   * Returns true if node is in game boundary given by nx, ny\n   */ node.inBounds = (nx, ny)=>node.x >= 0 && node.x < nx && node.y >= 0 && node.y < ny;\n    /**\n   * Returns true if node's components equal n's components\n   */ node.eq = (n)=>node.x == n.x && node.y == n.y;\n    /**\n   * Returns a new Node with the sum of node and n's components\n   */ node.sum = (n)=>Node(node.x + n.x, node.y + n.y);\n    /**\n   * Returns a new Node with the difference of node and n's components\n   */ node.sub = (n)=>Node(node.x - n.x, node.y - n.y);\n    return node;\n};\n/**\n * Object that maps a value to a location\n */ const NodeMap = ()=>{\n    const nm = {};\n    nm.lookup = new Map();\n    nm.encXY = (x, y)=>`${x},${y}`;\n    nm.set = (node, value)=>nm.lookup.set(nm.encXY(node.x, node.y), value);\n    nm.get = (node)=>nm.lookup.get(nm.encXY(node.x, node.y));\n    nm.size = ()=>nm.lookup.size;\n    return nm;\n};\n/**\n * Object that maps a Node to a location\n */ const NodeSet = ()=>{\n    const ns = {};\n    ns.lookup = new Map();\n    ns.encXY = (x, y)=>`${x},${y}`;\n    ns.add = (x, y)=>ns.lookup.set(ns.encXY(x, y), Node(x, y));\n    ns.addNode = (node)=>ns.lookup.set(ns.encXY(node.x, node.y), node);\n    ns.delete = (x, y)=>ns.lookup.delete(ns.encXY(x, y));\n    ns.deleteNode = (node)=>ns.lookup.delete(ns.encXY(node.x, node.y));\n    ns.has = (x, y)=>ns.lookup.has(ns.encXY(x, y));\n    ns.hasNode = (node)=>ns.lookup.has(ns.encXY(node.x, node.y));\n    ns.get = (x, y)=>ns.lookup.get(ns.encXY(x, y));\n    ns.size = ()=>ns.lookup.size;\n    ns.copy = ()=>{\n        const nsCopy = NodeSet();\n        nsCopy.lookup = new Map(ns.lookup);\n        return nsCopy;\n    };\n    return ns;\n};\n/**\n * This contains all the functions needed to run the game\n */ const game = {\n    /**\n   * Constants\n   */ NORTH: Node(0, -1),\n    SOUTH: Node(0, 1),\n    EAST: Node(1, 0),\n    WEST: Node(-1, 0),\n    /**\n   * Returns a State with mutations based on update\n   */ next: (nx, ny, walls)=>(state = null, update = null)=>{\n            if (state == null) {\n                const yStart = Math.floor(ny / 2);\n                const snake = [\n                    Node(1, yStart),\n                    Node(0, yStart)\n                ];\n                return {\n                    isAlive: true,\n                    justEaten: true,\n                    snake: snake,\n                    direction: game.EAST,\n                    apple: game.nextApple(nx, ny, snake, walls),\n                    walls: walls,\n                    nx: nx,\n                    ny: ny\n                };\n            } else {\n                const isValidDir = game.isValidDir(state.snake, update ? update.direction : null);\n                // Necessary otherwise 1/4 exploration moves in qlearning could result in death\n                const direction = isValidDir ? update.direction : state.direction;\n                const head = game.nextHead(state.snake, direction);\n                const willEat = game.willEat(head, state.apple);\n                const willLive = game.willLive(state.nx, state.ny, head, state.snake, state.walls);\n                const snake = willLive ? game.nextSnake(state.snake, head, willEat) : state.snake;\n                return {\n                    isAlive: willLive,\n                    justEaten: willEat,\n                    snake: snake,\n                    direction: direction,\n                    apple: willEat ? game.nextApple(state.nx, state.ny, snake, state.walls) : state.apple,\n                    walls: state.walls,\n                    nx: state.nx,\n                    ny: state.ny\n                };\n            }\n        },\n    /**\n   *\n   */ isValidDir: (snake, dir)=>dir == null ? false : !game.nextHead(snake, dir).eq(snake[1]),\n    /**\n   * Returns true if head is equal to apple\n   */ willEat: (head, apple)=>head.eq(apple),\n    /**\n   * Returns true if snake does not leave the game area or intercept itself\n   */ willLive: (nx, ny, head, snake, walls)=>{\n        return head.inBounds(nx, ny) && !snake.some((node)=>node.eq(head)) && !walls.has(head.x, head.y);\n    },\n    /**\n   * Returns a Node where the snake's head would be if it moved toward dir\n   */ nextHead: (snake, dir)=>snake[0].sum(dir),\n    /**\n   * If grow is true, return head + snake, else return head + snake[0:-1]\n   */ nextSnake: (snake, head, grow)=>[\n            head\n        ].concat(grow ? snake : snake.slice(0, -1)),\n    /**\n   * Returns a randomly positioned node that excludes any part of snake\n   * If null, then the snake has filled all possible positions in the game\n   */ nextApple: (nx, ny, snake, walls)=>{\n        if (snake.length + walls.size() >= nx * ny) return null;\n        let apple = null;\n        while(apple == null || snake.some((node)=>node.eq(apple)) || walls.has(apple.x, apple.y))apple = Node(utils.randInt(0, nx - 1), utils.randInt(0, ny - 1));\n        return apple;\n    }\n};\ngame.DIRECTIONS = [\n    game.NORTH,\n    game.SOUTH,\n    game.EAST,\n    game.WEST\n];\ngame.DIR_SYMBOLS = NodeMap();\ngame.DIR_SYMBOLS.set(game.NORTH, \"^\");\ngame.DIR_SYMBOLS.set(game.SOUTH, \"v\");\ngame.DIR_SYMBOLS.set(game.EAST, \">\");\ngame.DIR_SYMBOLS.set(game.WEST, \"<\");\ngame.DIR_OPPOSITES = NodeMap();\ngame.DIR_OPPOSITES.set(game.NORTH, game.SOUTH);\ngame.DIR_OPPOSITES.set(game.SOUTH, game.NORTH);\ngame.DIR_OPPOSITES.set(game.EAST, game.WEST);\ngame.DIR_OPPOSITES.set(game.WEST, game.EAST);\n\n//# sourceMappingURL=index.e51f3a02.js.map\n","/**\n * This is the object used for each snake segment and apple\n * It contains its integer grid location, as well as some useful methods\n */\nconst Node = (x, y) => {\n  const node = {};\n  node.x = x;\n  node.y = y;\n\n  /**\n   * Returns true if node is in game boundary given by nx, ny\n   */\n  node.inBounds = (nx, ny) => node.x >= 0 && node.x < nx && node.y >= 0 && node.y < ny;\n\n  /**\n   * Returns true if node's components equal n's components\n   */\n  node.eq = (n) => node.x == n.x && node.y == n.y;\n\n  /**\n   * Returns a new Node with the sum of node and n's components\n   */\n  node.sum = (n) => Node(node.x + n.x, node.y + n.y);\n\n  /**\n   * Returns a new Node with the difference of node and n's components\n   */\n  node.sub = (n) => Node(node.x - n.x, node.y - n.y);\n\n  return node;\n};\n\n/**\n * Object that maps a value to a location\n */\n\nconst NodeMap = () => {\n  const nm = {};\n  nm.lookup = new Map();\n  nm.encXY = (x, y) => `${x},${y}`;\n  nm.set = (node, value) => nm.lookup.set(nm.encXY(node.x, node.y), value);\n  nm.get = (node) => nm.lookup.get(nm.encXY(node.x, node.y));\n  nm.size = () => nm.lookup.size;\n\n  return nm;\n};\n\n/**\n * Object that maps a Node to a location\n */\nconst NodeSet = () => {\n  const ns = {};\n  ns.lookup = new Map();\n\n  ns.encXY = (x, y) => `${x},${y}`;\n\n  ns.add = (x, y) => ns.lookup.set(ns.encXY(x, y), Node(x, y));\n\n  ns.addNode = (node) => ns.lookup.set(ns.encXY(node.x, node.y), node);\n\n  ns.delete = (x, y) => ns.lookup.delete(ns.encXY(x, y));\n\n  ns.deleteNode = (node) => ns.lookup.delete(ns.encXY(node.x, node.y));\n\n  ns.has = (x, y) => ns.lookup.has(ns.encXY(x, y));\n\n  ns.hasNode = (node) => ns.lookup.has(ns.encXY(node.x, node.y));\n\n  ns.get = (x, y) => ns.lookup.get(ns.encXY(x, y));\n\n  ns.size = () => ns.lookup.size;\n\n  ns.copy = () => {\n    const nsCopy = NodeSet();\n    nsCopy.lookup = new Map(ns.lookup);\n    return nsCopy;\n  };\n\n  return ns;\n};\n\n/**\n * This contains all the functions needed to run the game\n */\nconst game = {\n  /**\n   * Constants\n   */\n  NORTH: Node(0, -1),\n  SOUTH: Node(0, 1),\n  EAST: Node(1, 0),\n  WEST: Node(-1, 0),\n\n  /**\n   * Returns a State with mutations based on update\n   */\n  next:\n    (nx, ny, walls) =>\n    (state = null, update = null) => {\n      if (state == null) {\n        const yStart = Math.floor(ny / 2);\n        const snake = [Node(1, yStart), Node(0, yStart)];\n        return {\n          isAlive: true,\n          justEaten: true,\n          snake: snake,\n          direction: game.EAST,\n          apple: game.nextApple(nx, ny, snake, walls),\n          walls: walls,\n          nx: nx,\n          ny: ny,\n        };\n      } else {\n        const isValidDir = game.isValidDir(state.snake, update ? update.direction : null);\n        // Necessary otherwise 1/4 exploration moves in qlearning could result in death\n        const direction = isValidDir ? update.direction : state.direction;\n        const head = game.nextHead(state.snake, direction);\n        const willEat = game.willEat(head, state.apple);\n        const willLive = game.willLive(state.nx, state.ny, head, state.snake, state.walls);\n        const snake = willLive ? game.nextSnake(state.snake, head, willEat) : state.snake;\n        return {\n          isAlive: willLive,\n          justEaten: willEat,\n          snake: snake,\n          direction: direction,\n          apple: willEat ? game.nextApple(state.nx, state.ny, snake, state.walls) : state.apple,\n          walls: state.walls,\n          nx: state.nx,\n          ny: state.ny,\n        };\n      }\n    },\n\n  /**\n   *\n   */\n  isValidDir: (snake, dir) => (dir == null ? false : !game.nextHead(snake, dir).eq(snake[1])),\n\n  /**\n   * Returns true if head is equal to apple\n   */\n  willEat: (head, apple) => head.eq(apple),\n\n  /**\n   * Returns true if snake does not leave the game area or intercept itself\n   */\n  willLive: (nx, ny, head, snake, walls) => {\n    return head.inBounds(nx, ny) && !snake.some((node) => node.eq(head)) && !walls.has(head.x, head.y);\n  },\n\n  /**\n   * Returns a Node where the snake's head would be if it moved toward dir\n   */\n  nextHead: (snake, dir) => snake[0].sum(dir),\n\n  /**\n   * If grow is true, return head + snake, else return head + snake[0:-1]\n   */\n  nextSnake: (snake, head, grow) => [head].concat(grow ? snake : snake.slice(0, -1)),\n\n  /**\n   * Returns a randomly positioned node that excludes any part of snake\n   * If null, then the snake has filled all possible positions in the game\n   */\n  nextApple: (nx, ny, snake, walls) => {\n    if (snake.length + walls.size() >= nx * ny) return null;\n    let apple = null;\n    while (apple == null || snake.some((node) => node.eq(apple)) || walls.has(apple.x, apple.y)) {\n      apple = Node(utils.randInt(0, nx - 1), utils.randInt(0, ny - 1));\n    }\n    return apple;\n  },\n};\n\ngame.DIRECTIONS = [game.NORTH, game.SOUTH, game.EAST, game.WEST];\n\ngame.DIR_SYMBOLS = NodeMap();\ngame.DIR_SYMBOLS.set(game.NORTH, '^');\ngame.DIR_SYMBOLS.set(game.SOUTH, 'v');\ngame.DIR_SYMBOLS.set(game.EAST, '>');\ngame.DIR_SYMBOLS.set(game.WEST, '<');\n\ngame.DIR_OPPOSITES = NodeMap();\ngame.DIR_OPPOSITES.set(game.NORTH, game.SOUTH);\ngame.DIR_OPPOSITES.set(game.SOUTH, game.NORTH);\ngame.DIR_OPPOSITES.set(game.EAST, game.WEST);\ngame.DIR_OPPOSITES.set(game.WEST, game.EAST);\n"],"names":["Node","x","y","node","inBounds","nx","ny","eq","n","sum","sub","NodeMap","nm","lookup","Map","encXY","set","value","get","size","game","NORTH","SOUTH","EAST","WEST","next","walls","state","update","yStart","Math","floor","snake","isAlive","justEaten","direction","apple","nextApple","isValidDir","head","nextHead","willEat","willLive","nextSnake","dir","some","has","grow","concat","slice","length","utils","randInt","DIRECTIONS","DIR_SYMBOLS","DIR_OPPOSITES"],"version":3,"file":"index.e51f3a02.js.map"}