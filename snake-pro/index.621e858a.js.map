{"mappings":"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","sources":["<anon>","src/snake-pro/src/sketch.js"],"sourcesContent":["const sketch = (p)=>{\n    FRAMERATE_MAX = 60;\n    FRAMERATE_MIN = 1;\n    FRAMERATE_STEP = 1;\n    FRAMERATE_INITIAL = FRAMERATE_MAX;\n    SIZE_MAX = 25;\n    SIZE_MIN = 2;\n    SIZE_STEP = 1;\n    SIZE_INITIAL = 10;\n    SIZE_INITIAL_HAMILTONIAN = 4;\n    SIZE_MAX_HAMILTONIAN = 6;\n    // Pre-allocate DOM component vars, cant be initialized until setup() is called\n    let canvas = null;\n    const initCanvas = ()=>{\n        canvas = p.createCanvas(600, 600);\n        canvas.parent(\"#canvas\");\n    };\n    /**\n   * Score Elements\n   */ let score = 0;\n    let scoreCounter = null;\n    const initScoreCounter = ()=>{\n        scoreCounter = p.createSpan(`${score}`);\n        scoreCounter.parent(\"#scoreCount\");\n    };\n    const calcScore = (state)=>state.snake.length - 2;\n    const updateScore = (s)=>{\n        score = s;\n        scoreCounter.html(score);\n    };\n    let scores = [];\n    let scoreMean = null;\n    let scoreMedian = null;\n    let scoreMin = null;\n    let scoreMax = null;\n    let gameCount = null;\n    const initScoreStats = ()=>{\n        gameCount = p.createSpan(\"0\");\n        gameCount.parent(\"#gameCount\");\n        scoreMean = p.createSpan(\"0\");\n        scoreMean.parent(\"#scoreMean\");\n        scoreMedian = p.createSpan(\"0\");\n        scoreMedian.parent(\"#scoreMedian\");\n        scoreMin = p.createSpan(\"0\");\n        scoreMin.parent(\"#scoreMin\");\n        scoreMax = p.createSpan(\"0\");\n        scoreMax.parent(\"#scoreMax\");\n    };\n    const updateScoreStats = (score)=>{\n        if (score >= 0) scores.push(score);\n        scores.sort((a, b)=>a - b);\n        const sum = scores.reduce((acc, v)=>acc + v, 0);\n        const mid = Math.floor(scores.length / 2);\n        gameCount.html(scores.length);\n        scoreMean.html(scores.length > 0 ? (sum / scores.length).toFixed(2) : 0);\n        scoreMedian.html(scores.length > 0 ? scores[mid] : 0);\n        scoreMin.html(scores.length > 0 ? scores[0] : 0);\n        scoreMax.html(scores.length > 0 ? scores[scores.length - 1] : 0);\n    };\n    /**\n   * Player Selection Elements\n   */ const HUMAN = 0;\n    const QLEARN = 1;\n    const SP = 2;\n    const HMC = 3;\n    let playerSelect = null;\n    const initPlayerSelect = ()=>{\n        playerSelect = p.createSelect();\n        playerSelect.parent(\"#playerSelect\");\n        playerSelect.option(\"Human\", HUMAN);\n        playerSelect.option(\"Q-Learning\", QLEARN);\n        playerSelect.option(\"Shortest Path\", SP);\n        playerSelect.option(\"Hamiltonian Cycle\", HMC);\n        playerSelect.value(HMC);\n        playerSelect.changed(()=>{\n            gameSizeSlider.remove();\n            gameSizeLabel.remove();\n            initGameSizeSlider();\n            resetGame();\n        });\n    };\n    /**\n   * Game Settings Elements\n   */ let drawArrowsCb = null;\n    let gameSizeLabel = null;\n    let gameSizeSlider = null;\n    const initGameSizeSlider = ()=>{\n        if (playerSelect.value() == HMC) gameSizeSlider = p.createSlider(SIZE_MIN, SIZE_MAX_HAMILTONIAN, SIZE_INITIAL_HAMILTONIAN, SIZE_STEP);\n        else gameSizeSlider = p.createSlider(SIZE_MIN, SIZE_MAX, SIZE_INITIAL, SIZE_STEP);\n        gameSizeLabel = p.createSpan(`${gameSizeSlider.value()}`);\n        gameSizeLabel.parent(\"#gameSizeLbl\");\n        gameSizeSlider.parent(\"#gameSize\");\n        gameSizeSlider.changed(()=>{\n            gameSizeLabel.html(gameSizeSlider.value());\n            resetGame();\n        });\n    };\n    let drawWallsCb = null;\n    let gameSpeedLabel = null;\n    let gameSpeedSlider = null;\n    const initGameSpeedSlider = ()=>{\n        gameSpeedSlider = p.createSlider(FRAMERATE_MIN, FRAMERATE_MAX, FRAMERATE_INITIAL, FRAMERATE_STEP);\n        gameSpeedLabel = p.createSpan(`${gameSpeedSlider.value()}`);\n        gameSpeedLabel.parent(\"#gameSpeedLbl\");\n        gameSpeedSlider.parent(\"#gameSpeed\");\n        gameSpeedSlider.changed(()=>{\n            if (!drawWallsCb.checked()) p.frameRate(gameSpeedSlider.value());\n            gameSpeedLabel.html(gameSpeedSlider.value());\n        });\n    };\n    let clearWallsBtn = null;\n    let makeWalls = false;\n    let wallsSave = NodeSet();\n    const initWallsBtns = ()=>{\n        drawWallsCb = p.createCheckbox(\" Add/Remove Walls (pauses game)\", false);\n        drawWallsCb.parent(\"#drawWalls\");\n        drawWallsCb.changed(()=>{\n            if (drawWallsCb.checked()) p.frameRate(FRAMERATE_MAX);\n            if (!drawWallsCb.checked() && playerSelect.value() == HMC) {\n                p.frameRate(gameSpeedSlider.value());\n                resetGame();\n            }\n        });\n        clearWallsBtn = p.createButton(\"Clear Walls\");\n        clearWallsBtn.parent(\"#drawWalls\");\n        clearWallsBtn.mousePressed(clearWalls);\n    };\n    const clearWalls = ()=>{\n        wallsSave = NodeSet();\n        state.walls = wallsSave;\n        if (playerSelect.value() == HMC) resetGame();\n    };\n    /**\n   * Game State\n   */ const nX = ()=>2 * gameSizeSlider.value();\n    const nY = ()=>2 * gameSizeSlider.value();\n    const toX = (i)=>Math.floor(i * p.width / nX());\n    const toY = (i)=>Math.floor(i * p.height / nY());\n    const fromX = (x)=>Math.floor(x * nX() / p.width);\n    const fromY = (y)=>Math.floor(y * nY() / p.height);\n    let next = null;\n    let state = null;\n    let update = null;\n    const restart = ()=>{\n        next = game.next(nX(), nY(), wallsSave);\n        state = next();\n        update = {\n            direction: game.EAST\n        };\n        qModel.reset();\n        spModel = ShortestPath();\n    };\n    const resetGame = ()=>{\n        scores = [];\n        updateScore(0);\n        updateScoreStats(-1);\n        hmcModel.reset();\n        restart();\n    };\n    // Models\n    let qModel = QLearn(100, 50, 1, 0.05, 0.01, 0.9, 0.9, 1, -1);\n    let spModel = null;\n    let hmcModel = Hamiltonian(100, 100, 1000, 10);\n    /**\n   * Setup\n   */ p.setup = ()=>{\n        initCanvas();\n        initGameSpeedSlider();\n        initWallsBtns();\n        initScoreCounter();\n        initScoreStats();\n        initPlayerSelect();\n        // Must be done after player select\n        initGameSizeSlider();\n        drawArrowsCb = p.createCheckbox(\" Draw Path Arrows\", true);\n        drawArrowsCb.parent(\"#arrows\");\n        p.frameRate(gameSpeedSlider.value());\n        resetGame();\n    };\n    /**\n   * Draw\n   */ p.draw = ()=>{\n        p.background(240);\n        if (!drawWallsCb.checked()) {\n            // Update Game State\n            state = next(state, update);\n            if (state.justEaten) updateScore(calcScore(state));\n            if (!state.isAlive || state.apple == null) {\n                updateScoreStats(calcScore(state));\n                restart();\n            }\n            // Update Models\n            if (playerSelect.value() == QLEARN) {\n                // Update Q Learning\n                qModel.update(next, state, state.justEaten);\n                update.direction = qModel.getAction(state.snake[0]);\n                if (drawArrowsCb.checked()) p5QLearn.draw(p, toX, toY, qModel);\n            } else if (playerSelect.value() == SP) {\n                // Update Shortest Path\n                spModel.update(state, state.apple);\n                update.direction = spModel.getAction(state.snake[0]);\n                if (drawArrowsCb.checked()) p5ShortestPath.draw(p, toX, toY, spModel);\n            } else if (playerSelect.value() == HMC) {\n                // Update Hamiltonian Cycle\n                hmcModel.update(state);\n                update.direction = hmcModel.getAction(state.snake[0]);\n                if (drawArrowsCb.checked()) p5Hamiltonian.draw(p, toX, toY, hmcModel);\n            }\n        }\n        p5Game.draw(p, toX, toY, state);\n        if (playerSelect.value() == HMC && !hmcModel.isHamiltonianCycle) p5Hamiltonian.notice(p, p.width / 2, p.height / 2);\n    };\n    /**\n   * Key Pressed\n   */ p.keyPressed = ()=>{\n        if (playerSelect.value() == HUMAN) {\n            const direction = p5Game.processUserInput(p);\n            update.direction = direction == null ? update.direction : direction;\n        }\n    };\n    // Required otherwise the Draw Wall feature will add walls to locations outside of canvas\n    const mouseOverCanvas = ()=>{\n        return p.mouseX <= p.width && p.mouseX >= 0 && p.mouseY <= p.height && p.mouseY >= 0;\n    };\n    /**\n   *\n   */ p.mousePressed = ()=>{\n        if (drawWallsCb.checked() && mouseOverCanvas()) {\n            const x = fromX(p.mouseX);\n            const y = fromY(p.mouseY);\n            if (!state.walls.has(x, y)) {\n                makeWalls = true;\n                state.walls.add(x, y);\n            } else {\n                makeWalls = false;\n                state.walls.delete(x, y);\n            }\n        }\n    };\n    /**\n   * Mouse Dragged\n   */ p.mouseDragged = ()=>{\n        if (drawWallsCb.checked() && mouseOverCanvas()) {\n            const x = fromX(p.mouseX);\n            const y = fromY(p.mouseY);\n            if (makeWalls && !state.walls.has(x, y)) state.walls.add(x, y);\n            else if (!makeWalls && state.walls.has(x, y)) state.walls.delete(x, y);\n        }\n    };\n};\n/**\n * Draw and Misc UI related functions for Game\n */ const p5Game = {\n    draw: (p, toX, toY, state)=>{\n        const snake = state.snake;\n        const apple = state.apple;\n        const walls = state.walls;\n        // Draw snake\n        p.stroke(0);\n        p.strokeWeight(toX(0.5));\n        p.fill(0);\n        snake.forEach((node1, i)=>{\n            if (i != snake.length - 1) p.line(toX(node1.x + 0.5), toY(node1.y + 0.5), toX(snake[i + 1].x + 0.5), toY(snake[i + 1].y + 0.5));\n        });\n        p.fill(255);\n        p.strokeWeight(2);\n        p.ellipse(toX(snake[0].x + 0.5), toY(snake[0].y + 0.5), toX(0.25), toY(0.25));\n        snake[snake.length - 1];\n        // Draw Apple\n        p.strokeWeight(2);\n        p.fill(255, 0, 0);\n        p.ellipse(toX(apple.x + 0.5), toY(apple.y + 0.5), toX(0.75), toY(0.75));\n        // Draw Walls\n        p.strokeWeight(2);\n        p.stroke(34, 139, 34);\n        p.fill(34, 139, 34);\n        walls.lookup.forEach((node1)=>{\n            p.rect(toX(node1.x), toY(node1.y), toX(1), toY(1));\n        });\n        // Draw Outer Frame\n        p.stroke(0);\n        p.noFill();\n        p.strokeWeight(5);\n        p.rect(0, 0, p.width, p.height);\n    },\n    processUserInput: (p)=>{\n        if (p.key == \"w\" || p.keyIsDown(38)) return game.NORTH;\n        else if (p.key == \"s\" || p.keyIsDown(40)) return game.SOUTH;\n        else if (p.key == \"d\" || p.keyIsDown(39)) return game.EAST;\n        else if (p.key == \"a\" || p.keyIsDown(37)) return game.WEST;\n        else return null;\n    }\n};\n/**\n * Draw Functions that can be shared between modules\n */ const p5Utils = {\n    drawArrow: (p, direction, toX, toY)=>{\n        if (direction.eq(game.NORTH)) p5Utils._drawArrow(p, node, 0, -0.5, 0.15, 0, toX, toY);\n        else if (direction.eq(game.SOUTH)) p5Utils._drawArrow(p, node, 0, 0.5, 0.15, 0, toX, toY);\n        else if (direction.eq(game.EAST)) p5Utils._drawArrow(p, node, 0.5, 0, 0, 0.15, toX, toY);\n        else if (direction.eq(game.WEST)) p5Utils._drawArrow(p, node, -0.5, 0, 0, 0.15, toX, toY);\n    },\n    _drawArrow: (p, node1, tipXMove, tipYMove, baseXMove, baseYMove, toX, toY)=>{\n        let x = node1.x + 0.5;\n        let y = node1.y + 0.5;\n        p.triangle(toX(x + baseXMove), toY(y + baseYMove), toX(x + tipXMove), toY(y + tipYMove), toX(x - baseXMove), toY(y - baseYMove));\n    }\n};\n/**\n * Draw and Misc UI related functions for Shortest Path\n */ const p5ShortestPath = {\n    draw: (p, toX, toY, model)=>{\n        p.noStroke();\n        p.fill(`rgb(0,191,255)`);\n        model.policy.map((v, i)=>v.map((q, j)=>{\n                if (q != null) {\n                    node = Node(i, j);\n                    p5Utils.drawArrow(p, model.getAction(node), toX, toY);\n                }\n            }));\n    }\n};\n/**\n * Draw and Misc UI related functions for Hamiltonian Cycle\n */ const p5Hamiltonian = {\n    draw: (p, toX, toY, model)=>{\n        p.noStroke();\n        p.fill(`rgb(0,191,255)`);\n        if (model.isHamiltonianCycle) model.policy.map((v, i)=>v.map((q, j)=>{\n                if (q != null) {\n                    node = Node(i, j);\n                    p5Utils.drawArrow(p, model.getAction(node), toX, toY);\n                }\n            }));\n        else model.spAgent.policy.map((v, i)=>v.map((q, j)=>{\n                if (q != null) {\n                    node = Node(i, j);\n                    p5Utils.drawArrow(p, model.getAction(node), toX, toY);\n                }\n            }));\n    },\n    notice: (p, x, y)=>{\n        p.textSize(30);\n        p.stroke(255);\n        p.strokeWeight(2);\n        p.fill(0);\n        p.textAlign(p.CENTER);\n        p.text(\"Searching for Cycle...\", x, y);\n    }\n};\n/**\n * Draw and Misc UI related functions for QLearn\n */ const p5QLearn = {\n    draw: (p, toX, toY, model)=>{\n        // Get the largest value in the qTable\n        let vmax = null;\n        for(let i = 0; i < model.policy.length; i++)for(let j = 0; j < model.policy[0].length; j++){\n            const v = model.maxQ(Node(i, j));\n            if (vmax == null || v > vmax) vmax = v;\n        }\n        p.noStroke();\n        model.policy.map((v, i)=>v.map((q, j)=>{\n                node = Node(i, j);\n                if (!model.allQEq(node)) {\n                    p.fill(`rgba(0,191,255,${Math.max(0.1, p.map(model.maxQ(node), vmax / 6, vmax, 0, 1))})`);\n                    p5Utils.drawArrow(p, model.getAction(node), toX, toY);\n                }\n            }));\n    }\n};\nlet p5Instance = new p5(sketch);\n\n//# sourceMappingURL=index.621e858a.js.map\n","const sketch = (p) => {\n  FRAMERATE_MAX = 60;\n  FRAMERATE_MIN = 1;\n  FRAMERATE_STEP = 1;\n  FRAMERATE_INITIAL = FRAMERATE_MAX;\n\n  SIZE_MAX = 25;\n  SIZE_MIN = 2;\n  SIZE_STEP = 1;\n  SIZE_INITIAL = 10;\n  SIZE_INITIAL_HAMILTONIAN = 4;\n  SIZE_MAX_HAMILTONIAN = 6;\n\n  // Pre-allocate DOM component vars, cant be initialized until setup() is called\n  let canvas = null;\n  const initCanvas = () => {\n    canvas = p.createCanvas(600, 600);\n    canvas.parent('#canvas');\n  };\n\n  /**\n   * Score Elements\n   */\n  let score = 0;\n  let scoreCounter = null;\n  const initScoreCounter = () => {\n    scoreCounter = p.createSpan(`${score}`);\n    scoreCounter.parent('#scoreCount');\n  };\n  const calcScore = (state) => state.snake.length - 2;\n  const updateScore = (s) => {\n    score = s;\n    scoreCounter.html(score);\n  };\n\n  let scores = [];\n  let scoreMean = null;\n  let scoreMedian = null;\n  let scoreMin = null;\n  let scoreMax = null;\n  let gameCount = null;\n  const initScoreStats = () => {\n    gameCount = p.createSpan('0');\n    gameCount.parent('#gameCount');\n    scoreMean = p.createSpan('0');\n    scoreMean.parent('#scoreMean');\n    scoreMedian = p.createSpan('0');\n    scoreMedian.parent('#scoreMedian');\n    scoreMin = p.createSpan('0');\n    scoreMin.parent('#scoreMin');\n    scoreMax = p.createSpan('0');\n    scoreMax.parent('#scoreMax');\n  };\n  const updateScoreStats = (score) => {\n    if (score >= 0) scores.push(score);\n    scores.sort((a, b) => a - b);\n    const sum = scores.reduce((acc, v) => acc + v, 0);\n    const mid = Math.floor(scores.length / 2);\n    gameCount.html(scores.length);\n    scoreMean.html(scores.length > 0 ? (sum / scores.length).toFixed(2) : 0);\n    scoreMedian.html(scores.length > 0 ? scores[mid] : 0);\n    scoreMin.html(scores.length > 0 ? scores[0] : 0);\n    scoreMax.html(scores.length > 0 ? scores[scores.length - 1] : 0);\n  };\n\n  /**\n   * Player Selection Elements\n   */\n  const HUMAN = 0;\n  const QLEARN = 1;\n  const SP = 2;\n  const HMC = 3;\n  let playerSelect = null;\n  const initPlayerSelect = () => {\n    playerSelect = p.createSelect();\n    playerSelect.parent('#playerSelect');\n    playerSelect.option('Human', HUMAN);\n    playerSelect.option('Q-Learning', QLEARN);\n    playerSelect.option('Shortest Path', SP);\n    playerSelect.option('Hamiltonian Cycle', HMC);\n    playerSelect.value(HMC);\n    playerSelect.changed(() => {\n      gameSizeSlider.remove();\n      gameSizeLabel.remove();\n      initGameSizeSlider();\n      resetGame();\n    });\n  };\n\n  /**\n   * Game Settings Elements\n   */\n  let drawArrowsCb = null;\n  let gameSizeLabel = null;\n  let gameSizeSlider = null;\n  const initGameSizeSlider = () => {\n    if (playerSelect.value() == HMC)\n      gameSizeSlider = p.createSlider(SIZE_MIN, SIZE_MAX_HAMILTONIAN, SIZE_INITIAL_HAMILTONIAN, SIZE_STEP);\n    else gameSizeSlider = p.createSlider(SIZE_MIN, SIZE_MAX, SIZE_INITIAL, SIZE_STEP);\n    gameSizeLabel = p.createSpan(`${gameSizeSlider.value()}`);\n    gameSizeLabel.parent('#gameSizeLbl');\n    gameSizeSlider.parent('#gameSize');\n    gameSizeSlider.changed(() => {\n      gameSizeLabel.html(gameSizeSlider.value());\n      resetGame();\n    });\n  };\n\n  let drawWallsCb = null;\n  let gameSpeedLabel = null;\n  let gameSpeedSlider = null;\n  const initGameSpeedSlider = () => {\n    gameSpeedSlider = p.createSlider(FRAMERATE_MIN, FRAMERATE_MAX, FRAMERATE_INITIAL, FRAMERATE_STEP);\n    gameSpeedLabel = p.createSpan(`${gameSpeedSlider.value()}`);\n    gameSpeedLabel.parent('#gameSpeedLbl');\n    gameSpeedSlider.parent('#gameSpeed');\n    gameSpeedSlider.changed(() => {\n      if (!drawWallsCb.checked()) p.frameRate(gameSpeedSlider.value());\n      gameSpeedLabel.html(gameSpeedSlider.value());\n    });\n  };\n\n  let clearWallsBtn = null;\n  let makeWalls = false;\n  let wallsSave = NodeSet();\n  const initWallsBtns = () => {\n    drawWallsCb = p.createCheckbox(' Add/Remove Walls (pauses game)', false);\n    drawWallsCb.parent('#drawWalls');\n    drawWallsCb.changed(() => {\n      if (drawWallsCb.checked()) p.frameRate(FRAMERATE_MAX);\n      if (!drawWallsCb.checked() && playerSelect.value() == HMC) {\n        p.frameRate(gameSpeedSlider.value());\n        resetGame();\n      }\n    });\n    clearWallsBtn = p.createButton('Clear Walls');\n    clearWallsBtn.parent('#drawWalls');\n    clearWallsBtn.mousePressed(clearWalls);\n  };\n  const clearWalls = () => {\n    wallsSave = NodeSet();\n    state.walls = wallsSave;\n    if (playerSelect.value() == HMC) resetGame();\n  };\n\n  /**\n   * Game State\n   */\n  const nX = () => 2 * gameSizeSlider.value();\n  const nY = () => 2 * gameSizeSlider.value();\n  const toX = (i) => Math.floor((i * p.width) / nX());\n  const toY = (i) => Math.floor((i * p.height) / nY());\n  const fromX = (x) => Math.floor((x * nX()) / p.width);\n  const fromY = (y) => Math.floor((y * nY()) / p.height);\n\n  let next = null;\n  let state = null;\n  let update = null;\n  const restart = () => {\n    next = game.next(nX(), nY(), wallsSave);\n    state = next();\n    update = { direction: game.EAST };\n    qModel.reset();\n    spModel = ShortestPath();\n  };\n  const resetGame = () => {\n    scores = [];\n    updateScore(0);\n    updateScoreStats(-1);\n    hmcModel.reset();\n    restart();\n  };\n\n  // Models\n  let qModel = QLearn(100, 50, 1, 0.05, 0.01, 0.9, 0.9, 1, -1);\n  let spModel = null;\n  let hmcModel = Hamiltonian(100, 100, 1000, 10);\n\n  /**\n   * Setup\n   */\n  p.setup = () => {\n    initCanvas();\n    initGameSpeedSlider();\n    initWallsBtns();\n\n    initScoreCounter();\n    initScoreStats();\n    initPlayerSelect();\n\n    // Must be done after player select\n    initGameSizeSlider();\n\n    drawArrowsCb = p.createCheckbox(' Draw Path Arrows', true);\n    drawArrowsCb.parent('#arrows');\n    p.frameRate(gameSpeedSlider.value());\n    resetGame();\n  };\n\n  /**\n   * Draw\n   */\n  p.draw = () => {\n    p.background(240);\n\n    if (!drawWallsCb.checked()) {\n      // Update Game State\n      state = next(state, update);\n      if (state.justEaten) updateScore(calcScore(state));\n      if (!state.isAlive || state.apple == null) {\n        updateScoreStats(calcScore(state));\n        restart();\n      }\n\n      // Update Models\n      if (playerSelect.value() == QLEARN) {\n        // Update Q Learning\n        qModel.update(next, state, state.justEaten);\n        update.direction = qModel.getAction(state.snake[0]);\n        if (drawArrowsCb.checked()) p5QLearn.draw(p, toX, toY, qModel);\n      } else if (playerSelect.value() == SP) {\n        // Update Shortest Path\n        spModel.update(state, state.apple);\n        update.direction = spModel.getAction(state.snake[0]);\n        if (drawArrowsCb.checked()) p5ShortestPath.draw(p, toX, toY, spModel);\n      } else if (playerSelect.value() == HMC) {\n        // Update Hamiltonian Cycle\n        hmcModel.update(state);\n        update.direction = hmcModel.getAction(state.snake[0]);\n        if (drawArrowsCb.checked()) p5Hamiltonian.draw(p, toX, toY, hmcModel);\n      }\n    }\n\n    p5Game.draw(p, toX, toY, state);\n\n    if (playerSelect.value() == HMC && !hmcModel.isHamiltonianCycle) p5Hamiltonian.notice(p, p.width / 2, p.height / 2);\n  };\n\n  /**\n   * Key Pressed\n   */\n  p.keyPressed = () => {\n    if (playerSelect.value() == HUMAN) {\n      const direction = p5Game.processUserInput(p);\n      update.direction = direction == null ? update.direction : direction;\n    }\n  };\n\n  // Required otherwise the Draw Wall feature will add walls to locations outside of canvas\n  const mouseOverCanvas = () => {\n    return p.mouseX <= p.width && p.mouseX >= 0 && p.mouseY <= p.height && p.mouseY >= 0;\n  };\n\n  /**\n   *\n   */\n  p.mousePressed = () => {\n    if (drawWallsCb.checked() && mouseOverCanvas()) {\n      const x = fromX(p.mouseX);\n      const y = fromY(p.mouseY);\n      if (!state.walls.has(x, y)) {\n        makeWalls = true;\n        state.walls.add(x, y);\n      } else {\n        makeWalls = false;\n        state.walls.delete(x, y);\n      }\n    }\n  };\n\n  /**\n   * Mouse Dragged\n   */\n  p.mouseDragged = () => {\n    if (drawWallsCb.checked() && mouseOverCanvas()) {\n      const x = fromX(p.mouseX);\n      const y = fromY(p.mouseY);\n      if (makeWalls && !state.walls.has(x, y)) state.walls.add(x, y);\n      else if (!makeWalls && state.walls.has(x, y)) state.walls.delete(x, y);\n    }\n  };\n};\n\n/**\n * Draw and Misc UI related functions for Game\n */\nconst p5Game = {\n  draw: (p, toX, toY, state) => {\n    const snake = state.snake;\n    const apple = state.apple;\n    const walls = state.walls;\n\n    // Draw snake\n    p.stroke(0);\n    p.strokeWeight(toX(0.5));\n    p.fill(0);\n    snake.forEach((node, i) => {\n      if (i != snake.length - 1) {\n        p.line(toX(node.x + 0.5), toY(node.y + 0.5), toX(snake[i + 1].x + 0.5), toY(snake[i + 1].y + 0.5));\n      }\n    });\n    p.fill(255);\n    p.strokeWeight(2);\n    p.ellipse(toX(snake[0].x + 0.5), toY(snake[0].y + 0.5), toX(0.25), toY(0.25));\n    snake[snake.length - 1];\n    // Draw Apple\n    p.strokeWeight(2);\n    p.fill(255, 0, 0);\n    p.ellipse(toX(apple.x + 0.5), toY(apple.y + 0.5), toX(0.75), toY(0.75));\n\n    // Draw Walls\n    p.strokeWeight(2);\n    p.stroke(34, 139, 34);\n    p.fill(34, 139, 34);\n    walls.lookup.forEach((node) => {\n      p.rect(toX(node.x), toY(node.y), toX(1), toY(1));\n    });\n\n    // Draw Outer Frame\n    p.stroke(0);\n    p.noFill();\n    p.strokeWeight(5);\n    p.rect(0, 0, p.width, p.height);\n  },\n\n  processUserInput: (p) => {\n    if (p.key == 'w' || p.keyIsDown(38)) return game.NORTH;\n    else if (p.key == 's' || p.keyIsDown(40)) return game.SOUTH;\n    else if (p.key == 'd' || p.keyIsDown(39)) return game.EAST;\n    else if (p.key == 'a' || p.keyIsDown(37)) return game.WEST;\n    else return null;\n  },\n};\n\n/**\n * Draw Functions that can be shared between modules\n */\nconst p5Utils = {\n  drawArrow: (p, direction, toX, toY) => {\n    if (direction.eq(game.NORTH)) p5Utils._drawArrow(p, node, 0, -0.5, 0.15, 0, toX, toY);\n    else if (direction.eq(game.SOUTH)) p5Utils._drawArrow(p, node, 0, 0.5, 0.15, 0, toX, toY);\n    else if (direction.eq(game.EAST)) p5Utils._drawArrow(p, node, 0.5, 0, 0, 0.15, toX, toY);\n    else if (direction.eq(game.WEST)) p5Utils._drawArrow(p, node, -0.5, 0, 0, 0.15, toX, toY);\n  },\n\n  _drawArrow: (p, node, tipXMove, tipYMove, baseXMove, baseYMove, toX, toY) => {\n    let x = node.x + 0.5;\n    let y = node.y + 0.5;\n    p.triangle(\n      toX(x + baseXMove),\n      toY(y + baseYMove),\n      toX(x + tipXMove),\n      toY(y + tipYMove),\n      toX(x - baseXMove),\n      toY(y - baseYMove),\n    );\n  },\n};\n\n/**\n * Draw and Misc UI related functions for Shortest Path\n */\nconst p5ShortestPath = {\n  draw: (p, toX, toY, model) => {\n    p.noStroke();\n    p.fill(`rgb(0,191,255)`);\n    model.policy.map((v, i) =>\n      v.map((q, j) => {\n        if (q != null) {\n          node = Node(i, j);\n          p5Utils.drawArrow(p, model.getAction(node), toX, toY);\n        }\n      }),\n    );\n  },\n};\n\n/**\n * Draw and Misc UI related functions for Hamiltonian Cycle\n */\nconst p5Hamiltonian = {\n  draw: (p, toX, toY, model) => {\n    p.noStroke();\n    p.fill(`rgb(0,191,255)`);\n    if (model.isHamiltonianCycle) {\n      model.policy.map((v, i) =>\n        v.map((q, j) => {\n          if (q != null) {\n            node = Node(i, j);\n            p5Utils.drawArrow(p, model.getAction(node), toX, toY);\n          }\n        }),\n      );\n    } else {\n      model.spAgent.policy.map((v, i) =>\n        v.map((q, j) => {\n          if (q != null) {\n            node = Node(i, j);\n            p5Utils.drawArrow(p, model.getAction(node), toX, toY);\n          }\n        }),\n      );\n    }\n  },\n\n  notice: (p, x, y) => {\n    p.textSize(30);\n    p.stroke(255);\n    p.strokeWeight(2);\n    p.fill(0);\n    p.textAlign(p.CENTER);\n    p.text('Searching for Cycle...', x, y);\n  },\n};\n\n/**\n * Draw and Misc UI related functions for QLearn\n */\nconst p5QLearn = {\n  draw: (p, toX, toY, model) => {\n    // Get the largest value in the qTable\n    let vmax = null;\n    for (let i = 0; i < model.policy.length; i++) {\n      for (let j = 0; j < model.policy[0].length; j++) {\n        const v = model.maxQ(Node(i, j));\n        if (vmax == null || v > vmax) vmax = v;\n      }\n    }\n\n    p.noStroke();\n    model.policy.map((v, i) =>\n      v.map((q, j) => {\n        node = Node(i, j);\n        if (!model.allQEq(node)) {\n          p.fill(`rgba(0,191,255,${Math.max(0.1, p.map(model.maxQ(node), vmax / 6, vmax, 0, 1))})`);\n          p5Utils.drawArrow(p, model.getAction(node), toX, toY);\n        }\n      }),\n    );\n  },\n};\n\nlet p5Instance = new p5(sketch);\n"],"names":["p5Game","draw","p","toX","toY","state","snake","apple","walls","stroke","strokeWeight","fill","forEach","node1","i","length","line","x","y","ellipse","lookup","rect","noFill","width","height","processUserInput","key","keyIsDown","game","NORTH","SOUTH","EAST","WEST","p5Utils","drawArrow","direction","eq","_drawArrow","node","tipXMove","tipYMove","baseXMove","baseYMove","triangle","p5ShortestPath","model","noStroke","policy","map","v","q","j","Node","getAction","p5Hamiltonian","isHamiltonianCycle","spAgent","notice","textSize","textAlign","CENTER","text","p5QLearn","vmax","maxQ","allQEq","Math","max","p5","FRAMERATE_MAX","FRAMERATE_MIN","FRAMERATE_STEP","FRAMERATE_INITIAL","SIZE_MAX","SIZE_MIN","SIZE_STEP","SIZE_INITIAL","SIZE_INITIAL_HAMILTONIAN","SIZE_MAX_HAMILTONIAN","initCanvas","canvas","createCanvas","parent","score","scoreCounter","initScoreCounter","createSpan","calcScore","updateScore","s","html","scores","scoreMean","scoreMedian","scoreMin","scoreMax","gameCount","initScoreStats","updateScoreStats","push","sort","a","b","sum","reduce","acc","mid","floor","toFixed","playerSelect","initPlayerSelect","createSelect","option","value","changed","gameSizeSlider","remove","gameSizeLabel","initGameSizeSlider","resetGame","drawArrowsCb","createSlider","drawWallsCb","gameSpeedLabel","gameSpeedSlider","initGameSpeedSlider","checked","frameRate","clearWallsBtn","makeWalls","wallsSave","NodeSet","initWallsBtns","createCheckbox","createButton","mousePressed","clearWalls","nX","nY","fromX","fromY","next","update","restart","qModel","reset","spModel","ShortestPath","hmcModel","QLearn","Hamiltonian","setup","background","justEaten","isAlive","keyPressed","mouseOverCanvas","mouseX","mouseY","has","delete","add","mouseDragged"],"version":3,"file":"index.621e858a.js.map"}