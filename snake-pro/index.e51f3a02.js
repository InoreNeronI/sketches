const e=(n,l)=>{let t={};return t.x=n,t.y=l,t.inBounds=(e,n)=>t.x>=0&&t.x<e&&t.y>=0&&t.y<n,t.eq=e=>t.x==e.x&&t.y==e.y,t.sum=n=>e(t.x+n.x,t.y+n.y),t.sub=n=>e(t.x-n.x,t.y-n.y),t},n=()=>{let e={};return e.lookup=new Map,e.encXY=(e,n)=>`${e},${n}`,e.set=(n,l)=>e.lookup.set(e.encXY(n.x,n.y),l),e.get=n=>e.lookup.get(e.encXY(n.x,n.y)),e.size=()=>e.lookup.size,e},l={NORTH:e(0,-1),SOUTH:e(0,1),EAST:e(1,0),WEST:e(-1,0),next:(n,t,s)=>(S=null,i=null)=>{if(null==S){let S=Math.floor(t/2),i=[e(1,S),e(0,S)];return{isAlive:!0,justEaten:!0,snake:i,direction:l.EAST,apple:l.nextApple(n,t,i,s),walls:s,nx:n,ny:t}}{let e=l.isValidDir(S.snake,i?i.direction:null)?i.direction:S.direction,n=l.nextHead(S.snake,e),t=l.willEat(n,S.apple),s=l.willLive(S.nx,S.ny,n,S.snake,S.walls),a=s?l.nextSnake(S.snake,n,t):S.snake;return{isAlive:s,justEaten:t,snake:a,direction:e,apple:t?l.nextApple(S.nx,S.ny,a,S.walls):S.apple,walls:S.walls,nx:S.nx,ny:S.ny}}},isValidDir:(e,n)=>null!=n&&!l.nextHead(e,n).eq(e[1]),willEat:(e,n)=>e.eq(n),willLive:(e,n,l,t,s)=>l.inBounds(e,n)&&!t.some(e=>e.eq(l))&&!s.has(l.x,l.y),nextHead:(e,n)=>e[0].sum(n),nextSnake:(e,n,l)=>[n].concat(l?e:e.slice(0,-1)),nextApple:(n,l,t,s)=>{if(t.length+s.size()>=n*l)return null;let S=null;for(;null==S||t.some(e=>e.eq(S))||s.has(S.x,S.y);)S=e(utils.randInt(0,n-1),utils.randInt(0,l-1));return S}};l.DIRECTIONS=[l.NORTH,l.SOUTH,l.EAST,l.WEST],l.DIR_SYMBOLS=n(),l.DIR_SYMBOLS.set(l.NORTH,"^"),l.DIR_SYMBOLS.set(l.SOUTH,"v"),l.DIR_SYMBOLS.set(l.EAST,">"),l.DIR_SYMBOLS.set(l.WEST,"<"),l.DIR_OPPOSITES=n(),l.DIR_OPPOSITES.set(l.NORTH,l.SOUTH),l.DIR_OPPOSITES.set(l.SOUTH,l.NORTH),l.DIR_OPPOSITES.set(l.EAST,l.WEST),l.DIR_OPPOSITES.set(l.WEST,l.EAST);
//# sourceMappingURL=index.e51f3a02.js.map
