{"mappings":"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","sources":["src/snake-pro/src/shortest-path.js"],"sourcesContent":["/**\n *\n */\nconst ShortestPath = () => {\n  const sp = {};\n  sp.path = null;\n  sp.policy = null;\n\n  sp.getAction = (node) => sp.policy[node.x][node.y];\n\n  sp.improvisePath = (state) => {\n    const start = [null, state.snake[0]];\n    const neighbors = [state.direction]\n      .concat(game.DIRECTIONS.filter((d) => !d.eq(state.direction)))\n      .map((d) => state.snake[0].sum(d))\n      .filter((n) => n.inBounds(state.nx, state.ny) && !state.snake.some((n1) => n1.eq(n) && !state.walls.has(n.x, n.y)));\n\n    if (neighbors.length > 0) return fnShortestPath.buildPath([start, neighbors[0]]);\n    else return fnShortestPath.buildPath([start, state.snake[0].sum(state.direction)]);\n  };\n\n  sp.update = (state, goal) => {\n    const exclusions = state.walls.copy();\n    state.snake.forEach((n) => exclusions.addNode(n));\n    let path = fnShortestPath.search(state.snake[0], goal, state.nx, state.ny, exclusions, state.direction);\n    if (path.length > 0) {\n      sp.path = path;\n      sp.policy = fnShortestPath.buildPolicy(sp.path, state.nx, state.ny);\n    } else {\n      sp.path = sp.improvisePath(state);\n      sp.policy = fnShortestPath.buildPolicy(sp.path, state.nx, state.ny);\n    }\n  };\n\n  return sp;\n};\n\nconst fnShortestPath = {\n  search: (origin, goal, nx, ny, exclusions = NodeSet(), startDir = game.NORTH) => {\n    const open = [[null, origin]];\n    const closed = exclusions;\n\n    let current = null;\n    while (open.length > 0) {\n      current = open.shift();\n      if (current[1].eq(goal)) return fnShortestPath.buildPath(current);\n      else {\n        const currentDir = current[0] == null ? startDir : current[1].sub(current[0][1]);\n        const dirs = [currentDir].concat(game.DIRECTIONS.filter((d) => !d.eq(currentDir)));\n        dirs\n          .map((d) => current[1].sum(d))\n          .filter((n) => n.inBounds(nx, ny) && !closed.has(n.x, n.y))\n          .forEach((n) => {\n            open.push([current, n]);\n            closed.addNode(n);\n          });\n      }\n    }\n\n    return [];\n  },\n\n  buildPath: (current) => {\n    let path = [];\n    for (let c = current; c != null; c = c[0]) {\n      path.push(c[1]);\n    }\n    return path;\n  },\n\n  buildPolicy: (path, nx, ny) => {\n    let policy = Array.from(Array(nx), (_) => Array.from(Array(ny), (_) => null));\n    for (let i = 0; i < path.length - 1; i++) {\n      const nextNode = path[i];\n      const srcNode = path[i + 1];\n      policy[srcNode.x][srcNode.y] = nextNode.sub(srcNode);\n    }\n    return policy;\n  },\n};\n"],"names":[],"version":3,"file":"index.cff84fbc.js.map"}