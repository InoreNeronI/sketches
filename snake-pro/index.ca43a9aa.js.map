{"mappings":"","sources":["src/snake-pro/src/shortest-path.js"],"sourcesContent":["/**\n *\n */\nconst ShortestPath = () => {\n  const sp = {};\n  sp.path = null;\n  sp.policy = null;\n\n  sp.getAction = (node) => sp.policy[node.x][node.y];\n\n  sp.improvisePath = (state) => {\n    const start = [null, state.snake[0]];\n    const neighbors = [state.direction]\n      .concat(game.DIRECTIONS.filter((d) => !d.eq(state.direction)))\n      .map((d) => state.snake[0].sum(d))\n      .filter((n) => n.inBounds(state.nx, state.ny) && !state.snake.some((n1) => n1.eq(n) && !state.walls.has(n.x, n.y)));\n\n    if (neighbors.length > 0) return fnShortestPath.buildPath([start, neighbors[0]]);\n    else return fnShortestPath.buildPath([start, state.snake[0].sum(state.direction)]);\n  };\n\n  sp.update = (state, goal) => {\n    const exclusions = state.walls.copy();\n    state.snake.forEach((n) => exclusions.addNode(n));\n    let path = fnShortestPath.search(state.snake[0], goal, state.nx, state.ny, exclusions, state.direction);\n    if (path.length > 0) {\n      sp.path = path;\n      sp.policy = fnShortestPath.buildPolicy(sp.path, state.nx, state.ny);\n    } else {\n      sp.path = sp.improvisePath(state);\n      sp.policy = fnShortestPath.buildPolicy(sp.path, state.nx, state.ny);\n    }\n  };\n\n  return sp;\n};\n\nconst fnShortestPath = {\n  search: (origin, goal, nx, ny, exclusions = NodeSet(), startDir = game.NORTH) => {\n    const open = [[null, origin]];\n    const closed = exclusions;\n\n    let current = null;\n    while (open.length > 0) {\n      current = open.shift();\n      if (current[1].eq(goal)) return fnShortestPath.buildPath(current);\n      else {\n        const currentDir = current[0] == null ? startDir : current[1].sub(current[0][1]);\n        const dirs = [currentDir].concat(game.DIRECTIONS.filter((d) => !d.eq(currentDir)));\n        dirs\n          .map((d) => current[1].sum(d))\n          .filter((n) => n.inBounds(nx, ny) && !closed.has(n.x, n.y))\n          .forEach((n) => {\n            open.push([current, n]);\n            closed.addNode(n);\n          });\n      }\n    }\n\n    return [];\n  },\n\n  buildPath: (current) => {\n    let path = [];\n    for (let c = current; c != null; c = c[0]) {\n      path.push(c[1]);\n    }\n    return path;\n  },\n\n  buildPolicy: (path, nx, ny) => {\n    let policy = Array.from(Array(nx), (_) => Array.from(Array(ny), (_) => null));\n    for (let i = 0; i < path.length - 1; i++) {\n      const nextNode = path[i];\n      const srcNode = path[i + 1];\n      policy[srcNode.x][srcNode.y] = nextNode.sub(srcNode);\n    }\n    return policy;\n  },\n};\n"],"names":[],"version":3,"file":"index.ca43a9aa.js.map"}