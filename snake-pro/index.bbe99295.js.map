{"mappings":"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","sources":["src/snake-pro/src/game.js"],"sourcesContent":["/**\n * This is the object used for each snake segment and apple\n * It contains its integer grid location, as well as some useful methods\n */\nconst Node = (x, y) => {\n  const node = {};\n  node.x = x;\n  node.y = y;\n\n  /**\n   * Returns true if node is in game boundary given by nx, ny\n   */\n  node.inBounds = (nx, ny) => node.x >= 0 && node.x < nx && node.y >= 0 && node.y < ny;\n\n  /**\n   * Returns true if node's components equal n's components\n   */\n  node.eq = (n) => node.x == n.x && node.y == n.y;\n\n  /**\n   * Returns a new Node with the sum of node and n's components\n   */\n  node.sum = (n) => Node(node.x + n.x, node.y + n.y);\n\n  /**\n   * Returns a new Node with the difference of node and n's components\n   */\n  node.sub = (n) => Node(node.x - n.x, node.y - n.y);\n\n  return node;\n};\n\n/**\n * Object that maps a value to a location\n */\n\nconst NodeMap = () => {\n  const nm = {};\n  nm.lookup = new Map();\n  nm.encXY = (x, y) => `${x},${y}`;\n  nm.set = (node, value) => nm.lookup.set(nm.encXY(node.x, node.y), value);\n  nm.get = (node) => nm.lookup.get(nm.encXY(node.x, node.y));\n  nm.size = () => nm.lookup.size;\n\n  return nm;\n};\n\n/**\n * Object that maps a Node to a location\n */\nconst NodeSet = () => {\n  const ns = {};\n  ns.lookup = new Map();\n\n  ns.encXY = (x, y) => `${x},${y}`;\n\n  ns.add = (x, y) => ns.lookup.set(ns.encXY(x, y), Node(x, y));\n\n  ns.addNode = (node) => ns.lookup.set(ns.encXY(node.x, node.y), node);\n\n  ns.delete = (x, y) => ns.lookup.delete(ns.encXY(x, y));\n\n  ns.deleteNode = (node) => ns.lookup.delete(ns.encXY(node.x, node.y));\n\n  ns.has = (x, y) => ns.lookup.has(ns.encXY(x, y));\n\n  ns.hasNode = (node) => ns.lookup.has(ns.encXY(node.x, node.y));\n\n  ns.get = (x, y) => ns.lookup.get(ns.encXY(x, y));\n\n  ns.size = () => ns.lookup.size;\n\n  ns.copy = () => {\n    const nsCopy = NodeSet();\n    nsCopy.lookup = new Map(ns.lookup);\n    return nsCopy;\n  };\n\n  return ns;\n};\n\n/**\n * This contains all the functions needed to run the game\n */\nconst game = {\n  /**\n   * Constants\n   */\n  NORTH: Node(0, -1),\n  SOUTH: Node(0, 1),\n  EAST: Node(1, 0),\n  WEST: Node(-1, 0),\n\n  /**\n   * Returns a State with mutations based on update\n   */\n  next:\n    (nx, ny, walls) =>\n    (state = null, update = null) => {\n      if (state == null) {\n        const yStart = Math.floor(ny / 2);\n        const snake = [Node(1, yStart), Node(0, yStart)];\n        return {\n          isAlive: true,\n          justEaten: true,\n          snake: snake,\n          direction: game.EAST,\n          apple: game.nextApple(nx, ny, snake, walls),\n          walls: walls,\n          nx: nx,\n          ny: ny,\n        };\n      } else {\n        const isValidDir = game.isValidDir(state.snake, update ? update.direction : null);\n        // Necessary otherwise 1/4 exploration moves in qlearning could result in death\n        const direction = isValidDir ? update.direction : state.direction;\n        const head = game.nextHead(state.snake, direction);\n        const willEat = game.willEat(head, state.apple);\n        const willLive = game.willLive(state.nx, state.ny, head, state.snake, state.walls);\n        const snake = willLive ? game.nextSnake(state.snake, head, willEat) : state.snake;\n        return {\n          isAlive: willLive,\n          justEaten: willEat,\n          snake: snake,\n          direction: direction,\n          apple: willEat ? game.nextApple(state.nx, state.ny, snake, state.walls) : state.apple,\n          walls: state.walls,\n          nx: state.nx,\n          ny: state.ny,\n        };\n      }\n    },\n\n  /**\n   *\n   */\n  isValidDir: (snake, dir) => (dir == null ? false : !game.nextHead(snake, dir).eq(snake[1])),\n\n  /**\n   * Returns true if head is equal to apple\n   */\n  willEat: (head, apple) => head.eq(apple),\n\n  /**\n   * Returns true if snake does not leave the game area or intercept itself\n   */\n  willLive: (nx, ny, head, snake, walls) => {\n    return head.inBounds(nx, ny) && !snake.some((node) => node.eq(head)) && !walls.has(head.x, head.y);\n  },\n\n  /**\n   * Returns a Node where the snake's head would be if it moved toward dir\n   */\n  nextHead: (snake, dir) => snake[0].sum(dir),\n\n  /**\n   * If grow is true, return head + snake, else return head + snake[0:-1]\n   */\n  nextSnake: (snake, head, grow) => [head].concat(grow ? snake : snake.slice(0, -1)),\n\n  /**\n   * Returns a randomly positioned node that excludes any part of snake\n   * If null, then the snake has filled all possible positions in the game\n   */\n  nextApple: (nx, ny, snake, walls) => {\n    if (snake.length + walls.size() >= nx * ny) return null;\n    let apple = null;\n    while (apple == null || snake.some((node) => node.eq(apple)) || walls.has(apple.x, apple.y)) {\n      apple = Node(utils.randInt(0, nx - 1), utils.randInt(0, ny - 1));\n    }\n    return apple;\n  },\n};\n\ngame.DIRECTIONS = [game.NORTH, game.SOUTH, game.EAST, game.WEST];\n\ngame.DIR_SYMBOLS = NodeMap();\ngame.DIR_SYMBOLS.set(game.NORTH, '^');\ngame.DIR_SYMBOLS.set(game.SOUTH, 'v');\ngame.DIR_SYMBOLS.set(game.EAST, '>');\ngame.DIR_SYMBOLS.set(game.WEST, '<');\n\ngame.DIR_OPPOSITES = NodeMap();\ngame.DIR_OPPOSITES.set(game.NORTH, game.SOUTH);\ngame.DIR_OPPOSITES.set(game.SOUTH, game.NORTH);\ngame.DIR_OPPOSITES.set(game.EAST, game.WEST);\ngame.DIR_OPPOSITES.set(game.WEST, game.EAST);\n"],"names":[],"version":3,"file":"index.bbe99295.js.map"}