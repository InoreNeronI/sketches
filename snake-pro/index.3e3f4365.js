fnHamiltonian={buildCycle:(e,t,n=NodeSet(),r=0,g=100,l=100)=>{let a=fnHamiltonian.mkGraph(e,t);return fnHamiltonian.processExclusions(a,n),fnHamiltonian.runDeletion(a),fnHamiltonian.getDestroyerPaths(a,r).forEach(e=>fnHamiltonian.invertPath(e)),fnHamiltonian.invertConnectorPaths(a,g,l),a},processExclusions:(e,t)=>{t.lookup.forEach(t=>{game.DIRECTIONS.forEach(n=>e[t.x][t.y].deleteEdge(n))})},buildPath:e=>{let t=null;for(let n=0;n<e.length;n++)for(let r=0;r<e[n].length;r++)if(null==t&&0!=e[n][r].nEdges){t=e[n][r];break}let n=[t],r=t.getMove(),g=t.getNeighbor(r);for(;g!=t&&null!=g&&n.length<e.length*e[0].length&&(n.push(g),null!=(r=g.getMove(game.DIR_OPPOSITES.get(r))));)g=g.getNeighbor(r);return g==t&&n.push(g),n},buildPolicy:(e,t,n)=>{let r=Array.from(Array(t),e=>Array.from(Array(n),e=>null));for(let t=0;t<e.length-1;t++){let n=e[t],g=e[t+1];r[n.x][n.y]=g.sub(n)}return r},Vertex:(e,t,n)=>{let r=Node(e,t);return r.graph=n,r.edges=NodeMap(),game.DIRECTIONS.forEach(e=>r.edges.set(e,1)),r.nEdges=game.DIRECTIONS.length,r.setEdge=(e,t)=>{t>0&&0>=r.edges.get(e)?r.nEdges++:t<=0&&r.edges.get(e)>0&&r.nEdges--,r.edges.set(e,t)},r.getEdge=e=>r.edges.get(e),r.invertEdge=e=>{r.getEdge(e)>=0&&(r.setEdge(e,r.getEdge(e)>0?0:1),r.getNeighbor(e).setEdge(game.DIR_OPPOSITES.get(e),r.getEdge(e)))},r.deleteEdge=e=>{if(r.getEdge(e)>=-1){r.setEdge(e,-1);let t=r.getNeighbor(e);null!=t&&t.setEdge(game.DIR_OPPOSITES.get(e),r.getEdge(e))}},r.getNeighbor=e=>{let t=r.sum(e);return t.inBounds(r.graph.length,r.graph[0].length)?r.graph[t.x][t.y]:null},r.getMove=(e=null)=>{for(let t=0;t<game.DIRECTIONS.length;t++)if(r.getEdge(game.DIRECTIONS[t])>0&&(null==e||!game.DIRECTIONS[t].eq(e)))return game.DIRECTIONS[t];return null},r},mkGraph:(e,t)=>{let n=Array.from(Array(e),e=>Array.from(Array(t),e=>null));for(let e=0;e<n.length;e++)for(let t=0;t<n[e].length;t++)n[e][t]=fnHamiltonian.Vertex(e,t,n),0==e?n[e][t].deleteEdge(game.WEST):e==n.length-1&&n[e][t].deleteEdge(game.EAST),0==t?n[e][t].deleteEdge(game.NORTH):t==n[e].length-1&&n[e][t].deleteEdge(game.SOUTH);return n},runDeletion:e=>{for(let t=0;t<e.length;t++)for(let n=0;n<e[t].length;n++){let r=e[t][n],g=game.DIRECTIONS.concat();utils.shuffle(g);for(let e=0;e<g.length&&!(r.nEdges<=2);e++)r.getEdge(g[e])>0&&r.getNeighbor(g[e]).nEdges>2&&r.invertEdge(g[e])}},getRemainders:e=>{let t=NodeSet();for(let n=0;n<e.length;n++)for(let r=0;r<e[n].length;r++)e[n][r].nEdges>2&&t.addNode(e[n][r]);return t},PathNode:(e,t)=>{let n={};return n.vertex=e,n.parent=t,n.dirToParent=null==t?null:t.vertex.sub(n.vertex),n.length=null==t?1:t.length+1,n.pathVertices=null==t?NodeSet():n.parent.pathVertices.copy(),n.pathVertices.addNode(n.vertex),n.isDestroyer=n.length>=4&&n.length%2==0&&1==n.vertex.getEdge(n.dirToParent)&&0==n.parent.vertex.getEdge(n.parent.dirToParent),n.isAltEdge=!(n.length<3)&&n.vertex.getEdge(n.dirToParent)!=n.parent.vertex.getEdge(n.parent.dirToParent),n.isEvenAltEdge=n.isAltEdge&&n.length%2==1,n.toPath=()=>{let e=[];for(c=n;null!=c;c=c.parent)e.push(c.vertex);return e},n},_find:(e,t,n,r=0,g=()=>!0,l=()=>!0)=>{let a=(e,n)=>{let r=e.vertex.getNeighbor(n);return null!=r&&(r==t||!e.pathVertices.hasNode(r))&&g(e,n)},o=[fnHamiltonian.PathNode(t,null)],d=0,i=null;for(;(r<=0||d<r)&&o.length>0&&n.size()>0;){if(i=o.shift(),n.hasNode(i.vertex)&&l(i))return n.deleteNode(i.vertex),i.toPath();game.DIRECTIONS.forEach(t=>{if((null==i.parent||!t.eq(i.dirToParent))&&a(i,t)){let n=i.vertex.sum(t);o.push(fnHamiltonian.PathNode(e[n.x][n.y],i))}}),d++}return[t]},findConnector:(e,t,n,r=100)=>fnHamiltonian._find(e,t,n,r,(e,t)=>e.length<3||e.isAltEdge&&e.vertex.getEdge(e.dirToParent)!=e.vertex.getEdge(t),e=>e.isEvenAltEdge),invertConnectorPaths:(e,t=0,n=100)=>{for(let r=0;r<n;r++){let n=e[utils.randInt(0,e.length-1)][utils.randInt(0,e[0].length-1)],r=NodeSet();if(r.addNode(n),fnHamiltonian.invertPath(fnHamiltonian.findConnector(e,n,r,t)),fnHamiltonian.isHamiltonianCycle(e))break}},findDestroyer:(e,t,n,r=0)=>(n.deleteNode(t),fnHamiltonian._find(e,t,n,r,(e,t)=>1==e.length&&1==e.vertex.getEdge(t)||2==e.length&&1==e.vertex.getEdge(e.dirToParent)&&0==e.vertex.getEdge(t)||3==e.length&&0==e.vertex.getEdge(e.dirToParent)&&1==e.vertex.getEdge(t)||e.length>=4&&e.isDestroyer&&0==e.vertex.getEdge(t)||e.length>=4&&!e.isDestroyer&&e.parent.isDestroyer&&1==e.vertex.getEdge(t))),getDestroyerPaths:(e,t=0)=>{let n=fnHamiltonian.getRemainders(e),r=n.copy(),g=[];return n.lookup.forEach(n=>{r.hasNode(n)&&g.push(fnHamiltonian.findDestroyer(e,n,r,t))}),g},invertPath:e=>{e.forEach((t,n)=>{if(n<e.length-1){let r=e[n+1].sub(t);t.invertEdge(r)}})},isHamiltonianCycle:e=>{let t=NodeSet(),n=NodeSet(),r=null;for(let n=0;n<e.length;n++)for(let g=0;g<e[n].length;g++)if(0==e[n][g].nEdges)t.addNode(e[n][g]);else{if(2!=e[n][g].nEdges)return!1;null==r&&(r=e[n][g])}n.addNode(r);let g=r.getMove(),l=r.getNeighbor(g);for(;!n.hasNode(l)&&!t.hasNode(l)&&(n.addNode(l),g=l.getMove(game.DIR_OPPOSITES.get(g)),null!=(l=l.getNeighbor(g))););let a=n.size()+t.size(),o=e.length*e[0].length;return null!=l&&l==r&&a==o},toString:e=>{let t="";for(let n=0;n<e[0].length;n++){for(let r=0;r<e.length;r++){for(let g=0;g<game.DIRECTIONS.length;g++)1==e[r][n].getEdge(game.DIRECTIONS[g])?t+=game.DIR_SYMBOLS.get(game.DIRECTIONS[g]):t+=" ";t+=", "}t+="\n"}return t}};
//# sourceMappingURL=index.3e3f4365.js.map
