{"mappings":"","sources":["src/snake-pro/tests/hamiltonian-tests.js"],"sourcesContent":["const HamiltonianTests = {\n  'make Graph': () => {\n    const exp44Graph = ` v> ,  v><,  v><,  v <, \n^v> , ^v><, ^v><, ^v <, \n^v> , ^v><, ^v><, ^v <, \n^ > , ^ ><, ^ ><, ^  <, \n`;\n\n    let graph = fnHamiltonian.mkGraph(4, 4);\n    eq(fnHamiltonian.toString(graph), exp44Graph);\n  },\n\n  Vertex: () => {\n    let graph = fnHamiltonian.mkGraph(4, 4);\n    // Vertex set/get edge\n    let vx = fnHamiltonian.Vertex(0, 0, graph);\n    eq(vx.nEdges, 4);\n    vx.setEdge(game.EAST, 0);\n    eq(vx.nEdges, 3);\n    vx.setEdge(game.EAST, -1);\n    eq(vx.nEdges, 3);\n    eq(vx.getEdge(game.NORTH), 1);\n    eq(vx.getEdge(game.SOUTH), 1);\n    eq(vx.getEdge(game.EAST), -1);\n    eq(vx.getEdge(game.WEST), 1);\n    vx.setEdge(game.EAST, 1);\n    eq(vx.getEdge(game.EAST), 1);\n\n    // vertex get neighbor\n    eq(graph[1][1].getNeighbor(game.NORTH), graph[1][0]);\n    eq(graph[1][1].getNeighbor(game.SOUTH), graph[1][2]);\n    eq(graph[1][1].getNeighbor(game.EAST), graph[2][1]);\n    eq(graph[1][1].getNeighbor(game.WEST), graph[0][1]);\n\n    // mk graph\n    eq(graph[3][3].nEdges, 2);\n    eq(graph[0][0].nEdges, 2);\n    eq(graph[0][1].nEdges, 3);\n    eq(graph[1][0].nEdges, 3);\n    eq(graph[1][1].nEdges, 4);\n\n    // invert edge\n    graph[0][0].invertEdge(game.NORTH); // Should do nothing\n    eq(graph[0][0].nEdges, 2);\n\n    graph[0][0].invertEdge(game.SOUTH);\n    eq(graph[0][0].nEdges, 1);\n    eq(graph[0][1].nEdges, 2);\n\n    graph[1][1].invertEdge(game.NORTH);\n    eq(graph[1][0].nEdges, 2);\n    eq(graph[1][1].nEdges, 3);\n\n    eq(graph[3][3].nEdges, 2);\n  },\n\n  deletion: () => {\n    const exp44Graph = ` v> ,  v><,  v><,  v <, \n^v> , ^v><, ^v><, ^v <, \n^v> , ^v><, ^v><, ^v <, \n^ > , ^ ><, ^ ><, ^  <, \n`;\n\n    let graph = fnHamiltonian.mkGraph(4, 4);\n    fnHamiltonian.runDeletion(graph);\n    for (let i = 0; i < graph.length; i++) {\n      for (let j = 0; j < graph[i].length; j++) {\n        game.DIRECTIONS.forEach((d) => {\n          if (graph[i][j].getEdge(d) >= 0) {\n            // They match their neighbors\n            eq(graph[i][j].getEdge(d), graph[i][j].getNeighbor(d).getEdge(game.DIR_OPPOSITES.get(d)));\n          }\n        });\n        eq(true, graph[i][j].nEdges >= 2);\n        if (graph[i][j].nEdges > 2) {\n          if (i - 1 >= 0) eq(true, graph[i - 1][j].nEdges == 2);\n          if (j - 1 >= 0) eq(true, graph[i][j - 1].nEdges == 2);\n          if (i + 1 < graph.length) eq(true, graph[i + 1][j].nEdges == 2);\n          if (j + 1 < graph[i].length) eq(true, graph[i][j + 1].nEdges == 2);\n        }\n      }\n    }\n    eq(false, exp44Graph == fnHamiltonian.toString(graph));\n  },\n\n  'get remainders': () => {\n    eq(fnHamiltonian.getRemainders(fnHamiltonian.mkGraph(2, 2)).size(), 0);\n    eq(fnHamiltonian.getRemainders(fnHamiltonian.mkGraph(3, 3)).size(), 5);\n    eq(fnHamiltonian.getRemainders(fnHamiltonian.mkGraph(4, 4)).size(), 12);\n  },\n\n  PathNode: () => {\n    let graph = fnHamiltonian.mkGraph(4, 4);\n\n    const dn0 = fnHamiltonian.PathNode(graph[0][0], null);\n    eq(dn0.vertex, graph[0][0]);\n    eq(dn0.parent, null);\n    eq(dn0.dirToParent, null);\n    eq(dn0.pathVertices.size(), 1);\n    eq(dn0.pathVertices.hasNode(dn0.vertex), true);\n    eq(dn0.length, 1);\n    eq(dn0.isDestroyer, false);\n\n    // Add a node\n    const dn1 = fnHamiltonian.PathNode(graph[0][1], dn0);\n    eq(dn1.vertex, graph[0][1]);\n    eq(dn1.parent, dn0);\n    eq(true, dn1.dirToParent.eq(game.NORTH));\n    eq(dn0.pathVertices.size(), 1);\n    eq(dn0.pathVertices.hasNode(dn1.vertex), false);\n    eq(dn1.pathVertices.size(), 2);\n    eq(dn1.pathVertices.hasNode(dn1.vertex), true);\n    eq(dn1.length, 2);\n    eq(dn1.isDestroyer, false);\n\n    const dn2 = fnHamiltonian.PathNode(graph[1][1], dn1);\n    eq(dn2.vertex, graph[1][1]);\n    eq(dn2.parent, dn1);\n    eq(true, dn2.dirToParent.eq(game.WEST));\n    eq(dn2.length, 3);\n    eq(dn2.isDestroyer, false);\n\n    let dn3 = fnHamiltonian.PathNode(graph[2][1], dn2);\n    eq(dn3.vertex, graph[2][1]);\n    eq(dn3.parent, dn2);\n    eq(true, dn3.dirToParent.eq(game.WEST));\n    eq(dn3.length, 4);\n    eq(dn3.isDestroyer, false);\n\n    // Add alternation\n    graph[0][1].invertEdge(game.EAST);\n\n    dn3 = fnHamiltonian.PathNode(graph[2][1], dn2);\n    eq(dn3.vertex, graph[2][1]);\n    eq(dn3.parent, dn2);\n    eq(true, dn3.dirToParent.eq(game.WEST));\n    eq(dn3.length, 4);\n    eq(dn3.isDestroyer, true);\n\n    let dn4 = fnHamiltonian.PathNode(graph[3][1], dn3);\n    eq(dn4.vertex, graph[3][1]);\n    eq(dn4.parent, dn3);\n    eq(true, dn4.dirToParent.eq(game.WEST));\n    eq(dn4.length, 5);\n    eq(dn4.isDestroyer, false);\n\n    let dn5 = fnHamiltonian.PathNode(graph[3][2], dn4);\n    eq(dn5.vertex, graph[3][2]);\n    eq(dn5.parent, dn4);\n    eq(true, dn5.dirToParent.eq(game.NORTH));\n    eq(dn5.length, 6);\n    eq(dn5.isDestroyer, false);\n\n    // Add alternation\n    graph[2][1].invertEdge(game.EAST);\n\n    dn5 = fnHamiltonian.PathNode(graph[3][2], dn4);\n    eq(dn5.vertex, graph[3][2]);\n    eq(dn5.parent, dn4);\n    eq(true, dn5.dirToParent.eq(game.NORTH));\n    eq(dn5.length, 6);\n    eq(dn5.isDestroyer, true);\n\n    let path = dn5.toPath();\n    eq(path.length, 6);\n    eq(path[5], dn0.vertex);\n    eq(path[4], dn1.vertex);\n    eq(path[3], dn2.vertex);\n    eq(path[2], dn3.vertex);\n    eq(path[1], dn4.vertex);\n    eq(path[0], dn5.vertex);\n  },\n\n  'find connector': () => {\n    const exp44Graph = ` v> ,   ><,   ><,  v <, \n^v  ,  v> ,  v <, ^v  , \n^v  , ^v  , ^v  , ^v  , \n^ > , ^  <, ^ > , ^  <, \n`;\n    let graph = fnHamiltonian.mkGraph(4, 4);\n    eq(fnHamiltonian.isHamiltonianCycle(graph), false);\n    graph[1][0].invertEdge(game.EAST);\n    graph[1][1].invertEdge(game.EAST);\n    graph[3][1].invertEdge(game.WEST);\n    graph[3][2].invertEdge(game.WEST);\n    graph[2][3].invertEdge(game.WEST);\n    graph[2][2].invertEdge(game.WEST);\n    graph[1][1].invertEdge(game.WEST);\n    graph[1][2].invertEdge(game.WEST);\n\n    let node = graph[0][0];\n    let goals = NodeSet();\n    goals.addNode(node);\n    let path = fnHamiltonian.findConnector(graph, node, goals);\n    eq(path.length, 1);\n    eq(goals.size(), 1);\n\n    node = graph[1][0];\n    goals = NodeSet();\n    goals.addNode(node);\n    path = fnHamiltonian.findConnector(graph, node, goals);\n    eq(path.length, 5);\n    eq(goals.size(), 0);\n\n    fnHamiltonian.invertPath(path);\n    eq(fnHamiltonian.isHamiltonianCycle(graph), true);\n    eq(fnHamiltonian.toString(graph), exp44Graph);\n  },\n\n  'find destroyer': () => {\n    let graph = fnHamiltonian.mkGraph(4, 4);\n\n    graph[0][1].invertEdge(game.EAST);\n    graph[2][1].invertEdge(game.EAST);\n\n    const goals = NodeSet();\n    //goals.addNode(graph[3][2])\n    goals.addNode(graph[3][0]);\n    const paths = [];\n    paths.push(fnHamiltonian.findDestroyer(graph, graph[0][0], goals));\n    eq(goals.size(), 0);\n    eq(paths[0].length, 6);\n    eq(paths[0][5], graph[0][0]);\n    eq(paths[0][4], graph[0][1]);\n    eq(paths[0][3], graph[1][1]);\n    eq(paths[0][2], graph[2][1]);\n    eq(paths[0][1], graph[3][1]);\n    eq(paths[0][0], graph[3][0]);\n  },\n\n  'get destroyer paths': () => {\n    let graph = fnHamiltonian.mkGraph(10, 10);\n    fnHamiltonian.runDeletion(graph);\n    const paths = fnHamiltonian.getDestroyerPaths(graph);\n    const rems = fnHamiltonian.getRemainders(graph);\n\n    eq(rems.size() / 2, paths.length);\n    // Make sure that the paths start and end with vertices in rems\n    paths.forEach((p) => {\n      eq(rems.hasNode(p[0]), true);\n      rems.deleteNode(p[0]);\n      eq(rems.hasNode(p[p.length - 1]), true);\n      rems.deleteNode(p[p.length - 1]);\n    });\n  },\n\n  'invert paths': () => {\n    const graphExp = ` v> ,  v><,   ><,  v><,  v <, \n^v  , ^v  ,  v> , ^  <, ^v  , \n^v> , ^  <, ^v  ,  v> , ^v <, \n^ > ,   ><, ^  <, ^ > , ^  <, \n`;\n\n    let graph = fnHamiltonian.mkGraph(5, 4);\n\n    graph[0][1].invertEdge(game.EAST);\n    graph[1][1].invertEdge(game.EAST);\n    graph[2][1].invertEdge(game.NORTH);\n    graph[3][1].invertEdge(game.SOUTH);\n    graph[3][1].invertEdge(game.EAST);\n    graph[1][2].invertEdge(game.SOUTH);\n    graph[1][2].invertEdge(game.EAST);\n    graph[2][2].invertEdge(game.EAST);\n    graph[2][3].invertEdge(game.EAST);\n    eq(fnHamiltonian.toString(graph), graphExp);\n\n    const paths = fnHamiltonian.getDestroyerPaths(graph);\n    fnHamiltonian.invertPath(paths[0]);\n    fnHamiltonian.invertPath(paths[1]);\n\n    eq(fnHamiltonian.getRemainders(graph).size(), 0);\n\n    graph = fnHamiltonian.mkGraph(10, 10);\n    fnHamiltonian.runDeletion(graph);\n    fnHamiltonian.getDestroyerPaths(graph).forEach((p) => {\n      fnHamiltonian.invertPath(p);\n    });\n    eq(fnHamiltonian.getRemainders(graph).size(), 0);\n  },\n\n  'is hamiltonian cycle': () => {\n    const exp44Graph = ` v> ,   ><,   ><,  v <, \n^v  ,  v> ,  v <, ^v  , \n^v  , ^v  , ^v  , ^v  , \n^ > , ^  <, ^ > , ^  <, \n`;\n    let graph = fnHamiltonian.mkGraph(4, 4);\n    eq(fnHamiltonian.isHamiltonianCycle(graph), false);\n    graph[1][0].invertEdge(game.SOUTH);\n    graph[2][0].invertEdge(game.SOUTH);\n    graph[3][1].invertEdge(game.WEST);\n    graph[3][2].invertEdge(game.WEST);\n    graph[2][3].invertEdge(game.WEST);\n    graph[2][2].invertEdge(game.WEST);\n    graph[1][1].invertEdge(game.WEST);\n    graph[1][2].invertEdge(game.WEST);\n    eq(fnHamiltonian.toString(graph), exp44Graph);\n    eq(fnHamiltonian.isHamiltonianCycle(graph), true);\n    // Make two unconnected cycles\n    graph[1][0].invertEdge(game.SOUTH);\n    graph[2][0].invertEdge(game.SOUTH);\n    graph[1][0].invertEdge(game.EAST);\n    graph[1][1].invertEdge(game.EAST);\n    eq(fnHamiltonian.isHamiltonianCycle(graph), false);\n  },\n\n  'build hamiltonian cycle': () => {\n    let graph = fnHamiltonian.buildCycle(4, 4, NodeSet(), 0, 200, 1000);\n    console.log(fnHamiltonian.toString(graph));\n    eq(fnHamiltonian.isHamiltonianCycle(graph), true);\n\n    graph = fnHamiltonian.buildCycle(6, 6, NodeSet(), 0, 200, 1000);\n    console.log(fnHamiltonian.toString(graph));\n    eq(fnHamiltonian.isHamiltonianCycle(graph), true);\n\n    graph = fnHamiltonian.buildCycle(8, 8, NodeSet(), 0, 200, 1000);\n    console.log(fnHamiltonian.toString(graph));\n    eq(fnHamiltonian.isHamiltonianCycle(graph), true);\n  },\n\n  /*'make example fig2': () => {\n    const graphExp = ` v> ,  v><,   ><,  v><,  v <, \n^v  , ^v  ,  v> , ^  <, ^v  , \n^v> , ^  <, ^v  ,  v> , ^v <, \n^ > ,   ><, ^  <, ^ > , ^  <, \n`\n\n    let graph = fnHamiltonian.mkGraph(5,4)\n\n    graph[0][1].invertEdge(game.EAST)\n    graph[1][1].invertEdge(game.EAST)\n    graph[2][1].invertEdge(game.NORTH)\n    graph[3][1].invertEdge(game.SOUTH)\n    graph[3][1].invertEdge(game.EAST)\n    graph[1][2].invertEdge(game.SOUTH)\n    graph[1][2].invertEdge(game.EAST)\n    graph[2][2].invertEdge(game.EAST)\n    graph[2][3].invertEdge(game.EAST)\n    eq(fnHamiltonian.toString(graph), graphExp)\n\n    const remainders = fnHamiltonian.getRemainders(graph)\n    eq(remainders.size(), 4)\n\n    const paths = fnHamiltonian.getDestroyerPaths(graph)\n    console.log(paths)\n    eq(paths.length, 2)\n    eq(paths[0][0].eq(Node(1,0)), true)\n    eq(paths[0][paths[0].length-1].eq(Node(0,2)), true)\n    eq(paths[1][0].eq(Node(1,0)), true)\n    eq(paths[1][paths[1].length-1].eq(Node(0,2)), true)\n  },*/\n};\n"],"names":[],"version":3,"file":"test.a5fef555.js.map"}