{"mappings":"","sources":["src/snake-pro/tests/game-tests.js"],"sourcesContent":["const gameTests = {\n  Node: () => {\n    const nodes = [Node(1, 2), Node(1, 2), Node(0, 3), Node(1, 3), Node(0, 2)];\n\n    eq(1, nodes[0].x);\n    eq(2, nodes[0].y);\n\n    //equality\n    eq(true, nodes[0].eq(nodes[1]));\n    eq(false, nodes[0].eq(nodes[2]));\n    eq(false, nodes[0].eq(nodes[3]));\n    eq(false, nodes[0].eq(nodes[4]));\n\n    // sum\n    eq(true, Node(2, 4).eq(nodes[0].sum(nodes[1])));\n    eq(false, Node(2, 2).eq(nodes[0].sum(nodes[1])));\n    eq(false, Node(1, 4).eq(nodes[0].sum(nodes[1])));\n    eq(true, Node(1, 5).eq(nodes[0].sum(nodes[2])));\n    eq(true, Node(2, 5).eq(nodes[0].sum(nodes[3])));\n    eq(true, Node(1, 4).eq(nodes[0].sum(nodes[4])));\n\n    // inbounds\n    eq(true, nodes[0].inBounds(3, 3));\n    eq(true, nodes[0].inBounds(2, 3));\n    eq(false, nodes[0].inBounds(0, 3));\n    eq(false, nodes[0].inBounds(2, 2));\n    eq(false, Node(-1, 2).inBounds(5, 5));\n    eq(false, Node(2, -1).inBounds(5, 5));\n  },\n\n  NodeSet: () => {\n    const walls = NodeSet();\n    eq(walls.size(), 0);\n    eq(walls.has(10, 6), false);\n    walls.add(10, 6);\n    eq(walls.size(), 1);\n    eq(walls.has(10, 6), true);\n    eq(true, walls.get(10, 6).eq(Node(10, 6)));\n    walls.delete(10, 6);\n    eq(walls.size(), 0);\n    eq(walls.has(10, 6), false);\n  },\n\n  willEat: () => {\n    const head = Node(5, 8);\n    const apples = [Node(5, 8), Node(5, 9), Node(4, 8)];\n\n    eq(true, game.willEat(head, apples[0]));\n    eq(false, game.willEat(head, apples[1]));\n    eq(false, game.willEat(head, apples[2]));\n  },\n\n  willLive: () => {\n    const heads = [Node(5, 8), Node(1, 1), Node(1, -1), Node(-1, 1)];\n    const snake1 = [Node(0, 0), Node(0, 1)];\n    const snake2 = [Node(1, 1), Node(0, 1)];\n    const wallsEmpty = NodeSet();\n\n    eq(false, game.willLive(2, 2, heads[0], snake1, wallsEmpty));\n    eq(false, game.willLive(6, 8, heads[0], snake1, wallsEmpty));\n    eq(false, game.willLive(5, 9, heads[0], snake1, wallsEmpty));\n    eq(true, game.willLive(6, 9, heads[0], snake1, wallsEmpty));\n    eq(true, game.willLive(10, 10, heads[1], snake1, wallsEmpty));\n    eq(false, game.willLive(10, 10, heads[1], snake2, wallsEmpty));\n    eq(false, game.willLive(10, 10, heads[2], snake1, wallsEmpty));\n    eq(false, game.willLive(10, 10, heads[3], snake1, wallsEmpty));\n\n    const walls1 = NodeSet();\n    walls1.add(5, 8);\n    eq(false, game.willLive(6, 9, heads[0], snake1, walls1));\n    eq(true, game.willLive(10, 10, heads[1], snake1, walls1));\n    walls1.delete(5, 8);\n    walls1.add(1, 1);\n    eq(true, game.willLive(6, 9, heads[0], snake1, walls1));\n    eq(false, game.willLive(10, 10, heads[1], snake1, walls1));\n  },\n\n  nextHead: () => {\n    const cur = Node(1, 1);\n    eq(true, Node(1, 0).eq(cur.sum(game.NORTH)));\n    eq(true, Node(1, 2).eq(cur.sum(game.SOUTH)));\n    eq(true, Node(0, 1).eq(cur.sum(game.WEST)));\n    eq(true, Node(2, 1).eq(cur.sum(game.EAST)));\n  },\n\n  nextSnake: () => {\n    const snake1 = [Node(0, 1), Node(0, 0)];\n    const snake2 = [Node(1, 1), Node(0, 1), Node(0, 0)];\n    const snake3 = [Node(1, 1), Node(0, 1)];\n\n    eq(\n      true,\n      game.nextSnake(snake1, Node(1, 1), true).every((node, i) => node.eq(snake2[i])),\n    );\n    eq(false, game.nextSnake(snake1, Node(1, 1), true).length == snake3.length);\n    eq(false, game.nextSnake(snake1, Node(1, 1), false).length == snake2.length);\n    eq(\n      true,\n      game.nextSnake(snake1, Node(1, 1), false).every((node, i) => node.eq(snake3[i])),\n    );\n  },\n\n  nextApple: () => {\n    const snake1 = [Node(0, 0), Node(0, 1), Node(1, 1)];\n    const wall1 = NodeSet();\n    wall1.add(2, 1);\n    wall1.add(2, 0);\n\n    // Should never return any apples on the snake\n    for (let i = 0; i < 10; i++) {\n      eq(true, Node(1, 0).eq(game.nextApple(3, 2, snake1, wall1)));\n    }\n\n    let apple = game.nextApple(1000, 1000, snake1, wall1);\n    let tolerance = 1;\n    // Should always be different position, but this can still sometimes fail\n    for (let i = 0; i < 10; i++) {\n      let res = apple.eq(game.nextApple(1000, 1000, snake1, wall1));\n      if (res && tolerance > 0) {\n        tolerance--;\n        res = false;\n      }\n      eq(false, res);\n    }\n  },\n\n  next: () => {\n    const compareKeys = (a, b) => {\n      var aKeys = Object.keys(a).sort();\n      var bKeys = Object.keys(b).sort();\n      return JSON.stringify(aKeys) === JSON.stringify(bKeys);\n    };\n    const next = game.next(100, 99, NodeSet());\n    const dirs = game.DIRECTIONS;\n    let state = next();\n\n    // Check initial State\n    eq(state.nx, 100);\n    eq(state.ny, 99);\n    eq(state.isAlive, true);\n    eq(state.justEaten, true);\n    eq(\n      true,\n      state.snake.reduce((isLinked, node, i, arr) => {\n        if (i == 0) return true;\n        else if (isLinked) return dirs.some((d) => arr[i - 1].eq(d.sum(node)));\n        else return isLinked;\n      }),\n    );\n    eq(\n      true,\n      dirs.some((d) => d.eq(state.direction)),\n    );\n    eq(true, compareKeys(Node(0, 0), state.apple));\n    eq(true, compareKeys(NodeSet(), state.walls));\n\n    // Check initial state advanced by one step\n    let state3 = next(state);\n    eq(state3.nx, 100);\n    eq(state3.ny, 99);\n    eq(state3.isAlive, true);\n    eq(state3.justEaten, false);\n    eq(\n      true,\n      state.snake.reduce((isLinked, node, i, arr) => {\n        if (i == 0) return true;\n        else if (isLinked) return dirs.some((d) => arr[i - 1].eq(d.sum(node)));\n        else return isLinked;\n      }),\n    );\n    eq(\n      true,\n      dirs.some((d) => d.eq(state.direction)),\n    );\n    eq(state3.walls, state.walls);\n\n    // Check custom state\n    state.snake = [Node(6, 5), Node(5, 5)];\n    state.apple = Node(6, 6);\n    let state2 = next(state, { direction: game.SOUTH });\n    eq(false, state == state2); // state should always be a new state\n    eq(false, state.snake == state2.snake); // snake should always be a copy\n    eq(state2.nx, 100);\n    eq(state2.ny, 99);\n    eq(state2.isAlive, true);\n    eq(state2.justEaten, true);\n    eq(\n      true,\n      state2.snake.reduce((isLinked, node, i, arr) => {\n        if (i == 0) return true;\n        else if (isLinked) return dirs.some((d) => arr[i - 1].eq(d.sum(node)));\n        else return isLinked;\n      }),\n    );\n    eq(state2.snake.length, 3);\n    eq(true, state2.direction.eq(game.SOUTH));\n    eq(true, compareKeys(Node(0, 0), state2.apple));\n  },\n};\n"],"names":[],"version":3,"file":"test.efd79501.js.map"}