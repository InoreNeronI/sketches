{"mappings":"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","sources":["<anon>","src/snake-pro/src/hamiltonian.js"],"sourcesContent":["const Hamiltonian = (findDestroyerStepLimit = 100, findConnectorStepLimit = 100, findConnectorIterLimit = 1000, updateLimit = 30)=>{\n    const hm = {};\n    hm.getAction = (node, state = null)=>{\n        if (hm.isHamiltonianCycle) return hm.policy[node.x][node.y];\n        else return hm.spAgent.getAction(node);\n    };\n    hm.update = (state)=>{\n        let updated = false;\n        if (hm.graph == null) {\n            // Init Graph\n            hm.graph = fnHamiltonian.buildCycle(state.nx, state.ny, state.walls, hm.findDestroyerStepLimit, hm.findConnectorStepLimit, hm.findConnectorIterLimit);\n            hm.isHamiltonianCycle = fnHamiltonian.isHamiltonianCycle(hm.graph);\n            updated = true;\n        } else if (!hm.isHamiltonianCycle) {\n            // Continue to search for a Hamiltonian Cycle\n            // TODO: Improve iteration efficiency\n            // Possibly get Sets of separate cycles in the graph, and only iterate on the edges of cycles that neighbor other edges,\n            // from smallest cycles\n            fnHamiltonian.invertConnectorPaths(hm.graph, 100, 1000);\n            hm.isHamiltonianCycle = fnHamiltonian.isHamiltonianCycle(hm.graph);\n            updated = true;\n        }\n        if (updated) {\n            if (hm.isHamiltonianCycle) {\n                hm.path = fnHamiltonian.buildPath(hm.graph);\n                hm.pathNodeIndex = NodeMap();\n                hm.path.forEach((vx, i)=>hm.pathNodeIndex.set(vx, i));\n                hm.policy = fnHamiltonian.buildPolicy(hm.path, hm.graph.length, hm.graph[0].length);\n            } else {\n                // If not Cycle, then use Shortest Path agent\n                hm.spAgent.update(state, state.apple);\n                // Attempt to find a path in the given graph up to updateLimit times,\n                // beyond that, just re-init and try with a different graph\n                hm.updateCount++;\n                if (hm.updateCount >= hm.updateLimit) {\n                    hm.reset();\n                    hm.update(state);\n                }\n            }\n        }\n    };\n    hm.reset = ()=>{\n        hm.spAgent = ShortestPath();\n        hm.graph = null;\n        hm.isHamiltonianCycle = false;\n        hm.path = null;\n        hm.pathNodeIndex = null;\n        hm.policy = null;\n        hm.updateCount = 0;\n    };\n    hm.findDestroyerStepLimit = findDestroyerStepLimit;\n    hm.findConnectorStepLimit = findConnectorStepLimit;\n    hm.findConnectorIterLimit = findConnectorIterLimit;\n    hm.updateLimit = updateLimit;\n    hm.reset();\n    return hm;\n};\n// https://springerplus.springeropen.com/articles/10.1186/s40064-016-2746-8\nfnHamiltonian = {\n    /**\n   * Returns a graph initialized to the given dimensions.\n   * Will attempt to find a hamiltonian cycle while adhering to the given limits.\n   */ buildCycle: (nx, ny, exclusions = NodeSet(), findDestroyerStepLimit = 0, findConnectorStepLimit = 100, findConnectorIterLimit = 100)=>{\n        let graph = fnHamiltonian.mkGraph(nx, ny);\n        fnHamiltonian.processExclusions(graph, exclusions);\n        fnHamiltonian.runDeletion(graph);\n        fnHamiltonian.getDestroyerPaths(graph, findDestroyerStepLimit).forEach((p)=>fnHamiltonian.invertPath(p));\n        fnHamiltonian.invertConnectorPaths(graph, findConnectorStepLimit, findConnectorIterLimit);\n        return graph;\n    },\n    /**\n   * Deletes all edges for the vertices given in the exclusions Set\n   */ processExclusions: (graph, exclusions)=>{\n        exclusions.lookup.forEach((node)=>{\n            game.DIRECTIONS.forEach((d)=>graph[node.x][node.y].deleteEdge(d));\n        });\n    },\n    /**\n   * Returns an array containing the vertex progression for the hamiltonian cycle\n   */ buildPath: (graph)=>{\n        let start = null;\n        // Check that all vertices are valid\n        for(let i = 0; i < graph.length; i++){\n            for(let j = 0; j < graph[i].length; j++)if (start == null && graph[i][j].nEdges != 0) {\n                start = graph[i][j];\n                break;\n            }\n        }\n        // Build Path\n        let path = [\n            start\n        ];\n        let prevDir = start.getMove();\n        let current = start.getNeighbor(prevDir);\n        while(current != start && current != null && path.length < graph.length * graph[0].length){\n            path.push(current);\n            prevDir = current.getMove(game.DIR_OPPOSITES.get(prevDir));\n            if (prevDir == null) break; // A dead end has been hit\n            current = current.getNeighbor(prevDir);\n        }\n        if (current == start) path.push(current);\n        return path;\n    },\n    /**\n   * Returns a 2D matrix with directions to follow on each node based on the given path\n   */ buildPolicy: (path, nx, ny)=>{\n        let policy = Array.from(Array(nx), (_)=>Array.from(Array(ny), (_)=>null));\n        for(let i = 0; i < path.length - 1; i++){\n            const srcVx = path[i];\n            const nextVx = path[i + 1];\n            policy[srcVx.x][srcVx.y] = nextVx.sub(srcVx);\n        }\n        return policy;\n    },\n    /**\n   * Child class of Node that also includes methods for tracking and modifying its edges\n   */ Vertex: (x, y, graph)=>{\n        const vx = Node(x, y);\n        vx.graph = graph;\n        vx.edges = NodeMap();\n        game.DIRECTIONS.forEach((dir)=>vx.edges.set(dir, 1));\n        vx.nEdges = game.DIRECTIONS.length;\n        // Set Edge to a specific value\n        vx.setEdge = (dir, value)=>{\n            if (value > 0 && vx.edges.get(dir) <= 0) vx.nEdges++;\n            else if (value <= 0 && vx.edges.get(dir) > 0) vx.nEdges--;\n            vx.edges.set(dir, value);\n        };\n        // Returns the value of an end in a given direction\n        vx.getEdge = (dir)=>vx.edges.get(dir);\n        // Invert the value of an edge between 0 and 1 (also affects its neighbor)\n        // Has no effect on values less than 0\n        vx.invertEdge = (dir)=>{\n            if (vx.getEdge(dir) >= 0) {\n                vx.setEdge(dir, vx.getEdge(dir) > 0 ? 0 : 1);\n                vx.getNeighbor(dir).setEdge(game.DIR_OPPOSITES.get(dir), vx.getEdge(dir));\n            }\n        };\n        // Delete this edge by setting its value to -1 (also affects its neighbor)\n        vx.deleteEdge = (dir)=>{\n            if (vx.getEdge(dir) >= -1) {\n                vx.setEdge(dir, -1);\n                const neighbor = vx.getNeighbor(dir);\n                if (neighbor != null) neighbor.setEdge(game.DIR_OPPOSITES.get(dir), vx.getEdge(dir));\n            }\n        };\n        // Returns the neighboring Vertex in a given direction\n        vx.getNeighbor = (dir)=>{\n            const node = vx.sum(dir);\n            return node.inBounds(vx.graph.length, vx.graph[0].length) ? vx.graph[node.x][node.y] : null;\n        };\n        // Returns the first direction to move in from the vertex\n        vx.getMove = (exDir = null)=>{\n            for(let i = 0; i < game.DIRECTIONS.length; i++){\n                if (vx.getEdge(game.DIRECTIONS[i]) > 0 && (exDir == null ? true : !game.DIRECTIONS[i].eq(exDir))) return game.DIRECTIONS[i];\n            }\n            return null;\n        };\n        return vx;\n    },\n    /**\n   * Returns a graph of width nx and height ny where all vertexes are connected to their\n   * North, South, East and West neighbors (except at the 4 sides of the graph)\n   */ mkGraph: (nx, ny)=>{\n        const graph = Array.from(Array(nx), (_)=>Array.from(Array(ny), (_)=>null));\n        // 1 for edge, 0 for deleted edge, -1 for no edge\n        for(let i = 0; i < graph.length; i++)for(let j = 0; j < graph[i].length; j++){\n            graph[i][j] = fnHamiltonian.Vertex(i, j, graph);\n            // No edges at the ends of the graph\n            if (i == 0) graph[i][j].deleteEdge(game.WEST);\n            else if (i == graph.length - 1) graph[i][j].deleteEdge(game.EAST);\n            if (j == 0) graph[i][j].deleteEdge(game.NORTH);\n            else if (j == graph[i].length - 1) graph[i][j].deleteEdge(game.SOUTH);\n        }\n        return graph;\n    },\n    /**\n   * Randomly delete surplus edges in place from each vertex until there are none remaining\n   */ runDeletion: (graph)=>{\n        for(let i = 0; i < graph.length; i++)for(let j = 0; j < graph[i].length; j++){\n            // In vertex[i,j],\n            const vx = graph[i][j];\n            const ord = game.DIRECTIONS.concat();\n            utils.shuffle(ord);\n            // Evaluate edges in random order,\n            for(let k = 0; k < ord.length; k++){\n                // no point looping if their at minimum number\n                if (vx.nEdges <= 2) break;\n                else if (vx.getEdge(ord[k]) > 0 && vx.getNeighbor(ord[k]).nEdges > 2) // Delete the current edge\n                vx.invertEdge(ord[k]);\n            }\n        }\n    },\n    /**\n   * Returns a NodeSet of all vertices with more than 2 edges remaining\n   */ getRemainders: (graph)=>{\n        const rems = NodeSet();\n        for(let i = 0; i < graph.length; i++){\n            for(let j = 0; j < graph[i].length; j++)if (graph[i][j].nEdges > 2) rems.addNode(graph[i][j]);\n        }\n        return rems;\n    },\n    /**\n   * Object used to track the progress of a path, used in findDestroyer()\n   */ PathNode: (vertex, parent)=>{\n        const dn = {};\n        dn.vertex = vertex;\n        dn.parent = parent;\n        dn.dirToParent = parent == null ? null : parent.vertex.sub(dn.vertex);\n        dn.length = parent == null ? 1 : parent.length + 1;\n        dn.pathVertices = parent == null ? NodeSet() : dn.parent.pathVertices.copy();\n        dn.pathVertices.addNode(dn.vertex);\n        // These only works assuming nodes are added to the path correctly\n        dn.isDestroyer = dn.length >= 4 && dn.length % 2 == 0 && dn.vertex.getEdge(dn.dirToParent) == 1 && dn.parent.vertex.getEdge(dn.parent.dirToParent) == 0;\n        dn.isAltEdge = dn.length < 3 ? false : dn.vertex.getEdge(dn.dirToParent) != dn.parent.vertex.getEdge(dn.parent.dirToParent);\n        dn.isEvenAltEdge = dn.isAltEdge && dn.length % 2 == 1;\n        dn.toPath = ()=>{\n            const path = [];\n            for(c = dn; c != null; c = c.parent)path.push(c.vertex);\n            return path;\n        };\n        return dn;\n    },\n    /**\n   * Breadth first search, can produce cycle unless prohibited in pathCriteria\n   */ _find: (graph, start, goals, stepLimit = 0, pathCriteria = ()=>true, goalCriteria = ()=>true)=>{\n        const continuePath = (current, dir)=>{\n            const neighbor = current.vertex.getNeighbor(dir);\n            // If the next vertex is not already part of the path (unless it is the start node), and meets path criteria\n            return neighbor != null && (neighbor == start || !current.pathVertices.hasNode(neighbor)) && pathCriteria(current, dir);\n        };\n        // Start BFS\n        const open = [\n            fnHamiltonian.PathNode(start, null)\n        ];\n        let steps = 0;\n        let current = null;\n        while((stepLimit <= 0 || steps < stepLimit) && open.length > 0 && goals.size() > 0){\n            current = open.shift();\n            if (goals.hasNode(current.vertex) && goalCriteria(current)) {\n                goals.deleteNode(current.vertex);\n                return current.toPath();\n            }\n            // For each direction from this vertex,\n            game.DIRECTIONS.forEach((dir)=>{\n                // Excluding the direction to the parent, add to open if meets criteria.\n                if (current.parent == null || !dir.eq(current.dirToParent)) {\n                    if (continuePath(current, dir)) {\n                        const node = current.vertex.sum(dir);\n                        open.push(fnHamiltonian.PathNode(graph[node.x][node.y], current));\n                    }\n                }\n            });\n            steps++;\n        }\n        return [\n            start\n        ];\n    },\n    /**\n   * Returns the shortest Connector cycle for a given starting node.\n   * This mutates the goals object by deleting the vertices that are part of the path.\n   */ findConnector: (graph, start, goals, stepLimit = 100)=>{\n        //\n        const pathCriteria = (current, dir)=>{\n            return current.length < 3 || current.isAltEdge && current.vertex.getEdge(current.dirToParent) != current.vertex.getEdge(dir);\n        };\n        const goalCriteria = (current)=>current.isEvenAltEdge;\n        return fnHamiltonian._find(graph, start, goals, stepLimit, pathCriteria, goalCriteria);\n    },\n    /**\n   * Randomly selects a vertex to search for a connector cycle, if one is found, it will invert it.\n   * This is done until the iteration limit is hit or a hamiltonian cycle is found.\n   */ invertConnectorPaths: (graph, stepLimit = 0, iterationLimit = 100)=>{\n        for(let i = 0; i < iterationLimit; i++){\n            const start = graph[utils.randInt(0, graph.length - 1)][utils.randInt(0, graph[0].length - 1)];\n            const goals = NodeSet();\n            goals.addNode(start);\n            fnHamiltonian.invertPath(fnHamiltonian.findConnector(graph, start, goals, stepLimit));\n            if (fnHamiltonian.isHamiltonianCycle(graph)) break;\n        }\n    },\n    /**\n   * Returns the shortest Destroyer path found between start and any one of the goals.\n   * This mutates the goals object by deleting the vertices that are part of the path.\n   */ findDestroyer: (graph, start, goals, stepLimit = 0)=>{\n        const pathCriteria = (current, dir)=>{\n            // If below minimum length, check if it is alternating in the right way\n            return current.length == 1 && current.vertex.getEdge(dir) == 1 || current.length == 2 && current.vertex.getEdge(current.dirToParent) == 1 && current.vertex.getEdge(dir) == 0 || current.length == 3 && current.vertex.getEdge(current.dirToParent) == 0 && current.vertex.getEdge(dir) == 1 || // If isDestroyer and the next edge has been deleted\n            current.length >= 4 && current.isDestroyer && current.vertex.getEdge(dir) == 0 || // If not destroyer, parent isDestroyer and the next edge exists\n            current.length >= 4 && !current.isDestroyer && current.parent.isDestroyer && current.vertex.getEdge(dir) == 1;\n        };\n        goals.deleteNode(start);\n        return fnHamiltonian._find(graph, start, goals, stepLimit, pathCriteria);\n    },\n    /**\n   * Returns an array of destroyer paths in a given graph.\n   * These paths start and end at remainder nodes (more than 2 edges).\n   */ getDestroyerPaths: (graph, stepLimit = 0)=>{\n        const remainders = fnHamiltonian.getRemainders(graph);\n        const remCopy = remainders.copy();\n        const paths = [];\n        remainders.lookup.forEach((vx)=>{\n            if (remCopy.hasNode(vx)) paths.push(fnHamiltonian.findDestroyer(graph, vx, remCopy, stepLimit));\n        });\n        return paths;\n    },\n    /**\n   * Inverts all edges in the path, 10101 becomes 01010\n   * When used on a destroyer path where the start and end vertices have 3 edges each,\n   * It will reduce them both down to 2 edges while maintaining the same number of edges for\n   * all other vertices in the path.\n   */ invertPath: (path)=>{\n        path.forEach((vx, i)=>{\n            if (i < path.length - 1) {\n                const dir = path[i + 1].sub(vx);\n                vx.invertEdge(dir);\n            }\n        });\n    },\n    /**\n   * Returns true if the graph contains a Hamiltonian cycle\n   */ isHamiltonianCycle: (graph)=>{\n        const exclusions = NodeSet();\n        const pathVertices = NodeSet();\n        let start = null;\n        // Check that all vertices are valid\n        for(let i = 0; i < graph.length; i++)for(let j = 0; j < graph[i].length; j++){\n            // No edges means it is deliberately excluded from the path\n            if (graph[i][j].nEdges == 0) exclusions.addNode(graph[i][j]);\n            else if (graph[i][j].nEdges != 2) return false;\n            else if (start == null) start = graph[i][j];\n        }\n        // Go through the path and check if it is a Hamiltonian Cycle\n        pathVertices.addNode(start);\n        let prevDir = start.getMove();\n        let current = start.getNeighbor(prevDir);\n        while(!pathVertices.hasNode(current) && !exclusions.hasNode(current)){\n            pathVertices.addNode(current);\n            prevDir = current.getMove(game.DIR_OPPOSITES.get(prevDir));\n            current = current.getNeighbor(prevDir);\n            if (current == null) break;\n        }\n        const nVx = pathVertices.size() + exclusions.size();\n        const nGraphVx = graph.length * graph[0].length;\n        return current != null && current == start && nVx == nGraphVx;\n    },\n    /**\n   * Returns a string representation of the given graph\n   */ toString: (graph)=>{\n        let string = \"\";\n        // Rows first and then Columns\n        for(let j = 0; j < graph[0].length; j++){\n            for(let i = 0; i < graph.length; i++){\n                for(let k = 0; k < game.DIRECTIONS.length; k++){\n                    const v = graph[i][j].getEdge(game.DIRECTIONS[k]);\n                    if (v == 1) string += game.DIR_SYMBOLS.get(game.DIRECTIONS[k]);\n                    else string += \" \";\n                }\n                string += \", \";\n            }\n            string += \"\\n\";\n        }\n        return string;\n    }\n};\n\n//# sourceMappingURL=index.3e3f4365.js.map\n","const Hamiltonian = (findDestroyerStepLimit = 100, findConnectorStepLimit = 100, findConnectorIterLimit = 1000, updateLimit = 30) => {\n  const hm = {};\n\n  hm.getAction = (node, state = null) => {\n    if (hm.isHamiltonianCycle) {\n      return hm.policy[node.x][node.y];\n    } else return hm.spAgent.getAction(node);\n  };\n\n  hm.update = (state) => {\n    let updated = false;\n    if (hm.graph == null) {\n      // Init Graph\n      hm.graph = fnHamiltonian.buildCycle(\n        state.nx,\n        state.ny,\n        state.walls,\n        hm.findDestroyerStepLimit,\n        hm.findConnectorStepLimit,\n        hm.findConnectorIterLimit,\n      );\n      hm.isHamiltonianCycle = fnHamiltonian.isHamiltonianCycle(hm.graph);\n      updated = true;\n    } else if (!hm.isHamiltonianCycle) {\n      // Continue to search for a Hamiltonian Cycle\n      // TODO: Improve iteration efficiency\n      // Possibly get Sets of separate cycles in the graph, and only iterate on the edges of cycles that neighbor other edges,\n      // from smallest cycles\n      fnHamiltonian.invertConnectorPaths(hm.graph, 100, 1000);\n      hm.isHamiltonianCycle = fnHamiltonian.isHamiltonianCycle(hm.graph);\n      updated = true;\n    }\n\n    if (updated) {\n      if (hm.isHamiltonianCycle) {\n        hm.path = fnHamiltonian.buildPath(hm.graph);\n        hm.pathNodeIndex = NodeMap();\n        hm.path.forEach((vx, i) => hm.pathNodeIndex.set(vx, i));\n        hm.policy = fnHamiltonian.buildPolicy(hm.path, hm.graph.length, hm.graph[0].length);\n      } else {\n        // If not Cycle, then use Shortest Path agent\n        hm.spAgent.update(state, state.apple);\n        // Attempt to find a path in the given graph up to updateLimit times,\n        // beyond that, just re-init and try with a different graph\n        hm.updateCount++;\n        if (hm.updateCount >= hm.updateLimit) {\n          hm.reset();\n          hm.update(state);\n        }\n      }\n    }\n  };\n\n  hm.reset = () => {\n    hm.spAgent = ShortestPath();\n    hm.graph = null;\n    hm.isHamiltonianCycle = false;\n    hm.path = null;\n    hm.pathNodeIndex = null;\n    hm.policy = null;\n    hm.updateCount = 0;\n  };\n\n  hm.findDestroyerStepLimit = findDestroyerStepLimit;\n  hm.findConnectorStepLimit = findConnectorStepLimit;\n  hm.findConnectorIterLimit = findConnectorIterLimit;\n  hm.updateLimit = updateLimit;\n  hm.reset();\n\n  return hm;\n};\n\n// https://springerplus.springeropen.com/articles/10.1186/s40064-016-2746-8\nfnHamiltonian = {\n  /**\n   * Returns a graph initialized to the given dimensions.\n   * Will attempt to find a hamiltonian cycle while adhering to the given limits.\n   */\n  buildCycle: (nx, ny, exclusions = NodeSet(), findDestroyerStepLimit = 0, findConnectorStepLimit = 100, findConnectorIterLimit = 100) => {\n    let graph = fnHamiltonian.mkGraph(nx, ny);\n    fnHamiltonian.processExclusions(graph, exclusions);\n    fnHamiltonian.runDeletion(graph);\n    fnHamiltonian.getDestroyerPaths(graph, findDestroyerStepLimit).forEach((p) => fnHamiltonian.invertPath(p));\n    fnHamiltonian.invertConnectorPaths(graph, findConnectorStepLimit, findConnectorIterLimit);\n    return graph;\n  },\n\n  /**\n   * Deletes all edges for the vertices given in the exclusions Set\n   */\n  processExclusions: (graph, exclusions) => {\n    exclusions.lookup.forEach((node) => {\n      game.DIRECTIONS.forEach((d) => graph[node.x][node.y].deleteEdge(d));\n    });\n  },\n\n  /**\n   * Returns an array containing the vertex progression for the hamiltonian cycle\n   */\n  buildPath: (graph) => {\n    let start = null;\n    // Check that all vertices are valid\n    for (let i = 0; i < graph.length; i++) {\n      for (let j = 0; j < graph[i].length; j++) {\n        if (start == null && graph[i][j].nEdges != 0) {\n          start = graph[i][j];\n          break;\n        }\n      }\n    }\n\n    // Build Path\n    let path = [start];\n    let prevDir = start.getMove();\n    let current = start.getNeighbor(prevDir);\n    while (current != start && current != null && path.length < graph.length * graph[0].length) {\n      path.push(current);\n      prevDir = current.getMove(game.DIR_OPPOSITES.get(prevDir));\n      if (prevDir == null) break; // A dead end has been hit\n      current = current.getNeighbor(prevDir);\n    }\n\n    if (current == start) path.push(current);\n\n    return path;\n  },\n\n  /**\n   * Returns a 2D matrix with directions to follow on each node based on the given path\n   */\n  buildPolicy: (path, nx, ny) => {\n    let policy = Array.from(Array(nx), (_) => Array.from(Array(ny), (_) => null));\n    for (let i = 0; i < path.length - 1; i++) {\n      const srcVx = path[i];\n      const nextVx = path[i + 1];\n      policy[srcVx.x][srcVx.y] = nextVx.sub(srcVx);\n    }\n    return policy;\n  },\n\n  /**\n   * Child class of Node that also includes methods for tracking and modifying its edges\n   */\n  Vertex: (x, y, graph) => {\n    const vx = Node(x, y);\n    vx.graph = graph;\n    vx.edges = NodeMap();\n    game.DIRECTIONS.forEach((dir) => vx.edges.set(dir, 1));\n    vx.nEdges = game.DIRECTIONS.length;\n\n    // Set Edge to a specific value\n    vx.setEdge = (dir, value) => {\n      if (value > 0 && vx.edges.get(dir) <= 0) vx.nEdges++;\n      else if (value <= 0 && vx.edges.get(dir) > 0) vx.nEdges--;\n      vx.edges.set(dir, value);\n    };\n\n    // Returns the value of an end in a given direction\n    vx.getEdge = (dir) => vx.edges.get(dir);\n\n    // Invert the value of an edge between 0 and 1 (also affects its neighbor)\n    // Has no effect on values less than 0\n    vx.invertEdge = (dir) => {\n      if (vx.getEdge(dir) >= 0) {\n        vx.setEdge(dir, vx.getEdge(dir) > 0 ? 0 : 1);\n        vx.getNeighbor(dir).setEdge(game.DIR_OPPOSITES.get(dir), vx.getEdge(dir));\n      }\n    };\n\n    // Delete this edge by setting its value to -1 (also affects its neighbor)\n    vx.deleteEdge = (dir) => {\n      if (vx.getEdge(dir) >= -1) {\n        vx.setEdge(dir, -1);\n        const neighbor = vx.getNeighbor(dir);\n        if (neighbor != null) neighbor.setEdge(game.DIR_OPPOSITES.get(dir), vx.getEdge(dir));\n      }\n    };\n\n    // Returns the neighboring Vertex in a given direction\n    vx.getNeighbor = (dir) => {\n      const node = vx.sum(dir);\n      return node.inBounds(vx.graph.length, vx.graph[0].length) ? vx.graph[node.x][node.y] : null;\n    };\n\n    // Returns the first direction to move in from the vertex\n    vx.getMove = (exDir = null) => {\n      for (let i = 0; i < game.DIRECTIONS.length; i++) {\n        if (vx.getEdge(game.DIRECTIONS[i]) > 0 && (exDir == null ? true : !game.DIRECTIONS[i].eq(exDir))) {\n          return game.DIRECTIONS[i];\n        }\n      }\n      return null;\n    };\n\n    return vx;\n  },\n\n  /**\n   * Returns a graph of width nx and height ny where all vertexes are connected to their\n   * North, South, East and West neighbors (except at the 4 sides of the graph)\n   */\n  mkGraph: (nx, ny) => {\n    const graph = Array.from(Array(nx), (_) => Array.from(Array(ny), (_) => null));\n    // 1 for edge, 0 for deleted edge, -1 for no edge\n    for (let i = 0; i < graph.length; i++) {\n      for (let j = 0; j < graph[i].length; j++) {\n        graph[i][j] = fnHamiltonian.Vertex(i, j, graph);\n        // No edges at the ends of the graph\n        if (i == 0) graph[i][j].deleteEdge(game.WEST);\n        else if (i == graph.length - 1) graph[i][j].deleteEdge(game.EAST);\n        if (j == 0) graph[i][j].deleteEdge(game.NORTH);\n        else if (j == graph[i].length - 1) graph[i][j].deleteEdge(game.SOUTH);\n      }\n    }\n    return graph;\n  },\n\n  /**\n   * Randomly delete surplus edges in place from each vertex until there are none remaining\n   */\n  runDeletion: (graph) => {\n    for (let i = 0; i < graph.length; i++) {\n      for (let j = 0; j < graph[i].length; j++) {\n        // In vertex[i,j],\n        const vx = graph[i][j];\n        const ord = game.DIRECTIONS.concat();\n        utils.shuffle(ord);\n        // Evaluate edges in random order,\n        for (let k = 0; k < ord.length; k++) {\n          // no point looping if their at minimum number\n          if (vx.nEdges <= 2) break;\n          // If there are more than 2 edges and the current edge has not been deleted\n          // and will not cause its neighbor to end up with less than 2 edges as well,\n          else if (vx.getEdge(ord[k]) > 0 && vx.getNeighbor(ord[k]).nEdges > 2) {\n            // Delete the current edge\n            vx.invertEdge(ord[k]);\n          }\n        }\n      }\n    }\n  },\n\n  /**\n   * Returns a NodeSet of all vertices with more than 2 edges remaining\n   */\n  getRemainders: (graph) => {\n    const rems = NodeSet();\n    for (let i = 0; i < graph.length; i++) {\n      for (let j = 0; j < graph[i].length; j++) {\n        if (graph[i][j].nEdges > 2) rems.addNode(graph[i][j]);\n      }\n    }\n    return rems;\n  },\n\n  /**\n   * Object used to track the progress of a path, used in findDestroyer()\n   */\n  PathNode: (vertex, parent) => {\n    const dn = {};\n\n    dn.vertex = vertex;\n    dn.parent = parent;\n    dn.dirToParent = parent == null ? null : parent.vertex.sub(dn.vertex);\n    dn.length = parent == null ? 1 : parent.length + 1;\n    dn.pathVertices = parent == null ? NodeSet() : dn.parent.pathVertices.copy();\n    dn.pathVertices.addNode(dn.vertex);\n    // These only works assuming nodes are added to the path correctly\n    dn.isDestroyer =\n      dn.length >= 4 &&\n      dn.length % 2 == 0 &&\n      dn.vertex.getEdge(dn.dirToParent) == 1 &&\n      dn.parent.vertex.getEdge(dn.parent.dirToParent) == 0;\n    dn.isAltEdge = dn.length < 3 ? false : dn.vertex.getEdge(dn.dirToParent) != dn.parent.vertex.getEdge(dn.parent.dirToParent);\n    dn.isEvenAltEdge = dn.isAltEdge && dn.length % 2 == 1;\n\n    dn.toPath = () => {\n      const path = [];\n      for (c = dn; c != null; c = c.parent) {\n        path.push(c.vertex);\n      }\n      return path;\n    };\n\n    return dn;\n  },\n\n  /**\n   * Breadth first search, can produce cycle unless prohibited in pathCriteria\n   */\n  _find: (graph, start, goals, stepLimit = 0, pathCriteria = () => true, goalCriteria = () => true) => {\n    const continuePath = (current, dir) => {\n      const neighbor = current.vertex.getNeighbor(dir);\n      // If the next vertex is not already part of the path (unless it is the start node), and meets path criteria\n      return neighbor != null && (neighbor == start || !current.pathVertices.hasNode(neighbor)) && pathCriteria(current, dir);\n    };\n    // Start BFS\n    const open = [fnHamiltonian.PathNode(start, null)];\n    let steps = 0;\n    let current = null;\n    while ((stepLimit <= 0 || steps < stepLimit) && open.length > 0 && goals.size() > 0) {\n      current = open.shift();\n      if (goals.hasNode(current.vertex) && goalCriteria(current)) {\n        goals.deleteNode(current.vertex);\n        return current.toPath();\n      }\n      // For each direction from this vertex,\n      game.DIRECTIONS.forEach((dir) => {\n        // Excluding the direction to the parent, add to open if meets criteria.\n        if (current.parent == null || !dir.eq(current.dirToParent)) {\n          if (continuePath(current, dir)) {\n            const node = current.vertex.sum(dir);\n            open.push(fnHamiltonian.PathNode(graph[node.x][node.y], current));\n          }\n        }\n      });\n      steps++;\n    }\n\n    return [start];\n  },\n\n  /**\n   * Returns the shortest Connector cycle for a given starting node.\n   * This mutates the goals object by deleting the vertices that are part of the path.\n   */\n  findConnector: (graph, start, goals, stepLimit = 100) => {\n    //\n    const pathCriteria = (current, dir) => {\n      return current.length < 3 || (current.isAltEdge && current.vertex.getEdge(current.dirToParent) != current.vertex.getEdge(dir));\n    };\n    const goalCriteria = (current) => current.isEvenAltEdge;\n    return fnHamiltonian._find(graph, start, goals, stepLimit, pathCriteria, goalCriteria);\n  },\n\n  /**\n   * Randomly selects a vertex to search for a connector cycle, if one is found, it will invert it.\n   * This is done until the iteration limit is hit or a hamiltonian cycle is found.\n   */\n  invertConnectorPaths: (graph, stepLimit = 0, iterationLimit = 100) => {\n    for (let i = 0; i < iterationLimit; i++) {\n      const start = graph[utils.randInt(0, graph.length - 1)][utils.randInt(0, graph[0].length - 1)];\n      const goals = NodeSet();\n      goals.addNode(start);\n      fnHamiltonian.invertPath(fnHamiltonian.findConnector(graph, start, goals, stepLimit));\n      if (fnHamiltonian.isHamiltonianCycle(graph)) break;\n    }\n  },\n\n  /**\n   * Returns the shortest Destroyer path found between start and any one of the goals.\n   * This mutates the goals object by deleting the vertices that are part of the path.\n   */\n  findDestroyer: (graph, start, goals, stepLimit = 0) => {\n    const pathCriteria = (current, dir) => {\n      // If below minimum length, check if it is alternating in the right way\n      return (\n        (current.length == 1 && current.vertex.getEdge(dir) == 1) ||\n        (current.length == 2 && current.vertex.getEdge(current.dirToParent) == 1 && current.vertex.getEdge(dir) == 0) ||\n        (current.length == 3 && current.vertex.getEdge(current.dirToParent) == 0 && current.vertex.getEdge(dir) == 1) ||\n        // If isDestroyer and the next edge has been deleted\n        (current.length >= 4 && current.isDestroyer && current.vertex.getEdge(dir) == 0) ||\n        // If not destroyer, parent isDestroyer and the next edge exists\n        (current.length >= 4 && !current.isDestroyer && current.parent.isDestroyer && current.vertex.getEdge(dir) == 1)\n      );\n    };\n    goals.deleteNode(start);\n    return fnHamiltonian._find(graph, start, goals, stepLimit, pathCriteria);\n  },\n\n  /**\n   * Returns an array of destroyer paths in a given graph.\n   * These paths start and end at remainder nodes (more than 2 edges).\n   */\n  getDestroyerPaths: (graph, stepLimit = 0) => {\n    const remainders = fnHamiltonian.getRemainders(graph);\n    const remCopy = remainders.copy();\n    const paths = [];\n    remainders.lookup.forEach((vx) => {\n      if (remCopy.hasNode(vx)) paths.push(fnHamiltonian.findDestroyer(graph, vx, remCopy, stepLimit));\n    });\n    return paths;\n  },\n\n  /**\n   * Inverts all edges in the path, 10101 becomes 01010\n   * When used on a destroyer path where the start and end vertices have 3 edges each,\n   * It will reduce them both down to 2 edges while maintaining the same number of edges for\n   * all other vertices in the path.\n   */\n  invertPath: (path) => {\n    path.forEach((vx, i) => {\n      if (i < path.length - 1) {\n        const dir = path[i + 1].sub(vx);\n        vx.invertEdge(dir);\n      }\n    });\n  },\n\n  /**\n   * Returns true if the graph contains a Hamiltonian cycle\n   */\n  isHamiltonianCycle: (graph) => {\n    const exclusions = NodeSet();\n    const pathVertices = NodeSet();\n    let start = null;\n    // Check that all vertices are valid\n    for (let i = 0; i < graph.length; i++) {\n      for (let j = 0; j < graph[i].length; j++) {\n        // No edges means it is deliberately excluded from the path\n        if (graph[i][j].nEdges == 0) exclusions.addNode(graph[i][j]);\n        // Must only have 2 edges\n        else if (graph[i][j].nEdges != 2) return false;\n        else if (start == null) start = graph[i][j];\n      }\n    }\n\n    // Go through the path and check if it is a Hamiltonian Cycle\n    pathVertices.addNode(start);\n    let prevDir = start.getMove();\n    let current = start.getNeighbor(prevDir);\n    while (!pathVertices.hasNode(current) && !exclusions.hasNode(current)) {\n      pathVertices.addNode(current);\n      prevDir = current.getMove(game.DIR_OPPOSITES.get(prevDir));\n      current = current.getNeighbor(prevDir);\n      if (current == null) break;\n    }\n\n    const nVx = pathVertices.size() + exclusions.size();\n    const nGraphVx = graph.length * graph[0].length;\n    return current != null && current == start && nVx == nGraphVx;\n  },\n\n  /**\n   * Returns a string representation of the given graph\n   */\n  toString: (graph) => {\n    let string = '';\n    // Rows first and then Columns\n    for (let j = 0; j < graph[0].length; j++) {\n      for (let i = 0; i < graph.length; i++) {\n        for (let k = 0; k < game.DIRECTIONS.length; k++) {\n          const v = graph[i][j].getEdge(game.DIRECTIONS[k]);\n          if (v == 1) string += game.DIR_SYMBOLS.get(game.DIRECTIONS[k]);\n          else string += ' ';\n        }\n        string += ', ';\n      }\n      string += '\\n';\n    }\n    return string;\n  },\n};\n"],"names":["fnHamiltonian","buildCycle","nx","ny","exclusions","NodeSet","findDestroyerStepLimit","findConnectorStepLimit","findConnectorIterLimit","graph","mkGraph","processExclusions","runDeletion","getDestroyerPaths","forEach","p","invertPath","invertConnectorPaths","lookup","node","game","DIRECTIONS","d","x","y","deleteEdge","buildPath","start","i","length","j","nEdges","path","prevDir","getMove","current","getNeighbor","push","DIR_OPPOSITES","get","buildPolicy","policy","Array","from","_","srcVx","nextVx","sub","Vertex","vx","Node","edges","NodeMap","dir","set","setEdge","value","getEdge","invertEdge","neighbor","sum","inBounds","exDir","eq","WEST","EAST","NORTH","SOUTH","ord","concat","utils","shuffle","k","getRemainders","rems","addNode","PathNode","vertex","parent","dn","dirToParent","pathVertices","copy","isDestroyer","isAltEdge","isEvenAltEdge","toPath","c","_find","goals","stepLimit","pathCriteria","goalCriteria","continuePath","hasNode","open","steps","size","shift","deleteNode","findConnector","iterationLimit","randInt","isHamiltonianCycle","findDestroyer","remainders","remCopy","paths","nVx","nGraphVx","toString","string","v","DIR_SYMBOLS"],"version":3,"file":"index.3e3f4365.js.map"}