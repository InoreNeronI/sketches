{"mappings":"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","sources":["<anon>","node_modules/processing-js/processing.js"],"sourcesContent":["(function() {\n    function r(e, n, t1) {\n        function o(i, f) {\n            if (!n[i]) {\n                if (!e[i]) {\n                    var c = \"function\" == typeof require && undefined;\n                    if (!f && c) return c(i, !0);\n                    if (u) return u(i, !0);\n                    var a = new Error(\"Cannot find module '\" + i + \"'\");\n                    throw a.code = \"MODULE_NOT_FOUND\", a;\n                }\n                var p = n[i] = {\n                    exports: {}\n                };\n                e[i][0].call(p.exports, function(r) {\n                    var n = e[i][1][r];\n                    return o(n || r);\n                }, p, p.exports, r, e, n, t1);\n            }\n            return n[i].exports;\n        }\n        for(var u = \"function\" == typeof require && undefined, i = 0; i < t1.length; i++)o(t1[i]);\n        return o;\n    }\n    return r;\n})()({\n    1: [\n        function(require1, module, exports) {\n            // build script for generating processing.js\n            var Browser = {\n                isDomPresent: true,\n                navigator: navigator,\n                window: window,\n                document: document,\n                ajax: function(url) {\n                    var xhr = new XMLHttpRequest();\n                    xhr.open(\"GET\", url, false);\n                    if (xhr.overrideMimeType) xhr.overrideMimeType(\"text/plain\");\n                    xhr.setRequestHeader(\"If-Modified-Since\", \"Fri, 01 Jan 1960 00:00:00 GMT\");\n                    xhr.send(null);\n                    // failed request?\n                    if (xhr.status !== 200 && xhr.status !== 0) throw \"XMLHttpRequest failed, status code \" + xhr.status;\n                    return xhr.responseText;\n                }\n            };\n            window.Processing = require1(\"./src/\")(Browser);\n        },\n        {\n            \"./src/\": 28\n        }\n    ],\n    2: [\n        function(require1, module, exports) {\n            module.exports = {\n                \"name\": \"processing-js\",\n                \"version\": \"1.6.6\",\n                \"author\": \"Processing.js\",\n                \"repository\": {\n                    \"type\": \"git\",\n                    \"url\": \"git@github.com/processing-js/processing-js.git\"\n                },\n                \"main\": \"processing.min.js\",\n                \"bugs\": \"https://github.com/processing-js/processing-js/issues\",\n                \"devDependencies\": {\n                    \"argv\": \"^0.0.2\",\n                    \"browserify\": \"^17.0.0\",\n                    \"express\": \"^4.18.2\",\n                    \"grunt\": \"^1.6.1\",\n                    \"grunt-cli\": \"^1.4.3\",\n                    \"grunt-contrib-jshint\": \"^3.2.0\",\n                    \"http-server\": \"^14.1.1\",\n                    \"nunjucks\": \"^3.2.4\",\n                    \"terser\": \"^5.26.0\"\n                },\n                \"scripts\": {\n                    \"test\": \"node test\",\n                    \"test:manual\": \"http-server -o test/manual\",\n                    \"start\": \"browserify build.js -o processing.js && terser processing.js --compress ecma=2020,computed_props=false > processing.min.js\"\n                },\n                \"license\": \"MIT\"\n            };\n        },\n        {}\n    ],\n    3: [\n        function(require1, module, exports) {\n            /**\n* A ObjectIterator is an iterator wrapper for objects. If passed object contains\n* the iterator method, the object instance will be replaced by the result returned by\n* this method call. If passed object is an array, the ObjectIterator instance iterates\n* through its items.\n*\n* @param {Object} obj The object to be iterated.\n*/ module.exports = function ObjectIterator1(obj) {\n                if (obj instanceof Array) {\n                    // iterate through array items\n                    var index = -1;\n                    this.hasNext = function() {\n                        return ++index < obj.length;\n                    };\n                    this.next = function() {\n                        return obj[index];\n                    };\n                } else if (obj.iterator instanceof Function) return obj.iterator();\n                else throw \"Unable to iterate: \" + obj;\n            };\n        },\n        {}\n    ],\n    4: [\n        function(require1, module, exports) {\n            /**\n * Processing.js environment constants\n */ module.exports = {\n                X: 0,\n                Y: 1,\n                Z: 2,\n                R: 3,\n                G: 4,\n                B: 5,\n                A: 6,\n                U: 7,\n                V: 8,\n                NX: 9,\n                NY: 10,\n                NZ: 11,\n                EDGE: 12,\n                // Stroke\n                SR: 13,\n                SG: 14,\n                SB: 15,\n                SA: 16,\n                SW: 17,\n                // Transformations (2D and 3D)\n                TX: 18,\n                TY: 19,\n                TZ: 20,\n                VX: 21,\n                VY: 22,\n                VZ: 23,\n                VW: 24,\n                // Material properties\n                AR: 25,\n                AG: 26,\n                AB: 27,\n                DR: 3,\n                DG: 4,\n                DB: 5,\n                DA: 6,\n                SPR: 28,\n                SPG: 29,\n                SPB: 30,\n                SHINE: 31,\n                ER: 32,\n                EG: 33,\n                EB: 34,\n                BEEN_LIT: 35,\n                VERTEX_FIELD_COUNT: 36,\n                // Renderers\n                P2D: 1,\n                JAVA2D: 1,\n                WEBGL: 2,\n                P3D: 2,\n                OPENGL: 2,\n                PDF: 0,\n                DXF: 0,\n                // Platform IDs\n                OTHER: 0,\n                WINDOWS: 1,\n                MACOSX: 2,\n                LINUX: 3,\n                EPSILON: 0.0001,\n                MAX_FLOAT: 3.4028235e+38,\n                MIN_FLOAT: -340282350000000000000000000000000000000,\n                MAX_INT: 2147483647,\n                MIN_INT: -2147483648,\n                PI: Math.PI,\n                TWO_PI: 2 * Math.PI,\n                TAU: 2 * Math.PI,\n                HALF_PI: Math.PI / 2,\n                THIRD_PI: Math.PI / 3,\n                QUARTER_PI: Math.PI / 4,\n                DEG_TO_RAD: Math.PI / 180,\n                RAD_TO_DEG: 180 / Math.PI,\n                WHITESPACE: \" \t\\n\\r\\f\\xa0\",\n                // Color modes\n                RGB: 1,\n                ARGB: 2,\n                HSB: 3,\n                ALPHA: 4,\n                CMYK: 5,\n                // Image file types\n                TIFF: 0,\n                TARGA: 1,\n                JPEG: 2,\n                GIF: 3,\n                // Filter/convert types\n                BLUR: 11,\n                GRAY: 12,\n                INVERT: 13,\n                OPAQUE: 14,\n                POSTERIZE: 15,\n                THRESHOLD: 16,\n                ERODE: 17,\n                DILATE: 18,\n                // Blend modes\n                REPLACE: 0,\n                BLEND: 1,\n                ADD: 2,\n                SUBTRACT: 4,\n                LIGHTEST: 8,\n                DARKEST: 16,\n                DIFFERENCE: 32,\n                EXCLUSION: 64,\n                MULTIPLY: 128,\n                SCREEN: 256,\n                OVERLAY: 512,\n                HARD_LIGHT: 1024,\n                SOFT_LIGHT: 2048,\n                DODGE: 4096,\n                BURN: 8192,\n                // Color component bit masks\n                ALPHA_MASK: 0xff000000,\n                RED_MASK: 0x00ff0000,\n                GREEN_MASK: 0x0000ff00,\n                BLUE_MASK: 0x000000ff,\n                // Projection matrices\n                CUSTOM: 0,\n                ORTHOGRAPHIC: 2,\n                PERSPECTIVE: 3,\n                // Shapes\n                POINT: 2,\n                POINTS: 2,\n                LINE: 4,\n                LINES: 4,\n                TRIANGLE: 8,\n                TRIANGLES: 9,\n                TRIANGLE_STRIP: 10,\n                TRIANGLE_FAN: 11,\n                QUAD: 16,\n                QUADS: 16,\n                QUAD_STRIP: 17,\n                POLYGON: 20,\n                PATH: 21,\n                RECT: 30,\n                ELLIPSE: 31,\n                ARC: 32,\n                SPHERE: 40,\n                BOX: 41,\n                // Arc drawing modes\n                //OPEN:          1, // shared with Shape closing modes   \n                CHORD: 2,\n                PIE: 3,\n                GROUP: 0,\n                PRIMITIVE: 1,\n                //PATH:         21, // shared with Shape PATH\n                GEOMETRY: 3,\n                // Shape Vertex\n                VERTEX: 0,\n                BEZIER_VERTEX: 1,\n                CURVE_VERTEX: 2,\n                BREAK: 3,\n                CLOSESHAPE: 4,\n                // Shape closing modes\n                OPEN: 1,\n                CLOSE: 2,\n                // Shape drawing modes\n                CORNER: 0,\n                CORNERS: 1,\n                RADIUS: 2,\n                CENTER_RADIUS: 2,\n                CENTER: 3,\n                DIAMETER: 3,\n                CENTER_DIAMETER: 3,\n                // Text vertical alignment modes\n                BASELINE: 0,\n                TOP: 101,\n                BOTTOM: 102,\n                // UV Texture coordinate modes\n                NORMAL: 1,\n                NORMALIZED: 1,\n                IMAGE: 2,\n                // Text placement modes\n                MODEL: 4,\n                SHAPE: 5,\n                // Stroke modes\n                SQUARE: \"butt\",\n                ROUND: \"round\",\n                PROJECT: \"square\",\n                MITER: \"miter\",\n                BEVEL: \"bevel\",\n                // Lighting modes\n                AMBIENT: 0,\n                DIRECTIONAL: 1,\n                //POINT:     2, Shared with Shape constant\n                SPOT: 3,\n                // Key constants\n                // Both key and keyCode will be equal to these values\n                BACKSPACE: 8,\n                TAB: 9,\n                ENTER: 10,\n                RETURN: 13,\n                ESC: 27,\n                DELETE: 127,\n                CODED: 0xffff,\n                // p.key will be CODED and p.keyCode will be this value\n                SHIFT: 16,\n                CONTROL: 17,\n                ALT: 18,\n                CAPSLK: 20,\n                PGUP: 33,\n                PGDN: 34,\n                END: 35,\n                HOME: 36,\n                LEFT: 37,\n                UP: 38,\n                RIGHT: 39,\n                DOWN: 40,\n                F1: 112,\n                F2: 113,\n                F3: 114,\n                F4: 115,\n                F5: 116,\n                F6: 117,\n                F7: 118,\n                F8: 119,\n                F9: 120,\n                F10: 121,\n                F11: 122,\n                F12: 123,\n                NUMLK: 144,\n                META: 157,\n                INSERT: 155,\n                // Cursor types\n                ARROW: \"default\",\n                CROSS: \"crosshair\",\n                HAND: \"pointer\",\n                MOVE: \"move\",\n                TEXT: \"text\",\n                WAIT: \"wait\",\n                NOCURSOR: \"url('data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='), auto\",\n                // Hints\n                DISABLE_OPENGL_2X_SMOOTH: 1,\n                ENABLE_OPENGL_2X_SMOOTH: -1,\n                ENABLE_OPENGL_4X_SMOOTH: 2,\n                ENABLE_NATIVE_FONTS: 3,\n                DISABLE_DEPTH_TEST: 4,\n                ENABLE_DEPTH_TEST: -4,\n                ENABLE_DEPTH_SORT: 5,\n                DISABLE_DEPTH_SORT: -5,\n                DISABLE_OPENGL_ERROR_REPORT: 6,\n                ENABLE_OPENGL_ERROR_REPORT: -6,\n                ENABLE_ACCURATE_TEXTURES: 7,\n                DISABLE_ACCURATE_TEXTURES: -7,\n                HINT_COUNT: 10,\n                // PJS defined constants\n                SINCOS_LENGTH: 720,\n                PRECISIONB: 15,\n                PRECISIONF: 32768,\n                PREC_MAXVAL: 32767,\n                PREC_ALPHA_SHIFT: 9,\n                PREC_RED_SHIFT: 1,\n                NORMAL_MODE_AUTO: 0,\n                NORMAL_MODE_SHAPE: 1,\n                NORMAL_MODE_VERTEX: 2,\n                MAX_LIGHTS: 8\n            };\n        },\n        {}\n    ],\n    5: [\n        function(require1, module, exports) {\n            // the logger for print() and println()\n            module.exports = function PjsConsole(document1) {\n                var e = {\n                    BufferMax: 200\n                }, style = document1.createElement(\"style\"), added = false;\n                style.textContent = [\n                    \".pjsconsole.hidden {\",\n                    \"  display: none!important;\",\n                    \"}\"\n                ].join(\"\\n\");\n                e.wrapper = document1.createElement(\"div\");\n                style.textContent += [\n                    \"\",\n                    \".pjsconsole {\",\n                    \"  opacity: .75;\",\n                    \"  display: block;\",\n                    \"  position: fixed;\",\n                    \"  bottom: 0px;\",\n                    \"  left: 0px;\",\n                    \"  right: 0px;\",\n                    \"  height: 50px;\",\n                    \"  background-color: #aaa;\",\n                    \"}\"\n                ].join(\"\\n\");\n                e.wrapper.classList.add(\"pjsconsole\");\n                e.dragger = document1.createElement(\"div\");\n                style.textContent += [\n                    \"\",\n                    \".pjsconsole .dragger {\",\n                    \"  display: block;\",\n                    \"  border: 3px black raised;\",\n                    \"  cursor: n-resize;\",\n                    \"  position: absolute;\",\n                    \"  top: 0px;\",\n                    \"  left: 0px;\",\n                    \"  right: 0px;\",\n                    \"  height: 5px;\",\n                    \"  background-color: #333;\",\n                    \"}\"\n                ].join(\"\\n\");\n                e.dragger.classList.add(\"dragger\");\n                e.closer = document1.createElement(\"div\");\n                style.textContent += [\n                    \"\",\n                    \".pjsconsole .closer {\",\n                    \"  opacity: .5;\",\n                    \"  display: block;\",\n                    \"  border: 3px black raised;\",\n                    \"  position: absolute;\",\n                    \"  top: 10px;\",\n                    \"  right: 30px;\",\n                    \"  height: 20px;\",\n                    \"  width: 20px;\",\n                    \"  background-color: #ddd;\",\n                    \"  color: #000;\",\n                    \"  line-height: 20px;\",\n                    \"  text-align: center;\",\n                    \"  cursor: pointer\",\n                    \"}\"\n                ].join(\"\\n\");\n                e.closer.classList.add(\"closer\");\n                e.closer.innerHTML = \"&#10006;\";\n                e.javaconsole = document1.createElement(\"div\");\n                style.textContent += [\n                    \"\",\n                    \".pjsconsole .console {\",\n                    \"  overflow-x: auto;\",\n                    \"  display: block;\",\n                    \"  position: absolute;\",\n                    \"  left: 10px;\",\n                    \"  right: 0px;\",\n                    \"  bottom: 5px;\",\n                    \"  top: 10px;\",\n                    \"  overflow-y: scroll;\",\n                    \"  height: 40px;\",\n                    \"}\"\n                ].join(\"\\n\");\n                e.javaconsole.setAttribute(\"class\", \"console\");\n                e.wrapper.appendChild(e.dragger);\n                e.wrapper.appendChild(e.javaconsole);\n                e.wrapper.appendChild(e.closer);\n                e.dragger.onmousedown = function(t1) {\n                    e.divheight = e.wrapper.style.height;\n                    if (document1.selection) document1.selection.empty();\n                    else window.getSelection().removeAllRanges();\n                    var n = t1.screenY;\n                    window.onmousemove = function(t1) {\n                        e.wrapper.style.height = parseFloat(e.divheight) + (n - t1.screenY) + \"px\";\n                        e.javaconsole.style.height = parseFloat(e.divheight) + (n - t1.screenY) - 10 + \"px\";\n                    };\n                    window.onmouseup = function(t1) {\n                        if (document1.selection) document1.selection.empty();\n                        else window.getSelection().removeAllRanges();\n                        e.wrapper.style.height = parseFloat(e.divheight) + (n - t1.screenY) + \"px\";\n                        e.javaconsole.style.height = parseFloat(e.divheight) + (n - t1.screenY) - 10 + \"px\";\n                        window.onmousemove = null;\n                        window.onmouseup = null;\n                    };\n                };\n                e.BufferArray = [];\n                e.print = e.log = function() {\n                    if (!added) {\n                        document1.body.appendChild(style);\n                        document1.body.appendChild(e.wrapper);\n                        added = true;\n                    }\n                    var args = Array.prototype.slice.call(arguments);\n                    t = args.map(function(t1, idx) {\n                        return t1 + (idx + 1 === args.length ? \"\" : \" \");\n                    }).join(\"\");\n                    if (e.BufferArray[e.BufferArray.length - 1]) e.BufferArray[e.BufferArray.length - 1] += t + \"\";\n                    else e.BufferArray.push(t);\n                    e.javaconsole.innerHTML = e.BufferArray.join(\"\");\n                    e.showconsole();\n                };\n                e.println = function() {\n                    var args = Array.prototype.slice.call(arguments);\n                    args.push(\"<br>\");\n                    e.print.apply(e, args);\n                    if (e.BufferArray.length > e.BufferMax) e.BufferArray.splice(0, 1);\n                    else e.javaconsole.scrollTop = e.javaconsole.scrollHeight;\n                };\n                e.showconsole = function() {\n                    e.wrapper.classList.remove(\"hidden\");\n                };\n                e.hideconsole = function() {\n                    e.wrapper.classList.add(\"hidden\");\n                };\n                e.closer.onclick = function() {\n                    e.hideconsole();\n                };\n                e.hideconsole();\n                return e;\n            };\n        },\n        {}\n    ],\n    6: [\n        function(require1, module, exports) {\n            /**\n * Processing.js default scope\n */ module.exports = function(options) {\n                // Building defaultScope. Changing of the prototype protects\n                // internal Processing code from the changes in defaultScope\n                function DefaultScope() {}\n                DefaultScope.prototype = options.PConstants;\n                var defaultScope1 = new DefaultScope();\n                // copy over all known Object types and helper objects\n                Object.keys(options).forEach(function(prop) {\n                    defaultScope1[prop] = options[prop];\n                });\n                ////////////////////////////////////////////////////////////////////////////\n                // Class inheritance helper methods\n                ////////////////////////////////////////////////////////////////////////////\n                defaultScope1.defineProperty = function(obj, name, desc) {\n                    if (\"defineProperty\" in Object) Object.defineProperty(obj, name, desc);\n                    else {\n                        if (desc.hasOwnProperty(\"get\")) obj.__defineGetter__(name, desc.get);\n                        if (desc.hasOwnProperty(\"set\")) obj.__defineSetter__(name, desc.set);\n                    }\n                };\n                /**\n   * class overloading, part 1\n   */ function overloadBaseClassFunction(object, name, basefn) {\n                    if (!object.hasOwnProperty(name) || typeof object[name] !== \"function\") {\n                        // object method is not a function or just inherited from Object.prototype\n                        object[name] = basefn;\n                        return;\n                    }\n                    var fn = object[name];\n                    if (\"$overloads\" in fn) {\n                        // the object method already overloaded (see defaultScope.addMethod)\n                        // let's just change a fallback method\n                        fn.$defaultOverload = basefn;\n                        return;\n                    }\n                    if (!(\"$overloads\" in basefn) && fn.length === basefn.length) // special case when we just overriding the method\n                    return;\n                    var overloads, defaultOverload;\n                    if (\"$overloads\" in basefn) {\n                        // let's inherit base class overloads to speed up things\n                        overloads = basefn.$overloads.slice(0);\n                        overloads[fn.length] = fn;\n                        defaultOverload = basefn.$defaultOverload;\n                    } else {\n                        overloads = [];\n                        overloads[basefn.length] = basefn;\n                        overloads[fn.length] = fn;\n                        defaultOverload = fn;\n                    }\n                    var hubfn = function() {\n                        var fn = hubfn.$overloads[arguments.length] || (\"$methodArgsIndex\" in hubfn && arguments.length > hubfn.$methodArgsIndex ? hubfn.$overloads[hubfn.$methodArgsIndex] : null) || hubfn.$defaultOverload;\n                        return fn.apply(this, arguments);\n                    };\n                    hubfn.$overloads = overloads;\n                    if (\"$methodArgsIndex\" in basefn) hubfn.$methodArgsIndex = basefn.$methodArgsIndex;\n                    hubfn.$defaultOverload = defaultOverload;\n                    hubfn.name = name;\n                    object[name] = hubfn;\n                }\n                /**\n   * class overloading, part 2\n   */ function extendClass(subClass, baseClass) {\n                    function extendGetterSetter(propertyName) {\n                        defaultScope1.defineProperty(subClass, propertyName, {\n                            get: function() {\n                                return baseClass[propertyName];\n                            },\n                            set: function(v) {\n                                baseClass[propertyName] = v;\n                            },\n                            enumerable: true\n                        });\n                    }\n                    var properties = [];\n                    for(var propertyName in baseClass){\n                        if (typeof baseClass[propertyName] === \"function\") overloadBaseClassFunction(subClass, propertyName, baseClass[propertyName]);\n                        else if (propertyName.charAt(0) !== \"$\" && !(propertyName in subClass)) // Delaying the properties extension due to the IE9 bug (see #918).\n                        properties.push(propertyName);\n                    }\n                    while(properties.length > 0)extendGetterSetter(properties.shift());\n                    subClass.$super = baseClass;\n                }\n                /**\n   * class overloading, part 3\n   */ defaultScope1.extendClassChain = function(base) {\n                    var path = [\n                        base\n                    ];\n                    for(var self = base.$upcast; self; self = self.$upcast){\n                        extendClass(self, base);\n                        path.push(self);\n                        base = self;\n                    }\n                    while(path.length > 0)path.pop().$self = base;\n                };\n                // static\n                defaultScope1.extendStaticMembers = function(derived, base) {\n                    extendClass(derived, base);\n                };\n                // interface\n                defaultScope1.extendInterfaceMembers = function(derived, base) {\n                    extendClass(derived, base);\n                };\n                /**\n   * Java methods and JavaScript functions differ enough that\n   * we need a special function to make sure it all links up\n   * as classical hierarchical class chains.\n   */ defaultScope1.addMethod = function(object, name, fn, hasMethodArgs) {\n                    var existingfn = object[name];\n                    if (existingfn || hasMethodArgs) {\n                        var args = fn.length;\n                        // builds the overload methods table\n                        if (\"$overloads\" in existingfn) existingfn.$overloads[args] = fn;\n                        else {\n                            var hubfn = function() {\n                                var fn = hubfn.$overloads[arguments.length] || (\"$methodArgsIndex\" in hubfn && arguments.length > hubfn.$methodArgsIndex ? hubfn.$overloads[hubfn.$methodArgsIndex] : null) || hubfn.$defaultOverload;\n                                return fn.apply(this, arguments);\n                            };\n                            var overloads = [];\n                            if (existingfn) overloads[existingfn.length] = existingfn;\n                            overloads[args] = fn;\n                            hubfn.$overloads = overloads;\n                            hubfn.$defaultOverload = existingfn || fn;\n                            if (hasMethodArgs) hubfn.$methodArgsIndex = args;\n                            hubfn.name = name;\n                            object[name] = hubfn;\n                        }\n                    } else object[name] = fn;\n                };\n                // internal helper function\n                function isNumericalJavaType(type) {\n                    if (typeof type !== \"string\") return false;\n                    return [\n                        \"byte\",\n                        \"int\",\n                        \"char\",\n                        \"color\",\n                        \"float\",\n                        \"long\",\n                        \"double\"\n                    ].indexOf(type) !== -1;\n                }\n                /**\n   * Java's arrays are pre-filled when declared with\n   * an initial size, but no content. JS arrays are not.\n   */ defaultScope1.createJavaArray = function(type, bounds) {\n                    var result = null, defaultValue = null;\n                    if (typeof type === \"string\") {\n                        if (type === \"boolean\") defaultValue = false;\n                        else if (isNumericalJavaType(type)) defaultValue = 0;\n                    }\n                    if (typeof bounds[0] === \"number\") {\n                        var itemsCount = 0 | bounds[0];\n                        if (bounds.length <= 1) {\n                            result = [];\n                            result.length = itemsCount;\n                            for(var i = 0; i < itemsCount; ++i)result[i] = defaultValue;\n                        } else {\n                            result = [];\n                            var newBounds = bounds.slice(1);\n                            for(var j = 0; j < itemsCount; ++j)result.push(defaultScope1.createJavaArray(type, newBounds));\n                        }\n                    }\n                    return result;\n                };\n                // screenWidth and screenHeight are shared by all instances.\n                // and return the width/height of the browser's viewport.\n                defaultScope1.defineProperty(defaultScope1, \"screenWidth\", {\n                    get: function() {\n                        return window.innerWidth;\n                    }\n                });\n                defaultScope1.defineProperty(defaultScope1, \"screenHeight\", {\n                    get: function() {\n                        return window.innerHeight;\n                    }\n                });\n                return defaultScope1;\n            };\n        },\n        {}\n    ],\n    7: [\n        function(require1, module, exports) {\n            /**\n * Finalise the Processing.js object.\n */ module.exports = function finalizeProcessing(Processing1, options) {\n                // unpack options\n                var window1 = options.window, document1 = options.document, XMLHttpRequest1 = window1.XMLHttpRequest, noop = options.noop, isDOMPresent = options.isDOMPresent, version = options.version, undef;\n                // versioning\n                Processing1.version = version ? version : \"@DEV-VERSION@\";\n                // Share lib space\n                Processing1.lib = {};\n                /**\n   * External libraries can be added to the global Processing\n   * objects with the `registerLibrary` function.\n   */ Processing1.registerLibrary = function(name, library) {\n                    Processing1.lib[name] = library;\n                    if (library.hasOwnProperty(\"init\")) library.init(defaultScope);\n                };\n                /**\n   * This is the object that acts as our version of PApplet.\n   * This can be called as Processing.Sketch() or as\n   * Processing.Sketch(function) in which case the function\n   * must be an already-compiled-to-JS sketch function.\n   */ Processing1.Sketch = function(attachFunction) {\n                    this.attachFunction = attachFunction;\n                    this.options = {\n                        pauseOnBlur: false,\n                        globalKeyEvents: false\n                    };\n                    /* Optional Sketch event hooks:\n     *   onLoad       - parsing/preloading is done, before sketch starts\n     *   onSetup      - setup() has been called, before first draw()\n     *   onPause      - noLoop() has been called, pausing draw loop\n     *   onLoop       - loop() has been called, resuming draw loop\n     *   onFrameStart - draw() loop about to begin\n     *   onFrameEnd   - draw() loop finished\n     *   onExit       - exit() done being called\n     */ this.onLoad = noop;\n                    this.onSetup = noop;\n                    this.onPause = noop;\n                    this.onLoop = noop;\n                    this.onFrameStart = noop;\n                    this.onFrameEnd = noop;\n                    this.onExit = noop;\n                    this.params = {};\n                    this.imageCache = {\n                        pending: 0,\n                        images: {},\n                        // Opera requires special administration for preloading\n                        operaCache: {},\n                        // Specify an optional img arg if the image is already loaded in the DOM,\n                        // otherwise href will get loaded.\n                        add: function(href, img) {\n                            // Prevent muliple loads for an image, in case it gets\n                            // preloaded more than once, or is added via JS and then preloaded.\n                            if (this.images[href]) return;\n                            if (!isDOMPresent) this.images[href] = null;\n                            // No image in the DOM, kick-off a background load\n                            if (!img) {\n                                img = new Image();\n                                img.onload = function(owner) {\n                                    return function() {\n                                        owner.pending--;\n                                    };\n                                }(this);\n                                this.pending++;\n                                img.src = href;\n                            }\n                            this.images[href] = img;\n                            // Opera will not load images until they are inserted into the DOM.\n                            if (window1.opera) {\n                                var div = document1.createElement(\"div\");\n                                div.appendChild(img);\n                                // we can't use \"display: none\", since that makes it invisible, and thus not load\n                                div.style.position = \"absolute\";\n                                div.style.opacity = 0;\n                                div.style.width = \"1px\";\n                                div.style.height = \"1px\";\n                                if (!this.operaCache[href]) {\n                                    document1.body.appendChild(div);\n                                    this.operaCache[href] = div;\n                                }\n                            }\n                        }\n                    };\n                    this.sourceCode = undefined;\n                    this.attach = function(processing) {\n                        // either attachFunction or sourceCode must be present on attach\n                        if (typeof this.attachFunction === \"function\") this.attachFunction(processing);\n                        else if (this.sourceCode) {\n                            var func = new Function(\"return (\" + this.sourceCode + \");\")();\n                            func(processing);\n                            this.attachFunction = func;\n                        } else throw \"Unable to attach sketch to the processing instance\";\n                    };\n                    this.toString = function() {\n                        var i;\n                        var code = \"((function(Sketch) {\\n\";\n                        code += \"var sketch = new Sketch(\\n\" + this.sourceCode + \");\\n\";\n                        for(i in this.options)if (this.options.hasOwnProperty(i)) {\n                            var value = this.options[i];\n                            code += \"sketch.options.\" + i + \" = \" + (typeof value === \"string\" ? '\"' + value + '\"' : \"\" + value) + \";\\n\";\n                        }\n                        for(i in this.imageCache)if (this.options.hasOwnProperty(i)) code += 'sketch.imageCache.add(\"' + i + '\");\\n';\n                        // TODO serialize fonts\n                        code += \"return sketch;\\n})(Processing.Sketch))\";\n                        return code;\n                    };\n                };\n                /**\n   * aggregate all source code into a single file, then rewrite that\n   * source and bind to canvas via new Processing(canvas, sourcestring).\n   * @param {CANVAS} canvas The html canvas element to bind to\n   * @param {String[]} sources The array of files that must be loaded\n   * @param {Function} onComplete A callback, called with the sketch as the argument.\n   */ var loadSketchFromSources = Processing1.loadSketchFromSources = function(canvas, sources, onComplete) {\n                    var code = [], errors = [], sourcesCount = sources.length, loaded = 0;\n                    function ajaxAsync(url, callback) {\n                        var xhr = new XMLHttpRequest1();\n                        xhr.onreadystatechange = function() {\n                            if (xhr.readyState === 4) {\n                                var error;\n                                if (xhr.status !== 200 && xhr.status !== 0) error = \"Invalid XHR status \" + xhr.status;\n                                else if (xhr.responseText === \"\") {\n                                    // Give a hint when loading fails due to same-origin issues on file:/// urls\n                                    if (\"withCredentials\" in new XMLHttpRequest1() && new XMLHttpRequest1().withCredentials === false && window1.location.protocol === \"file:\") error = \"XMLHttpRequest failure, possibly due to a same-origin policy violation. You can try loading this page in another browser, or load it from http://localhost using a local webserver. See the Processing.js README for a more detailed explanation of this problem and solutions.\";\n                                    else error = \"File is empty.\";\n                                }\n                                callback(xhr.responseText, error);\n                            }\n                        };\n                        xhr.open(\"GET\", url, true);\n                        if (xhr.overrideMimeType) xhr.overrideMimeType(\"application/json\");\n                        xhr.setRequestHeader(\"If-Modified-Since\", \"Fri, 01 Jan 1960 00:00:00 GMT\"); // no cache\n                        xhr.send(null);\n                    }\n                    function loadBlock(index, filename) {\n                        function callback(block, error) {\n                            code[index] = block;\n                            ++loaded;\n                            if (error) errors.push(filename + \" ==> \" + error);\n                            if (loaded === sourcesCount) {\n                                if (errors.length === 0) {\n                                    // This used to throw, but it was constantly getting in the way of debugging where things go wrong!\n                                    var sketch = new Processing1(canvas, code.join(\"\\n\"));\n                                    if (onComplete) onComplete(sketch);\n                                } else throw \"Processing.js: Unable to load pjs sketch files: \" + errors.join(\"\\n\");\n                            }\n                        }\n                        if (filename.charAt(0) === \"#\") {\n                            // trying to get script from the element\n                            var scriptElement = document1.getElementById(filename.substring(1));\n                            if (scriptElement) callback(scriptElement.text || scriptElement.textContent);\n                            else callback(\"\", \"Unable to load pjs sketch: element with id '\" + filename.substring(1) + \"' was not found\");\n                            return;\n                        }\n                        ajaxAsync(filename, callback);\n                    }\n                    for(var i = 0; i < sourcesCount; ++i)loadBlock(i, sources[i]);\n                };\n                /**\n   * Automatic initialization function.\n   */ var init = function() {\n                    document1.removeEventListener(\"DOMContentLoaded\", init, false);\n                    var i;\n                    // before running through init, clear the instances list, to prevent\n                    // sketch duplication when page content is dynamically swapped without\n                    // swapping out processing.js\n                    while(Processing1.instances.length > 0){\n                        for(i = Processing1.instances.length - 1; i >= 0; i--)if (Processing1.instances[i]) Processing1.instances[i].exit();\n                    }\n                    var canvas = document1.getElementsByTagName(\"canvas\"), filenames;\n                    const l = canvas.length;\n                    for(i = 0; i < l; i++){\n                        // datasrc and data-src are deprecated.\n                        var processingSources = canvas[i].getAttribute(\"data-processing-sources\");\n                        if (processingSources === null) {\n                            // Temporary fallback for datasrc and data-src\n                            processingSources = canvas[i].getAttribute(\"data-src\");\n                            if (processingSources === null) processingSources = canvas[i].getAttribute(\"datasrc\");\n                        }\n                        if (processingSources) {\n                            filenames = processingSources.split(/\\s+/g);\n                            for(var j = 0; j < filenames.length;)if (filenames[j]) j++;\n                            else filenames.splice(j, 1);\n                            loadSketchFromSources(canvas[i], filenames);\n                        }\n                    }\n                    // also process all <script>-indicated sketches, if there are any\n                    var s, last, source, instance, nodelist = document1.getElementsByTagName(\"script\"), scripts = [];\n                    // snapshot the DOM, as the nodelist is only a DOM view, and is\n                    // updated instantly when a script element is added or removed.\n                    for(s = nodelist.length - 1; s >= 0; s--)scripts.push(nodelist[s]);\n                    // iterate over all script elements to see if they contain Processing code\n                    for(s = 0, last = scripts.length; s < last; s++){\n                        var script = scripts[s];\n                        if (!script.getAttribute) continue;\n                        var type = script.getAttribute(\"type\");\n                        if (type && (type.toLowerCase() === \"text/processing\" || type.toLowerCase() === \"application/processing\")) {\n                            var target = script.getAttribute(\"data-processing-target\");\n                            canvas = undef;\n                            if (target) canvas = document1.getElementById(target);\n                            else {\n                                var nextSibling = script.nextSibling;\n                                while(nextSibling && nextSibling.nodeType !== 1)nextSibling = nextSibling.nextSibling;\n                                if (nextSibling && nextSibling.nodeName.toLowerCase() === \"canvas\") canvas = nextSibling;\n                            }\n                            if (canvas) {\n                                if (script.getAttribute(\"src\")) {\n                                    filenames = script.getAttribute(\"src\").split(/\\s+/);\n                                    loadSketchFromSources(canvas, filenames);\n                                    continue;\n                                }\n                                source = script.textContent || script.text;\n                                instance = new Processing1(canvas, source);\n                            }\n                        }\n                    }\n                };\n                /**\n   * automatic loading of all sketches on the page\n   */ document1.addEventListener(\"DOMContentLoaded\", init, false);\n                /**\n   * Make Processing run through init after already having\n   * been set up for a page. This function exists mostly for pages\n   * that swap content in/out without reloading a page.\n   */ Processing1.reload = init;\n                /**\n   * Disable the automatic loading of all sketches on the page.\n   * This will work as long as it's issued before DOMContentLoaded.\n   */ Processing1.disableInit = function() {\n                    document1.removeEventListener(\"DOMContentLoaded\", init, false);\n                };\n                // done.\n                return Processing1;\n            };\n        },\n        {}\n    ],\n    8: [\n        function(require1, module, exports) {\n            /**\n * Returns Java equals() result for two objects. If the first object\n * has the \"equals\" function, it preforms the call of this function.\n * Otherwise the method uses the JavaScript === operator.\n *\n * @param {Object} obj          The first object.\n * @param {Object} other        The second object.\n *\n * @returns {boolean}           true if the objects are equal.\n */ module.exports = function virtEquals(obj, other) {\n                if (obj === null || other === null) return obj === null && other === null;\n                if (typeof obj === \"string\") return obj === other;\n                if (typeof obj !== \"object\") return obj === other;\n                if (obj.equals instanceof Function) return obj.equals(other);\n                return obj === other;\n            };\n        },\n        {}\n    ],\n    9: [\n        function(require1, module, exports) {\n            /**\n * Returns Java hashCode() result for the object. If the object has the \"hashCode\" function,\n * it preforms the call of this function. Otherwise it uses/creates the \"$id\" property,\n * which is used as the hashCode.\n *\n * @param {Object} obj          The object.\n * @returns {int}               The object's hash code.\n */ module.exports = function virtHashCode(obj, undef) {\n                if (typeof obj === \"string\") {\n                    var hash = 0;\n                    for(var i = 0; i < obj.length; ++i)hash = hash * 31 + obj.charCodeAt(i) & 0xFFFFFFFF;\n                    return hash;\n                }\n                if (typeof obj !== \"object\") return obj & 0xFFFFFFFF;\n                if (obj.hashCode instanceof Function) return obj.hashCode();\n                if (obj.$id === undef) obj.$id = Math.floor(Math.random() * 0x10000) - 0x8000 << 16 | Math.floor(Math.random() * 0x10000);\n                return obj.$id;\n            };\n        },\n        {}\n    ],\n    10: [\n        function(require1, module, exports) {\n            /**\n * An ArrayList stores a variable number of objects.\n *\n * @param {int} initialCapacity optional defines the initial capacity of the list, it's empty by default\n *\n * @returns {ArrayList} new ArrayList object\n */ module.exports = function(options) {\n                var virtHashCode = options.virtHashCode, virtEquals = options.virtEquals;\n                function Iterator(array) {\n                    var index = -1;\n                    this.hasNext = function() {\n                        return index + 1 < array.length;\n                    };\n                    this.next = function() {\n                        return array[++index];\n                    };\n                    this.remove = function() {\n                        array.splice(index--, 1);\n                    };\n                }\n                function ArrayList(a) {\n                    var array = [];\n                    if (a && a.toArray) array = a.toArray();\n                    /**\n     * @member ArrayList\n     * ArrayList.get() Returns the element at the specified position in this list.\n     *\n     * @param {int} i index of element to return\n     *\n     * @returns {Object} the element at the specified position in this list.\n     */ this.get = function(i) {\n                        return array[i];\n                    };\n                    /**\n     * @member ArrayList\n     * ArrayList.contains() Returns true if this list contains the specified element.\n     *\n     * @param {Object} item element whose presence in this List is to be tested.\n     *\n     * @returns {boolean} true if the specified element is present; false otherwise.\n     */ this.contains = function(item) {\n                        return this.indexOf(item) > -1;\n                    };\n                    /**\n     * @member ArrayList\n     * ArrayList.indexOf() Returns the position this element takes in the list, or -1 if the element is not found.\n     *\n     * @param {Object} item element whose position in this List is to be tested.\n     *\n     * @returns {int} the list position that the first match for this element holds in the list, or -1 if it is not in the list.\n     */ this.indexOf = function(item) {\n                        for(var i = 0, len = array.length; i < len; ++i){\n                            if (virtEquals(item, array[i])) return i;\n                        }\n                        return -1;\n                    };\n                    /**\n     * @member ArrayList\n     * ArrayList.lastIndexOf() Returns the index of the last occurrence of the specified element in this list,\n     * or -1 if this list does not contain the element. More formally, returns the highest index i such that\n     * (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.\n     *\n     * @param {Object} item element to search for.\n     *\n     * @returns {int} the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element.\n     */ this.lastIndexOf = function(item) {\n                        for(var i = array.length - 1; i >= 0; --i){\n                            if (virtEquals(item, array[i])) return i;\n                        }\n                        return -1;\n                    };\n                    /**\n     * @member ArrayList\n     * ArrayList.add() Adds the specified element to this list.\n     *\n     * @param {int}    index  optional index at which the specified element is to be inserted\n     * @param {Object} object element to be added to the list\n     */ this.add = function() {\n                        if (arguments.length === 1) array.push(arguments[0]); // for add(Object)\n                        else if (arguments.length === 2) {\n                            var arg0 = arguments[0];\n                            if (typeof arg0 === \"number\") {\n                                if (arg0 >= 0 && arg0 <= array.length) array.splice(arg0, 0, arguments[1]); // for add(i, Object)\n                                else throw arg0 + \" is not a valid index\";\n                            } else throw typeof arg0 + \" is not a number\";\n                        } else throw \"Please use the proper number of parameters.\";\n                    };\n                    /**\n     * @member ArrayList\n     * ArrayList.addAll(collection) appends all of the elements in the specified\n     * Collection to the end of this list, in the order that they are returned by\n     * the specified Collection's Iterator.\n     *\n     * When called as addAll(index, collection) the elements are inserted into\n     * this list at the position indicated by index.\n     *\n     * @param {index} Optional; specifies the position the colletion should be inserted at\n     * @param {collection} Any iterable object (ArrayList, HashMap.keySet(), etc.)\n     * @throws out of bounds error for negative index, or index greater than list size.\n     */ this.addAll = function(arg1, arg2) {\n                        // addAll(int, Collection)\n                        var it;\n                        if (typeof arg1 === \"number\") {\n                            if (arg1 < 0 || arg1 > array.length) throw \"Index out of bounds for addAll: \" + arg1 + \" greater or equal than \" + array.length;\n                            it = new ObjectIterator(arg2);\n                            while(it.hasNext())array.splice(arg1++, 0, it.next());\n                        } else {\n                            it = new ObjectIterator(arg1);\n                            while(it.hasNext())array.push(it.next());\n                        }\n                    };\n                    /**\n     * @member ArrayList\n     * ArrayList.set() Replaces the element at the specified position in this list with the specified element.\n     *\n     * @param {int}    index  index of element to replace\n     * @param {Object} object element to be stored at the specified position\n     */ this.set = function() {\n                        if (arguments.length === 2) {\n                            var arg0 = arguments[0];\n                            if (typeof arg0 === \"number\") {\n                                if (arg0 >= 0 && arg0 < array.length) array.splice(arg0, 1, arguments[1]);\n                                else throw arg0 + \" is not a valid index.\";\n                            } else throw typeof arg0 + \" is not a number\";\n                        } else throw \"Please use the proper number of parameters.\";\n                    };\n                    /**\n     * @member ArrayList\n     * ArrayList.size() Returns the number of elements in this list.\n     *\n     * @returns {int} the number of elements in this list\n     */ this.size = function() {\n                        return array.length;\n                    };\n                    /**\n     * @member ArrayList\n     * ArrayList.clear() Removes all of the elements from this list. The list will be empty after this call returns.\n     */ this.clear = function() {\n                        array.length = 0;\n                    };\n                    /**\n     * @member ArrayList\n     * ArrayList.remove() Removes an element either based on index, if the argument is a number, or\n     * by equality check, if the argument is an object.\n     *\n     * @param {int|Object} item either the index of the element to be removed, or the element itself.\n     *\n     * @returns {Object|boolean} If removal is by index, the element that was removed, or null if nothing was removed. If removal is by object, true if removal occurred, otherwise false.\n     */ this.remove = function(item) {\n                        if (typeof item === \"number\") return array.splice(item, 1)[0];\n                        item = this.indexOf(item);\n                        if (item > -1) {\n                            array.splice(item, 1);\n                            return true;\n                        }\n                        return false;\n                    };\n                    /**\n     * @member ArrayList\n     * ArrayList.removeAll Removes from this List all of the elements from\n     * the current ArrayList which are present in the passed in paramater ArrayList 'c'.\n     * Shifts any succeeding elements to the left (reduces their index).\n     *\n     * @param {ArrayList} the ArrayList to compare to the current ArrayList\n     *\n     * @returns {boolean} true if the ArrayList had an element removed; false otherwise\n     */ this.removeAll = function(c) {\n                        var i, x, item, newList = new ArrayList();\n                        newList.addAll(this);\n                        this.clear();\n                        // For every item that exists in the original ArrayList and not in the c ArrayList\n                        // copy it into the empty 'this' ArrayList to create the new 'this' Array.\n                        for(i = 0, x = 0; i < newList.size(); i++){\n                            item = newList.get(i);\n                            if (!c.contains(item)) this.add(x++, item);\n                        }\n                        if (this.size() < newList.size()) return true;\n                        return false;\n                    };\n                    /**\n     * @member ArrayList\n     * ArrayList.isEmpty() Tests if this list has no elements.\n     *\n     * @returns {boolean} true if this list has no elements; false otherwise\n     */ this.isEmpty = function() {\n                        return !array.length;\n                    };\n                    /**\n     * @member ArrayList\n     * ArrayList.clone() Returns a shallow copy of this ArrayList instance. (The elements themselves are not copied.)\n     *\n     * @returns {ArrayList} a clone of this ArrayList instance\n     */ this.clone = function() {\n                        return new ArrayList(this);\n                    };\n                    /**\n     * @member ArrayList\n     * ArrayList.toArray() Returns an array containing all of the elements in this list in the correct order.\n     *\n     * @returns {Object[]} Returns an array containing all of the elements in this list in the correct order\n     */ this.toArray = function() {\n                        return array.slice(0);\n                    };\n                    this.iterator = function() {\n                        return new Iterator(array);\n                    };\n                }\n                return ArrayList;\n            };\n        },\n        {}\n    ],\n    11: [\n        function(require1, module, exports) {\n            module.exports = function(charMap, undef) {\n                var Char1 = function(chr) {\n                    if (typeof chr === \"string\" && chr.length === 1) this.code = chr.charCodeAt(0);\n                    else if (typeof chr === \"number\") this.code = chr;\n                    else if (chr instanceof Char1) this.code = chr;\n                    else this.code = NaN;\n                    return charMap[this.code] === undef ? charMap[this.code] = this : charMap[this.code];\n                };\n                Char1.prototype.toString = function() {\n                    return String.fromCharCode(this.code);\n                };\n                Char1.prototype.valueOf = function() {\n                    return this.code;\n                };\n                return Char1;\n            }({});\n        },\n        {}\n    ],\n    12: [\n        function(require1, module, exports) {\n            /**\n* A HashMap stores a collection of objects, each referenced by a key. This is similar to an Array, only\n* instead of accessing elements with a numeric index, a String  is used. (If you are familiar with\n* associative arrays from other languages, this is the same idea.)\n*\n* @param {int} initialCapacity          defines the initial capacity of the map, it's 16 by default\n* @param {float} loadFactor             the load factor for the map, the default is 0.75\n* @param {Map} m                        gives the new HashMap the same mappings as this Map\n*/ module.exports = function(options) {\n                var virtHashCode = options.virtHashCode, virtEquals = options.virtEquals;\n                /**\n  * @member HashMap\n  * A HashMap stores a collection of objects, each referenced by a key. This is similar to an Array, only\n  * instead of accessing elements with a numeric index, a String  is used. (If you are familiar with\n  * associative arrays from other languages, this is the same idea.)\n  *\n  * @param {int} initialCapacity          defines the initial capacity of the map, it's 16 by default\n  * @param {float} loadFactor             the load factor for the map, the default is 0.75\n  * @param {Map} m                        gives the new HashMap the same mappings as this Map\n  */ function HashMap() {\n                    if (arguments.length === 1 && arguments[0] instanceof HashMap) return arguments[0].clone();\n                    var initialCapacity = arguments.length > 0 ? arguments[0] : 16;\n                    var loadFactor = arguments.length > 1 ? arguments[1] : 0.75;\n                    var buckets = [];\n                    buckets.length = initialCapacity;\n                    var count = 0;\n                    var hashMap = this;\n                    function getBucketIndex(key) {\n                        var index = virtHashCode(key) % buckets.length;\n                        return index < 0 ? buckets.length + index : index;\n                    }\n                    function ensureLoad() {\n                        if (count <= loadFactor * buckets.length) return;\n                        var allEntries = [];\n                        for(var i = 0; i < buckets.length; ++i)if (buckets[i] !== undefined) allEntries = allEntries.concat(buckets[i]);\n                        var newBucketsLength = buckets.length * 2;\n                        buckets = [];\n                        buckets.length = newBucketsLength;\n                        for(var j = 0; j < allEntries.length; ++j){\n                            var index = getBucketIndex(allEntries[j].key);\n                            var bucket = buckets[index];\n                            if (bucket === undefined) buckets[index] = bucket = [];\n                            bucket.push(allEntries[j]);\n                        }\n                    }\n                    function Iterator(conversion, removeItem) {\n                        var bucketIndex = 0;\n                        var itemIndex = -1;\n                        var endOfBuckets = false;\n                        var currentItem;\n                        function findNext() {\n                            while(!endOfBuckets){\n                                ++itemIndex;\n                                if (bucketIndex >= buckets.length) endOfBuckets = true;\n                                else if (buckets[bucketIndex] === undefined || itemIndex >= buckets[bucketIndex].length) {\n                                    itemIndex = -1;\n                                    ++bucketIndex;\n                                } else return;\n                            }\n                        }\n                        /*\n      * @member Iterator\n      * Checks if the Iterator has more items\n      */ this.hasNext = function() {\n                            return !endOfBuckets;\n                        };\n                        /*\n      * @member Iterator\n      * Return the next Item\n      */ this.next = function() {\n                            currentItem = conversion(buckets[bucketIndex][itemIndex]);\n                            findNext();\n                            return currentItem;\n                        };\n                        /*\n      * @member Iterator\n      * Remove the current item\n      */ this.remove = function() {\n                            if (currentItem !== undefined) {\n                                removeItem(currentItem);\n                                --itemIndex;\n                                findNext();\n                            }\n                        };\n                        findNext();\n                    }\n                    function Set(conversion, isIn, removeItem) {\n                        this.clear = function() {\n                            hashMap.clear();\n                        };\n                        this.contains = function(o) {\n                            return isIn(o);\n                        };\n                        this.containsAll = function(o) {\n                            var it = o.iterator();\n                            while(it.hasNext()){\n                                if (!this.contains(it.next())) return false;\n                            }\n                            return true;\n                        };\n                        this.isEmpty = function() {\n                            return hashMap.isEmpty();\n                        };\n                        this.iterator = function() {\n                            return new Iterator(conversion, removeItem);\n                        };\n                        this.remove = function(o) {\n                            if (this.contains(o)) {\n                                removeItem(o);\n                                return true;\n                            }\n                            return false;\n                        };\n                        this.removeAll = function(c) {\n                            var it = c.iterator();\n                            var changed = false;\n                            while(it.hasNext()){\n                                var item = it.next();\n                                if (this.contains(item)) {\n                                    removeItem(item);\n                                    changed = true;\n                                }\n                            }\n                            return true;\n                        };\n                        this.retainAll = function(c) {\n                            var it = this.iterator();\n                            var toRemove = [];\n                            while(it.hasNext()){\n                                var entry = it.next();\n                                if (!c.contains(entry)) toRemove.push(entry);\n                            }\n                            for(var i = 0; i < toRemove.length; ++i)removeItem(toRemove[i]);\n                            return toRemove.length > 0;\n                        };\n                        this.size = function() {\n                            return hashMap.size();\n                        };\n                        this.toArray = function() {\n                            var result = [];\n                            var it = this.iterator();\n                            while(it.hasNext())result.push(it.next());\n                            return result;\n                        };\n                    }\n                    function Entry(pair) {\n                        this._isIn = function(map) {\n                            return map === hashMap && pair.removed === undefined;\n                        };\n                        this.equals = function(o) {\n                            return virtEquals(pair.key, o.getKey());\n                        };\n                        this.getKey = function() {\n                            return pair.key;\n                        };\n                        this.getValue = function() {\n                            return pair.value;\n                        };\n                        this.hashCode = function(o) {\n                            return virtHashCode(pair.key);\n                        };\n                        this.setValue = function(value) {\n                            var old = pair.value;\n                            pair.value = value;\n                            return old;\n                        };\n                    }\n                    this.clear = function() {\n                        count = 0;\n                        buckets = [];\n                        buckets.length = initialCapacity;\n                    };\n                    this.clone = function() {\n                        var map = new HashMap();\n                        map.putAll(this);\n                        return map;\n                    };\n                    this.containsKey = function(key) {\n                        var index = getBucketIndex(key);\n                        var bucket = buckets[index];\n                        if (bucket === undefined) return false;\n                        for(var i = 0; i < bucket.length; ++i){\n                            if (virtEquals(bucket[i].key, key)) return true;\n                        }\n                        return false;\n                    };\n                    this.containsValue = function(value) {\n                        for(var i = 0; i < buckets.length; ++i){\n                            var bucket = buckets[i];\n                            if (bucket === undefined) continue;\n                            for(var j = 0; j < bucket.length; ++j){\n                                if (virtEquals(bucket[j].value, value)) return true;\n                            }\n                        }\n                        return false;\n                    };\n                    this.entrySet = function() {\n                        return new Set(function(pair) {\n                            return new Entry(pair);\n                        }, function(pair) {\n                            return pair instanceof Entry && pair._isIn(hashMap);\n                        }, function(pair) {\n                            return hashMap.remove(pair.getKey());\n                        });\n                    };\n                    this.get = function(key) {\n                        var index = getBucketIndex(key);\n                        var bucket = buckets[index];\n                        if (bucket === undefined) return null;\n                        for(var i = 0; i < bucket.length; ++i){\n                            if (virtEquals(bucket[i].key, key)) return bucket[i].value;\n                        }\n                        return null;\n                    };\n                    this.isEmpty = function() {\n                        return count === 0;\n                    };\n                    this.keySet = function() {\n                        return new Set(// get key from pair\n                        function(pair) {\n                            return pair.key;\n                        }, // is-in test\n                        function(key) {\n                            return hashMap.containsKey(key);\n                        }, // remove from hashmap by key\n                        function(key) {\n                            return hashMap.remove(key);\n                        });\n                    };\n                    this.values = function() {\n                        return new Set(// get value from pair\n                        function(pair) {\n                            return pair.value;\n                        }, // is-in test\n                        function(value) {\n                            return hashMap.containsValue(value);\n                        }, // remove from hashmap by value\n                        function(value) {\n                            return hashMap.removeByValue(value);\n                        });\n                    };\n                    this.put = function(key, value) {\n                        var index = getBucketIndex(key);\n                        var bucket = buckets[index];\n                        if (bucket === undefined) {\n                            ++count;\n                            buckets[index] = [\n                                {\n                                    key: key,\n                                    value: value\n                                }\n                            ];\n                            ensureLoad();\n                            return null;\n                        }\n                        for(var i = 0; i < bucket.length; ++i)if (virtEquals(bucket[i].key, key)) {\n                            var previous = bucket[i].value;\n                            bucket[i].value = value;\n                            return previous;\n                        }\n                        ++count;\n                        bucket.push({\n                            key: key,\n                            value: value\n                        });\n                        ensureLoad();\n                        return null;\n                    };\n                    this.putAll = function(m) {\n                        var it = m.entrySet().iterator();\n                        while(it.hasNext()){\n                            var entry = it.next();\n                            this.put(entry.getKey(), entry.getValue());\n                        }\n                    };\n                    this.remove = function(key) {\n                        var index = getBucketIndex(key);\n                        var bucket = buckets[index];\n                        if (bucket === undefined) return null;\n                        for(var i = 0; i < bucket.length; ++i)if (virtEquals(bucket[i].key, key)) {\n                            --count;\n                            var previous = bucket[i].value;\n                            bucket[i].removed = true;\n                            if (bucket.length > 1) bucket.splice(i, 1);\n                            else buckets[index] = undefined;\n                            return previous;\n                        }\n                        return null;\n                    };\n                    this.removeByValue = function(value) {\n                        var bucket, i, ilen, pair;\n                        for(bucket in buckets){\n                            if (buckets.hasOwnProperty(bucket)) for(i = 0, ilen = buckets[bucket].length; i < ilen; i++){\n                                pair = buckets[bucket][i];\n                                // removal on values is based on identity, not equality\n                                if (pair.value === value) {\n                                    buckets[bucket].splice(i, 1);\n                                    return true;\n                                }\n                            }\n                        }\n                        return false;\n                    };\n                    this.size = function() {\n                        return count;\n                    };\n                }\n                return HashMap;\n            };\n        },\n        {}\n    ],\n    13: [\n        function(require1, module, exports) {\n            // module export\n            module.exports = function(options, undef) {\n                var window1 = options.Browser.window, document1 = options.Browser.document, noop = options.noop;\n                /**\n   * [internal function] computeFontMetrics() calculates various metrics for text\n   * placement. Currently this function computes the ascent, descent and leading\n   * (from \"lead\", used for vertical space) values for the currently active font.\n   */ function computeFontMetrics(pfont) {\n                    var emQuad = 250, correctionFactor = pfont.size / emQuad, canvas = document1.createElement(\"canvas\");\n                    canvas.width = 2 * emQuad;\n                    canvas.height = 2 * emQuad;\n                    canvas.style.opacity = 0;\n                    var cfmFont = pfont.getCSSDefinition(emQuad + \"px\", \"normal\"), ctx = canvas.getContext(\"2d\");\n                    ctx.font = cfmFont;\n                    // Size the canvas using a string with common max-ascent and max-descent letters.\n                    // Changing the canvas dimensions resets the context, so we must reset the font.\n                    var protrusions = \"dbflkhyjqpg\";\n                    canvas.width = ctx.measureText(protrusions).width;\n                    ctx.font = cfmFont;\n                    // for text lead values, we meaure a multiline text container.\n                    var leadDiv = document1.createElement(\"div\");\n                    leadDiv.style.position = \"absolute\";\n                    leadDiv.style.opacity = 0;\n                    leadDiv.style.fontFamily = '\"' + pfont.name + '\"';\n                    leadDiv.style.fontSize = emQuad + \"px\";\n                    leadDiv.innerHTML = protrusions + \"<br/>\" + protrusions;\n                    document1.body.appendChild(leadDiv);\n                    var w = canvas.width, h = canvas.height, baseline = h / 2;\n                    // Set all canvas pixeldata values to 255, with all the content\n                    // data being 0. This lets us scan for data[i] != 255.\n                    ctx.fillStyle = \"white\";\n                    ctx.fillRect(0, 0, w, h);\n                    ctx.fillStyle = \"black\";\n                    ctx.fillText(protrusions, 0, baseline);\n                    var pixelData = ctx.getImageData(0, 0, w, h).data;\n                    // canvas pixel data is w*4 by h*4, because R, G, B and A are separate,\n                    // consecutive values in the array, rather than stored as 32 bit ints.\n                    var i = 0, w4 = w * 4, len = pixelData.length;\n                    // Finding the ascent uses a normal, forward scanline\n                    while(++i < len && pixelData[i] === 255)noop();\n                    var ascent = Math.round(i / w4);\n                    // Finding the descent uses a reverse scanline\n                    i = len - 1;\n                    while(--i > 0 && pixelData[i] === 255)noop();\n                    var descent = Math.round(i / w4);\n                    // set font metrics\n                    pfont.ascent = correctionFactor * (baseline - ascent);\n                    pfont.descent = correctionFactor * (descent - baseline);\n                    // Then we try to get the real value from the browser\n                    if (document1.defaultView.getComputedStyle) {\n                        var leadDivHeight = document1.defaultView.getComputedStyle(leadDiv, null).getPropertyValue(\"height\");\n                        leadDivHeight = correctionFactor * leadDivHeight.replace(\"px\", \"\");\n                        if (leadDivHeight >= pfont.size * 2) pfont.leading = Math.round(leadDivHeight / 2);\n                    }\n                    document1.body.removeChild(leadDiv);\n                    // if we're caching, cache the context used for this pfont\n                    if (pfont.caching) return ctx;\n                }\n                /**\n   * Constructor for a system or from-file (non-SVG) font.\n   */ function PFont1(name, size) {\n                    // according to the P5 API, new PFont() is legal (albeit completely useless)\n                    if (name === undef) name = \"\";\n                    this.name = name;\n                    if (size === undef) size = 0;\n                    this.size = size;\n                    this.glyph = false;\n                    this.ascent = 0;\n                    this.descent = 0;\n                    // For leading, the \"safe\" value uses the standard TEX ratio\n                    this.leading = 1.2 * size;\n                    // Note that an italic, bold font must used \"... Bold Italic\"\n                    // in P5. \"... Italic Bold\" is treated as normal/normal.\n                    var illegalIndicator = name.indexOf(\" Italic Bold\");\n                    if (illegalIndicator !== -1) name = name.substring(0, illegalIndicator);\n                    // determine font style\n                    this.style = \"normal\";\n                    var italicsIndicator = name.indexOf(\" Italic\");\n                    if (italicsIndicator !== -1) {\n                        name = name.substring(0, italicsIndicator);\n                        this.style = \"italic\";\n                    }\n                    // determine font weight\n                    this.weight = \"normal\";\n                    var boldIndicator = name.indexOf(\" Bold\");\n                    if (boldIndicator !== -1) {\n                        name = name.substring(0, boldIndicator);\n                        this.weight = \"bold\";\n                    }\n                    // determine font-family name\n                    this.family = \"sans-serif\";\n                    if (name !== undef) switch(name){\n                        case \"sans-serif\":\n                        case \"serif\":\n                        case \"monospace\":\n                        case \"fantasy\":\n                        case \"cursive\":\n                            this.family = name;\n                            break;\n                        default:\n                            this.family = '\"' + name + '\", sans-serif';\n                            break;\n                    }\n                    // Calculate the ascent/descent/leading value based on\n                    // how the browser renders this font.\n                    this.context2d = computeFontMetrics(this);\n                    this.css = this.getCSSDefinition();\n                    if (this.context2d) this.context2d.font = this.css;\n                }\n                /**\n   * regulates whether or not we're caching the canvas\n   * 2d context for quick text width computation.\n   */ PFont1.prototype.caching = true;\n                /**\n   * This function generates the CSS \"font\" string for this PFont\n   */ PFont1.prototype.getCSSDefinition = function(fontSize, lineHeight) {\n                    if (fontSize === undef) fontSize = this.size + \"px\";\n                    if (lineHeight === undef) lineHeight = this.leading + \"px\";\n                    // CSS \"font\" definition: font-style font-variant font-weight font-size/line-height font-family\n                    var components = [\n                        this.style,\n                        \"normal\",\n                        this.weight,\n                        fontSize + \"/\" + lineHeight,\n                        this.family\n                    ];\n                    return components.join(\" \");\n                };\n                /**\n   * Rely on the cached context2d measureText function.\n   */ PFont1.prototype.measureTextWidth = function(string) {\n                    return this.context2d.measureText(string).width;\n                };\n                /**\n   * FALLBACK FUNCTION -- replaces Pfont.prototype.measureTextWidth\n   * when the font cache becomes too large. This contructs a new\n   * canvas 2d context object for calling measureText on.\n   */ PFont1.prototype.measureTextWidthFallback = function(string) {\n                    var canvas = document1.createElement(\"canvas\"), ctx = canvas.getContext(\"2d\");\n                    ctx.font = this.css;\n                    return ctx.measureText(string).width;\n                };\n                /**\n   * Global \"loaded fonts\" list, internal to PFont\n   */ PFont1.PFontCache = {\n                    length: 0\n                };\n                /**\n   * This function acts as single access point for getting and caching\n   * fonts across all sketches handled by an instance of Processing.js\n   */ PFont1.get = function(fontName, fontSize) {\n                    // round fontSize to one decimal point\n                    fontSize = (fontSize * 10 + 0.5 | 0) / 10;\n                    var cache = PFont1.PFontCache, idx = fontName + \"/\" + fontSize;\n                    if (!cache[idx]) {\n                        cache[idx] = new PFont1(fontName, fontSize);\n                        cache.length++;\n                        // FALLBACK FUNCTIONALITY 1:\n                        // If the cache has become large, switch over from full caching\n                        // to caching only the static metrics for each new font request.\n                        if (cache.length === 50) {\n                            PFont1.prototype.measureTextWidth = PFont1.prototype.measureTextWidthFallback;\n                            PFont1.prototype.caching = false;\n                            // clear contexts stored for each cached font\n                            var entry;\n                            for(entry in cache)if (entry !== \"length\") cache[entry].context2d = null;\n                            return new PFont1(fontName, fontSize);\n                        }\n                        // FALLBACK FUNCTIONALITY 2:\n                        // If the cache has become too large, switch off font caching entirely.\n                        if (cache.length === 400) {\n                            PFont1.PFontCache = {};\n                            PFont1.get = PFont1.getFallback;\n                            return new PFont1(fontName, fontSize);\n                        }\n                    }\n                    return cache[idx];\n                };\n                /**\n   * FALLBACK FUNCTION -- replaces PFont.get when the font cache\n   * becomes too large. This function bypasses font caching entirely.\n   */ PFont1.getFallback = function(fontName, fontSize) {\n                    return new PFont1(fontName, fontSize);\n                };\n                /**\n   * Lists all standard fonts. Due to browser limitations, this list is\n   * not the system font list, like in P5, but the CSS \"genre\" list.\n   */ PFont1.list = function() {\n                    return [\n                        \"sans-serif\",\n                        \"serif\",\n                        \"monospace\",\n                        \"fantasy\",\n                        \"cursive\"\n                    ];\n                };\n                /**\n   * Loading external fonts through @font-face rules is handled by PFont,\n   * to ensure fonts loaded in this way are globally available.\n   */ PFont1.preloading = {\n                    // template element used to compare font sizes\n                    template: {},\n                    // indicates whether or not the reference tiny font has been loaded\n                    initialized: false,\n                    // load the reference tiny font via a css @font-face rule\n                    initialize: function() {\n                        var generateTinyFont = function() {\n                            var encoded = \"#E3KAI2wAgT1MvMg7Eo3VmNtYX7ABi3CxnbHlm7Abw3kaGVhZ7ACs3OGhoZWE7A53CRobXR47AY3AGbG9jYQ7G03Bm1heH7ABC3CBuYW1l7Ae3AgcG9zd7AI3AE#B3AQ2kgTY18PPPUACwAg3ALSRoo3#yld0xg32QAB77#E777773B#E3C#I#Q77773E#Q7777777772CMAIw7AB77732B#M#Q3wAB#g3B#E#E2BB//82BB////w#B7#gAEg3E77x2B32B#E#Q#MTcBAQ32gAe#M#QQJ#E32M#QQJ#I#g32Q77#\";\n                            var expand = function(input) {\n                                return \"AAAAAAAA\".substr(~~input ? 7 - input : 6);\n                            };\n                            return encoded.replace(/[#237]/g, expand);\n                        };\n                        var fontface = document1.createElement(\"style\");\n                        fontface.setAttribute(\"type\", \"text/css\");\n                        fontface.innerHTML = '@font-face {\\n  font-family: \"PjsEmptyFont\";\\n  src: url(\\'data:application/x-font-ttf;base64,' + generateTinyFont() + \"')\\n\" + \"       format('truetype');\\n\" + \"}\";\n                        document1.head.appendChild(fontface);\n                        // set up the template element\n                        var element = document1.createElement(\"span\");\n                        element.style.cssText = 'position: absolute; top: -1000; left: 0; opacity: 0; font-family: \"PjsEmptyFont\", fantasy;';\n                        element.innerHTML = \"AAAAAAAA\";\n                        document1.body.appendChild(element);\n                        this.template = element;\n                        this.initialized = true;\n                    },\n                    // Shorthand function to get the computed width for an element.\n                    getElementWidth: function(element) {\n                        return document1.defaultView.getComputedStyle(element, \"\").getPropertyValue(\"width\");\n                    },\n                    // time taken so far in attempting to load a font\n                    timeAttempted: 0,\n                    // returns false if no fonts are pending load, or true otherwise.\n                    pending: function(intervallength) {\n                        if (!this.initialized) this.initialize();\n                        var element, computedWidthFont, computedWidthRef = this.getElementWidth(this.template);\n                        for(var i = 0; i < this.fontList.length; i++){\n                            // compares size of text in pixels. if equal, custom font is not yet loaded\n                            element = this.fontList[i];\n                            computedWidthFont = this.getElementWidth(element);\n                            if (this.timeAttempted < 4000 && computedWidthFont === computedWidthRef) {\n                                this.timeAttempted += intervallength;\n                                return true;\n                            } else {\n                                document1.body.removeChild(element);\n                                this.fontList.splice(i--, 1);\n                                this.timeAttempted = 0;\n                            }\n                        }\n                        // if there are no more fonts to load, pending is false\n                        if (this.fontList.length === 0) return false;\n                        // We should have already returned before getting here.\n                        // But, if we do get here, length!=0 so fonts are pending.\n                        return true;\n                    },\n                    // fontList contains elements to compare font sizes against a template\n                    fontList: [],\n                    // addedList contains the fontnames of all the fonts loaded via @font-face\n                    addedList: {},\n                    // adds a font to the font cache\n                    // creates an element using the font, to start loading the font,\n                    // and compare against a default font to see if the custom font is loaded\n                    add: function(fontSrc) {\n                        if (!this.initialized) this.initialize();\n                        // fontSrc can be a string or a javascript object\n                        // acceptable fonts are .ttf, .otf, and data uri\n                        var fontName = typeof fontSrc === \"object\" ? fontSrc.fontFace : fontSrc, fontUrl = typeof fontSrc === \"object\" ? fontSrc.url : fontSrc;\n                        // check whether we already created the @font-face rule for this font\n                        if (this.addedList[fontName]) return;\n                        // if we didn't, create the @font-face rule\n                        var style = document1.createElement(\"style\");\n                        style.setAttribute(\"type\", \"text/css\");\n                        style.innerHTML = \"@font-face{\\n  font-family: '\" + fontName + \"';\\n  src:  url('\" + fontUrl + \"');\\n}\\n\";\n                        document1.head.appendChild(style);\n                        this.addedList[fontName] = true;\n                        // also create the element to load and compare the new font\n                        var element = document1.createElement(\"span\");\n                        element.style.cssText = \"position: absolute; top: 0; left: 0; opacity: 0;\";\n                        element.style.fontFamily = '\"' + fontName + '\", \"PjsEmptyFont\", fantasy';\n                        element.innerHTML = \"AAAAAAAA\";\n                        document1.body.appendChild(element);\n                        this.fontList.push(element);\n                    }\n                };\n                return PFont1;\n            };\n        },\n        {}\n    ],\n    14: [\n        function(require1, module, exports) {\n            module.exports = function(options, undef) {\n                // FIXME: hack\n                var p = options.p;\n                /**\n   * PMatrix2D is a 3x2 affine matrix implementation. The constructor accepts another PMatrix2D or a list of six float elements.\n   * If no parameters are provided the matrix is set to the identity matrix.\n   *\n   * @param {PMatrix2D} matrix  the initial matrix to set to\n   * @param {float} m00         the first element of the matrix\n   * @param {float} m01         the second element of the matrix\n   * @param {float} m02         the third element of the matrix\n   * @param {float} m10         the fourth element of the matrix\n   * @param {float} m11         the fifth element of the matrix\n   * @param {float} m12         the sixth element of the matrix\n   */ var PMatrix2D = function() {\n                    if (arguments.length === 0) this.reset();\n                    else if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) this.set(arguments[0].array());\n                    else if (arguments.length === 6) this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);\n                };\n                /**\n   * PMatrix2D methods\n   */ PMatrix2D.prototype = {\n                    /**\n     * @member PMatrix2D\n     * The set() function sets the matrix elements. The function accepts either another PMatrix2D, an array of elements, or a list of six floats.\n     *\n     * @param {PMatrix2D} matrix    the matrix to set this matrix to\n     * @param {float[]} elements    an array of elements to set this matrix to\n     * @param {float} m00           the first element of the matrix\n     * @param {float} m01           the third element of the matrix\n     * @param {float} m10           the fourth element of the matrix\n     * @param {float} m11           the fith element of the matrix\n     * @param {float} m12           the sixth element of the matrix\n     */ set: function() {\n                        if (arguments.length === 6) {\n                            var a = arguments;\n                            this.set([\n                                a[0],\n                                a[1],\n                                a[2],\n                                a[3],\n                                a[4],\n                                a[5]\n                            ]);\n                        } else if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) this.elements = arguments[0].array();\n                        else if (arguments.length === 1 && arguments[0] instanceof Array) this.elements = arguments[0].slice();\n                    },\n                    /**\n     * @member PMatrix2D\n     * The get() function returns a copy of this PMatrix2D.\n     *\n     * @return {PMatrix2D} a copy of this PMatrix2D\n     */ get: function() {\n                        var outgoing = new PMatrix2D();\n                        outgoing.set(this.elements);\n                        return outgoing;\n                    },\n                    /**\n     * @member PMatrix2D\n     * The reset() function sets this PMatrix2D to the identity matrix.\n     */ reset: function() {\n                        this.set([\n                            1,\n                            0,\n                            0,\n                            0,\n                            1,\n                            0\n                        ]);\n                    },\n                    /**\n     * @member PMatrix2D\n     * The array() function returns a copy of the element values.\n     * @addon\n     *\n     * @return {float[]} returns a copy of the element values\n     */ array: function array() {\n                        return this.elements.slice();\n                    },\n                    /**\n     * @member PMatrix2D\n     * The translate() function translates this matrix by moving the current coordinates to the location specified by tx and ty.\n     *\n     * @param {float} tx  the x-axis coordinate to move to\n     * @param {float} ty  the y-axis coordinate to move to\n     */ translate: function(tx, ty) {\n                        this.elements[2] = tx * this.elements[0] + ty * this.elements[1] + this.elements[2];\n                        this.elements[5] = tx * this.elements[3] + ty * this.elements[4] + this.elements[5];\n                    },\n                    /**\n     * @member PMatrix2D\n     * The invTranslate() function translates this matrix by moving the current coordinates to the negative location specified by tx and ty.\n     *\n     * @param {float} tx  the x-axis coordinate to move to\n     * @param {float} ty  the y-axis coordinate to move to\n     */ invTranslate: function(tx, ty) {\n                        this.translate(-tx, -ty);\n                    },\n                    /**\n     * @member PMatrix2D\n     * The transpose() function is not used in processingjs.\n     */ transpose: function() {\n                    // Does nothing in Processing.\n                    },\n                    /**\n     * @member PMatrix2D\n     * The mult() function multiplied this matrix.\n     * If two array elements are passed in the function will multiply a two element vector against this matrix.\n     * If target is null or not length four, a new float array will be returned.\n     * The values for vec and target can be the same (though that's less efficient).\n     * If two PVectors are passed in the function multiply the x and y coordinates of a PVector against this matrix.\n     *\n     * @param {PVector} source, target  the PVectors used to multiply this matrix\n     * @param {float[]} source, target  the arrays used to multiply this matrix\n     *\n     * @return {PVector|float[]} returns a PVector or an array representing the new matrix\n     */ mult: function(source, target) {\n                        var x, y;\n                        if (source instanceof PVector) {\n                            x = source.x;\n                            y = source.y;\n                            if (!target) target = new PVector();\n                        } else if (source instanceof Array) {\n                            x = source[0];\n                            y = source[1];\n                            if (!target) target = [];\n                        }\n                        if (target instanceof Array) {\n                            target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2];\n                            target[1] = this.elements[3] * x + this.elements[4] * y + this.elements[5];\n                        } else if (target instanceof PVector) {\n                            target.x = this.elements[0] * x + this.elements[1] * y + this.elements[2];\n                            target.y = this.elements[3] * x + this.elements[4] * y + this.elements[5];\n                            target.z = 0;\n                        }\n                        return target;\n                    },\n                    /**\n     * @member PMatrix2D\n     * The multX() function calculates the x component of a vector from a transformation.\n     *\n     * @param {float} x the x component of the vector being transformed\n     * @param {float} y the y component of the vector being transformed\n     *\n     * @return {float} returnes the result of the calculation\n     */ multX: function(x, y) {\n                        return x * this.elements[0] + y * this.elements[1] + this.elements[2];\n                    },\n                    /**\n     * @member PMatrix2D\n     * The multY() function calculates the y component of a vector from a transformation.\n     *\n     * @param {float} x the x component of the vector being transformed\n     * @param {float} y the y component of the vector being transformed\n     *\n     * @return {float} returnes the result of the calculation\n     */ multY: function(x, y) {\n                        return x * this.elements[3] + y * this.elements[4] + this.elements[5];\n                    },\n                    /**\n     * @member PMatrix2D\n     * The skewX() function skews the matrix along the x-axis the amount specified by the angle parameter.\n     * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n     *\n     * @param {float} angle  angle of skew specified in radians\n     */ skewX: function(angle) {\n                        this.apply(1, 0, 1, angle, 0, 0);\n                    },\n                    /**\n     * @member PMatrix2D\n     * The skewY() function skews the matrix along the y-axis the amount specified by the angle parameter.\n     * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n     *\n     * @param {float} angle  angle of skew specified in radians\n     */ skewY: function(angle) {\n                        this.apply(1, 0, 1, 0, angle, 0);\n                    },\n                    /**\n     * @member PMatrix2D\n     * The shearX() function shears the matrix along the x-axis the amount specified by the angle parameter.\n     * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n     *\n     * @param {float} angle  angle of skew specified in radians\n     */ shearX: function(angle) {\n                        this.apply(1, 0, 1, Math.tan(angle), 0, 0);\n                    },\n                    /**\n     * @member PMatrix2D\n     * The shearY() function shears the matrix along the y-axis the amount specified by the angle parameter.\n     * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n     *\n     * @param {float} angle  angle of skew specified in radians\n     */ shearY: function(angle) {\n                        this.apply(1, 0, 1, 0, Math.tan(angle), 0);\n                    },\n                    /**\n     * @member PMatrix2D\n     * The determinant() function calvculates the determinant of this matrix.\n     *\n     * @return {float} the determinant of the matrix\n     */ determinant: function() {\n                        return this.elements[0] * this.elements[4] - this.elements[1] * this.elements[3];\n                    },\n                    /**\n     * @member PMatrix2D\n     * The invert() function inverts this matrix\n     *\n     * @return {boolean} true if successful\n     */ invert: function() {\n                        var d = this.determinant();\n                        if (Math.abs(d) > PConstants.MIN_INT) {\n                            var old00 = this.elements[0];\n                            var old01 = this.elements[1];\n                            var old02 = this.elements[2];\n                            var old10 = this.elements[3];\n                            var old11 = this.elements[4];\n                            var old12 = this.elements[5];\n                            this.elements[0] = old11 / d;\n                            this.elements[3] = -old10 / d;\n                            this.elements[1] = -old01 / d;\n                            this.elements[4] = old00 / d;\n                            this.elements[2] = (old01 * old12 - old11 * old02) / d;\n                            this.elements[5] = (old10 * old02 - old00 * old12) / d;\n                            return true;\n                        }\n                        return false;\n                    },\n                    /**\n     * @member PMatrix2D\n     * The scale() function increases or decreases the size of a shape by expanding and contracting vertices. When only one parameter is specified scale will occur in all dimensions.\n     * This is equivalent to a two parameter call.\n     *\n     * @param {float} sx  the amount to scale on the x-axis\n     * @param {float} sy  the amount to scale on the y-axis\n     */ scale: function(sx, sy) {\n                        if (sx && sy === undef) sy = sx;\n                        if (sx && sy) {\n                            this.elements[0] *= sx;\n                            this.elements[1] *= sy;\n                            this.elements[3] *= sx;\n                            this.elements[4] *= sy;\n                        }\n                    },\n                    /**\n      * @member PMatrix2D\n      * The invScale() function decreases or increases the size of a shape by contracting and expanding vertices. When only one parameter is specified scale will occur in all dimensions.\n      * This is equivalent to a two parameter call.\n      *\n      * @param {float} sx  the amount to scale on the x-axis\n      * @param {float} sy  the amount to scale on the y-axis\n      */ invScale: function(sx, sy) {\n                        if (sx && !sy) sy = sx;\n                        this.scale(1 / sx, 1 / sy);\n                    },\n                    /**\n     * @member PMatrix2D\n     * The apply() function multiplies the current matrix by the one specified through the parameters. Note that either a PMatrix2D or a list of floats can be passed in.\n     *\n     * @param {PMatrix2D} matrix    the matrix to apply this matrix to\n     * @param {float} m00           the first element of the matrix\n     * @param {float} m01           the third element of the matrix\n     * @param {float} m10           the fourth element of the matrix\n     * @param {float} m11           the fith element of the matrix\n     * @param {float} m12           the sixth element of the matrix\n     */ apply: function() {\n                        var source;\n                        if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) source = arguments[0].array();\n                        else if (arguments.length === 6) source = Array.prototype.slice.call(arguments);\n                        else if (arguments.length === 1 && arguments[0] instanceof Array) source = arguments[0];\n                        var result = [\n                            0,\n                            0,\n                            this.elements[2],\n                            0,\n                            0,\n                            this.elements[5]\n                        ];\n                        var e = 0;\n                        for(var row = 0; row < 2; row++)for(var col = 0; col < 3; col++, e++)result[e] += this.elements[row * 3 + 0] * source[col + 0] + this.elements[row * 3 + 1] * source[col + 3];\n                        this.elements = result.slice();\n                    },\n                    /**\n     * @member PMatrix2D\n     * The preApply() function applies another matrix to the left of this one. Note that either a PMatrix2D or elements of a matrix can be passed in.\n     *\n     * @param {PMatrix2D} matrix    the matrix to apply this matrix to\n     * @param {float} m00           the first element of the matrix\n     * @param {float} m01           the third element of the matrix\n     * @param {float} m10           the fourth element of the matrix\n     * @param {float} m11           the fith element of the matrix\n     * @param {float} m12           the sixth element of the matrix\n     */ preApply: function() {\n                        var source;\n                        if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) source = arguments[0].array();\n                        else if (arguments.length === 6) source = Array.prototype.slice.call(arguments);\n                        else if (arguments.length === 1 && arguments[0] instanceof Array) source = arguments[0];\n                        var result = [\n                            0,\n                            0,\n                            source[2],\n                            0,\n                            0,\n                            source[5]\n                        ];\n                        result[2] = source[2] + this.elements[2] * source[0] + this.elements[5] * source[1];\n                        result[5] = source[5] + this.elements[2] * source[3] + this.elements[5] * source[4];\n                        result[0] = this.elements[0] * source[0] + this.elements[3] * source[1];\n                        result[3] = this.elements[0] * source[3] + this.elements[3] * source[4];\n                        result[1] = this.elements[1] * source[0] + this.elements[4] * source[1];\n                        result[4] = this.elements[1] * source[3] + this.elements[4] * source[4];\n                        this.elements = result.slice();\n                    },\n                    /**\n     * @member PMatrix2D\n     * The rotate() function rotates the matrix.\n     *\n     * @param {float} angle         the angle of rotation in radiants\n     */ rotate: function(angle) {\n                        var c = Math.cos(angle);\n                        var s = Math.sin(angle);\n                        var temp1 = this.elements[0];\n                        var temp2 = this.elements[1];\n                        this.elements[0] = c * temp1 + s * temp2;\n                        this.elements[1] = -s * temp1 + c * temp2;\n                        temp1 = this.elements[3];\n                        temp2 = this.elements[4];\n                        this.elements[3] = c * temp1 + s * temp2;\n                        this.elements[4] = -s * temp1 + c * temp2;\n                    },\n                    /**\n     * @member PMatrix2D\n     * The rotateZ() function rotates the matrix.\n     *\n     * @param {float} angle         the angle of rotation in radiants\n     */ rotateZ: function(angle) {\n                        this.rotate(angle);\n                    },\n                    /**\n     * @member PMatrix2D\n     * The invRotateZ() function rotates the matrix in opposite direction.\n     *\n     * @param {float} angle         the angle of rotation in radiants\n     */ invRotateZ: function(angle) {\n                        this.rotateZ(angle - Math.PI);\n                    },\n                    /**\n     * @member PMatrix2D\n     * The print() function prints out the elements of this matrix\n     */ print: function() {\n                        var digits = printMatrixHelper(this.elements);\n                        var output = \"\" + p.nfs(this.elements[0], digits, 4) + \" \" + p.nfs(this.elements[1], digits, 4) + \" \" + p.nfs(this.elements[2], digits, 4) + \"\\n\" + p.nfs(this.elements[3], digits, 4) + \" \" + p.nfs(this.elements[4], digits, 4) + \" \" + p.nfs(this.elements[5], digits, 4) + \"\\n\\n\";\n                        p.println(output);\n                    }\n                };\n                return PMatrix2D;\n            };\n        },\n        {}\n    ],\n    15: [\n        function(require1, module, exports) {\n            module.exports = function(options, undef) {\n                // FIXME: hack\n                var p = options.p;\n                /**\n   * PMatrix3D is a 4x4  matrix implementation. The constructor accepts another PMatrix3D or a list of six or sixteen float elements.\n   * If no parameters are provided the matrix is set to the identity matrix.\n   */ var PMatrix3D = function() {\n                    // When a matrix is created, it is set to an identity matrix\n                    this.reset();\n                };\n                /**\n   * PMatrix3D methods\n   */ PMatrix3D.prototype = {\n                    /**\n     * @member PMatrix2D\n     * The set() function sets the matrix elements. The function accepts either another PMatrix3D, an array of elements, or a list of six or sixteen floats.\n     *\n     * @param {PMatrix3D} matrix    the initial matrix to set to\n     * @param {float[]} elements    an array of elements to set this matrix to\n     * @param {float} m00           the first element of the matrix\n     * @param {float} m01           the second element of the matrix\n     * @param {float} m02           the third element of the matrix\n     * @param {float} m03           the fourth element of the matrix\n     * @param {float} m10           the fifth element of the matrix\n     * @param {float} m11           the sixth element of the matrix\n     * @param {float} m12           the seventh element of the matrix\n     * @param {float} m13           the eight element of the matrix\n     * @param {float} m20           the nineth element of the matrix\n     * @param {float} m21           the tenth element of the matrix\n     * @param {float} m22           the eleventh element of the matrix\n     * @param {float} m23           the twelveth element of the matrix\n     * @param {float} m30           the thirteenth element of the matrix\n     * @param {float} m31           the fourtheenth element of the matrix\n     * @param {float} m32           the fivetheenth element of the matrix\n     * @param {float} m33           the sixteenth element of the matrix\n     */ set: function() {\n                        if (arguments.length === 16) this.elements = Array.prototype.slice.call(arguments);\n                        else if (arguments.length === 1 && arguments[0] instanceof PMatrix3D) this.elements = arguments[0].array();\n                        else if (arguments.length === 1 && arguments[0] instanceof Array) this.elements = arguments[0].slice();\n                    },\n                    /**\n     * @member PMatrix3D\n     * The get() function returns a copy of this PMatrix3D.\n     *\n     * @return {PMatrix3D} a copy of this PMatrix3D\n     */ get: function() {\n                        var outgoing = new PMatrix3D();\n                        outgoing.set(this.elements);\n                        return outgoing;\n                    },\n                    /**\n     * @member PMatrix3D\n     * The reset() function sets this PMatrix3D to the identity matrix.\n     */ reset: function() {\n                        this.elements = [\n                            1,\n                            0,\n                            0,\n                            0,\n                            0,\n                            1,\n                            0,\n                            0,\n                            0,\n                            0,\n                            1,\n                            0,\n                            0,\n                            0,\n                            0,\n                            1\n                        ];\n                    },\n                    /**\n     * @member PMatrix3D\n     * The array() function returns a copy of the element values.\n     * @addon\n     *\n     * @return {float[]} returns a copy of the element values\n     */ array: function array() {\n                        return this.elements.slice();\n                    },\n                    /**\n     * @member PMatrix3D\n     * The translate() function translates this matrix by moving the current coordinates to the location specified by tx, ty, and tz.\n     *\n     * @param {float} tx  the x-axis coordinate to move to\n     * @param {float} ty  the y-axis coordinate to move to\n     * @param {float} tz  the z-axis coordinate to move to\n     */ translate: function(tx, ty, tz) {\n                        if (tz === undef) tz = 0;\n                        this.elements[3] += tx * this.elements[0] + ty * this.elements[1] + tz * this.elements[2];\n                        this.elements[7] += tx * this.elements[4] + ty * this.elements[5] + tz * this.elements[6];\n                        this.elements[11] += tx * this.elements[8] + ty * this.elements[9] + tz * this.elements[10];\n                        this.elements[15] += tx * this.elements[12] + ty * this.elements[13] + tz * this.elements[14];\n                    },\n                    /**\n     * @member PMatrix3D\n     * The transpose() function transpose this matrix.\n     */ transpose: function() {\n                        var temp = this.elements[4];\n                        this.elements[4] = this.elements[1];\n                        this.elements[1] = temp;\n                        temp = this.elements[8];\n                        this.elements[8] = this.elements[2];\n                        this.elements[2] = temp;\n                        temp = this.elements[6];\n                        this.elements[6] = this.elements[9];\n                        this.elements[9] = temp;\n                        temp = this.elements[3];\n                        this.elements[3] = this.elements[12];\n                        this.elements[12] = temp;\n                        temp = this.elements[7];\n                        this.elements[7] = this.elements[13];\n                        this.elements[13] = temp;\n                        temp = this.elements[11];\n                        this.elements[11] = this.elements[14];\n                        this.elements[14] = temp;\n                    },\n                    /**\n     * @member PMatrix3D\n     * The mult() function multiplied this matrix.\n     * If two array elements are passed in the function will multiply a two element vector against this matrix.\n     * If target is null or not length four, a new float array will be returned.\n     * The values for vec and target can be the same (though that's less efficient).\n     * If two PVectors are passed in the function multiply the x and y coordinates of a PVector against this matrix.\n     *\n     * @param {PVector} source, target  the PVectors used to multiply this matrix\n     * @param {float[]} source, target  the arrays used to multiply this matrix\n     *\n     * @return {PVector|float[]} returns a PVector or an array representing the new matrix\n     */ mult: function(source, target) {\n                        var x, y, z, w;\n                        if (source instanceof PVector) {\n                            x = source.x;\n                            y = source.y;\n                            z = source.z;\n                            w = 1;\n                            if (!target) target = new PVector();\n                        } else if (source instanceof Array) {\n                            x = source[0];\n                            y = source[1];\n                            z = source[2];\n                            w = source[3] || 1;\n                            if (!target || target.length !== 3 && target.length !== 4) target = [\n                                0,\n                                0,\n                                0\n                            ];\n                        }\n                        if (target instanceof Array) {\n                            if (target.length === 3) {\n                                target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];\n                                target[1] = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];\n                                target[2] = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];\n                            } else if (target.length === 4) {\n                                target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3] * w;\n                                target[1] = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7] * w;\n                                target[2] = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11] * w;\n                                target[3] = this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15] * w;\n                            }\n                        }\n                        if (target instanceof PVector) {\n                            target.x = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];\n                            target.y = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];\n                            target.z = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];\n                        }\n                        return target;\n                    },\n                    /**\n     * @member PMatrix3D\n     * The preApply() function applies another matrix to the left of this one. Note that either a PMatrix3D or elements of a matrix can be passed in.\n     *\n     * @param {PMatrix3D} matrix    the matrix to apply this matrix to\n     * @param {float} m00           the first element of the matrix\n     * @param {float} m01           the second element of the matrix\n     * @param {float} m02           the third element of the matrix\n     * @param {float} m03           the fourth element of the matrix\n     * @param {float} m10           the fifth element of the matrix\n     * @param {float} m11           the sixth element of the matrix\n     * @param {float} m12           the seventh element of the matrix\n     * @param {float} m13           the eight element of the matrix\n     * @param {float} m20           the nineth element of the matrix\n     * @param {float} m21           the tenth element of the matrix\n     * @param {float} m22           the eleventh element of the matrix\n     * @param {float} m23           the twelveth element of the matrix\n     * @param {float} m30           the thirteenth element of the matrix\n     * @param {float} m31           the fourtheenth element of the matrix\n     * @param {float} m32           the fivetheenth element of the matrix\n     * @param {float} m33           the sixteenth element of the matrix\n     */ preApply: function() {\n                        var source;\n                        if (arguments.length === 1 && arguments[0] instanceof PMatrix3D) source = arguments[0].array();\n                        else if (arguments.length === 16) source = Array.prototype.slice.call(arguments);\n                        else if (arguments.length === 1 && arguments[0] instanceof Array) source = arguments[0];\n                        var result = [\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0\n                        ];\n                        var e = 0;\n                        for(var row = 0; row < 4; row++)for(var col = 0; col < 4; col++, e++)result[e] += this.elements[col + 0] * source[row * 4 + 0] + this.elements[col + 4] * source[row * 4 + 1] + this.elements[col + 8] * source[row * 4 + 2] + this.elements[col + 12] * source[row * 4 + 3];\n                        this.elements = result.slice();\n                    },\n                    /**\n     * @member PMatrix3D\n     * The apply() function multiplies the current matrix by the one specified through the parameters. Note that either a PMatrix3D or a list of floats can be passed in.\n     *\n     * @param {PMatrix3D} matrix    the matrix to apply this matrix to\n     * @param {float} m00           the first element of the matrix\n     * @param {float} m01           the second element of the matrix\n     * @param {float} m02           the third element of the matrix\n     * @param {float} m03           the fourth element of the matrix\n     * @param {float} m10           the fifth element of the matrix\n     * @param {float} m11           the sixth element of the matrix\n     * @param {float} m12           the seventh element of the matrix\n     * @param {float} m13           the eight element of the matrix\n     * @param {float} m20           the nineth element of the matrix\n     * @param {float} m21           the tenth element of the matrix\n     * @param {float} m22           the eleventh element of the matrix\n     * @param {float} m23           the twelveth element of the matrix\n     * @param {float} m30           the thirteenth element of the matrix\n     * @param {float} m31           the fourtheenth element of the matrix\n     * @param {float} m32           the fivetheenth element of the matrix\n     * @param {float} m33           the sixteenth element of the matrix\n     */ apply: function() {\n                        var source;\n                        if (arguments.length === 1 && arguments[0] instanceof PMatrix3D) source = arguments[0].array();\n                        else if (arguments.length === 16) source = Array.prototype.slice.call(arguments);\n                        else if (arguments.length === 1 && arguments[0] instanceof Array) source = arguments[0];\n                        var result = [\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0\n                        ];\n                        var e = 0;\n                        for(var row = 0; row < 4; row++)for(var col = 0; col < 4; col++, e++)result[e] += this.elements[row * 4 + 0] * source[col + 0] + this.elements[row * 4 + 1] * source[col + 4] + this.elements[row * 4 + 2] * source[col + 8] + this.elements[row * 4 + 3] * source[col + 12];\n                        this.elements = result.slice();\n                    },\n                    /**\n     * @member PMatrix3D\n     * The rotate() function rotates the matrix.\n     *\n     * @param {float} angle         the angle of rotation in radiants\n     */ rotate: function(angle, v0, v1, v2) {\n                        if (!v1) this.rotateZ(angle);\n                        else {\n                            // TODO should make sure this vector is normalized\n                            var c = Math.cos(angle);\n                            var s = Math.sin(angle);\n                            var t1 = 1.0 - c;\n                            this.apply(t1 * v0 * v0 + c, t1 * v0 * v1 - s * v2, t1 * v0 * v2 + s * v1, 0, t1 * v0 * v1 + s * v2, t1 * v1 * v1 + c, t1 * v1 * v2 - s * v0, 0, t1 * v0 * v2 - s * v1, t1 * v1 * v2 + s * v0, t1 * v2 * v2 + c, 0, 0, 0, 0, 1);\n                        }\n                    },\n                    /**\n     * @member PMatrix3D\n     * The invApply() function applies the inverted matrix to this matrix.\n     *\n     * @param {float} m00           the first element of the matrix\n     * @param {float} m01           the second element of the matrix\n     * @param {float} m02           the third element of the matrix\n     * @param {float} m03           the fourth element of the matrix\n     * @param {float} m10           the fifth element of the matrix\n     * @param {float} m11           the sixth element of the matrix\n     * @param {float} m12           the seventh element of the matrix\n     * @param {float} m13           the eight element of the matrix\n     * @param {float} m20           the nineth element of the matrix\n     * @param {float} m21           the tenth element of the matrix\n     * @param {float} m22           the eleventh element of the matrix\n     * @param {float} m23           the twelveth element of the matrix\n     * @param {float} m30           the thirteenth element of the matrix\n     * @param {float} m31           the fourtheenth element of the matrix\n     * @param {float} m32           the fivetheenth element of the matrix\n     * @param {float} m33           the sixteenth element of the matrix\n     *\n     * @return {boolean} returns true if the operation was successful.\n     */ invApply: function() {\n                        if (inverseCopy === undef) inverseCopy = new PMatrix3D();\n                        var a = arguments;\n                        inverseCopy.set(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n                        if (!inverseCopy.invert()) return false;\n                        this.preApply(inverseCopy);\n                        return true;\n                    },\n                    /**\n     * @member PMatrix3D\n     * The rotateZ() function rotates the matrix.\n     *\n     * @param {float} angle         the angle of rotation in radiants\n     */ rotateX: function(angle) {\n                        var c = Math.cos(angle);\n                        var s = Math.sin(angle);\n                        this.apply([\n                            1,\n                            0,\n                            0,\n                            0,\n                            0,\n                            c,\n                            -s,\n                            0,\n                            0,\n                            s,\n                            c,\n                            0,\n                            0,\n                            0,\n                            0,\n                            1\n                        ]);\n                    },\n                    /**\n     * @member PMatrix3D\n     * The rotateY() function rotates the matrix.\n     *\n     * @param {float} angle         the angle of rotation in radiants\n     */ rotateY: function(angle) {\n                        var c = Math.cos(angle);\n                        var s = Math.sin(angle);\n                        this.apply([\n                            c,\n                            0,\n                            s,\n                            0,\n                            0,\n                            1,\n                            0,\n                            0,\n                            -s,\n                            0,\n                            c,\n                            0,\n                            0,\n                            0,\n                            0,\n                            1\n                        ]);\n                    },\n                    /**\n     * @member PMatrix3D\n     * The rotateZ() function rotates the matrix.\n     *\n     * @param {float} angle         the angle of rotation in radiants\n     */ rotateZ: function(angle) {\n                        var c = Math.cos(angle);\n                        var s = Math.sin(angle);\n                        this.apply([\n                            c,\n                            -s,\n                            0,\n                            0,\n                            s,\n                            c,\n                            0,\n                            0,\n                            0,\n                            0,\n                            1,\n                            0,\n                            0,\n                            0,\n                            0,\n                            1\n                        ]);\n                    },\n                    /**\n     * @member PMatrix3D\n     * The scale() function increases or decreases the size of a matrix by expanding and contracting vertices. When only one parameter is specified scale will occur in all dimensions.\n     * This is equivalent to a three parameter call.\n     *\n     * @param {float} sx  the amount to scale on the x-axis\n     * @param {float} sy  the amount to scale on the y-axis\n     * @param {float} sz  the amount to scale on the z-axis\n     */ scale: function(sx, sy, sz) {\n                        if (sx && sy === undef && sz === undef) sy = sz = sx;\n                        else if (sx && sy && sz === undef) sz = 1;\n                        if (sx && sy && sz) {\n                            this.elements[0] *= sx;\n                            this.elements[1] *= sy;\n                            this.elements[2] *= sz;\n                            this.elements[4] *= sx;\n                            this.elements[5] *= sy;\n                            this.elements[6] *= sz;\n                            this.elements[8] *= sx;\n                            this.elements[9] *= sy;\n                            this.elements[10] *= sz;\n                            this.elements[12] *= sx;\n                            this.elements[13] *= sy;\n                            this.elements[14] *= sz;\n                        }\n                    },\n                    /**\n     * @member PMatrix3D\n     * The skewX() function skews the matrix along the x-axis the amount specified by the angle parameter.\n     * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n     *\n     * @param {float} angle  angle of skew specified in radians\n     */ skewX: function(angle) {\n                        var t1 = Math.tan(angle);\n                        this.apply(1, t1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n                    },\n                    /**\n     * @member PMatrix3D\n     * The skewY() function skews the matrix along the y-axis the amount specified by the angle parameter.\n     * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n     *\n     * @param {float} angle  angle of skew specified in radians\n     */ skewY: function(angle) {\n                        var t1 = Math.tan(angle);\n                        this.apply(1, 0, 0, 0, t1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n                    },\n                    /**\n     * @member PMatrix3D\n     * The shearX() function shears the matrix along the x-axis the amount specified by the angle parameter.\n     * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n     *\n     * @param {float} angle  angle of shear specified in radians\n     */ shearX: function(angle) {\n                        var t1 = Math.tan(angle);\n                        this.apply(1, t1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n                    },\n                    /**\n     * @member PMatrix3D\n     * The shearY() function shears the matrix along the y-axis the amount specified by the angle parameter.\n     * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n     *\n     * @param {float} angle  angle of shear specified in radians\n     */ shearY: function(angle) {\n                        var t1 = Math.tan(angle);\n                        this.apply(1, 0, 0, 0, t1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n                    },\n                    multX: function(x, y, z, w) {\n                        if (!z) return this.elements[0] * x + this.elements[1] * y + this.elements[3];\n                        if (!w) return this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];\n                        return this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3] * w;\n                    },\n                    multY: function(x, y, z, w) {\n                        if (!z) return this.elements[4] * x + this.elements[5] * y + this.elements[7];\n                        if (!w) return this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];\n                        return this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7] * w;\n                    },\n                    multZ: function(x, y, z, w) {\n                        if (!w) return this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];\n                        return this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11] * w;\n                    },\n                    multW: function(x, y, z, w) {\n                        if (!w) return this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15];\n                        return this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15] * w;\n                    },\n                    /**\n     * @member PMatrix3D\n     * The invert() function inverts this matrix\n     *\n     * @return {boolean} true if successful\n     */ invert: function() {\n                        var fA0 = this.elements[0] * this.elements[5] - this.elements[1] * this.elements[4];\n                        var fA1 = this.elements[0] * this.elements[6] - this.elements[2] * this.elements[4];\n                        var fA2 = this.elements[0] * this.elements[7] - this.elements[3] * this.elements[4];\n                        var fA3 = this.elements[1] * this.elements[6] - this.elements[2] * this.elements[5];\n                        var fA4 = this.elements[1] * this.elements[7] - this.elements[3] * this.elements[5];\n                        var fA5 = this.elements[2] * this.elements[7] - this.elements[3] * this.elements[6];\n                        var fB0 = this.elements[8] * this.elements[13] - this.elements[9] * this.elements[12];\n                        var fB1 = this.elements[8] * this.elements[14] - this.elements[10] * this.elements[12];\n                        var fB2 = this.elements[8] * this.elements[15] - this.elements[11] * this.elements[12];\n                        var fB3 = this.elements[9] * this.elements[14] - this.elements[10] * this.elements[13];\n                        var fB4 = this.elements[9] * this.elements[15] - this.elements[11] * this.elements[13];\n                        var fB5 = this.elements[10] * this.elements[15] - this.elements[11] * this.elements[14];\n                        // Determinant\n                        var fDet = fA0 * fB5 - fA1 * fB4 + fA2 * fB3 + fA3 * fB2 - fA4 * fB1 + fA5 * fB0;\n                        // Account for a very small value\n                        // return false if not successful.\n                        if (Math.abs(fDet) <= 1e-9) return false;\n                        var kInv = [];\n                        kInv[0] = +this.elements[5] * fB5 - this.elements[6] * fB4 + this.elements[7] * fB3;\n                        kInv[4] = -this.elements[4] * fB5 + this.elements[6] * fB2 - this.elements[7] * fB1;\n                        kInv[8] = +this.elements[4] * fB4 - this.elements[5] * fB2 + this.elements[7] * fB0;\n                        kInv[12] = -this.elements[4] * fB3 + this.elements[5] * fB1 - this.elements[6] * fB0;\n                        kInv[1] = -this.elements[1] * fB5 + this.elements[2] * fB4 - this.elements[3] * fB3;\n                        kInv[5] = +this.elements[0] * fB5 - this.elements[2] * fB2 + this.elements[3] * fB1;\n                        kInv[9] = -this.elements[0] * fB4 + this.elements[1] * fB2 - this.elements[3] * fB0;\n                        kInv[13] = +this.elements[0] * fB3 - this.elements[1] * fB1 + this.elements[2] * fB0;\n                        kInv[2] = +this.elements[13] * fA5 - this.elements[14] * fA4 + this.elements[15] * fA3;\n                        kInv[6] = -this.elements[12] * fA5 + this.elements[14] * fA2 - this.elements[15] * fA1;\n                        kInv[10] = +this.elements[12] * fA4 - this.elements[13] * fA2 + this.elements[15] * fA0;\n                        kInv[14] = -this.elements[12] * fA3 + this.elements[13] * fA1 - this.elements[14] * fA0;\n                        kInv[3] = -this.elements[9] * fA5 + this.elements[10] * fA4 - this.elements[11] * fA3;\n                        kInv[7] = +this.elements[8] * fA5 - this.elements[10] * fA2 + this.elements[11] * fA1;\n                        kInv[11] = -this.elements[8] * fA4 + this.elements[9] * fA2 - this.elements[11] * fA0;\n                        kInv[15] = +this.elements[8] * fA3 - this.elements[9] * fA1 + this.elements[10] * fA0;\n                        // Inverse using Determinant\n                        var fInvDet = 1.0 / fDet;\n                        kInv[0] *= fInvDet;\n                        kInv[1] *= fInvDet;\n                        kInv[2] *= fInvDet;\n                        kInv[3] *= fInvDet;\n                        kInv[4] *= fInvDet;\n                        kInv[5] *= fInvDet;\n                        kInv[6] *= fInvDet;\n                        kInv[7] *= fInvDet;\n                        kInv[8] *= fInvDet;\n                        kInv[9] *= fInvDet;\n                        kInv[10] *= fInvDet;\n                        kInv[11] *= fInvDet;\n                        kInv[12] *= fInvDet;\n                        kInv[13] *= fInvDet;\n                        kInv[14] *= fInvDet;\n                        kInv[15] *= fInvDet;\n                        this.elements = kInv.slice();\n                        return true;\n                    },\n                    toString: function() {\n                        var str = \"\";\n                        for(var i = 0; i < 15; i++)str += this.elements[i] + \", \";\n                        str += this.elements[15];\n                        return str;\n                    },\n                    /**\n     * @member PMatrix3D\n     * The print() function prints out the elements of this matrix\n     */ print: function() {\n                        var digits = printMatrixHelper(this.elements);\n                        var output = \"\" + p.nfs(this.elements[0], digits, 4) + \" \" + p.nfs(this.elements[1], digits, 4) + \" \" + p.nfs(this.elements[2], digits, 4) + \" \" + p.nfs(this.elements[3], digits, 4) + \"\\n\" + p.nfs(this.elements[4], digits, 4) + \" \" + p.nfs(this.elements[5], digits, 4) + \" \" + p.nfs(this.elements[6], digits, 4) + \" \" + p.nfs(this.elements[7], digits, 4) + \"\\n\" + p.nfs(this.elements[8], digits, 4) + \" \" + p.nfs(this.elements[9], digits, 4) + \" \" + p.nfs(this.elements[10], digits, 4) + \" \" + p.nfs(this.elements[11], digits, 4) + \"\\n\" + p.nfs(this.elements[12], digits, 4) + \" \" + p.nfs(this.elements[13], digits, 4) + \" \" + p.nfs(this.elements[14], digits, 4) + \" \" + p.nfs(this.elements[15], digits, 4) + \"\\n\\n\";\n                        p.println(output);\n                    },\n                    invTranslate: function(tx, ty, tz) {\n                        this.preApply(1, 0, 0, -tx, 0, 1, 0, -ty, 0, 0, 1, -tz, 0, 0, 0, 1);\n                    },\n                    invRotateX: function(angle) {\n                        var c = Math.cos(-angle);\n                        var s = Math.sin(-angle);\n                        this.preApply([\n                            1,\n                            0,\n                            0,\n                            0,\n                            0,\n                            c,\n                            -s,\n                            0,\n                            0,\n                            s,\n                            c,\n                            0,\n                            0,\n                            0,\n                            0,\n                            1\n                        ]);\n                    },\n                    invRotateY: function(angle) {\n                        var c = Math.cos(-angle);\n                        var s = Math.sin(-angle);\n                        this.preApply([\n                            c,\n                            0,\n                            s,\n                            0,\n                            0,\n                            1,\n                            0,\n                            0,\n                            -s,\n                            0,\n                            c,\n                            0,\n                            0,\n                            0,\n                            0,\n                            1\n                        ]);\n                    },\n                    invRotateZ: function(angle) {\n                        var c = Math.cos(-angle);\n                        var s = Math.sin(-angle);\n                        this.preApply([\n                            c,\n                            -s,\n                            0,\n                            0,\n                            s,\n                            c,\n                            0,\n                            0,\n                            0,\n                            0,\n                            1,\n                            0,\n                            0,\n                            0,\n                            0,\n                            1\n                        ]);\n                    },\n                    invScale: function(x, y, z) {\n                        this.preApply([\n                            1 / x,\n                            0,\n                            0,\n                            0,\n                            0,\n                            1 / y,\n                            0,\n                            0,\n                            0,\n                            0,\n                            1 / z,\n                            0,\n                            0,\n                            0,\n                            0,\n                            1\n                        ]);\n                    }\n                };\n                return PMatrix3D;\n            };\n        },\n        {}\n    ],\n    16: [\n        function(require1, module, exports) {\n            module.exports = function(options) {\n                var PConstants1 = options.PConstants, PMatrix2D = options.PMatrix2D, PMatrix3D = options.PMatrix3D;\n                /**\n   * Datatype for storing shapes. Processing can currently load and display SVG (Scalable Vector Graphics) shapes.\n   * Before a shape is used, it must be loaded with the <b>loadShape()</b> function. The <b>shape()</b> function is used to draw the shape to the display window.\n   * The <b>PShape</b> object contain a group of methods, linked below, that can operate on the shape data.\n   * <br><br>The <b>loadShape()</b> method supports SVG files created with Inkscape and Adobe Illustrator.\n   * It is not a full SVG implementation, but offers some straightforward support for handling vector data.\n   *\n   * @param {int} family the shape type, one of GROUP, PRIMITIVE, PATH, or GEOMETRY\n   *\n   * @see #shape()\n   * @see #loadShape()\n   * @see #shapeMode()\n   */ var PShape = function(family) {\n                    this.family = family || PConstants1.GROUP;\n                    this.visible = true;\n                    this.style = true;\n                    this.children = [];\n                    this.nameTable = [];\n                    this.params = [];\n                    this.name = \"\";\n                    this.image = null; //type PImage\n                    this.matrix = null;\n                    this.kind = null;\n                    this.close = null;\n                    this.width = null;\n                    this.height = null;\n                    this.parent = null;\n                };\n                /**\n    * PShape methods\n    * missing: findChild(), apply(), contains(), findChild(), getPrimitive(), getParams(), getVertex() , getVertexCount(),\n    * getVertexCode() , getVertexCodes() , getVertexCodeCount(), getVertexX(), getVertexY(), getVertexZ()\n    */ PShape.prototype = {\n                    /**\n     * @member PShape\n     * The isVisible() function returns a boolean value \"true\" if the image is set to be visible, \"false\" if not. This is modified with the <b>setVisible()</b> parameter.\n     * <br><br>The visibility of a shape is usually controlled by whatever program created the SVG file.\n     * For instance, this parameter is controlled by showing or hiding the shape in the layers palette in Adobe Illustrator.\n     *\n     * @return {boolean}  returns \"true\" if the image is set to be visible, \"false\" if not\n     */ isVisible: function() {\n                        return this.visible;\n                    },\n                    /**\n     * @member PShape\n     * The setVisible() function sets the shape to be visible or invisible. This is determined by the value of the <b>visible</b> parameter.\n     * <br><br>The visibility of a shape is usually controlled by whatever program created the SVG file.\n     * For instance, this parameter is controlled by showing or hiding the shape in the layers palette in Adobe Illustrator.\n     *\n     * @param {boolean} visible \"false\" makes the shape invisible and \"true\" makes it visible\n     */ setVisible: function(visible) {\n                        this.visible = visible;\n                    },\n                    /**\n     * @member PShape\n     * The disableStyle() function disables the shape's style data and uses Processing's current styles. Styles include attributes such as colors, stroke weight, and stroke joints.\n     * Overrides this shape's style information and uses PGraphics styles and colors. Identical to ignoreStyles(true). Also disables styles for all child shapes.\n     */ disableStyle: function() {\n                        this.style = false;\n                        for(var i = 0, j = this.children.length; i < j; i++)this.children[i].disableStyle();\n                    },\n                    /**\n     * @member PShape\n     * The enableStyle() function enables the shape's style data and ignores Processing's current styles. Styles include attributes such as colors, stroke weight, and stroke joints.\n     */ enableStyle: function() {\n                        this.style = true;\n                        for(var i = 0, j = this.children.length; i < j; i++)this.children[i].enableStyle();\n                    },\n                    /**\n     * @member PShape\n     * The getFamily function returns the shape type\n     *\n     * @return {int} the shape type, one of GROUP, PRIMITIVE, PATH, or GEOMETRY\n     */ getFamily: function() {\n                        return this.family;\n                    },\n                    /**\n     * @member PShape\n     * The getWidth() function gets the width of the drawing area (not necessarily the shape boundary).\n     */ getWidth: function() {\n                        return this.width;\n                    },\n                    /**\n     * @member PShape\n     * The getHeight() function gets the height of the drawing area (not necessarily the shape boundary).\n     */ getHeight: function() {\n                        return this.height;\n                    },\n                    /**\n     * @member PShape\n     * The setName() function sets the name of the shape\n     *\n     * @param {String} name the name of the shape\n     */ setName: function(name) {\n                        this.name = name;\n                    },\n                    /**\n     * @member PShape\n     * The getName() function returns the name of the shape\n     *\n     * @return {String} the name of the shape\n     */ getName: function() {\n                        return this.name;\n                    },\n                    /**\n     * @member PShape\n     * Called by the following (the shape() command adds the g)\n     * PShape s = loadShapes(\"blah.svg\");\n     * shape(s);\n     */ draw: function(renderContext) {\n                        if (!renderContext) throw \"render context missing for draw() in PShape\";\n                        if (this.visible) {\n                            this.pre(renderContext);\n                            this.drawImpl(renderContext);\n                            this.post(renderContext);\n                        }\n                    },\n                    /**\n     * @member PShape\n     * the drawImpl() function draws the SVG document.\n     */ drawImpl: function(renderContext) {\n                        if (this.family === PConstants1.GROUP) this.drawGroup(renderContext);\n                        else if (this.family === PConstants1.PRIMITIVE) this.drawPrimitive(renderContext);\n                        else if (this.family === PConstants1.GEOMETRY) this.drawGeometry(renderContext);\n                        else if (this.family === PConstants1.PATH) this.drawPath(renderContext);\n                    },\n                    /**\n     * @member PShape\n     * The drawPath() function draws the <path> part of the SVG document.\n     */ drawPath: function(renderContext) {\n                        var i, j;\n                        if (this.vertices.length === 0) return;\n                        renderContext.beginShape();\n                        if (this.vertexCodes.length === 0) {\n                            if (this.vertices[0].length === 2) for(i = 0, j = this.vertices.length; i < j; i++)renderContext.vertex(this.vertices[i][0], this.vertices[i][1]);\n                            else for(i = 0, j = this.vertices.length; i < j; i++)renderContext.vertex(this.vertices[i][0], this.vertices[i][1], this.vertices[i][2]);\n                        } else {\n                            var index = 0;\n                            if (this.vertices[0].length === 2) for(i = 0, j = this.vertexCodes.length; i < j; i++){\n                                if (this.vertexCodes[i] === PConstants1.VERTEX) {\n                                    renderContext.vertex(this.vertices[index][0], this.vertices[index][1], this.vertices[index].moveTo);\n                                    renderContext.breakShape = false;\n                                    index++;\n                                } else if (this.vertexCodes[i] === PConstants1.BEZIER_VERTEX) {\n                                    renderContext.bezierVertex(this.vertices[index + 0][0], this.vertices[index + 0][1], this.vertices[index + 1][0], this.vertices[index + 1][1], this.vertices[index + 2][0], this.vertices[index + 2][1]);\n                                    index += 3;\n                                } else if (this.vertexCodes[i] === PConstants1.CURVE_VERTEX) {\n                                    renderContext.curveVertex(this.vertices[index][0], this.vertices[index][1]);\n                                    index++;\n                                } else if (this.vertexCodes[i] === PConstants1.BREAK) renderContext.breakShape = true;\n                            }\n                            else for(i = 0, j = this.vertexCodes.length; i < j; i++){\n                                if (this.vertexCodes[i] === PConstants1.VERTEX) {\n                                    renderContext.vertex(this.vertices[index][0], this.vertices[index][1], this.vertices[index][2]);\n                                    if (this.vertices[index].moveTo === true) vertArray[vertArray.length - 1].moveTo = true;\n                                    else if (this.vertices[index].moveTo === false) vertArray[vertArray.length - 1].moveTo = false;\n                                    renderContext.breakShape = false;\n                                } else if (this.vertexCodes[i] === PConstants1.BEZIER_VERTEX) {\n                                    renderContext.bezierVertex(this.vertices[index + 0][0], this.vertices[index + 0][1], this.vertices[index + 0][2], this.vertices[index + 1][0], this.vertices[index + 1][1], this.vertices[index + 1][2], this.vertices[index + 2][0], this.vertices[index + 2][1], this.vertices[index + 2][2]);\n                                    index += 3;\n                                } else if (this.vertexCodes[i] === PConstants1.CURVE_VERTEX) {\n                                    renderContext.curveVertex(this.vertices[index][0], this.vertices[index][1], this.vertices[index][2]);\n                                    index++;\n                                } else if (this.vertexCodes[i] === PConstants1.BREAK) renderContext.breakShape = true;\n                            }\n                        }\n                        renderContext.endShape(this.close ? PConstants1.CLOSE : PConstants1.OPEN);\n                    },\n                    /**\n     * @member PShape\n     * The drawGeometry() function draws the geometry part of the SVG document.\n     */ drawGeometry: function(renderContext) {\n                        var i, j;\n                        renderContext.beginShape(this.kind);\n                        if (this.style) for(i = 0, j = this.vertices.length; i < j; i++)renderContext.vertex(this.vertices[i]);\n                        else for(i = 0, j = this.vertices.length; i < j; i++){\n                            var vert = this.vertices[i];\n                            if (vert[2] === 0) renderContext.vertex(vert[0], vert[1]);\n                            else renderContext.vertex(vert[0], vert[1], vert[2]);\n                        }\n                        renderContext.endShape();\n                    },\n                    /**\n     * @member PShape\n     * The drawGroup() function draws the <g> part of the SVG document.\n     */ drawGroup: function(renderContext) {\n                        for(var i = 0, j = this.children.length; i < j; i++)this.children[i].draw(renderContext);\n                    },\n                    /**\n     * @member PShape\n     * The drawPrimitive() function draws SVG document shape elements. These can be point, line, triangle, quad, rect, ellipse, arc, box, or sphere.\n     */ drawPrimitive: function(renderContext) {\n                        if (this.kind === PConstants1.POINT) renderContext.point(this.params[0], this.params[1]);\n                        else if (this.kind === PConstants1.LINE) {\n                            if (this.params.length === 4) renderContext.line(this.params[0], this.params[1], this.params[2], this.params[3]);\n                            else renderContext.line(this.params[0], this.params[1], this.params[2], this.params[3], this.params[4], this.params[5]);\n                        } else if (this.kind === PConstants1.TRIANGLE) renderContext.triangle(this.params[0], this.params[1], this.params[2], this.params[3], this.params[4], this.params[5]);\n                        else if (this.kind === PConstants1.QUAD) renderContext.quad(this.params[0], this.params[1], this.params[2], this.params[3], this.params[4], this.params[5], this.params[6], this.params[7]);\n                        else if (this.kind === PConstants1.RECT) {\n                            if (this.image !== null) {\n                                var imMode = imageModeConvert;\n                                renderContext.imageMode(PConstants1.CORNER);\n                                renderContext.image(this.image, this.params[0], this.params[1], this.params[2], this.params[3]);\n                                imageModeConvert = imMode;\n                            } else {\n                                var rcMode = renderContext.curRectMode;\n                                renderContext.rectMode(PConstants1.CORNER);\n                                renderContext.rect(this.params[0], this.params[1], this.params[2], this.params[3]);\n                                renderContext.curRectMode = rcMode;\n                            }\n                        } else if (this.kind === PConstants1.ELLIPSE) {\n                            var elMode = renderContext.curEllipseMode;\n                            renderContext.ellipseMode(PConstants1.CORNER);\n                            renderContext.ellipse(this.params[0], this.params[1], this.params[2], this.params[3]);\n                            renderContext.curEllipseMode = elMode;\n                        } else if (this.kind === PConstants1.ARC) {\n                            var eMode = curEllipseMode;\n                            renderContext.ellipseMode(PConstants1.CORNER);\n                            renderContext.arc(this.params[0], this.params[1], this.params[2], this.params[3], this.params[4], this.params[5]);\n                            curEllipseMode = eMode;\n                        } else if (this.kind === PConstants1.BOX) {\n                            if (this.params.length === 1) renderContext.box(this.params[0]);\n                            else renderContext.box(this.params[0], this.params[1], this.params[2]);\n                        } else if (this.kind === PConstants1.SPHERE) renderContext.sphere(this.params[0]);\n                    },\n                    /**\n     * @member PShape\n     * The pre() function performs the preparations before the SVG is drawn. This includes doing transformations and storing previous styles.\n     */ pre: function(renderContext) {\n                        if (this.matrix) {\n                            renderContext.pushMatrix();\n                            renderContext.transform(this.matrix);\n                        }\n                        if (this.style) {\n                            renderContext.pushStyle();\n                            this.styles(renderContext);\n                        }\n                    },\n                    /**\n     * @member PShape\n     * The post() function performs the necessary actions after the SVG is drawn. This includes removing transformations and removing added styles.\n     */ post: function(renderContext) {\n                        if (this.matrix) renderContext.popMatrix();\n                        if (this.style) renderContext.popStyle();\n                    },\n                    /**\n     * @member PShape\n     * The styles() function changes the Processing's current styles\n     */ styles: function(renderContext) {\n                        if (this.stroke) {\n                            renderContext.stroke(this.strokeColor);\n                            renderContext.strokeWeight(this.strokeWeight);\n                            renderContext.strokeCap(this.strokeCap);\n                            renderContext.strokeJoin(this.strokeJoin);\n                        } else renderContext.noStroke();\n                        if (this.fill) renderContext.fill(this.fillColor);\n                        else renderContext.noFill();\n                    },\n                    /**\n     * @member PShape\n     * The getChild() function extracts a child shape from a parent shape. Specify the name of the shape with the <b>target</b> parameter or the\n     * layer position of the shape to get with the <b>index</b> parameter.\n     * The shape is returned as a <b>PShape</b> object, or <b>null</b> is returned if there is an error.\n     *\n     * @param {String} target   the name of the shape to get\n     * @param {int} index   the layer position of the shape to get\n     *\n     * @return {PShape} returns a child element of a shape as a PShape object or null if there is an error\n     */ getChild: function(child) {\n                        var i, j;\n                        if (typeof child === \"number\") return this.children[child];\n                        var found;\n                        if (child === \"\" || this.name === child) return this;\n                        if (this.nameTable.length > 0) {\n                            for(i = 0, j = this.nameTable.length; i < j || found; i++)if (this.nameTable[i].getName === child) {\n                                found = this.nameTable[i];\n                                break;\n                            }\n                            if (found) return found;\n                        }\n                        for(i = 0, j = this.children.length; i < j; i++){\n                            found = this.children[i].getChild(child);\n                            if (found) return found;\n                        }\n                        return null;\n                    },\n                    /**\n     * @member PShape\n     * The getChildCount() returns the number of children\n     *\n     * @return {int} returns a count of children\n     */ getChildCount: function() {\n                        return this.children.length;\n                    },\n                    /**\n     * @member PShape\n     * The addChild() adds a child to the PShape.\n     *\n     * @param {PShape} child the child to add\n     */ addChild: function(child) {\n                        this.children.push(child);\n                        child.parent = this;\n                        if (child.getName() !== null) this.addName(child.getName(), child);\n                    },\n                    /**\n     * @member PShape\n     * The addName() functions adds a shape to the name lookup table.\n     *\n     * @param {String} name   the name to be added\n     * @param {PShape} shape  the shape\n     */ addName: function(name, shape) {\n                        if (this.parent !== null) this.parent.addName(name, shape);\n                        else this.nameTable.push([\n                            name,\n                            shape\n                        ]);\n                    },\n                    /**\n     * @member PShape\n     * The translate() function specifies an amount to displace the shape. The <b>x</b> parameter specifies left/right translation, the <b>y</b> parameter specifies up/down translation, and the <b>z</b> parameter specifies translations toward/away from the screen.\n     * Subsequent calls to the method accumulates the effect. For example, calling <b>translate(50, 0)</b> and then <b>translate(20, 0)</b> is the same as <b>translate(70, 0)</b>.\n     * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.\n     * <br><br>Using this method with the <b>z</b> parameter requires using the P3D or OPENGL parameter in combination with size.\n     *\n     * @param {int|float} x left/right translation\n     * @param {int|float} y up/down translation\n     * @param {int|float} z forward/back translation\n     *\n     * @see PMatrix2D#translate\n     * @see PMatrix3D#translate\n     */ translate: function() {\n                        if (arguments.length === 2) {\n                            this.checkMatrix(2);\n                            this.matrix.translate(arguments[0], arguments[1]);\n                        } else {\n                            this.checkMatrix(3);\n                            this.matrix.translate(arguments[0], arguments[1], 0);\n                        }\n                    },\n                    /**\n     * @member PShape\n     * The checkMatrix() function makes sure that the shape's matrix is 1) not null, and 2) has a matrix\n     * that can handle <em>at least</em> the specified number of dimensions.\n     *\n     * @param {int} dimensions the specified number of dimensions\n     */ checkMatrix: function(dimensions) {\n                        if (this.matrix === null) {\n                            if (dimensions === 2) this.matrix = new PMatrix2D();\n                            else this.matrix = new PMatrix3D();\n                        } else if (dimensions === 3 && this.matrix instanceof PMatrix2D) this.matrix = new PMatrix3D();\n                    },\n                    /**\n     * @member PShape\n     * The rotateX() function rotates a shape around the x-axis the amount specified by the <b>angle</b> parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the <b>radians()</b> method.\n     * <br><br>Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction.\n     * Subsequent calls to the method accumulates the effect. For example, calling <b>rotateX(HALF_PI)</b> and then <b>rotateX(HALF_PI)</b> is the same as <b>rotateX(PI)</b>.\n     * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.\n     * <br><br>This method requires a 3D renderer. You need to pass P3D or OPENGL as a third parameter into the <b>size()</b> method as shown in the example above.\n     *\n     * @param {float}angle angle of rotation specified in radians\n     *\n     * @see PMatrix3D#rotateX\n     */ rotateX: function(angle) {\n                        this.rotate(angle, 1, 0, 0);\n                    },\n                    /**\n     * @member PShape\n     * The rotateY() function rotates a shape around the y-axis the amount specified by the <b>angle</b> parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the <b>radians()</b> method.\n     * <br><br>Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction.\n     * Subsequent calls to the method accumulates the effect. For example, calling <b>rotateY(HALF_PI)</b> and then <b>rotateY(HALF_PI)</b> is the same as <b>rotateY(PI)</b>.\n     * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.\n     * <br><br>This method requires a 3D renderer. You need to pass P3D or OPENGL as a third parameter into the <b>size()</b> method as shown in the example above.\n     *\n     * @param {float}angle angle of rotation specified in radians\n     *\n     * @see PMatrix3D#rotateY\n     */ rotateY: function(angle) {\n                        this.rotate(angle, 0, 1, 0);\n                    },\n                    /**\n     * @member PShape\n     * The rotateZ() function rotates a shape around the z-axis the amount specified by the <b>angle</b> parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the <b>radians()</b> method.\n     * <br><br>Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction.\n     * Subsequent calls to the method accumulates the effect. For example, calling <b>rotateZ(HALF_PI)</b> and then <b>rotateZ(HALF_PI)</b> is the same as <b>rotateZ(PI)</b>.\n     * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.\n     * <br><br>This method requires a 3D renderer. You need to pass P3D or OPENGL as a third parameter into the <b>size()</b> method as shown in the example above.\n     *\n     * @param {float}angle angle of rotation specified in radians\n     *\n     * @see PMatrix3D#rotateZ\n     */ rotateZ: function(angle) {\n                        this.rotate(angle, 0, 0, 1);\n                    },\n                    /**\n     * @member PShape\n     * The rotate() function rotates a shape the amount specified by the <b>angle</b> parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the <b>radians()</b> method.\n     * <br><br>Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction.\n     * Transformations apply to everything that happens after and subsequent calls to the method accumulates the effect.\n     * For example, calling <b>rotate(HALF_PI)</b> and then <b>rotate(HALF_PI)</b> is the same as <b>rotate(PI)</b>.\n     * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.\n     * If optional parameters x,y,z are supplied, the rotate is about the point (x, y, z).\n     *\n     * @param {float}angle  angle of rotation specified in radians\n     * @param {float}x      x-coordinate of the point\n     * @param {float}y      y-coordinate of the point\n     * @param {float}z      z-coordinate of the point\n     * @see PMatrix2D#rotate\n     * @see PMatrix3D#rotate\n     */ rotate: function() {\n                        if (arguments.length === 1) {\n                            this.checkMatrix(2);\n                            this.matrix.rotate(arguments[0]);\n                        } else {\n                            this.checkMatrix(3);\n                            this.matrix.rotate(arguments[0], arguments[1], arguments[2], arguments[3]);\n                        }\n                    },\n                    /**\n     * @member PShape\n     * The scale() function increases or decreases the size of a shape by expanding and contracting vertices. Shapes always scale from the relative origin of their bounding box.\n     * Scale values are specified as decimal percentages. For example, the method call <b>scale(2.0)</b> increases the dimension of a shape by 200%.\n     * Subsequent calls to the method multiply the effect. For example, calling <b>scale(2.0)</b> and then <b>scale(1.5)</b> is the same as <b>scale(3.0)</b>.\n     * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.\n     * <br><br>Using this fuction with the <b>z</b> parameter requires passing P3D or OPENGL into the size() parameter.\n     *\n     * @param {float}s      percentage to scale the object\n     * @param {float}x      percentage to scale the object in the x-axis\n     * @param {float}y      percentage to scale the object in the y-axis\n     * @param {float}z      percentage to scale the object in the z-axis\n     *\n     * @see PMatrix2D#scale\n     * @see PMatrix3D#scale\n     */ scale: function() {\n                        if (arguments.length === 2) {\n                            this.checkMatrix(2);\n                            this.matrix.scale(arguments[0], arguments[1]);\n                        } else if (arguments.length === 3) {\n                            this.checkMatrix(2);\n                            this.matrix.scale(arguments[0], arguments[1], arguments[2]);\n                        } else {\n                            this.checkMatrix(2);\n                            this.matrix.scale(arguments[0]);\n                        }\n                    },\n                    /**\n     * @member PShape\n     * The resetMatrix() function resets the matrix\n     *\n     * @see PMatrix2D#reset\n     * @see PMatrix3D#reset\n     */ resetMatrix: function() {\n                        this.checkMatrix(2);\n                        this.matrix.reset();\n                    },\n                    /**\n     * @member PShape\n     * The applyMatrix() function multiplies this matrix by another matrix of type PMatrix3D or PMatrix2D.\n     * Individual elements can also be provided\n     *\n     * @param {PMatrix3D|PMatrix2D} matrix   the matrix to multiply by\n     *\n     * @see PMatrix2D#apply\n     * @see PMatrix3D#apply\n     */ applyMatrix: function(matrix) {\n                        if (arguments.length === 1) this.applyMatrix(matrix.elements[0], matrix.elements[1], 0, matrix.elements[2], matrix.elements[3], matrix.elements[4], 0, matrix.elements[5], 0, 0, 1, 0, 0, 0, 0, 1);\n                        else if (arguments.length === 6) {\n                            this.checkMatrix(2);\n                            this.matrix.apply(arguments[0], arguments[1], arguments[2], 0, arguments[3], arguments[4], arguments[5], 0, 0, 0, 1, 0, 0, 0, 0, 1);\n                        } else if (arguments.length === 16) {\n                            this.checkMatrix(3);\n                            this.matrix.apply(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8], arguments[9], arguments[10], arguments[11], arguments[12], arguments[13], arguments[14], arguments[15]);\n                        }\n                    }\n                };\n                return PShape;\n            };\n        },\n        {}\n    ],\n    17: [\n        function(require1, module, exports) {\n            /**\n * SVG stands for Scalable Vector Graphics, a portable graphics format. It is\n * a vector format so it allows for infinite resolution and relatively small\n * file sizes. Most modern media software can view SVG files, including Adobe\n * products, Firefox, etc. Illustrator and Inkscape can edit SVG files.\n *\n * @param {PApplet} parent     typically use \"this\"\n * @param {String} filename    name of the SVG file to load\n * @param {XMLElement} xml     an XMLElement element\n * @param {PShapeSVG} parent   the parent PShapeSVG\n *\n * @see PShape\n */ module.exports = function(options) {\n                var CommonFunctions = options.CommonFunctions, PConstants1 = options.PConstants, PShape = options.PShape, XMLElement1 = options.XMLElement, colors = options.colors;\n                var PShapeSVG1 = function() {\n                    PShape.call(this); // PShape is the base class.\n                    if (arguments.length === 1) {\n                        this.element = arguments[0];\n                        // set values to their defaults according to the SVG spec\n                        this.vertexCodes = [];\n                        this.vertices = [];\n                        this.opacity = 1;\n                        this.stroke = false;\n                        this.strokeColor = PConstants1.ALPHA_MASK;\n                        this.strokeWeight = 1;\n                        this.strokeCap = PConstants1.SQUARE; // BUTT in svg spec\n                        this.strokeJoin = PConstants1.MITER;\n                        this.strokeGradient = null;\n                        this.strokeGradientPaint = null;\n                        this.strokeName = null;\n                        this.strokeOpacity = 1;\n                        this.fill = true;\n                        this.fillColor = PConstants1.ALPHA_MASK;\n                        this.fillGradient = null;\n                        this.fillGradientPaint = null;\n                        this.fillName = null;\n                        this.fillOpacity = 1;\n                        if (this.element.getName() !== \"svg\") throw \"root is not <svg>, it's <\" + this.element.getName() + \">\";\n                    } else if (arguments.length === 2) {\n                        if (typeof arguments[1] === \"string\") {\n                            if (arguments[1].indexOf(\".svg\") > -1) {\n                                this.element = new XMLElement1(true, arguments[1]);\n                                // set values to their defaults according to the SVG spec\n                                this.vertexCodes = [];\n                                this.vertices = [];\n                                this.opacity = 1;\n                                this.stroke = false;\n                                this.strokeColor = PConstants1.ALPHA_MASK;\n                                this.strokeWeight = 1;\n                                this.strokeCap = PConstants1.SQUARE; // BUTT in svg spec\n                                this.strokeJoin = PConstants1.MITER;\n                                this.strokeGradient = \"\";\n                                this.strokeGradientPaint = \"\";\n                                this.strokeName = \"\";\n                                this.strokeOpacity = 1;\n                                this.fill = true;\n                                this.fillColor = PConstants1.ALPHA_MASK;\n                                this.fillGradient = null;\n                                this.fillGradientPaint = null;\n                                this.fillOpacity = 1;\n                            }\n                        } else if (arguments[0]) {\n                            this.element = arguments[1];\n                            this.vertexCodes = arguments[0].vertexCodes.slice();\n                            this.vertices = arguments[0].vertices.slice();\n                            this.stroke = arguments[0].stroke;\n                            this.strokeColor = arguments[0].strokeColor;\n                            this.strokeWeight = arguments[0].strokeWeight;\n                            this.strokeCap = arguments[0].strokeCap;\n                            this.strokeJoin = arguments[0].strokeJoin;\n                            this.strokeGradient = arguments[0].strokeGradient;\n                            this.strokeGradientPaint = arguments[0].strokeGradientPaint;\n                            this.strokeName = arguments[0].strokeName;\n                            this.fill = arguments[0].fill;\n                            this.fillColor = arguments[0].fillColor;\n                            this.fillGradient = arguments[0].fillGradient;\n                            this.fillGradientPaint = arguments[0].fillGradientPaint;\n                            this.fillName = arguments[0].fillName;\n                            this.strokeOpacity = arguments[0].strokeOpacity;\n                            this.fillOpacity = arguments[0].fillOpacity;\n                            this.opacity = arguments[0].opacity;\n                        }\n                    }\n                    this.name = this.element.getStringAttribute(\"id\");\n                    var displayStr = this.element.getStringAttribute(\"display\", \"inline\");\n                    this.visible = displayStr !== \"none\";\n                    var str = this.element.getAttribute(\"transform\");\n                    if (str) this.matrix = this.parseMatrix(str);\n                    // not proper parsing of the viewBox, but will cover us for cases where\n                    // the width and height of the object is not specified\n                    var viewBoxStr = this.element.getStringAttribute(\"viewBox\");\n                    if (viewBoxStr !== null) {\n                        var viewBox = viewBoxStr.split(\" \");\n                        this.width = viewBox[2];\n                        this.height = viewBox[3];\n                    }\n                    // TODO if viewbox is not same as width/height, then use it to scale\n                    // the original objects. for now, viewbox only used when width/height\n                    // are empty values (which by the spec means w/h of \"100%\"\n                    var unitWidth = this.element.getStringAttribute(\"width\");\n                    var unitHeight = this.element.getStringAttribute(\"height\");\n                    if (unitWidth !== null) {\n                        this.width = this.parseUnitSize(unitWidth);\n                        this.height = this.parseUnitSize(unitHeight);\n                    } else if (this.width === 0 || this.height === 0) {\n                        // For the spec, the default is 100% and 100%. For purposes\n                        // here, insert a dummy value because this is prolly just a\n                        // font or something for which the w/h doesn't matter.\n                        this.width = 1;\n                        this.height = 1;\n                        //show warning\n                        throw \"The width and/or height is not readable in the <svg> tag of this file.\";\n                    }\n                    this.parseColors(this.element);\n                    this.parseChildren(this.element);\n                };\n                /**\n   * PShapeSVG methods are inherited from the PShape prototype\n   */ PShapeSVG1.prototype = new PShape();\n                /**\n   * @member PShapeSVG\n   * The parseMatrix() function parses the specified SVG matrix into a PMatrix2D. Note that PMatrix2D\n   * is rotated relative to the SVG definition, so parameters are rearranged\n   * here. More about the transformation matrices in\n   * <a href=\"http://www.w3.org/TR/SVG/coords.html#TransformAttribute\">this section</a>\n   * of the SVG documentation.\n   *\n   * @param {String} str text of the matrix param.\n   *\n   * @return {PMatrix2D} a PMatrix2D\n   */ PShapeSVG1.prototype.parseMatrix = function() {\n                    function getCoords(s) {\n                        var m = [];\n                        s.replace(/\\((.*?)\\)/, function() {\n                            return function(all, params) {\n                                // get the coordinates that can be separated by spaces or a comma\n                                m = params.replace(/,+/g, \" \").split(/\\s+/);\n                            };\n                        }());\n                        return m;\n                    }\n                    return function(str) {\n                        this.checkMatrix(2);\n                        var pieces = [];\n                        str.replace(/\\s*(\\w+)\\((.*?)\\)/g, function(all) {\n                            // get a list of transform definitions\n                            pieces.push(CommonFunctions.trim(all));\n                        });\n                        if (pieces.length === 0) return null;\n                        for(var i = 0, j = pieces.length; i < j; i++){\n                            var m = getCoords(pieces[i]);\n                            if (pieces[i].indexOf(\"matrix\") !== -1) this.matrix.set(m[0], m[2], m[4], m[1], m[3], m[5]);\n                            else if (pieces[i].indexOf(\"translate\") !== -1) {\n                                var tx = m[0];\n                                var ty = m.length === 2 ? m[1] : 0;\n                                this.matrix.translate(tx, ty);\n                            } else if (pieces[i].indexOf(\"scale\") !== -1) {\n                                var sx = m[0];\n                                var sy = m.length === 2 ? m[1] : m[0];\n                                this.matrix.scale(sx, sy);\n                            } else if (pieces[i].indexOf(\"rotate\") !== -1) {\n                                var angle = m[0];\n                                if (m.length === 1) this.matrix.rotate(CommonFunctions.radians(angle));\n                                else if (m.length === 3) {\n                                    this.matrix.translate(m[1], m[2]);\n                                    this.matrix.rotate(CommonFunctions.radians(m[0]));\n                                    this.matrix.translate(-m[1], -m[2]);\n                                }\n                            } else if (pieces[i].indexOf(\"skewX\") !== -1) this.matrix.skewX(parseFloat(m[0]));\n                            else if (pieces[i].indexOf(\"skewY\") !== -1) this.matrix.skewY(m[0]);\n                            else if (pieces[i].indexOf(\"shearX\") !== -1) this.matrix.shearX(m[0]);\n                            else if (pieces[i].indexOf(\"shearY\") !== -1) this.matrix.shearY(m[0]);\n                        }\n                        return this.matrix;\n                    };\n                }();\n                /**\n   * @member PShapeSVG\n   * The parseChildren() function parses the specified XMLElement\n   *\n   * @param {XMLElement}element the XMLElement to parse\n   */ PShapeSVG1.prototype.parseChildren = function(element) {\n                    var newelement = element.getChildren();\n                    var base = new PShape();\n                    var i, j;\n                    for(i = 0, j = newelement.length; i < j; i++){\n                        var kid = this.parseChild(newelement[i]);\n                        if (kid) base.addChild(kid);\n                    }\n                    for(i = 0, j = base.children.length; i < j; i++)this.children.push(base.children[i]);\n                };\n                /**\n   * @member PShapeSVG\n   * The getName() function returns the name\n   *\n   * @return {String} the name\n   */ PShapeSVG1.prototype.getName = function() {\n                    return this.name;\n                };\n                /**\n   * @member PShapeSVG\n   * The parseChild() function parses a child XML element.\n   *\n   * @param {XMLElement} elem the element to parse\n   *\n   * @return {PShape} the newly created PShape\n   */ PShapeSVG1.prototype.parseChild = function(elem) {\n                    var name = elem.getName();\n                    var shape;\n                    if (name === \"g\") shape = new PShapeSVG1(this, elem);\n                    else if (name === \"defs\") // generally this will contain gradient info, so may\n                    // as well just throw it into a group element for parsing\n                    shape = new PShapeSVG1(this, elem);\n                    else if (name === \"line\") {\n                        shape = new PShapeSVG1(this, elem);\n                        shape.parseLine();\n                    } else if (name === \"circle\") {\n                        shape = new PShapeSVG1(this, elem);\n                        shape.parseEllipse(true);\n                    } else if (name === \"ellipse\") {\n                        shape = new PShapeSVG1(this, elem);\n                        shape.parseEllipse(false);\n                    } else if (name === \"rect\") {\n                        shape = new PShapeSVG1(this, elem);\n                        shape.parseRect();\n                    } else if (name === \"polygon\") {\n                        shape = new PShapeSVG1(this, elem);\n                        shape.parsePoly(true);\n                    } else if (name === \"polyline\") {\n                        shape = new PShapeSVG1(this, elem);\n                        shape.parsePoly(false);\n                    } else if (name === \"path\") {\n                        shape = new PShapeSVG1(this, elem);\n                        shape.parsePath();\n                    } else if (name === \"radialGradient\") //return new RadialGradient(this, elem);\n                    unimplemented(\"PShapeSVG.prototype.parseChild, name = radialGradient\");\n                    else if (name === \"linearGradient\") //return new LinearGradient(this, elem);\n                    unimplemented(\"PShapeSVG.prototype.parseChild, name = linearGradient\");\n                    else if (name === \"text\") unimplemented(\"PShapeSVG.prototype.parseChild, name = text\");\n                    else if (name === \"filter\") unimplemented(\"PShapeSVG.prototype.parseChild, name = filter\");\n                    else if (name === \"mask\") unimplemented(\"PShapeSVG.prototype.parseChild, name = mask\");\n                    return shape;\n                };\n                /**\n   * @member PShapeSVG\n   * The parsePath() function parses the <path> element of the svg file\n   * A path is defined by including a path element which contains a d=\"(path data)\" attribute, where the d attribute contains\n   * the moveto, line, curve (both cubic and quadratic Beziers), arc and closepath instructions.\n   **/ PShapeSVG1.prototype.parsePath = function() {\n                    this.family = PConstants1.PATH;\n                    this.kind = 0;\n                    var pathDataChars = [];\n                    var c;\n                    //change multiple spaces and commas to single space\n                    var pathData = CommonFunctions.trim(this.element.getStringAttribute(\"d\").replace(/[\\s,]+/g, \" \"));\n                    if (pathData === null) return;\n                    pathData = pathData.split(\"\");\n                    var cx = 0, cy = 0, ctrlX = 0, ctrlY = 0, ctrlX1 = 0, ctrlX2 = 0, ctrlY1 = 0, ctrlY2 = 0, endX = 0, endY = 0, ppx = 0, ppy = 0, px = 0, py = 0, i = 0, valOf = 0;\n                    var str = \"\";\n                    var tmpArray = [];\n                    var flag = false;\n                    var lastInstruction;\n                    var command;\n                    var j, k;\n                    while(i < pathData.length){\n                        valOf = pathData[i].charCodeAt(0);\n                        if (valOf >= 65 && valOf <= 90 || valOf >= 97 && valOf <= 122) {\n                            // if it's a letter\n                            // populate the tmpArray with coordinates\n                            j = i;\n                            i++;\n                            if (i < pathData.length) {\n                                tmpArray = [];\n                                valOf = pathData[i].charCodeAt(0);\n                                while(!(valOf >= 65 && valOf <= 90 || valOf >= 97 && valOf <= 100 || valOf >= 102 && valOf <= 122) && flag === false){\n                                    if (valOf === 32) {\n                                        // sometimes you get a space after the letter\n                                        if (str !== \"\") {\n                                            tmpArray.push(parseFloat(str));\n                                            str = \"\";\n                                        }\n                                        i++;\n                                    } else if (valOf === 45) {\n                                        // allow for 'e' notation in numbers, e.g. 2.10e-9\n                                        if (pathData[i - 1].charCodeAt(0) === 101) {\n                                            str += pathData[i].toString();\n                                            i++;\n                                        } else {\n                                            // sometimes no space separator after (ex: 104.535-16.322)\n                                            if (str !== \"\") tmpArray.push(parseFloat(str));\n                                            str = pathData[i].toString();\n                                            i++;\n                                        }\n                                    } else {\n                                        str += pathData[i].toString();\n                                        i++;\n                                    }\n                                    if (i === pathData.length) flag = true;\n                                    else valOf = pathData[i].charCodeAt(0);\n                                }\n                            }\n                            if (str !== \"\") {\n                                tmpArray.push(parseFloat(str));\n                                str = \"\";\n                            }\n                            command = pathData[j];\n                            valOf = command.charCodeAt(0);\n                            if (valOf === 77) {\n                                if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {\n                                    // need one+ pairs of co-ordinates\n                                    cx = tmpArray[0];\n                                    cy = tmpArray[1];\n                                    this.parsePathMoveto(cx, cy);\n                                    if (tmpArray.length > 2) for(j = 2, k = tmpArray.length; j < k; j += 2){\n                                        // absolute line to\n                                        cx = tmpArray[j];\n                                        cy = tmpArray[j + 1];\n                                        this.parsePathLineto(cx, cy);\n                                    }\n                                }\n                            } else if (valOf === 109) {\n                                if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {\n                                    // need one+ pairs of co-ordinates\n                                    cx += tmpArray[0];\n                                    cy += tmpArray[1];\n                                    this.parsePathMoveto(cx, cy);\n                                    if (tmpArray.length > 2) for(j = 2, k = tmpArray.length; j < k; j += 2){\n                                        // relative line to\n                                        cx += tmpArray[j];\n                                        cy += tmpArray[j + 1];\n                                        this.parsePathLineto(cx, cy);\n                                    }\n                                }\n                            } else if (valOf === 76) {\n                                if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) // need one+ pairs of co-ordinates\n                                for(j = 0, k = tmpArray.length; j < k; j += 2){\n                                    cx = tmpArray[j];\n                                    cy = tmpArray[j + 1];\n                                    this.parsePathLineto(cx, cy);\n                                }\n                            } else if (valOf === 108) {\n                                if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) // need one+ pairs of co-ordinates\n                                for(j = 0, k = tmpArray.length; j < k; j += 2){\n                                    cx += tmpArray[j];\n                                    cy += tmpArray[j + 1];\n                                    this.parsePathLineto(cx, cy);\n                                }\n                            } else if (valOf === 72) for(j = 0, k = tmpArray.length; j < k; j++){\n                                // multiple x co-ordinates can be provided\n                                cx = tmpArray[j];\n                                this.parsePathLineto(cx, cy);\n                            }\n                            else if (valOf === 104) for(j = 0, k = tmpArray.length; j < k; j++){\n                                // multiple x co-ordinates can be provided\n                                cx += tmpArray[j];\n                                this.parsePathLineto(cx, cy);\n                            }\n                            else if (valOf === 86) for(j = 0, k = tmpArray.length; j < k; j++){\n                                // multiple y co-ordinates can be provided\n                                cy = tmpArray[j];\n                                this.parsePathLineto(cx, cy);\n                            }\n                            else if (valOf === 118) for(j = 0, k = tmpArray.length; j < k; j++){\n                                // multiple y co-ordinates can be provided\n                                cy += tmpArray[j];\n                                this.parsePathLineto(cx, cy);\n                            }\n                            else if (valOf === 67) {\n                                if (tmpArray.length >= 6 && tmpArray.length % 6 === 0) // need one+ multiples of 6 co-ordinates\n                                for(j = 0, k = tmpArray.length; j < k; j += 6){\n                                    ctrlX1 = tmpArray[j];\n                                    ctrlY1 = tmpArray[j + 1];\n                                    ctrlX2 = tmpArray[j + 2];\n                                    ctrlY2 = tmpArray[j + 3];\n                                    endX = tmpArray[j + 4];\n                                    endY = tmpArray[j + 5];\n                                    this.parsePathCurveto(ctrlX1, ctrlY1, ctrlX2, ctrlY2, endX, endY);\n                                    cx = endX;\n                                    cy = endY;\n                                }\n                            } else if (valOf === 99) {\n                                if (tmpArray.length >= 6 && tmpArray.length % 6 === 0) // need one+ multiples of 6 co-ordinates\n                                for(j = 0, k = tmpArray.length; j < k; j += 6){\n                                    ctrlX1 = cx + tmpArray[j];\n                                    ctrlY1 = cy + tmpArray[j + 1];\n                                    ctrlX2 = cx + tmpArray[j + 2];\n                                    ctrlY2 = cy + tmpArray[j + 3];\n                                    endX = cx + tmpArray[j + 4];\n                                    endY = cy + tmpArray[j + 5];\n                                    this.parsePathCurveto(ctrlX1, ctrlY1, ctrlX2, ctrlY2, endX, endY);\n                                    cx = endX;\n                                    cy = endY;\n                                }\n                            } else if (valOf === 83) {\n                                if (tmpArray.length >= 4 && tmpArray.length % 4 === 0) // need one+ multiples of 4 co-ordinates\n                                for(j = 0, k = tmpArray.length; j < k; j += 4){\n                                    if (lastInstruction.toLowerCase() === \"c\" || lastInstruction.toLowerCase() === \"s\") {\n                                        ppx = this.vertices[this.vertices.length - 2][0];\n                                        ppy = this.vertices[this.vertices.length - 2][1];\n                                        px = this.vertices[this.vertices.length - 1][0];\n                                        py = this.vertices[this.vertices.length - 1][1];\n                                        ctrlX1 = px + (px - ppx);\n                                        ctrlY1 = py + (py - ppy);\n                                    } else {\n                                        //If there is no previous curve,\n                                        //the current point will be used as the first control point.\n                                        ctrlX1 = this.vertices[this.vertices.length - 1][0];\n                                        ctrlY1 = this.vertices[this.vertices.length - 1][1];\n                                    }\n                                    ctrlX2 = tmpArray[j];\n                                    ctrlY2 = tmpArray[j + 1];\n                                    endX = tmpArray[j + 2];\n                                    endY = tmpArray[j + 3];\n                                    this.parsePathCurveto(ctrlX1, ctrlY1, ctrlX2, ctrlY2, endX, endY);\n                                    cx = endX;\n                                    cy = endY;\n                                }\n                            } else if (valOf === 115) {\n                                if (tmpArray.length >= 4 && tmpArray.length % 4 === 0) // need one+ multiples of 4 co-ordinates\n                                for(j = 0, k = tmpArray.length; j < k; j += 4){\n                                    if (lastInstruction.toLowerCase() === \"c\" || lastInstruction.toLowerCase() === \"s\") {\n                                        ppx = this.vertices[this.vertices.length - 2][0];\n                                        ppy = this.vertices[this.vertices.length - 2][1];\n                                        px = this.vertices[this.vertices.length - 1][0];\n                                        py = this.vertices[this.vertices.length - 1][1];\n                                        ctrlX1 = px + (px - ppx);\n                                        ctrlY1 = py + (py - ppy);\n                                    } else {\n                                        //If there is no previous curve,\n                                        //the current point will be used as the first control point.\n                                        ctrlX1 = this.vertices[this.vertices.length - 1][0];\n                                        ctrlY1 = this.vertices[this.vertices.length - 1][1];\n                                    }\n                                    ctrlX2 = cx + tmpArray[j];\n                                    ctrlY2 = cy + tmpArray[j + 1];\n                                    endX = cx + tmpArray[j + 2];\n                                    endY = cy + tmpArray[j + 3];\n                                    this.parsePathCurveto(ctrlX1, ctrlY1, ctrlX2, ctrlY2, endX, endY);\n                                    cx = endX;\n                                    cy = endY;\n                                }\n                            } else if (valOf === 81) {\n                                if (tmpArray.length >= 4 && tmpArray.length % 4 === 0) // need one+ multiples of 4 co-ordinates\n                                for(j = 0, k = tmpArray.length; j < k; j += 4){\n                                    ctrlX = tmpArray[j];\n                                    ctrlY = tmpArray[j + 1];\n                                    endX = tmpArray[j + 2];\n                                    endY = tmpArray[j + 3];\n                                    this.parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);\n                                    cx = endX;\n                                    cy = endY;\n                                }\n                            } else if (valOf === 113) {\n                                if (tmpArray.length >= 4 && tmpArray.length % 4 === 0) // need one+ multiples of 4 co-ordinates\n                                for(j = 0, k = tmpArray.length; j < k; j += 4){\n                                    ctrlX = cx + tmpArray[j];\n                                    ctrlY = cy + tmpArray[j + 1];\n                                    endX = cx + tmpArray[j + 2];\n                                    endY = cy + tmpArray[j + 3];\n                                    this.parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);\n                                    cx = endX;\n                                    cy = endY;\n                                }\n                            } else if (valOf === 84) {\n                                // T - quadratic curve to shorthand (absolute)\n                                if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) // need one+ pairs of co-ordinates\n                                for(j = 0, k = tmpArray.length; j < k; j += 2){\n                                    if (lastInstruction.toLowerCase() === \"q\" || lastInstruction.toLowerCase() === \"t\") {\n                                        ppx = this.vertices[this.vertices.length - 2][0];\n                                        ppy = this.vertices[this.vertices.length - 2][1];\n                                        px = this.vertices[this.vertices.length - 1][0];\n                                        py = this.vertices[this.vertices.length - 1][1];\n                                        ctrlX = px + (px - ppx);\n                                        ctrlY = py + (py - ppy);\n                                    } else {\n                                        // If there is no previous command or if the previous command\n                                        // was not a Q, q, T or t, assume the control point is\n                                        // coincident with the current point.\n                                        ctrlX = cx;\n                                        ctrlY = cy;\n                                    }\n                                    endX = tmpArray[j];\n                                    endY = tmpArray[j + 1];\n                                    this.parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);\n                                    cx = endX;\n                                    cy = endY;\n                                }\n                            } else if (valOf === 116) {\n                                // t - quadratic curve to shorthand (relative)\n                                if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) // need one+ pairs of co-ordinates\n                                for(j = 0, k = tmpArray.length; j < k; j += 2){\n                                    if (lastInstruction.toLowerCase() === \"q\" || lastInstruction.toLowerCase() === \"t\") {\n                                        ppx = this.vertices[this.vertices.length - 2][0];\n                                        ppy = this.vertices[this.vertices.length - 2][1];\n                                        px = this.vertices[this.vertices.length - 1][0];\n                                        py = this.vertices[this.vertices.length - 1][1];\n                                        ctrlX = px + (px - ppx);\n                                        ctrlY = py + (py - ppy);\n                                    } else {\n                                        // If there is no previous command or if the previous command\n                                        // was not a Q, q, T or t, assume the control point is\n                                        // coincident with the current point.\n                                        ctrlX = cx;\n                                        ctrlY = cy;\n                                    }\n                                    endX = cx + tmpArray[j];\n                                    endY = cy + tmpArray[j + 1];\n                                    this.parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);\n                                    cx = endX;\n                                    cy = endY;\n                                }\n                            } else if (valOf === 90 || valOf === 122) this.close = true;\n                            lastInstruction = command.toString();\n                        } else i++;\n                    }\n                };\n                /**\n   * @member PShapeSVG\n   * PShapeSVG.parsePath() helper function\n   *\n   * @see PShapeSVG#parsePath\n   */ PShapeSVG1.prototype.parsePathQuadto = function(x1, y1, cx, cy, x2, y2) {\n                    if (this.vertices.length > 0) {\n                        this.parsePathCode(PConstants1.BEZIER_VERTEX);\n                        // x1/y1 already covered by last moveto, lineto, or curveto\n                        this.parsePathVertex(x1 + (cx - x1) * 2 / 3, y1 + (cy - y1) * 2 / 3);\n                        this.parsePathVertex(x2 + (cx - x2) * 2 / 3, y2 + (cy - y2) * 2 / 3);\n                        this.parsePathVertex(x2, y2);\n                    } else throw \"Path must start with M/m\";\n                };\n                /**\n   * @member PShapeSVG\n   * PShapeSVG.parsePath() helper function\n   *\n   * @see PShapeSVG#parsePath\n   */ PShapeSVG1.prototype.parsePathCurveto = function(x1, y1, x2, y2, x3, y3) {\n                    if (this.vertices.length > 0) {\n                        this.parsePathCode(PConstants1.BEZIER_VERTEX);\n                        this.parsePathVertex(x1, y1);\n                        this.parsePathVertex(x2, y2);\n                        this.parsePathVertex(x3, y3);\n                    } else throw \"Path must start with M/m\";\n                };\n                /**\n   * @member PShapeSVG\n   * PShapeSVG.parsePath() helper function\n   *\n   * @see PShapeSVG#parsePath\n   */ PShapeSVG1.prototype.parsePathLineto = function(px, py) {\n                    if (this.vertices.length > 0) {\n                        this.parsePathCode(PConstants1.VERTEX);\n                        this.parsePathVertex(px, py);\n                        // add property to distinguish between curContext.moveTo\n                        // or curContext.lineTo\n                        this.vertices[this.vertices.length - 1].moveTo = false;\n                    } else throw \"Path must start with M/m\";\n                };\n                PShapeSVG1.prototype.parsePathMoveto = function(px, py) {\n                    if (this.vertices.length > 0) this.parsePathCode(PConstants1.BREAK);\n                    this.parsePathCode(PConstants1.VERTEX);\n                    this.parsePathVertex(px, py);\n                    // add property to distinguish between curContext.moveTo\n                    // or curContext.lineTo\n                    this.vertices[this.vertices.length - 1].moveTo = true;\n                };\n                /**\n   * @member PShapeSVG\n   * PShapeSVG.parsePath() helper function\n   *\n   * @see PShapeSVG#parsePath\n   */ PShapeSVG1.prototype.parsePathVertex = function(x, y) {\n                    var verts = [];\n                    verts[0] = x;\n                    verts[1] = y;\n                    this.vertices.push(verts);\n                };\n                /**\n   * @member PShapeSVG\n   * PShapeSVG.parsePath() helper function\n   *\n   * @see PShapeSVG#parsePath\n   */ PShapeSVG1.prototype.parsePathCode = function(what) {\n                    this.vertexCodes.push(what);\n                };\n                /**\n   * @member PShapeSVG\n   * The parsePoly() function parses a polyline or polygon from an SVG file.\n   *\n   * @param {boolean}val true if shape is closed (polygon), false if not (polyline)\n   */ PShapeSVG1.prototype.parsePoly = function(val) {\n                    this.family = PConstants1.PATH;\n                    this.close = val;\n                    var pointsAttr = CommonFunctions.trim(this.element.getStringAttribute(\"points\").replace(/[,\\s]+/g, \" \"));\n                    if (pointsAttr !== null) {\n                        //split into array\n                        var pointsBuffer = pointsAttr.split(\" \");\n                        if (pointsBuffer.length % 2 === 0) for(var i = 0, j = pointsBuffer.length; i < j; i++){\n                            var verts = [];\n                            verts[0] = pointsBuffer[i];\n                            verts[1] = pointsBuffer[++i];\n                            this.vertices.push(verts);\n                        }\n                        else throw \"Error parsing polygon points: odd number of coordinates provided\";\n                    }\n                };\n                /**\n   * @member PShapeSVG\n   * The parseRect() function parses a rect from an SVG file.\n   */ PShapeSVG1.prototype.parseRect = function() {\n                    this.kind = PConstants1.RECT;\n                    this.family = PConstants1.PRIMITIVE;\n                    this.params = [];\n                    this.params[0] = this.element.getFloatAttribute(\"x\");\n                    this.params[1] = this.element.getFloatAttribute(\"y\");\n                    this.params[2] = this.element.getFloatAttribute(\"width\");\n                    this.params[3] = this.element.getFloatAttribute(\"height\");\n                    if (this.params[2] < 0 || this.params[3] < 0) throw \"svg error: negative width or height found while parsing <rect>\";\n                };\n                /**\n   * @member PShapeSVG\n   * The parseEllipse() function handles parsing ellipse and circle tags.\n   *\n   * @param {boolean}val true if this is a circle and not an ellipse\n   */ PShapeSVG1.prototype.parseEllipse = function(val) {\n                    this.kind = PConstants1.ELLIPSE;\n                    this.family = PConstants1.PRIMITIVE;\n                    this.params = [];\n                    this.params[0] = this.element.getFloatAttribute(\"cx\") | 0;\n                    this.params[1] = this.element.getFloatAttribute(\"cy\") | 0;\n                    var rx, ry;\n                    if (val) {\n                        rx = ry = this.element.getFloatAttribute(\"r\");\n                        if (rx < 0) throw \"svg error: negative radius found while parsing <circle>\";\n                    } else {\n                        rx = this.element.getFloatAttribute(\"rx\");\n                        ry = this.element.getFloatAttribute(\"ry\");\n                        if (rx < 0 || ry < 0) throw \"svg error: negative x-axis radius or y-axis radius found while parsing <ellipse>\";\n                    }\n                    this.params[0] -= rx;\n                    this.params[1] -= ry;\n                    this.params[2] = rx * 2;\n                    this.params[3] = ry * 2;\n                };\n                /**\n   * @member PShapeSVG\n   * The parseLine() function handles parsing line tags.\n   *\n   * @param {boolean}val true if this is a circle and not an ellipse\n   */ PShapeSVG1.prototype.parseLine = function() {\n                    this.kind = PConstants1.LINE;\n                    this.family = PConstants1.PRIMITIVE;\n                    this.params = [];\n                    this.params[0] = this.element.getFloatAttribute(\"x1\");\n                    this.params[1] = this.element.getFloatAttribute(\"y1\");\n                    this.params[2] = this.element.getFloatAttribute(\"x2\");\n                    this.params[3] = this.element.getFloatAttribute(\"y2\");\n                };\n                /**\n   * @member PShapeSVG\n   * The parseColors() function handles parsing the opacity, strijem stroke-width, stroke-linejoin,stroke-linecap, fill, and style attributes\n   *\n   * @param {XMLElement}element the element of which attributes to parse\n   */ PShapeSVG1.prototype.parseColors = function(element) {\n                    if (element.hasAttribute(\"opacity\")) this.setOpacity(element.getAttribute(\"opacity\"));\n                    if (element.hasAttribute(\"stroke\")) this.setStroke(element.getAttribute(\"stroke\"));\n                    if (element.hasAttribute(\"stroke-width\")) // if NaN (i.e. if it's 'inherit') then default\n                    // back to the inherit setting\n                    this.setStrokeWeight(element.getAttribute(\"stroke-width\"));\n                    if (element.hasAttribute(\"stroke-linejoin\")) this.setStrokeJoin(element.getAttribute(\"stroke-linejoin\"));\n                    if (element.hasAttribute(\"stroke-linecap\")) this.setStrokeCap(element.getStringAttribute(\"stroke-linecap\"));\n                    // fill defaults to black (though stroke defaults to \"none\")\n                    // http://www.w3.org/TR/SVG/painting.html#FillProperties\n                    if (element.hasAttribute(\"fill\")) this.setFill(element.getStringAttribute(\"fill\"));\n                    if (element.hasAttribute(\"style\")) {\n                        var styleText = element.getStringAttribute(\"style\");\n                        var styleTokens = styleText.toString().split(\";\");\n                        for(var i = 0, j = styleTokens.length; i < j; i++){\n                            var tokens = CommonFunctions.trim(styleTokens[i].split(\":\"));\n                            if (tokens[0] === \"fill\") this.setFill(tokens[1]);\n                            else if (tokens[0] === \"fill-opacity\") this.setFillOpacity(tokens[1]);\n                            else if (tokens[0] === \"stroke\") this.setStroke(tokens[1]);\n                            else if (tokens[0] === \"stroke-width\") this.setStrokeWeight(tokens[1]);\n                            else if (tokens[0] === \"stroke-linecap\") this.setStrokeCap(tokens[1]);\n                            else if (tokens[0] === \"stroke-linejoin\") this.setStrokeJoin(tokens[1]);\n                            else if (tokens[0] === \"stroke-opacity\") this.setStrokeOpacity(tokens[1]);\n                            else if (tokens[0] === \"opacity\") this.setOpacity(tokens[1]);\n                             // Other attributes are not yet implemented\n                        }\n                    }\n                };\n                /**\n   * @member PShapeSVG\n   * PShapeSVG.parseColors() helper function\n   *\n   * @param {String} opacityText the value of fillOpacity\n   *\n   * @see PShapeSVG#parseColors\n   */ PShapeSVG1.prototype.setFillOpacity = function(opacityText) {\n                    this.fillOpacity = parseFloat(opacityText);\n                    this.fillColor = this.fillOpacity * 255 << 24 | this.fillColor & 0xFFFFFF;\n                };\n                /**\n   * @member PShapeSVG\n   * PShapeSVG.parseColors() helper function\n   *\n   * @param {String} fillText the value of fill\n   *\n   * @see PShapeSVG#parseColors\n   */ PShapeSVG1.prototype.setFill = function(fillText) {\n                    var opacityMask = this.fillColor & 0xFF000000;\n                    if (fillText === \"none\") this.fill = false;\n                    else if (fillText.indexOf(\"#\") === 0) {\n                        this.fill = true;\n                        if (fillText.length === 4) // convert #00F to #0000FF\n                        fillText = fillText.replace(/#(.)(.)(.)/, \"#$1$1$2$2$3$3\");\n                        this.fillColor = opacityMask | parseInt(fillText.substring(1), 16) & 0xFFFFFF;\n                    } else if (fillText.indexOf(\"rgb\") === 0) {\n                        this.fill = true;\n                        this.fillColor = opacityMask | this.parseRGB(fillText);\n                    } else if (fillText.indexOf(\"url(#\") === 0) this.fillName = fillText.substring(5, fillText.length - 1);\n                    else if (colors[fillText]) {\n                        this.fill = true;\n                        this.fillColor = opacityMask | parseInt(colors[fillText].substring(1), 16) & 0xFFFFFF;\n                    }\n                };\n                /**\n   * @member PShapeSVG\n   * PShapeSVG.parseColors() helper function\n   *\n   * @param {String} opacity the value of opacity\n   *\n   * @see PShapeSVG#parseColors\n   */ PShapeSVG1.prototype.setOpacity = function(opacity) {\n                    this.strokeColor = parseFloat(opacity) * 255 << 24 | this.strokeColor & 0xFFFFFF;\n                    this.fillColor = parseFloat(opacity) * 255 << 24 | this.fillColor & 0xFFFFFF;\n                };\n                /**\n   * @member PShapeSVG\n   * PShapeSVG.parseColors() helper function\n   *\n   * @param {String} strokeText the value to set stroke to\n   *\n   * @see PShapeSVG#parseColors\n   */ PShapeSVG1.prototype.setStroke = function(strokeText) {\n                    var opacityMask = this.strokeColor & 0xFF000000;\n                    if (strokeText === \"none\") this.stroke = false;\n                    else if (strokeText.charAt(0) === \"#\") {\n                        this.stroke = true;\n                        if (strokeText.length === 4) // convert #00F to #0000FF\n                        strokeText = strokeText.replace(/#(.)(.)(.)/, \"#$1$1$2$2$3$3\");\n                        this.strokeColor = opacityMask | parseInt(strokeText.substring(1), 16) & 0xFFFFFF;\n                    } else if (strokeText.indexOf(\"rgb\") === 0) {\n                        this.stroke = true;\n                        this.strokeColor = opacityMask | this.parseRGB(strokeText);\n                    } else if (strokeText.indexOf(\"url(#\") === 0) this.strokeName = strokeText.substring(5, strokeText.length - 1);\n                    else if (colors[strokeText]) {\n                        this.stroke = true;\n                        this.strokeColor = opacityMask | parseInt(colors[strokeText].substring(1), 16) & 0xFFFFFF;\n                    }\n                };\n                /**\n   * @member PShapeSVG\n   * PShapeSVG.parseColors() helper function\n   *\n   * @param {String} weight the value to set strokeWeight to\n   *\n   * @see PShapeSVG#parseColors\n   */ PShapeSVG1.prototype.setStrokeWeight = function(weight) {\n                    this.strokeWeight = this.parseUnitSize(weight);\n                };\n                /**\n   * @member PShapeSVG\n   * PShapeSVG.parseColors() helper function\n   *\n   * @param {String} linejoin the value to set strokeJoin to\n   *\n   * @see PShapeSVG#parseColors\n   */ PShapeSVG1.prototype.setStrokeJoin = function(linejoin) {\n                    if (linejoin === \"miter\") this.strokeJoin = PConstants1.MITER;\n                    else if (linejoin === \"round\") this.strokeJoin = PConstants1.ROUND;\n                    else if (linejoin === \"bevel\") this.strokeJoin = PConstants1.BEVEL;\n                };\n                /**\n   * @member PShapeSVG\n   * PShapeSVG.parseColors() helper function\n   *\n   * @param {String} linecap the value to set strokeCap to\n   *\n   * @see PShapeSVG#parseColors\n   */ PShapeSVG1.prototype.setStrokeCap = function(linecap) {\n                    if (linecap === \"butt\") this.strokeCap = PConstants1.SQUARE;\n                    else if (linecap === \"round\") this.strokeCap = PConstants1.ROUND;\n                    else if (linecap === \"square\") this.strokeCap = PConstants1.PROJECT;\n                };\n                /**\n   * @member PShapeSVG\n   * PShapeSVG.parseColors() helper function\n   *\n   * @param {String} opacityText the value to set stroke opacity to\n   *\n   * @see PShapeSVG#parseColors\n   */ PShapeSVG1.prototype.setStrokeOpacity = function(opacityText) {\n                    this.strokeOpacity = parseFloat(opacityText);\n                    this.strokeColor = this.strokeOpacity * 255 << 24 | this.strokeColor & 0xFFFFFF;\n                };\n                /**\n   * @member PShapeSVG\n   * The parseRGB() function parses an rbg() color string and returns a color int\n   *\n   * @param {String} color the color to parse in rbg() format\n   *\n   * @return {int} the equivalent color int\n   */ PShapeSVG1.prototype.parseRGB = function(color) {\n                    var sub = color.substring(color.indexOf(\"(\") + 1, color.indexOf(\")\"));\n                    var values = sub.split(\", \");\n                    return values[0] << 16 | values[1] << 8 | values[2];\n                };\n                /**\n   * @member PShapeSVG\n   * The parseUnitSize() function parse a size that may have a suffix for its units.\n   * Ignoring cases where this could also be a percentage.\n   * The <A HREF=\"http://www.w3.org/TR/SVG/coords.html#Units\">units</A> spec:\n   * <UL>\n   * <LI>\"1pt\" equals \"1.25px\" (and therefore 1.25 user units)\n   * <LI>\"1pc\" equals \"15px\" (and therefore 15 user units)\n   * <LI>\"1mm\" would be \"3.543307px\" (3.543307 user units)\n   * <LI>\"1cm\" equals \"35.43307px\" (and therefore 35.43307 user units)\n   * <LI>\"1in\" equals \"90px\" (and therefore 90 user units)\n   * </UL>\n   */ PShapeSVG1.prototype.parseUnitSize = function(text) {\n                    var len = text.length - 2;\n                    if (len < 0) return text;\n                    if (text.indexOf(\"pt\") === len) return parseFloat(text.substring(0, len)) * 1.25;\n                    if (text.indexOf(\"pc\") === len) return parseFloat(text.substring(0, len)) * 15;\n                    if (text.indexOf(\"mm\") === len) return parseFloat(text.substring(0, len)) * 3.543307;\n                    if (text.indexOf(\"cm\") === len) return parseFloat(text.substring(0, len)) * 35.43307;\n                    if (text.indexOf(\"in\") === len) return parseFloat(text.substring(0, len)) * 90;\n                    if (text.indexOf(\"px\") === len) return parseFloat(text.substring(0, len));\n                    return parseFloat(text);\n                };\n                return PShapeSVG1;\n            };\n        },\n        {}\n    ],\n    18: [\n        function(require1, module, exports) {\n            module.exports = function(options, undef) {\n                var PConstants1 = options.PConstants;\n                function PVector1(x, y, z) {\n                    this.x = x || 0;\n                    this.y = y || 0;\n                    this.z = z || 0;\n                }\n                PVector1.fromAngle = function(angle, v) {\n                    if (v === undef || v === null) v = new PVector1();\n                    v.x = Math.cos(angle);\n                    v.y = Math.sin(angle);\n                    return v;\n                };\n                PVector1.random2D = function(v) {\n                    return PVector1.fromAngle(Math.random() * PConstants1.TWO_PI, v);\n                };\n                PVector1.random3D = function(v) {\n                    var angle = Math.random() * PConstants1.TWO_PI;\n                    var vz = Math.random() * 2 - 1;\n                    var mult = Math.sqrt(1 - vz * vz);\n                    var vx = mult * Math.cos(angle);\n                    var vy = mult * Math.sin(angle);\n                    if (v === undef || v === null) v = new PVector1(vx, vy, vz);\n                    else v.set(vx, vy, vz);\n                    return v;\n                };\n                PVector1.dist = function(v1, v2) {\n                    return v1.dist(v2);\n                };\n                PVector1.dot = function(v1, v2) {\n                    return v1.dot(v2);\n                };\n                PVector1.cross = function(v1, v2) {\n                    return v1.cross(v2);\n                };\n                PVector1.sub = function(v1, v2) {\n                    return new PVector1(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);\n                };\n                PVector1.angleBetween = function(v1, v2) {\n                    return Math.acos(v1.dot(v2) / Math.sqrt(v1.magSq() * v2.magSq()));\n                };\n                PVector1.lerp = function(v1, v2, amt) {\n                    // non-static lerp mutates object, but this version returns a new vector\n                    var retval = new PVector1(v1.x, v1.y, v1.z);\n                    retval.lerp(v2, amt);\n                    return retval;\n                };\n                // Common vector operations for PVector\n                PVector1.prototype = {\n                    set: function(v, y, z) {\n                        if (arguments.length === 1) this.set(v.x || v[0] || 0, v.y || v[1] || 0, v.z || v[2] || 0);\n                        else {\n                            this.x = v;\n                            this.y = y;\n                            this.z = z;\n                        }\n                    },\n                    get: function() {\n                        return new PVector1(this.x, this.y, this.z);\n                    },\n                    mag: function() {\n                        var x = this.x, y = this.y, z = this.z;\n                        return Math.sqrt(x * x + y * y + z * z);\n                    },\n                    magSq: function() {\n                        var x = this.x, y = this.y, z = this.z;\n                        return x * x + y * y + z * z;\n                    },\n                    setMag: function(v_or_len, len) {\n                        if (len === undef) {\n                            len = v_or_len;\n                            this.normalize();\n                            this.mult(len);\n                        } else {\n                            var v = v_or_len;\n                            v.normalize();\n                            v.mult(len);\n                            return v;\n                        }\n                    },\n                    add: function(v, y, z) {\n                        if (arguments.length === 1) {\n                            this.x += v.x;\n                            this.y += v.y;\n                            this.z += v.z;\n                        } else if (arguments.length === 2) {\n                            // 2D Vector\n                            this.x += v;\n                            this.y += y;\n                        } else {\n                            this.x += v;\n                            this.y += y;\n                            this.z += z;\n                        }\n                    },\n                    sub: function(v, y, z) {\n                        if (arguments.length === 1) {\n                            this.x -= v.x;\n                            this.y -= v.y;\n                            this.z -= v.z;\n                        } else if (arguments.length === 2) {\n                            // 2D Vector\n                            this.x -= v;\n                            this.y -= y;\n                        } else {\n                            this.x -= v;\n                            this.y -= y;\n                            this.z -= z;\n                        }\n                    },\n                    mult: function(v) {\n                        if (typeof v === \"number\") {\n                            this.x *= v;\n                            this.y *= v;\n                            this.z *= v;\n                        } else {\n                            this.x *= v.x;\n                            this.y *= v.y;\n                            this.z *= v.z;\n                        }\n                    },\n                    div: function(v) {\n                        if (typeof v === \"number\") {\n                            this.x /= v;\n                            this.y /= v;\n                            this.z /= v;\n                        } else {\n                            this.x /= v.x;\n                            this.y /= v.y;\n                            this.z /= v.z;\n                        }\n                    },\n                    rotate: function(angle) {\n                        var prev_x = this.x;\n                        var c = Math.cos(angle);\n                        var s = Math.sin(angle);\n                        this.x = c * this.x - s * this.y;\n                        this.y = s * prev_x + c * this.y;\n                    },\n                    dist: function(v) {\n                        var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n                        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n                    },\n                    dot: function(v, y, z) {\n                        if (arguments.length === 1) return this.x * v.x + this.y * v.y + this.z * v.z;\n                        return this.x * v + this.y * y + this.z * z;\n                    },\n                    cross: function(v) {\n                        var x = this.x, y = this.y, z = this.z;\n                        return new PVector1(y * v.z - v.y * z, z * v.x - v.z * x, x * v.y - v.x * y);\n                    },\n                    lerp: function(v_or_x, amt_or_y, z, amt) {\n                        var lerp_val = function(start, stop, amt) {\n                            return start + (stop - start) * amt;\n                        };\n                        var x, y;\n                        if (arguments.length === 2) {\n                            // given vector and amt\n                            amt = amt_or_y;\n                            x = v_or_x.x;\n                            y = v_or_x.y;\n                            z = v_or_x.z;\n                        } else {\n                            // given x, y, z and amt\n                            x = v_or_x;\n                            y = amt_or_y;\n                        }\n                        this.x = lerp_val(this.x, x, amt);\n                        this.y = lerp_val(this.y, y, amt);\n                        this.z = lerp_val(this.z, z, amt);\n                    },\n                    normalize: function() {\n                        var m = this.mag();\n                        if (m > 0) this.div(m);\n                    },\n                    limit: function(high) {\n                        if (this.mag() > high) {\n                            this.normalize();\n                            this.mult(high);\n                        }\n                    },\n                    heading: function() {\n                        return -Math.atan2(-this.y, this.x);\n                    },\n                    heading2D: function() {\n                        return this.heading();\n                    },\n                    toString: function() {\n                        return \"[\" + this.x + \", \" + this.y + \", \" + this.z + \"]\";\n                    },\n                    array: function() {\n                        return [\n                            this.x,\n                            this.y,\n                            this.z\n                        ];\n                    }\n                };\n                function createPVectorMethod(method) {\n                    return function(v1, v2) {\n                        var v = v1.get();\n                        v[method](v2);\n                        return v;\n                    };\n                }\n                for(var method in PVector1.prototype)if (PVector1.prototype.hasOwnProperty(method) && !PVector1.hasOwnProperty(method)) PVector1[method] = createPVectorMethod(method);\n                return PVector1;\n            };\n        },\n        {}\n    ],\n    19: [\n        function(require1, module, exports) {\n            /**\n * XMLAttribute is an attribute of a XML element.\n *\n * @param {String} fname     the full name of the attribute\n * @param {String} n         the short name of the attribute\n * @param {String} namespace the namespace URI of the attribute\n * @param {String} v         the value of the attribute\n * @param {String }t         the type of the attribute\n *\n * @see XMLElement\n */ module.exports = function() {\n                var XMLAttribute = function(fname, n, nameSpace, v, t1) {\n                    this.fullName = fname || \"\";\n                    this.name = n || \"\";\n                    this.namespace = nameSpace || \"\";\n                    this.value = v;\n                    this.type = t1;\n                };\n                XMLAttribute.prototype = {\n                    /**\n     * @member XMLAttribute\n     * The getName() function returns the short name of the attribute\n     *\n     * @return {String} the short name of the attribute\n     */ getName: function() {\n                        return this.name;\n                    },\n                    /**\n     * @member XMLAttribute\n     * The getFullName() function returns the full name of the attribute\n     *\n     * @return {String} the full name of the attribute\n     */ getFullName: function() {\n                        return this.fullName;\n                    },\n                    /**\n     * @member XMLAttribute\n     * The getNamespace() function returns the namespace of the attribute\n     *\n     * @return {String} the namespace of the attribute\n     */ getNamespace: function() {\n                        return this.namespace;\n                    },\n                    /**\n     * @member XMLAttribute\n     * The getValue() function returns the value of the attribute\n     *\n     * @return {String} the value of the attribute\n     */ getValue: function() {\n                        return this.value;\n                    },\n                    /**\n     * @member XMLAttribute\n     * The getValue() function returns the type of the attribute\n     *\n     * @return {String} the type of the attribute\n     */ getType: function() {\n                        return this.type;\n                    },\n                    /**\n     * @member XMLAttribute\n     * The setValue() function sets the value of the attribute\n     *\n     * @param {String} newval the new value\n     */ setValue: function(newval) {\n                        this.value = newval;\n                    }\n                };\n                return XMLAttribute;\n            };\n        },\n        {}\n    ],\n    20: [\n        function(require1, module, exports) {\n            /**\n * XMLElement is a representation of an XML object. The object is able to parse XML code\n *\n * @param {PApplet} parent   typically use \"this\"\n * @param {String} filename  name of the XML/SVG file to load\n * @param {String} xml       the xml/svg string\n * @param {String} fullname  the full name of the element\n * @param {String} namespace the namespace  of the URI\n * @param {String} systemID  the system ID of the XML data where the element starts\n * @param {Integer }lineNr   the line in the XML data where the element starts\n */ module.exports = function(options, undef) {\n                var Browser = options.Browser, ajax = Browser.ajax, window1 = Browser.window, XMLHttpRequest1 = window1.XMLHttpRequest, DOMParser = window1.DOMParser, XMLAttribute = options.XMLAttribute;\n                var XMLElement1 = function(selector, uri, sysid, line) {\n                    this.attributes = [];\n                    this.children = [];\n                    this.fullName = null;\n                    this.name = null;\n                    this.namespace = \"\";\n                    this.content = null;\n                    this.parent = null;\n                    this.lineNr = \"\";\n                    this.systemID = \"\";\n                    this.type = \"ELEMENT\";\n                    if (selector) {\n                        if (typeof selector === \"string\") {\n                            if (uri === undef && selector.indexOf(\"<\") > -1) // load XML from text string\n                            this.parse(selector);\n                            else {\n                                // XMLElement(fullname, namespace, sysid, line) format\n                                this.fullName = selector;\n                                this.namespace = uri;\n                                this.systemId = sysid;\n                                this.lineNr = line;\n                            }\n                        } else // XMLElement(this, file uri) format\n                        this.parse(uri, true);\n                    }\n                };\n                /**\n   * XMLElement methods\n   * missing: enumerateAttributeNames(), enumerateChildren(),\n   * NOTE: parse does not work when a url is passed in\n   */ XMLElement1.prototype = {\n                    /**\n     * @member XMLElement\n     * The parse() function retrieves the file via ajax() and uses DOMParser()\n     * parseFromString method to make an XML document\n     * @addon\n     *\n     * @param {String} filename name of the XML/SVG file to load\n     *\n     * @throws ExceptionType Error loading document\n     *\n     * @see XMLElement#parseChildrenRecursive\n     */ parse: function(textstring, stringIsURI) {\n                        var xmlDoc;\n                        try {\n                            if (stringIsURI) textstring = ajax(textstring);\n                            xmlDoc = new DOMParser().parseFromString(textstring, \"text/xml\");\n                            var elements = xmlDoc.documentElement;\n                            if (elements) this.parseChildrenRecursive(null, elements);\n                            else throw \"Error loading document\";\n                            return this;\n                        } catch (e) {\n                            throw e;\n                        }\n                    },\n                    /**\n     * @member XMLElement\n     * Internal helper function for parse().\n     * Loops through the\n     * @addon\n     *\n     * @param {XMLElement} parent                      the parent node\n     * @param {XML document childNodes} elementpath    the remaining nodes that need parsing\n     *\n     * @return {XMLElement} the new element and its children elements\n     */ parseChildrenRecursive: function(parent, elementpath) {\n                        var xmlelement, xmlattribute, tmpattrib, l, m, child;\n                        if (!parent) {\n                            this.fullName = elementpath.localName;\n                            this.name = elementpath.nodeName;\n                            xmlelement = this;\n                        } else {\n                            xmlelement = new XMLElement1(elementpath.nodeName);\n                            xmlelement.parent = parent;\n                        }\n                        // if this is a text node, return a PCData element (parsed character data)\n                        if (elementpath.nodeType === 3 && elementpath.textContent !== \"\") return this.createPCDataElement(elementpath.textContent);\n                        // if this is a CDATA node, return a CData element (unparsed character data)\n                        if (elementpath.nodeType === 4) return this.createCDataElement(elementpath.textContent);\n                        // bind all attributes, if there are any\n                        if (elementpath.attributes) for(l = 0, m = elementpath.attributes.length; l < m; l++){\n                            tmpattrib = elementpath.attributes[l];\n                            xmlattribute = new XMLAttribute(tmpattrib.getname, tmpattrib.nodeName, tmpattrib.namespaceURI, tmpattrib.nodeValue, tmpattrib.nodeType);\n                            xmlelement.attributes.push(xmlattribute);\n                        }\n                        // bind all children, if there are any\n                        if (elementpath.childNodes) for(l = 0, m = elementpath.childNodes.length; l < m; l++){\n                            var node = elementpath.childNodes[l];\n                            child = xmlelement.parseChildrenRecursive(xmlelement, node);\n                            if (child !== null) xmlelement.children.push(child);\n                        }\n                        return xmlelement;\n                    },\n                    /**\n     * @member XMLElement\n     * The createElement() function Creates an empty element\n     *\n     * @param {String} fullName   the full name of the element\n     * @param {String} namespace  the namespace URI\n     * @param {String} systemID   the system ID of the XML data where the element starts\n     * @param {int} lineNr    the line in the XML data where the element starts\n     */ createElement: function(fullname, namespaceuri, sysid, line) {\n                        if (sysid === undef) return new XMLElement1(fullname, namespaceuri);\n                        return new XMLElement1(fullname, namespaceuri, sysid, line);\n                    },\n                    /**\n     * @member XMLElement\n     * The createPCDataElement() function creates an element to be used for #PCDATA content.\n     * Because Processing discards whitespace TEXT nodes, this method will not build an element\n     * if the passed content is empty after trimming for whitespace.\n     *\n     * @return {XMLElement} new \"pcdata\" XMLElement, or null if content consists only of whitespace\n     */ createPCDataElement: function(content, isCDATA) {\n                        if (content.replace(/^\\s+$/g, \"\") === \"\") return null;\n                        var pcdata = new XMLElement1();\n                        pcdata.type = \"TEXT\";\n                        pcdata.content = content;\n                        return pcdata;\n                    },\n                    /**\n     * @member XMLElement\n     * The createCDataElement() function creates an element to be used for CDATA content.\n     *\n     * @return {XMLElement} new \"cdata\" XMLElement, or null if content consists only of whitespace\n     */ createCDataElement: function(content) {\n                        var cdata = this.createPCDataElement(content);\n                        if (cdata === null) return null;\n                        cdata.type = \"CDATA\";\n                        var htmlentities = {\n                            \"<\": \"&lt;\",\n                            \">\": \"&gt;\",\n                            \"'\": \"&apos;\",\n                            '\"': \"&quot;\"\n                        }, entity;\n                        for(entity in htmlentities)if (!Object.hasOwnProperty(htmlentities, entity)) content = content.replace(new RegExp(entity, \"g\"), htmlentities[entity]);\n                        cdata.cdata = content;\n                        return cdata;\n                    },\n                    /**\n     * @member XMLElement\n     * The hasAttribute() function returns whether an attribute exists\n     *\n     * @param {String} name      name of the attribute\n     * @param {String} namespace the namespace URI of the attribute\n     *\n     * @return {boolean} true if the attribute exists\n     */ hasAttribute: function() {\n                        if (arguments.length === 1) return this.getAttribute(arguments[0]) !== null;\n                        if (arguments.length === 2) return this.getAttribute(arguments[0], arguments[1]) !== null;\n                    },\n                    /**\n     * @member XMLElement\n     * The equals() function checks to see if the XMLElement being passed in equals another XMLElement\n     *\n     * @param {XMLElement} rawElement the element to compare to\n     *\n     * @return {boolean} true if the element equals another element\n     */ equals: function(other) {\n                        if (!(other instanceof XMLElement1)) return false;\n                        var i, j;\n                        if (this.fullName !== other.fullName) return false;\n                        if (this.attributes.length !== other.getAttributeCount()) return false;\n                        // attributes may be ordered differently\n                        if (this.attributes.length !== other.attributes.length) return false;\n                        var attr_name, attr_ns, attr_value, attr_type, attr_other;\n                        for(i = 0, j = this.attributes.length; i < j; i++){\n                            attr_name = this.attributes[i].getName();\n                            attr_ns = this.attributes[i].getNamespace();\n                            attr_other = other.findAttribute(attr_name, attr_ns);\n                            if (attr_other === null) return false;\n                            if (this.attributes[i].getValue() !== attr_other.getValue()) return false;\n                            if (this.attributes[i].getType() !== attr_other.getType()) return false;\n                        }\n                        // children must be ordered identically\n                        if (this.children.length !== other.getChildCount()) return false;\n                        if (this.children.length > 0) {\n                            var child1, child2;\n                            for(i = 0, j = this.children.length; i < j; i++){\n                                child1 = this.getChild(i);\n                                child2 = other.getChild(i);\n                                if (!child1.equals(child2)) return false;\n                            }\n                            return true;\n                        }\n                        return this.content === other.content;\n                    },\n                    /**\n     * @member XMLElement\n     * The getContent() function returns the content of an element. If there is no such content, null is returned\n     *\n     * @return {String} the (possibly null) content\n     */ getContent: function() {\n                        if (this.type === \"TEXT\" || this.type === \"CDATA\") return this.content;\n                        var children = this.children;\n                        if (children.length === 1 && (children[0].type === \"TEXT\" || children[0].type === \"CDATA\")) return children[0].content;\n                        return null;\n                    },\n                    /**\n     * @member XMLElement\n     * The getAttribute() function returns the value of an attribute\n     *\n     * @param {String} name         the non-null full name of the attribute\n     * @param {String} namespace    the namespace URI, which may be null\n     * @param {String} defaultValue the default value of the attribute\n     *\n     * @return {String} the value, or defaultValue if the attribute does not exist\n     */ getAttribute: function() {\n                        var attribute;\n                        if (arguments.length === 2) {\n                            attribute = this.findAttribute(arguments[0]);\n                            if (attribute) return attribute.getValue();\n                            return arguments[1];\n                        } else if (arguments.length === 1) {\n                            attribute = this.findAttribute(arguments[0]);\n                            if (attribute) return attribute.getValue();\n                            return null;\n                        } else if (arguments.length === 3) {\n                            attribute = this.findAttribute(arguments[0], arguments[1]);\n                            if (attribute) return attribute.getValue();\n                            return arguments[2];\n                        }\n                    },\n                    /**\n     * @member XMLElement\n     * The getStringAttribute() function returns the string attribute of the element\n     * If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> value is returned.\n     * When calling the function without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value 0 is returned.\n     *\n     * @param name         the name of the attribute\n     * @param defaultValue value returned if the attribute is not found\n     *\n     * @return {String} the value, or defaultValue if the attribute does not exist\n     */ getStringAttribute: function() {\n                        if (arguments.length === 1) return this.getAttribute(arguments[0]);\n                        if (arguments.length === 2) return this.getAttribute(arguments[0], arguments[1]);\n                        return this.getAttribute(arguments[0], arguments[1], arguments[2]);\n                    },\n                    /**\n     * Processing 1.5 XML API wrapper for the generic String\n     * attribute getter. This may only take one argument.\n     */ getString: function(attributeName) {\n                        return this.getStringAttribute(attributeName);\n                    },\n                    /**\n     * @member XMLElement\n     * The getFloatAttribute() function returns the float attribute of the element.\n     * If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> value is returned.\n     * When calling the function without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value 0 is returned.\n     *\n     * @param name         the name of the attribute\n     * @param defaultValue value returned if the attribute is not found\n     *\n     * @return {float} the value, or defaultValue if the attribute does not exist\n     */ getFloatAttribute: function() {\n                        if (arguments.length === 1) return parseFloat(this.getAttribute(arguments[0], 0));\n                        if (arguments.length === 2) return this.getAttribute(arguments[0], arguments[1]);\n                        return this.getAttribute(arguments[0], arguments[1], arguments[2]);\n                    },\n                    /**\n     * Processing 1.5 XML API wrapper for the generic float\n     * attribute getter. This may only take one argument.\n     */ getFloat: function(attributeName) {\n                        return this.getFloatAttribute(attributeName);\n                    },\n                    /**\n     * @member XMLElement\n     * The getIntAttribute() function returns the integer attribute of the element.\n     * If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> value is returned.\n     * When calling the function without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value 0 is returned.\n     *\n     * @param name         the name of the attribute\n     * @param defaultValue value returned if the attribute is not found\n     *\n     * @return {int} the value, or defaultValue if the attribute does not exist\n     */ getIntAttribute: function() {\n                        if (arguments.length === 1) return this.getAttribute(arguments[0], 0);\n                        if (arguments.length === 2) return this.getAttribute(arguments[0], arguments[1]);\n                        return this.getAttribute(arguments[0], arguments[1], arguments[2]);\n                    },\n                    /**\n     * Processing 1.5 XML API wrapper for the generic int\n     * attribute getter. This may only take one argument.\n     */ getInt: function(attributeName) {\n                        return this.getIntAttribute(attributeName);\n                    },\n                    /**\n     * @member XMLElement\n     * The hasChildren() function returns whether the element has children.\n     *\n     * @return {boolean} true if the element has children.\n     */ hasChildren: function() {\n                        return this.children.length > 0;\n                    },\n                    /**\n     * @member XMLElement\n     * The addChild() function adds a child element\n     *\n     * @param {XMLElement} child the non-null child to add.\n     */ addChild: function(child) {\n                        if (child !== null) {\n                            child.parent = this;\n                            this.children.push(child);\n                        }\n                    },\n                    /**\n     * @member XMLElement\n     * The insertChild() function inserts a child element at the index provided\n     *\n     * @param {XMLElement} child  the non-null child to add.\n     * @param {int} index     where to put the child.\n     */ insertChild: function(child, index) {\n                        if (child) {\n                            if (child.getLocalName() === null && !this.hasChildren()) {\n                                var lastChild = this.children[this.children.length - 1];\n                                if (lastChild.getLocalName() === null) {\n                                    lastChild.setContent(lastChild.getContent() + child.getContent());\n                                    return;\n                                }\n                            }\n                            child.parent = this;\n                            this.children.splice(index, 0, child);\n                        }\n                    },\n                    /**\n     * @member XMLElement\n     * The getChild() returns the child XMLElement as specified by the <b>index</b> parameter.\n     * The value of the <b>index</b> parameter must be less than the total number of children to avoid going out of the array storing the child elements.\n     * When the <b>path</b> parameter is specified, then it will return all children that match that path. The path is a series of elements and sub-elements, separated by slashes.\n     *\n     * @param {int} index     where to put the child.\n     * @param {String} path       path to a particular element\n     *\n     * @return {XMLElement} the element\n     */ getChild: function(selector) {\n                        if (typeof selector === \"number\") return this.children[selector];\n                        if (selector.indexOf(\"/\") !== -1) // path traversal is required\n                        return this.getChildRecursive(selector.split(\"/\"), 0);\n                        var kid, kidName;\n                        for(var i = 0, j = this.getChildCount(); i < j; i++){\n                            kid = this.getChild(i);\n                            kidName = kid.getName();\n                            if (kidName !== null && kidName === selector) return kid;\n                        }\n                        return null;\n                    },\n                    /**\n     * @member XMLElement\n     * The getChildren() returns all of the children as an XMLElement array.\n     * When the <b>path</b> parameter is specified, then it will return all children that match that path.\n     * The path is a series of elements and sub-elements, separated by slashes.\n     *\n     * @param {String} path       element name or path/to/element\n     *\n     * @return {XMLElement} array of child elements that match\n     *\n     * @see XMLElement#getChildCount()\n     * @see XMLElement#getChild()\n     */ getChildren: function() {\n                        if (arguments.length === 1) {\n                            if (typeof arguments[0] === \"number\") return this.getChild(arguments[0]);\n                            if (arguments[0].indexOf(\"/\") !== -1) return this.getChildrenRecursive(arguments[0].split(\"/\"), 0);\n                            var matches = [];\n                            var kid, kidName;\n                            for(var i = 0, j = this.getChildCount(); i < j; i++){\n                                kid = this.getChild(i);\n                                kidName = kid.getName();\n                                if (kidName !== null && kidName === arguments[0]) matches.push(kid);\n                            }\n                            return matches;\n                        }\n                        return this.children;\n                    },\n                    /**\n     * @member XMLElement\n     * The getChildCount() returns the number of children for the element.\n     *\n     * @return {int} the count\n     *\n     * @see XMLElement#getChild()\n     * @see XMLElement#getChildren()\n     */ getChildCount: function() {\n                        return this.children.length;\n                    },\n                    /**\n     * @member XMLElement\n     * Internal helper function for getChild().\n     *\n     * @param {String[]} items   result of splitting the query on slashes\n     * @param {int} offset   where in the items[] array we're currently looking\n     *\n     * @return {XMLElement} matching element or null if no match\n     */ getChildRecursive: function(items, offset) {\n                        // terminating clause: we are the requested candidate\n                        if (offset === items.length) return this;\n                        // continuation clause\n                        var kid, kidName, matchName = items[offset];\n                        for(var i = 0, j = this.getChildCount(); i < j; i++){\n                            kid = this.getChild(i);\n                            kidName = kid.getName();\n                            if (kidName !== null && kidName === matchName) return kid.getChildRecursive(items, offset + 1);\n                        }\n                        return null;\n                    },\n                    /**\n     * @member XMLElement\n     * Internal helper function for getChildren().\n     *\n     * @param {String[]} items   result of splitting the query on slashes\n     * @param {int} offset   where in the items[] array we're currently looking\n     *\n     * @return {XMLElement[]} matching elements or empty array if no match\n     */ getChildrenRecursive: function(items, offset) {\n                        if (offset === items.length - 1) return this.getChildren(items[offset]);\n                        var matches = this.getChildren(items[offset]);\n                        var kidMatches = [];\n                        for(var i = 0; i < matches.length; i++)kidMatches = kidMatches.concat(matches[i].getChildrenRecursive(items, offset + 1));\n                        return kidMatches;\n                    },\n                    /**\n     * @member XMLElement\n     * The isLeaf() function returns whether the element is a leaf element.\n     *\n     * @return {boolean} true if the element has no children.\n     */ isLeaf: function() {\n                        return !this.hasChildren();\n                    },\n                    /**\n     * @member XMLElement\n     * The listChildren() function put the names of all children into an array. Same as looping through\n     * each child and calling getName() on each XMLElement.\n     *\n     * @return {String[]} a list of element names.\n     */ listChildren: function() {\n                        var arr = [];\n                        for(var i = 0, j = this.children.length; i < j; i++)arr.push(this.getChild(i).getName());\n                        return arr;\n                    },\n                    /**\n     * @member XMLElement\n     * The removeAttribute() function removes an attribute\n     *\n     * @param {String} name        the non-null name of the attribute.\n     * @param {String} namespace   the namespace URI of the attribute, which may be null.\n     */ removeAttribute: function(name, namespace) {\n                        this.namespace = namespace || \"\";\n                        for(var i = 0, j = this.attributes.length; i < j; i++)if (this.attributes[i].getName() === name && this.attributes[i].getNamespace() === this.namespace) {\n                            this.attributes.splice(i, 1);\n                            break;\n                        }\n                    },\n                    /**\n     * @member XMLElement\n     * The removeChild() removes a child element.\n     *\n     * @param {XMLElement} child      the the non-null child to be renoved\n     */ removeChild: function(child) {\n                        if (child) {\n                            for(var i = 0, j = this.children.length; i < j; i++)if (this.children[i].equals(child)) {\n                                this.children.splice(i, 1);\n                                break;\n                            }\n                        }\n                    },\n                    /**\n     * @member XMLElement\n     * The removeChildAtIndex() removes the child located at a certain index\n     *\n     * @param {int} index      the index of the child, where the first child has index 0\n     */ removeChildAtIndex: function(index) {\n                        if (this.children.length > index) this.children.splice(index, 1);\n                    },\n                    /**\n     * @member XMLElement\n     * The findAttribute() function searches an attribute\n     *\n     * @param {String} name        fullName the non-null full name of the attribute\n     * @param {String} namespace   the name space, which may be null\n     *\n     * @return {XMLAttribute} the attribute, or null if the attribute does not exist.\n     */ findAttribute: function(name, namespace) {\n                        this.namespace = namespace || \"\";\n                        for(var i = 0, j = this.attributes.length; i < j; i++){\n                            if (this.attributes[i].getName() === name && this.attributes[i].getNamespace() === this.namespace) return this.attributes[i];\n                        }\n                        return null;\n                    },\n                    /**\n     * @member XMLElement\n     * The setAttribute() function sets an attribute.\n     *\n     * @param {String} name        the non-null full name of the attribute\n     * @param {String} namespace   the non-null value of the attribute\n     */ setAttribute: function() {\n                        var attr;\n                        if (arguments.length === 3) {\n                            var index = arguments[0].indexOf(\":\");\n                            var name = arguments[0].substring(index + 1);\n                            attr = this.findAttribute(name, arguments[1]);\n                            if (attr) attr.setValue(arguments[2]);\n                            else {\n                                attr = new XMLAttribute(arguments[0], name, arguments[1], arguments[2], \"CDATA\");\n                                this.attributes.push(attr);\n                            }\n                        } else {\n                            attr = this.findAttribute(arguments[0]);\n                            if (attr) attr.setValue(arguments[1]);\n                            else {\n                                attr = new XMLAttribute(arguments[0], arguments[0], null, arguments[1], \"CDATA\");\n                                this.attributes.push(attr);\n                            }\n                        }\n                    },\n                    /**\n     * Processing 1.5 XML API wrapper for the generic String\n     * attribute setter. This must take two arguments.\n     */ setString: function(attribute, value) {\n                        this.setAttribute(attribute, value);\n                    },\n                    /**\n     * Processing 1.5 XML API wrapper for the generic int\n     * attribute setter. This must take two arguments.\n     */ setInt: function(attribute, value) {\n                        this.setAttribute(attribute, value);\n                    },\n                    /**\n     * Processing 1.5 XML API wrapper for the generic float\n     * attribute setter. This must take two arguments.\n     */ setFloat: function(attribute, value) {\n                        this.setAttribute(attribute, value);\n                    },\n                    /**\n     * @member XMLElement\n     * The setContent() function sets the #PCDATA content. It is an error to call this method with a\n     * non-null value if there are child objects.\n     *\n     * @param {String} content     the (possibly null) content\n     */ setContent: function(content) {\n                        if (this.children.length > 0) Processing.debug(\"Tried to set content for XMLElement with children\");\n                        this.content = content;\n                    },\n                    /**\n     * @member XMLElement\n     * The setName() function sets the full name. This method also sets the short name and clears the\n     * namespace URI.\n     *\n     * @param {String} name        the non-null name\n     * @param {String} namespace   the namespace URI, which may be null.\n     */ setName: function() {\n                        if (arguments.length === 1) {\n                            this.name = arguments[0];\n                            this.fullName = arguments[0];\n                            this.namespace = null;\n                        } else {\n                            var index = arguments[0].indexOf(\":\");\n                            if (arguments[1] === null || index < 0) this.name = arguments[0];\n                            else this.name = arguments[0].substring(index + 1);\n                            this.fullName = arguments[0];\n                            this.namespace = arguments[1];\n                        }\n                    },\n                    /**\n     * @member XMLElement\n     * The getName() function returns the full name (i.e. the name including an eventual namespace\n     * prefix) of the element.\n     *\n     * @return {String} the name, or null if the element only contains #PCDATA.\n     */ getName: function() {\n                        return this.fullName;\n                    },\n                    /**\n     * @member XMLElement\n     * The getLocalName() function returns the local name (i.e. the name excluding an eventual namespace\n     * prefix) of the element.\n     *\n     * @return {String} the name, or null if the element only contains #PCDATA.\n     */ getLocalName: function() {\n                        return this.name;\n                    },\n                    /**\n     * @member XMLElement\n     * The getAttributeCount() function returns the number of attributes for the node\n     * that this XMLElement represents.\n     *\n     * @return {int} the number of attributes in this XMLElement\n     */ getAttributeCount: function() {\n                        return this.attributes.length;\n                    },\n                    /**\n     * @member XMLElement\n     * The toString() function returns the XML definition of an XMLElement.\n     *\n     * @return {String} the XML definition of this XMLElement\n     */ toString: function() {\n                        // shortcut for text and cdata nodes\n                        if (this.type === \"TEXT\") return this.content || \"\";\n                        if (this.type === \"CDATA\") return this.cdata || \"\";\n                        // real XMLElements\n                        var tagstring = this.fullName;\n                        var xmlstring = \"<\" + tagstring;\n                        var a, c;\n                        // serialize the attributes to XML string\n                        for(a = 0; a < this.attributes.length; a++){\n                            var attr = this.attributes[a];\n                            xmlstring += \" \" + attr.getName() + \"=\" + '\"' + attr.getValue() + '\"';\n                        }\n                        // serialize all children to XML string\n                        if (this.children.length === 0) {\n                            if (this.content === \"\" || this.content === null || this.content === undefined) xmlstring += \"/>\";\n                            else xmlstring += \">\" + this.content + \"</\" + tagstring + \">\";\n                        } else {\n                            xmlstring += \">\";\n                            for(c = 0; c < this.children.length; c++)xmlstring += this.children[c].toString();\n                            xmlstring += \"</\" + tagstring + \">\";\n                        }\n                        return xmlstring;\n                    }\n                };\n                /**\n   * static Processing 1.5 XML API wrapper for the\n   * parse method. This may only take one argument.\n   */ XMLElement1.parse = function(xmlstring) {\n                    var element = new XMLElement1();\n                    element.parse(xmlstring);\n                    return element;\n                };\n                return XMLElement1;\n            };\n        },\n        {}\n    ],\n    21: [\n        function(require1, module, exports) {\n            /**\n * web colors, by name\n */ module.exports = {\n                aliceblue: \"#f0f8ff\",\n                antiquewhite: \"#faebd7\",\n                aqua: \"#00ffff\",\n                aquamarine: \"#7fffd4\",\n                azure: \"#f0ffff\",\n                beige: \"#f5f5dc\",\n                bisque: \"#ffe4c4\",\n                black: \"#000000\",\n                blanchedalmond: \"#ffebcd\",\n                blue: \"#0000ff\",\n                blueviolet: \"#8a2be2\",\n                brown: \"#a52a2a\",\n                burlywood: \"#deb887\",\n                cadetblue: \"#5f9ea0\",\n                chartreuse: \"#7fff00\",\n                chocolate: \"#d2691e\",\n                coral: \"#ff7f50\",\n                cornflowerblue: \"#6495ed\",\n                cornsilk: \"#fff8dc\",\n                crimson: \"#dc143c\",\n                cyan: \"#00ffff\",\n                darkblue: \"#00008b\",\n                darkcyan: \"#008b8b\",\n                darkgoldenrod: \"#b8860b\",\n                darkgray: \"#a9a9a9\",\n                darkgreen: \"#006400\",\n                darkkhaki: \"#bdb76b\",\n                darkmagenta: \"#8b008b\",\n                darkolivegreen: \"#556b2f\",\n                darkorange: \"#ff8c00\",\n                darkorchid: \"#9932cc\",\n                darkred: \"#8b0000\",\n                darksalmon: \"#e9967a\",\n                darkseagreen: \"#8fbc8f\",\n                darkslateblue: \"#483d8b\",\n                darkslategray: \"#2f4f4f\",\n                darkturquoise: \"#00ced1\",\n                darkviolet: \"#9400d3\",\n                deeppink: \"#ff1493\",\n                deepskyblue: \"#00bfff\",\n                dimgray: \"#696969\",\n                dodgerblue: \"#1e90ff\",\n                firebrick: \"#b22222\",\n                floralwhite: \"#fffaf0\",\n                forestgreen: \"#228b22\",\n                fuchsia: \"#ff00ff\",\n                gainsboro: \"#dcdcdc\",\n                ghostwhite: \"#f8f8ff\",\n                gold: \"#ffd700\",\n                goldenrod: \"#daa520\",\n                gray: \"#808080\",\n                green: \"#008000\",\n                greenyellow: \"#adff2f\",\n                honeydew: \"#f0fff0\",\n                hotpink: \"#ff69b4\",\n                indianred: \"#cd5c5c\",\n                indigo: \"#4b0082\",\n                ivory: \"#fffff0\",\n                khaki: \"#f0e68c\",\n                lavender: \"#e6e6fa\",\n                lavenderblush: \"#fff0f5\",\n                lawngreen: \"#7cfc00\",\n                lemonchiffon: \"#fffacd\",\n                lightblue: \"#add8e6\",\n                lightcoral: \"#f08080\",\n                lightcyan: \"#e0ffff\",\n                lightgoldenrodyellow: \"#fafad2\",\n                lightgrey: \"#d3d3d3\",\n                lightgreen: \"#90ee90\",\n                lightpink: \"#ffb6c1\",\n                lightsalmon: \"#ffa07a\",\n                lightseagreen: \"#20b2aa\",\n                lightskyblue: \"#87cefa\",\n                lightslategray: \"#778899\",\n                lightsteelblue: \"#b0c4de\",\n                lightyellow: \"#ffffe0\",\n                lime: \"#00ff00\",\n                limegreen: \"#32cd32\",\n                linen: \"#faf0e6\",\n                magenta: \"#ff00ff\",\n                maroon: \"#800000\",\n                mediumaquamarine: \"#66cdaa\",\n                mediumblue: \"#0000cd\",\n                mediumorchid: \"#ba55d3\",\n                mediumpurple: \"#9370d8\",\n                mediumseagreen: \"#3cb371\",\n                mediumslateblue: \"#7b68ee\",\n                mediumspringgreen: \"#00fa9a\",\n                mediumturquoise: \"#48d1cc\",\n                mediumvioletred: \"#c71585\",\n                midnightblue: \"#191970\",\n                mintcream: \"#f5fffa\",\n                mistyrose: \"#ffe4e1\",\n                moccasin: \"#ffe4b5\",\n                navajowhite: \"#ffdead\",\n                navy: \"#000080\",\n                oldlace: \"#fdf5e6\",\n                olive: \"#808000\",\n                olivedrab: \"#6b8e23\",\n                orange: \"#ffa500\",\n                orangered: \"#ff4500\",\n                orchid: \"#da70d6\",\n                palegoldenrod: \"#eee8aa\",\n                palegreen: \"#98fb98\",\n                paleturquoise: \"#afeeee\",\n                palevioletred: \"#d87093\",\n                papayawhip: \"#ffefd5\",\n                peachpuff: \"#ffdab9\",\n                peru: \"#cd853f\",\n                pink: \"#ffc0cb\",\n                plum: \"#dda0dd\",\n                powderblue: \"#b0e0e6\",\n                purple: \"#800080\",\n                red: \"#ff0000\",\n                rosybrown: \"#bc8f8f\",\n                royalblue: \"#4169e1\",\n                saddlebrown: \"#8b4513\",\n                salmon: \"#fa8072\",\n                sandybrown: \"#f4a460\",\n                seagreen: \"#2e8b57\",\n                seashell: \"#fff5ee\",\n                sienna: \"#a0522d\",\n                silver: \"#c0c0c0\",\n                skyblue: \"#87ceeb\",\n                slateblue: \"#6a5acd\",\n                slategray: \"#708090\",\n                snow: \"#fffafa\",\n                springgreen: \"#00ff7f\",\n                steelblue: \"#4682b4\",\n                tan: \"#d2b48c\",\n                teal: \"#008080\",\n                thistle: \"#d8bfd8\",\n                tomato: \"#ff6347\",\n                turquoise: \"#40e0d0\",\n                violet: \"#ee82ee\",\n                wheat: \"#f5deb3\",\n                white: \"#ffffff\",\n                whitesmoke: \"#f5f5f5\",\n                yellow: \"#ffff00\",\n                yellowgreen: \"#9acd32\"\n            };\n        },\n        {}\n    ],\n    22: [\n        function(require1, module, exports) {\n            module.exports = function(virtHashCode, virtEquals, undef) {\n                return function withProxyFunctions(p, removeFirstArgument) {\n                    /**\n     * The contains(string) function returns true if the string passed in the parameter\n     * is a substring of this string. It returns false if the string passed\n     * in the parameter is not a substring of this string.\n     *\n     * @param {String} The string to look for in the current string\n     *\n     * @return {boolean} returns true if this string contains\n     * the string passed as parameter. returns false, otherwise.\n     *\n     */ p.__contains = function(subject, subStr) {\n                        if (typeof subject !== \"string\") return subject.contains.apply(subject, removeFirstArgument(arguments));\n                        //Parameter is not null AND\n                        //The type of the parameter is the same as this object (string)\n                        //The javascript function that finds a substring returns 0 or higher\n                        return subject !== null && subStr !== null && typeof subStr === \"string\" && subject.indexOf(subStr) > -1;\n                    };\n                    /**\n     * The __replaceAll() function searches all matches between a substring (or regular expression) and a string,\n     * and replaces the matched substring with a new substring\n     *\n     * @param {String} subject    a substring\n     * @param {String} regex      a substring or a regular expression\n     * @param {String} replace    the string to replace the found value\n     *\n     * @return {String} returns result\n     *\n     * @see #match\n     */ p.__replaceAll = function(subject, regex, replacement) {\n                        if (typeof subject !== \"string\") return subject.replaceAll.apply(subject, removeFirstArgument(arguments));\n                        return subject.replace(new RegExp(regex, \"g\"), replacement);\n                    };\n                    /**\n     * The __replaceFirst() function searches first matche between a substring (or regular expression) and a string,\n     * and replaces the matched substring with a new substring\n     *\n     * @param {String} subject    a substring\n     * @param {String} regex      a substring or a regular expression\n     * @param {String} replace    the string to replace the found value\n     *\n     * @return {String} returns result\n     *\n     * @see #match\n     */ p.__replaceFirst = function(subject, regex, replacement) {\n                        if (typeof subject !== \"string\") return subject.replaceFirst.apply(subject, removeFirstArgument(arguments));\n                        return subject.replace(new RegExp(regex, \"\"), replacement);\n                    };\n                    /**\n     * The __replace() function searches all matches between a substring and a string,\n     * and replaces the matched substring with a new substring\n     *\n     * @param {String} subject         a substring\n     * @param {String} what         a substring to find\n     * @param {String} replacement    the string to replace the found value\n     *\n     * @return {String} returns result\n     */ p.__replace = function(subject, what, replacement) {\n                        if (typeof subject !== \"string\") return subject.replace.apply(subject, removeFirstArgument(arguments));\n                        if (what instanceof RegExp) return subject.replace(what, replacement);\n                        if (typeof what !== \"string\") what = what.toString();\n                        if (what === \"\") return subject;\n                        var i = subject.indexOf(what);\n                        if (i < 0) return subject;\n                        var j = 0, result = \"\";\n                        do {\n                            result += subject.substring(j, i) + replacement;\n                            j = i + what.length;\n                        }while ((i = subject.indexOf(what, j)) >= 0);\n                        return result + subject.substring(j);\n                    };\n                    /**\n     * The __equals() function compares two strings (or objects) to see if they are the same.\n     * This method is necessary because it's not possible to compare strings using the equality operator (==).\n     * Returns true if the strings are the same and false if they are not.\n     *\n     * @param {String} subject  a string used for comparison\n     * @param {String} other  a string used for comparison with\n     *\n     * @return {boolean} true is the strings are the same false otherwise\n     */ p.__equals = function(subject, other) {\n                        if (subject.equals instanceof Function) return subject.equals.apply(subject, removeFirstArgument(arguments));\n                        return virtEquals(subject, other);\n                    };\n                    /**\n     * The __equalsIgnoreCase() function compares two strings to see if they are the same.\n     * Returns true if the strings are the same, either when forced to all lower case or\n     * all upper case.\n     *\n     * @param {String} subject  a string used for comparison\n     * @param {String} other  a string used for comparison with\n     *\n     * @return {boolean} true is the strings are the same, ignoring case. false otherwise\n     */ p.__equalsIgnoreCase = function(subject, other) {\n                        if (typeof subject !== \"string\") return subject.equalsIgnoreCase.apply(subject, removeFirstArgument(arguments));\n                        return subject.toLowerCase() === other.toLowerCase();\n                    };\n                    /**\n     * The __toCharArray() function splits the string into a char array.\n     *\n     * @param {String} subject The string\n     *\n     * @return {Char[]} a char array\n     */ p.__toCharArray = function(subject) {\n                        if (typeof subject !== \"string\") return subject.toCharArray.apply(subject, removeFirstArgument(arguments));\n                        var chars = [];\n                        for(var i = 0, len = subject.length; i < len; ++i)chars[i] = new Char(subject.charAt(i));\n                        return chars;\n                    };\n                    /**\n     * The __split() function splits a string using the regex delimiter\n     * specified. If limit is specified, the resultant array will have number\n     * of elements equal to or less than the limit.\n     *\n     * @param {String} subject string to be split\n     * @param {String} regexp  regex string used to split the subject\n     * @param {int}    limit   max number of tokens to be returned\n     *\n     * @return {String[]} an array of tokens from the split string\n     */ p.__split = function(subject, regex, limit) {\n                        if (typeof subject !== \"string\") return subject.split.apply(subject, removeFirstArgument(arguments));\n                        var pattern = new RegExp(regex);\n                        // If limit is not specified, use JavaScript's built-in String.split.\n                        if (limit === undef || limit < 1) return subject.split(pattern);\n                        // If limit is specified, JavaScript's built-in String.split has a\n                        // different behaviour than Java's. A Java-compatible implementation is\n                        // provided here.\n                        var result = [], currSubject = subject, pos;\n                        while((pos = currSubject.search(pattern)) !== -1 && result.length < limit - 1){\n                            var match = pattern.exec(currSubject).toString();\n                            result.push(currSubject.substring(0, pos));\n                            currSubject = currSubject.substring(pos + match.length);\n                        }\n                        if (pos !== -1 || currSubject !== \"\") result.push(currSubject);\n                        return result;\n                    };\n                    /**\n     * The codePointAt() function returns the unicode value of the character at a given index of a string.\n     *\n     * @param  {int} idx         the index of the character\n     *\n     * @return {String} code     the String containing the unicode value of the character\n     */ p.__codePointAt = function(subject, idx) {\n                        var code = subject.charCodeAt(idx), hi, low;\n                        if (0xD800 <= code && code <= 0xDBFF) {\n                            hi = code;\n                            low = subject.charCodeAt(idx + 1);\n                            return (hi - 0xD800) * 0x400 + (low - 0xDC00) + 0x10000;\n                        }\n                        return code;\n                    };\n                    /**\n     * The matches() function checks whether or not a string matches a given regular expression.\n     *\n     * @param {String} str      the String on which the match is tested\n     * @param {String} regexp   the regexp for which a match is tested\n     *\n     * @return {boolean} true if the string fits the regexp, false otherwise\n     */ p.__matches = function(str, regexp) {\n                        return new RegExp(regexp).test(str);\n                    };\n                    /**\n     * The startsWith() function tests if a string starts with the specified prefix.  If the prefix\n     * is the empty String or equal to the subject String, startsWith() will also return true.\n     *\n     * @param {String} prefix   the String used to compare against the start of the subject String.\n     * @param {int}    toffset  (optional) an offset into the subject String where searching should begin.\n     *\n     * @return {boolean} true if the subject String starts with the prefix.\n     */ p.__startsWith = function(subject, prefix, toffset) {\n                        if (typeof subject !== \"string\") return subject.startsWith.apply(subject, removeFirstArgument(arguments));\n                        toffset = toffset || 0;\n                        if (toffset < 0 || toffset > subject.length) return false;\n                        return prefix === \"\" || prefix === subject ? true : subject.indexOf(prefix) === toffset;\n                    };\n                    /**\n     * The endsWith() function tests if a string ends with the specified suffix.  If the suffix\n     * is the empty String, endsWith() will also return true.\n     *\n     * @param {String} suffix   the String used to compare against the end of the subject String.\n     *\n     * @return {boolean} true if the subject String starts with the prefix.\n     */ p.__endsWith = function(subject, suffix) {\n                        if (typeof subject !== \"string\") return subject.endsWith.apply(subject, removeFirstArgument(arguments));\n                        var suffixLen = suffix ? suffix.length : 0;\n                        return suffix === \"\" || suffix === subject ? true : subject.indexOf(suffix) === subject.length - suffixLen;\n                    };\n                    /**\n     * The returns hash code of the.\n     *\n     * @param {Object} subject The string\n     *\n     * @return {int} a hash code\n     */ p.__hashCode = function(subject) {\n                        if (subject.hashCode instanceof Function) return subject.hashCode.apply(subject, removeFirstArgument(arguments));\n                        return virtHashCode(subject);\n                    };\n                    /**\n     * The __printStackTrace() prints stack trace to the console.\n     *\n     * @param {Exception} subject The error\n     */ p.__printStackTrace = function(subject) {\n                        p.println(\"Exception: \" + subject.toString());\n                    };\n                };\n            };\n        },\n        {}\n    ],\n    23: [\n        function(require1, module, exports) {\n            /**\n * For many \"math\" functions, we can delegate\n * to the Math object. For others, we can't.\n */ module.exports = function withMath(p, undef) {\n                var internalRandomGenerator = function() {\n                    return Math.random();\n                };\n                /**\n  * Calculates the absolute value (magnitude) of a number. The absolute value of a number is always positive.\n  *\n  * @param {int|float} value   int or float\n  *\n  * @returns {int|float}\n  */ p.abs = Math.abs;\n                /**\n  * Calculates the closest int value that is greater than or equal to the value of the parameter.\n  * For example, ceil(9.03) returns the value 10.\n  *\n  * @param {float} value   float\n  *\n  * @returns {int}\n  *\n  * @see floor\n  * @see round\n  */ p.ceil = Math.ceil;\n                /**\n  * Returns Euler's number e (2.71828...) raised to the power of the value parameter.\n  *\n  * @param {int|float} value   int or float: the exponent to raise e to\n  *\n  * @returns {float}\n  */ p.exp = Math.exp;\n                /**\n  * Calculates the closest int value that is less than or equal to the value of the parameter.\n  *\n  * @param {int|float} value        the value to floor\n  *\n  * @returns {int|float}\n  *\n  * @see ceil\n  * @see round\n  */ p.floor = Math.floor;\n                /**\n  * Calculates the natural logarithm (the base-e logarithm) of a number. This function\n  * expects the values greater than 0.0.\n  *\n  * @param {int|float} value        int or float: number must be greater then 0.0\n  *\n  * @returns {float}\n  */ p.log = Math.log;\n                /**\n  * Facilitates exponential expressions. The pow() function is an efficient way of\n  * multiplying numbers by themselves (or their reciprocal) in large quantities.\n  * For example, pow(3, 5) is equivalent to the expression 3*3*3*3*3 and pow(3, -5)\n  * is equivalent to 1 / 3*3*3*3*3.\n  *\n  * @param {int|float} num        base of the exponential expression\n  * @param {int|float} exponent   power of which to raise the base\n  *\n  * @returns {float}\n  *\n  * @see sqrt\n  */ p.pow = Math.pow;\n                /**\n  * Calculates the integer closest to the value parameter. For example, round(9.2) returns the value 9.\n  *\n  * @param {float} value        number to round\n  *\n  * @returns {int}\n  *\n  * @see floor\n  * @see ceil\n  */ p.round = Math.round;\n                /**\n  * Calculates the square root of a number. The square root of a number is always positive,\n  * even though there may be a valid negative root. The square root s of number a is such\n  * that s*s = a. It is the opposite of squaring.\n  *\n  * @param {float} value        int or float, non negative\n  *\n  * @returns {float}\n  *\n  * @see pow\n  * @see sq\n  */ p.sqrt = Math.sqrt;\n                // Trigonometry\n                /**\n  * The inverse of cos(), returns the arc cosine of a value. This function expects the\n  * values in the range of -1 to 1 and values are returned in the range 0 to PI (3.1415927).\n  *\n  * @param {float} value        the value whose arc cosine is to be returned\n  *\n  * @returns {float}\n  *\n  * @see cos\n  * @see asin\n  * @see atan\n  */ p.acos = Math.acos;\n                /**\n  * The inverse of sin(), returns the arc sine of a value. This function expects the values\n  * in the range of -1 to 1 and values are returned in the range -PI/2 to PI/2.\n  *\n  * @param {float} value        the value whose arc sine is to be returned\n  *\n  * @returns {float}\n  *\n  * @see sin\n  * @see acos\n  * @see atan\n  */ p.asin = Math.asin;\n                /**\n  * The inverse of tan(), returns the arc tangent of a value. This function expects the values\n  * in the range of -Infinity to Infinity (exclusive) and values are returned in the range -PI/2 to PI/2 .\n  *\n  * @param {float} value        -Infinity to Infinity (exclusive)\n  *\n  * @returns {float}\n  *\n  * @see tan\n  * @see asin\n  * @see acos\n  */ p.atan = Math.atan;\n                /**\n  * Calculates the angle (in radians) from a specified point to the coordinate origin as measured from\n  * the positive x-axis. Values are returned as a float in the range from PI to -PI. The atan2() function\n  * is most often used for orienting geometry to the position of the cursor. Note: The y-coordinate of the\n  * point is the first parameter and the x-coordinate is the second due the the structure of calculating the tangent.\n  *\n  * @param {float} y        y-coordinate of the point\n  * @param {float} x        x-coordinate of the point\n  *\n  * @returns {float}\n  *\n  * @see tan\n  */ p.atan2 = Math.atan2;\n                /**\n  * Calculates the cosine of an angle. This function expects the values of the angle parameter to be provided\n  * in radians (values from 0 to PI*2). Values are returned in the range -1 to 1.\n  *\n  * @param {float} value        an angle in radians\n  *\n  * @returns {float}\n  *\n  * @see tan\n  * @see sin\n  */ p.cos = Math.cos;\n                /**\n  * Calculates the sine of an angle. This function expects the values of the angle parameter to be provided in\n  * radians (values from 0 to 6.28). Values are returned in the range -1 to 1.\n  *\n  * @param {float} value        an angle in radians\n  *\n  * @returns {float}\n  *\n  * @see cos\n  * @see radians\n  */ p.sin = Math.sin;\n                /**\n  * Calculates the ratio of the sine and cosine of an angle. This function expects the values of the angle\n  * parameter to be provided in radians (values from 0 to PI*2). Values are returned in the range infinity to -infinity.\n  *\n  * @param {float} value        an angle in radians\n  *\n  * @returns {float}\n  *\n  * @see cos\n  * @see sin\n  * @see radians\n  */ p.tan = Math.tan;\n                /**\n  * Constrains a value to not exceed a maximum and minimum value.\n  *\n  * @param {int|float} value   the value to constrain\n  * @param {int|float} value   minimum limit\n  * @param {int|float} value   maximum limit\n  *\n  * @returns {int|float}\n  *\n  * @see max\n  * @see min\n  */ p.constrain = function(aNumber, aMin, aMax) {\n                    return aNumber > aMax ? aMax : aNumber < aMin ? aMin : aNumber;\n                };\n                /**\n  * Calculates the distance between two points.\n  *\n  * @param {int|float} x1     int or float: x-coordinate of the first point\n  * @param {int|float} y1     int or float: y-coordinate of the first point\n  * @param {int|float} z1     int or float: z-coordinate of the first point\n  * @param {int|float} x2     int or float: x-coordinate of the second point\n  * @param {int|float} y2     int or float: y-coordinate of the second point\n  * @param {int|float} z2     int or float: z-coordinate of the second point\n  *\n  * @returns {float}\n  */ p.dist = function() {\n                    var dx, dy, dz;\n                    if (arguments.length === 4) {\n                        dx = arguments[0] - arguments[2];\n                        dy = arguments[1] - arguments[3];\n                        return Math.sqrt(dx * dx + dy * dy);\n                    }\n                    if (arguments.length === 6) {\n                        dx = arguments[0] - arguments[3];\n                        dy = arguments[1] - arguments[4];\n                        dz = arguments[2] - arguments[5];\n                        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n                    }\n                };\n                /**\n  * Calculates a number between two numbers at a specific increment. The amt  parameter is the\n  * amount to interpolate between the two values where 0.0 equal to the first point, 0.1 is very\n  * near the first point, 0.5 is half-way in between, etc. The lerp function is convenient for\n  * creating motion along a straight path and for drawing dotted lines.\n  *\n  * @param {int|float} value1       float or int: first value\n  * @param {int|float} value2       float or int: second value\n  * @param {int|float} amt          float: between 0.0 and 1.0\n  *\n  * @returns {float}\n  *\n  * @see curvePoint\n  * @see bezierPoint\n  */ p.lerp = function(value1, value2, amt) {\n                    return (value2 - value1) * amt + value1;\n                };\n                /**\n  * Calculates the magnitude (or length) of a vector. A vector is a direction in space commonly\n  * used in computer graphics and linear algebra. Because it has no \"start\" position, the magnitude\n  * of a vector can be thought of as the distance from coordinate (0,0) to its (x,y) value.\n  * Therefore, mag() is a shortcut for writing \"dist(0, 0, x, y)\".\n  *\n  * @param {int|float} a       float or int: first value\n  * @param {int|float} b       float or int: second value\n  * @param {int|float} c       float or int: third value\n  *\n  * @returns {float}\n  *\n  * @see dist\n  */ p.mag = function(a, b, c) {\n                    if (c) return Math.sqrt(a * a + b * b + c * c);\n                    return Math.sqrt(a * a + b * b);\n                };\n                /**\n  * Re-maps a number from one range to another. In the example above, the number '25' is converted from\n  * a value in the range 0..100 into a value that ranges from the left edge (0) to the right edge (width) of the screen.\n  * Numbers outside the range are not clamped to 0 and 1, because out-of-range values are often intentional and useful.\n  *\n  * @param {float} value        The incoming value to be converted\n  * @param {float} istart       Lower bound of the value's current range\n  * @param {float} istop        Upper bound of the value's current range\n  * @param {float} ostart       Lower bound of the value's target range\n  * @param {float} ostop        Upper bound of the value's target range\n  *\n  * @returns {float}\n  *\n  * @see norm\n  * @see lerp\n  */ p.map = function(value, istart, istop, ostart, ostop) {\n                    return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));\n                };\n                /**\n  * Determines the largest value in a sequence of numbers.\n  *\n  * @param {int|float} value1         int or float\n  * @param {int|float} value2         int or float\n  * @param {int|float} value3         int or float\n  * @param {int|float} array          int or float array\n  *\n  * @returns {int|float}\n  *\n  * @see min\n  */ p.max = function() {\n                    if (arguments.length === 2) return arguments[0] < arguments[1] ? arguments[1] : arguments[0];\n                    var numbers = arguments.length === 1 ? arguments[0] : arguments; // if single argument, array is used\n                    if (!(\"length\" in numbers && numbers.length > 0)) throw \"Non-empty array is expected\";\n                    var max = numbers[0], count = numbers.length;\n                    for(var i = 1; i < count; ++i)if (max < numbers[i]) max = numbers[i];\n                    return max;\n                };\n                /**\n  * Determines the smallest value in a sequence of numbers.\n  *\n  * @param {int|float} value1         int or float\n  * @param {int|float} value2         int or float\n  * @param {int|float} value3         int or float\n  * @param {int|float} array          int or float array\n  *\n  * @returns {int|float}\n  *\n  * @see max\n  */ p.min = function() {\n                    if (arguments.length === 2) return arguments[0] < arguments[1] ? arguments[0] : arguments[1];\n                    var numbers = arguments.length === 1 ? arguments[0] : arguments; // if single argument, array is used\n                    if (!(\"length\" in numbers && numbers.length > 0)) throw \"Non-empty array is expected\";\n                    var min = numbers[0], count = numbers.length;\n                    for(var i = 1; i < count; ++i)if (min > numbers[i]) min = numbers[i];\n                    return min;\n                };\n                /**\n  * Normalizes a number from another range into a value between 0 and 1.\n  * Identical to map(value, low, high, 0, 1);\n  * Numbers outside the range are not clamped to 0 and 1, because out-of-range\n  * values are often intentional and useful.\n  *\n  * @param {float} aNumber    The incoming value to be converted\n  * @param {float} low        Lower bound of the value's current range\n  * @param {float} high       Upper bound of the value's current range\n  *\n  * @returns {float}\n  *\n  * @see map\n  * @see lerp\n  */ p.norm = function(aNumber, low, high) {\n                    return (aNumber - low) / (high - low);\n                };\n                /**\n  * Squares a number (multiplies a number by itself). The result is always a positive number,\n  * as multiplying two negative numbers always yields a positive result. For example, -1 * -1 = 1.\n  *\n  * @param {float} value        int or float\n  *\n  * @returns {float}\n  *\n  * @see sqrt\n  */ p.sq = function(aNumber) {\n                    return aNumber * aNumber;\n                };\n                /**\n  * Converts a radian measurement to its corresponding value in degrees. Radians and degrees are two ways of\n  * measuring the same thing. There are 360 degrees in a circle and 2*PI radians in a circle. For example,\n  * 90 degrees = PI/2 = 1.5707964. All trigonometric methods in Processing require their parameters to be specified in radians.\n  *\n  * @param {int|float} value        an angle in radians\n  *\n  * @returns {float}\n  *\n  * @see radians\n  */ p.degrees = function(aAngle) {\n                    return aAngle * 180 / Math.PI;\n                };\n                /**\n  * Generates random numbers. Each time the random() function is called, it returns an unexpected value within\n  * the specified range. If one parameter is passed to the function it will return a float between zero and the\n  * value of the high parameter. The function call random(5) returns values between 0 and 5 (starting at zero,\n  * up to but not including 5). If two parameters are passed, it will return a float with a value between the\n  * parameters. The function call random(-5, 10.2) returns values starting at -5 up to (but not including) 10.2.\n  * To convert a floating-point random number to an integer, use the int() function.\n  *\n  * @param {int|float} value1         if one parameter is used, the top end to random from, if two params the low end\n  * @param {int|float} value2         the top end of the random range\n  *\n  * @returns {float}\n  *\n  * @see randomSeed\n  * @see noise\n  */ p.random = function(aMin, aMax) {\n                    if (arguments.length === 0) {\n                        aMax = 1;\n                        aMin = 0;\n                    } else if (arguments.length === 1) {\n                        aMax = aMin;\n                        aMin = 0;\n                    }\n                    if (aMin === aMax) return aMin;\n                    for(var i = 0; i < 100; i++){\n                        var ir = internalRandomGenerator();\n                        var result = ir * (aMax - aMin) + aMin;\n                        if (result !== aMax) return result;\n                    // assertion: ir is never less than 0.5\n                    }\n                    return aMin;\n                };\n                // Pseudo-random generator\n                function Marsaglia(i1, i2) {\n                    // from http://www.math.uni-bielefeld.de/~sillke/ALGORITHMS/random/marsaglia-c\n                    var z = i1 || 362436069, w = i2 || 521288629;\n                    var intGenerator = function() {\n                        z = 36969 * (z & 65535) + (z >>> 16) & 0xFFFFFFFF;\n                        w = 18000 * (w & 65535) + (w >>> 16) & 0xFFFFFFFF;\n                        return ((z & 0xFFFF) << 16 | w & 0xFFFF) & 0xFFFFFFFF;\n                    };\n                    this.doubleGenerator = function() {\n                        var i = intGenerator() / 4294967296;\n                        return i < 0 ? 1 + i : i;\n                    };\n                    this.intGenerator = intGenerator;\n                }\n                Marsaglia.createRandomized = function() {\n                    var now = new Date();\n                    return new Marsaglia(now / 60000 & 0xFFFFFFFF, now & 0xFFFFFFFF);\n                };\n                /**\n  * Sets the seed value for random(). By default, random() produces different results each time the\n  * program is run. Set the value parameter to a constant to return the same pseudo-random numbers\n  * each time the software is run.\n  *\n  * @param {int|float} seed         int\n  *\n  * @see random\n  * @see noise\n  * @see noiseSeed\n  */ p.randomSeed = function(seed) {\n                    internalRandomGenerator = new Marsaglia(seed, (seed << 16) + (seed >> 16)).doubleGenerator;\n                    this.haveNextNextGaussian = false;\n                };\n                /**\n  * Returns a float from a random series of numbers having a mean of 0 and standard deviation of 1. Each time\n  * the randomGaussian() function is called, it returns a number fitting a Gaussian, or normal, distribution.\n  * There is theoretically no minimum or maximum value that randomGaussian() might return. Rather, there is just a\n  * very low probability that values far from the mean will be returned; and a higher probability that numbers\n  * near the mean will be returned.\n  *\n  * @returns {float}\n  *\n  * @see random\n  * @see noise\n  */ p.randomGaussian = function() {\n                    if (this.haveNextNextGaussian) {\n                        this.haveNextNextGaussian = false;\n                        return this.nextNextGaussian;\n                    }\n                    var v1, v2, s;\n                    do {\n                        v1 = 2 * internalRandomGenerator() - 1; // between -1.0 and 1.0\n                        v2 = 2 * internalRandomGenerator() - 1; // between -1.0 and 1.0\n                        s = v1 * v1 + v2 * v2;\n                    }while (s >= 1 || s === 0);\n                    var multiplier = Math.sqrt(-2 * Math.log(s) / s);\n                    this.nextNextGaussian = v2 * multiplier;\n                    this.haveNextNextGaussian = true;\n                    return v1 * multiplier;\n                };\n                // Noise functions and helpers\n                function PerlinNoise(seed) {\n                    var rnd = seed !== undef ? new Marsaglia(seed, (seed << 16) + (seed >> 16)) : Marsaglia.createRandomized();\n                    var i, j;\n                    // http://www.noisemachine.com/talk1/17b.html\n                    // http://mrl.nyu.edu/~perlin/noise/\n                    // generate permutation\n                    var perm = new Uint8Array(512);\n                    for(i = 0; i < 256; ++i)perm[i] = i;\n                    for(i = 0; i < 256; ++i){\n                        // NOTE: we can only do this because we've made sure the Marsaglia generator\n                        //       gives us numbers where the last byte in a pseudo-random number is\n                        //       still pseudo-random. If no 2nd argument is passed in the constructor,\n                        //       that is no longer the case and this pair swap will always run identically.\n                        var t1 = perm[j = rnd.intGenerator() & 0xFF];\n                        perm[j] = perm[i];\n                        perm[i] = t1;\n                    }\n                    // copy to avoid taking mod in perm[0];\n                    for(i = 0; i < 256; ++i)perm[i + 256] = perm[i];\n                    function grad3d(i, x, y, z) {\n                        var h = i & 15; // convert into 12 gradient directions\n                        var u = h < 8 ? x : y, v = h < 4 ? y : h === 12 || h === 14 ? x : z;\n                        return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);\n                    }\n                    function grad2d(i, x, y) {\n                        var v = (i & 1) === 0 ? x : y;\n                        return (i & 2) === 0 ? -v : v;\n                    }\n                    function grad1d(i, x) {\n                        return (i & 1) === 0 ? -x : x;\n                    }\n                    function lerp(t1, a, b) {\n                        return a + t1 * (b - a);\n                    }\n                    this.noise3d = function(x, y, z) {\n                        var X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255;\n                        x -= Math.floor(x);\n                        y -= Math.floor(y);\n                        z -= Math.floor(z);\n                        var fx = (3 - 2 * x) * x * x, fy = (3 - 2 * y) * y * y, fz = (3 - 2 * z) * z * z;\n                        var p0 = perm[X] + Y, p00 = perm[p0] + Z, p01 = perm[p0 + 1] + Z, p1 = perm[X + 1] + Y, p10 = perm[p1] + Z, p11 = perm[p1 + 1] + Z;\n                        return lerp(fz, lerp(fy, lerp(fx, grad3d(perm[p00], x, y, z), grad3d(perm[p10], x - 1, y, z)), lerp(fx, grad3d(perm[p01], x, y - 1, z), grad3d(perm[p11], x - 1, y - 1, z))), lerp(fy, lerp(fx, grad3d(perm[p00 + 1], x, y, z - 1), grad3d(perm[p10 + 1], x - 1, y, z - 1)), lerp(fx, grad3d(perm[p01 + 1], x, y - 1, z - 1), grad3d(perm[p11 + 1], x - 1, y - 1, z - 1))));\n                    };\n                    this.noise2d = function(x, y) {\n                        var X = Math.floor(x) & 255, Y = Math.floor(y) & 255;\n                        x -= Math.floor(x);\n                        y -= Math.floor(y);\n                        var fx = (3 - 2 * x) * x * x, fy = (3 - 2 * y) * y * y;\n                        var p0 = perm[X] + Y, p1 = perm[X + 1] + Y;\n                        return lerp(fy, lerp(fx, grad2d(perm[p0], x, y), grad2d(perm[p1], x - 1, y)), lerp(fx, grad2d(perm[p0 + 1], x, y - 1), grad2d(perm[p1 + 1], x - 1, y - 1)));\n                    };\n                    this.noise1d = function(x) {\n                        var X = Math.floor(x) & 255;\n                        x -= Math.floor(x);\n                        var fx = (3 - 2 * x) * x * x;\n                        return lerp(fx, grad1d(perm[X], x), grad1d(perm[X + 1], x - 1));\n                    };\n                }\n                // processing defaults\n                var noiseProfile = {\n                    generator: undef,\n                    octaves: 4,\n                    fallout: 0.5,\n                    seed: undef\n                };\n                /**\n  * Returns the Perlin noise value at specified coordinates. Perlin noise is a random sequence\n  * generator producing a more natural ordered, harmonic succession of numbers compared to the\n  * standard random() function. It was invented by Ken Perlin in the 1980s and been used since\n  * in graphical applications to produce procedural textures, natural motion, shapes, terrains etc.\n  * The main difference to the random() function is that Perlin noise is defined in an infinite\n  * n-dimensional space where each pair of coordinates corresponds to a fixed semi-random value\n  * (fixed only for the lifespan of the program). The resulting value will always be between 0.0\n  * and 1.0. Processing can compute 1D, 2D and 3D noise, depending on the number of coordinates\n  * given. The noise value can be animated by moving through the noise space as demonstrated in\n  * the example above. The 2nd and 3rd dimension can also be interpreted as time.\n  * The actual noise is structured similar to an audio signal, in respect to the function's use\n  * of frequencies. Similar to the concept of harmonics in physics, perlin noise is computed over\n  * several octaves which are added together for the final result.\n  * Another way to adjust the character of the resulting sequence is the scale of the input\n  * coordinates. As the function works within an infinite space the value of the coordinates\n  * doesn't matter as such, only the distance between successive coordinates does (eg. when using\n  * noise() within a loop). As a general rule the smaller the difference between coordinates, the\n  * smoother the resulting noise sequence will be. Steps of 0.005-0.03 work best for most applications,\n  * but this will differ depending on use.\n  *\n  * @param {float} x          x coordinate in noise space\n  * @param {float} y          y coordinate in noise space\n  * @param {float} z          z coordinate in noise space\n  *\n  * @returns {float}\n  *\n  * @see random\n  * @see noiseDetail\n  */ p.noise = function(x, y, z) {\n                    if (noiseProfile.generator === undef) // caching\n                    noiseProfile.generator = new PerlinNoise(noiseProfile.seed);\n                    var generator = noiseProfile.generator;\n                    var effect = 1, k = 1, sum = 0;\n                    for(var i = 0; i < noiseProfile.octaves; ++i){\n                        effect *= noiseProfile.fallout;\n                        switch(arguments.length){\n                            case 1:\n                                sum += effect * (1 + generator.noise1d(k * x)) / 2;\n                                break;\n                            case 2:\n                                sum += effect * (1 + generator.noise2d(k * x, k * y)) / 2;\n                                break;\n                            case 3:\n                                sum += effect * (1 + generator.noise3d(k * x, k * y, k * z)) / 2;\n                                break;\n                        }\n                        k *= 2;\n                    }\n                    return sum;\n                };\n                /**\n  * Adjusts the character and level of detail produced by the Perlin noise function.\n  * Similar to harmonics in physics, noise is computed over several octaves. Lower octaves\n  * contribute more to the output signal and as such define the overal intensity of the noise,\n  * whereas higher octaves create finer grained details in the noise sequence. By default,\n  * noise is computed over 4 octaves with each octave contributing exactly half than its\n  * predecessor, starting at 50% strength for the 1st octave. This falloff amount can be\n  * changed by adding an additional function parameter. Eg. a falloff factor of 0.75 means\n  * each octave will now have 75% impact (25% less) of the previous lower octave. Any value\n  * between 0.0 and 1.0 is valid, however note that values greater than 0.5 might result in\n  * greater than 1.0 values returned by noise(). By changing these parameters, the signal\n  * created by the noise() function can be adapted to fit very specific needs and characteristics.\n  *\n  * @param {int} octaves          number of octaves to be used by the noise() function\n  * @param {float} falloff        falloff factor for each octave\n  *\n  * @see noise\n  */ p.noiseDetail = function(octaves, fallout) {\n                    noiseProfile.octaves = octaves;\n                    if (fallout !== undef) noiseProfile.fallout = fallout;\n                };\n                /**\n  * Sets the seed value for noise(). By default, noise() produces different results each\n  * time the program is run. Set the value parameter to a constant to return the same\n  * pseudo-random numbers each time the software is run.\n  *\n  * @param {int} seed         int\n  *\n  * @returns {float}\n  *\n  * @see random\n  * @see radomSeed\n  * @see noise\n  * @see noiseDetail\n  */ p.noiseSeed = function(seed) {\n                    noiseProfile.seed = seed;\n                    noiseProfile.generator = undef;\n                };\n            };\n        },\n        {}\n    ],\n    24: [\n        function(require1, module, exports) {\n            /**\n * Common functions traditionally on \"p\" that should be class functions\n * that get bound to \"p\" when an instance is actually built, instead.\n */ module.exports = function commonFunctions(undef) {\n                var CommonFunctions = {\n                    /**\n     * Remove whitespace characters from the beginning and ending\n     * of a String or a String array. Works like String.trim() but includes the\n     * unicode nbsp character as well. If an array is passed in the function will return a new array not effecting the array passed in.\n     *\n     * @param {String} str    the string to trim\n     * @param {String[]} str  the string array to trim\n     *\n     * @return {String|String[]} retrurns a string or an array will removed whitespaces\n     */ trim: function(str) {\n                        if (str instanceof Array) {\n                            var arr = [];\n                            for(var i = 0; i < str.length; i++)arr.push(str[i].replace(/^\\s*/, \"\").replace(/\\s*$/, \"\").replace(/\\r*$/, \"\"));\n                            return arr;\n                        }\n                        return str.replace(/^\\s*/, \"\").replace(/\\s*$/, \"\").replace(/\\r*$/, \"\");\n                    },\n                    /**\n     * Converts a degree measurement to its corresponding value in radians. Radians and degrees are two ways of\n     * measuring the same thing. There are 360 degrees in a circle and 2*PI radians in a circle. For example,\n     * 90 degrees = PI/2 = 1.5707964. All trigonometric methods in Processing require their parameters to be specified in radians.\n     *\n     * @param {int|float} value        an angle in radians\n     *\n     * @returns {float}\n     *\n     * @see degrees\n     */ radians: function(aAngle) {\n                        return aAngle / 180 * Math.PI;\n                    },\n                    /**\n     * Number-to-String formatting function. Prepends \"plus\" or \"minus\" depending\n     * on whether the value is positive or negative, respectively, after padding\n     * the value with zeroes on the left and right, the number of zeroes used dictated\n     * by the values 'leftDigits' and 'rightDigits'. 'value' cannot be an array.\n     *\n     * @param {int|float} value                 the number to format\n     * @param {String} plus                     the prefix for positive numbers\n     * @param {String} minus                    the prefix for negative numbers\n     * @param {int} left                        number of digits to the left of the decimal point\n     * @param {int} right                       number of digits to the right of the decimal point\n     * @param {String} group                    string delimited for groups, such as the comma in \"1,000\"\n     *\n     * @returns {String or String[]}\n     *\n     * @see nfCore\n     */ nfCoreScalar: function(value, plus, minus, leftDigits, rightDigits, group) {\n                        var sign = value < 0 ? minus : plus;\n                        var autoDetectDecimals = rightDigits === 0;\n                        var rightDigitsOfDefault = rightDigits === undef || rightDigits < 0 ? 0 : rightDigits;\n                        var absValue = Math.abs(value);\n                        if (autoDetectDecimals) {\n                            rightDigitsOfDefault = 1;\n                            absValue *= 10;\n                            while(Math.abs(Math.round(absValue) - absValue) > 1e-6 && rightDigitsOfDefault < 7){\n                                ++rightDigitsOfDefault;\n                                absValue *= 10;\n                            }\n                        } else if (rightDigitsOfDefault !== 0) absValue *= Math.pow(10, rightDigitsOfDefault);\n                        // Using Java's default rounding policy HALF_EVEN. This policy is based\n                        // on the idea that 0.5 values round to the nearest even number, and\n                        // everything else is rounded normally.\n                        var number, doubled = absValue * 2;\n                        if (Math.floor(absValue) === absValue) number = absValue;\n                        else if (Math.floor(doubled) === doubled) {\n                            var floored = Math.floor(absValue);\n                            number = floored + floored % 2;\n                        } else number = Math.round(absValue);\n                        var buffer = \"\";\n                        var totalDigits = leftDigits + rightDigitsOfDefault;\n                        while(totalDigits > 0 || number > 0){\n                            totalDigits--;\n                            buffer = \"\" + number % 10 + buffer;\n                            number = Math.floor(number / 10);\n                        }\n                        if (group !== undef) {\n                            var i = buffer.length - 3 - rightDigitsOfDefault;\n                            while(i > 0){\n                                buffer = buffer.substring(0, i) + group + buffer.substring(i);\n                                i -= 3;\n                            }\n                        }\n                        if (rightDigitsOfDefault > 0) return sign + buffer.substring(0, buffer.length - rightDigitsOfDefault) + \".\" + buffer.substring(buffer.length - rightDigitsOfDefault, buffer.length);\n                        return sign + buffer;\n                    },\n                    /**\n    * Number-to-String formatting function. Prepends \"plus\" or \"minus\" depending\n    * on whether the value is positive or negative, respectively, after padding\n    * the value with zeroes on the left and right, the number of zeroes used dictated\n    * by the values 'leftDigits' and 'rightDigits'. 'value' can be an array;\n    * if the input is an array, each value in it is formatted separately, and\n    * an array with formatted values is returned.\n    *\n    * @param {int|int[]|float|float[]} value   the number(s) to format\n    * @param {String} plus                     the prefix for positive numbers\n    * @param {String} minus                    the prefix for negative numbers\n    * @param {int} left                        number of digits to the left of the decimal point\n    * @param {int} right                       number of digits to the right of the decimal point\n    * @param {String} group                    string delimited for groups, such as the comma in \"1,000\"\n    *\n    * @returns {String or String[]}\n    *\n    * @see nfCoreScalar\n    */ nfCore: function(value, plus, minus, leftDigits, rightDigits, group) {\n                        if (value instanceof Array) {\n                            var arr = [];\n                            for(var i = 0, len = value.length; i < len; i++)arr.push(CommonFunctions.nfCoreScalar(value[i], plus, minus, leftDigits, rightDigits, group));\n                            return arr;\n                        }\n                        return CommonFunctions.nfCoreScalar(value, plus, minus, leftDigits, rightDigits, group);\n                    },\n                    /**\n    * Utility function for formatting numbers into strings. There are two versions, one for\n    * formatting floats and one for formatting ints. The values for the digits, left, and\n    * right parameters should always be positive integers.\n    * As shown in the above example, nf() is used to add zeros to the left and/or right\n    * of a number. This is typically for aligning a list of numbers. To remove digits from\n    * a floating-point number, use the int(), ceil(), floor(), or round() functions.\n    *\n    * @param {int|int[]|float|float[]} value   the number(s) to format\n    * @param {int} left                        number of digits to the left of the decimal point\n    * @param {int} right                       number of digits to the right of the decimal point\n    *\n    * @returns {String or String[]}\n    *\n    * @see nfs\n    * @see nfp\n    * @see nfc\n    */ nf: function(value, leftDigits, rightDigits) {\n                        return CommonFunctions.nfCore(value, \"\", \"-\", leftDigits, rightDigits);\n                    },\n                    /**\n    * Utility function for formatting numbers into strings. Similar to nf()  but leaves a blank space in front\n    * of positive numbers so they align with negative numbers in spite of the minus symbol. There are two\n    * versions, one for formatting floats and one for formatting ints. The values for the digits, left,\n    * and right parameters should always be positive integers.\n    *\n    * @param {int|int[]|float|float[]} value   the number(s) to format\n    * @param {int} left                        number of digits to the left of the decimal point\n    * @param {int} right                       number of digits to the right of the decimal point\n    *\n    * @returns {String or String[]}\n    *\n    * @see nf\n    * @see nfp\n    * @see nfc\n    */ nfs: function(value, leftDigits, rightDigits) {\n                        return CommonFunctions.nfCore(value, \" \", \"-\", leftDigits, rightDigits);\n                    },\n                    /**\n    * Utility function for formatting numbers into strings. Similar to nf()  but puts a \"+\" in front of\n    * positive numbers and a \"-\" in front of negative numbers. There are two versions, one for formatting\n    * floats and one for formatting ints. The values for the digits, left, and right parameters should\n    * always be positive integers.\n    *\n    * @param {int|int[]|float|float[]} value   the number(s) to format\n    * @param {int} left                        number of digits to the left of the decimal point\n    * @param {int} right                       number of digits to the right of the decimal point\n    *\n    * @returns {String or String[]}\n    *\n    * @see nfs\n    * @see nf\n    * @see nfc\n    */ nfp: function(value, leftDigits, rightDigits) {\n                        return CommonFunctions.nfCore(value, \"+\", \"-\", leftDigits, rightDigits);\n                    },\n                    /**\n    * Utility function for formatting numbers into strings and placing appropriate commas to mark\n    * units of 1000. There are two versions, one for formatting ints and one for formatting an array\n    * of ints. The value for the digits parameter should always be a positive integer.\n    *\n    * @param {int|int[]|float|float[]} value   the number(s) to format\n    * @param {int} left                        number of digits to the left of the decimal point\n    * @param {int} right                       number of digits to the right of the decimal point\n    *\n    * @returns {String or String[]}\n    *\n    * @see nf\n    * @see nfs\n    * @see nfp\n    */ nfc: function(value, rightDigits) {\n                        return CommonFunctions.nfCore(value, \"\", \"-\", 0, rightDigits, \",\");\n                    },\n                    // used to bind all common functions to \"p\"\n                    withCommonFunctions: function withCommonFunctions(p) {\n                        [\n                            \"trim\",\n                            \"radians\",\n                            \"nf\",\n                            \"nfs\",\n                            \"nfp\",\n                            \"nfc\"\n                        ].forEach(function(f) {\n                            p[f] = CommonFunctions[f];\n                        });\n                    }\n                };\n                return CommonFunctions;\n            }();\n        },\n        {}\n    ],\n    25: [\n        function(require1, module, exports) {\n            /**\n * Touch and Mouse event handling\n */ module.exports = function withTouch(p, curElement, attachEventHandler, detachEventHandlersByType, document1, PConstants1, undef) {\n                // List of mouse event types\n                var mouseTypes = [\n                    \"mouseout\",\n                    \"mousemove\",\n                    \"mousedown\",\n                    \"mouseup\",\n                    \"DOMMouseScroll\",\n                    \"mousewheel\",\n                    \"touchstart\"\n                ];\n                /**\n   * Determine the location of the (mouse) pointer.\n   */ function calculateOffset(curElement, event) {\n                    var element = curElement, offsetX = 0, offsetY = 0;\n                    p.pmouseX = p.mouseX;\n                    p.pmouseY = p.mouseY;\n                    // Find element offset\n                    if (element.offsetParent) do {\n                        offsetX += element.offsetLeft;\n                        offsetY += element.offsetTop;\n                    }while (!!(element = element.offsetParent));\n                    // Find Scroll offset\n                    element = curElement;\n                    do {\n                        offsetX -= element.scrollLeft || 0;\n                        offsetY -= element.scrollTop || 0;\n                    }while (!!(element = element.parentNode));\n                    // Get padding and border style widths for mouse offsets\n                    var stylePaddingLeft, stylePaddingTop, styleBorderLeft, styleBorderTop;\n                    if (document1.defaultView && document1.defaultView.getComputedStyle) {\n                        stylePaddingLeft = parseInt(document1.defaultView.getComputedStyle(curElement, null).paddingLeft, 10) || 0;\n                        stylePaddingTop = parseInt(document1.defaultView.getComputedStyle(curElement, null).paddingTop, 10) || 0;\n                        styleBorderLeft = parseInt(document1.defaultView.getComputedStyle(curElement, null).borderLeftWidth, 10) || 0;\n                        styleBorderTop = parseInt(document1.defaultView.getComputedStyle(curElement, null).borderTopWidth, 10) || 0;\n                    }\n                    // Add padding and border style widths to offset\n                    offsetX += stylePaddingLeft;\n                    offsetY += stylePaddingTop;\n                    offsetX += styleBorderLeft;\n                    offsetY += styleBorderTop;\n                    // Take into account any scrolling done\n                    offsetX += window.pageXOffset;\n                    offsetY += window.pageYOffset;\n                    return {\n                        \"X\": offsetX,\n                        \"Y\": offsetY\n                    };\n                }\n                // simple relative position\n                function updateMousePosition(curElement, event) {\n                    var offset = calculateOffset(curElement, event);\n                    // Dropping support for IE clientX and clientY, switching to pageX and pageY\n                    // so we don't have to calculate scroll offset.\n                    // Removed in ticket #184. See rev: 2f106d1c7017fed92d045ba918db47d28e5c16f4\n                    p.mouseX = event.pageX - offset.X;\n                    p.mouseY = event.pageY - offset.Y;\n                }\n                /**\n   * Return a TouchEvent with canvas-specific x/y co-ordinates\n   */ function addTouchEventOffset(t1) {\n                    var offset = calculateOffset(t1.changedTouches[0].target, t1.changedTouches[0]), i;\n                    for(i = 0; i < t1.touches.length; i++){\n                        var touch = t1.touches[i];\n                        touch.offsetX = touch.pageX - offset.X;\n                        touch.offsetY = touch.pageY - offset.Y;\n                    }\n                    for(i = 0; i < t1.targetTouches.length; i++){\n                        var targetTouch = t1.targetTouches[i];\n                        targetTouch.offsetX = targetTouch.pageX - offset.X;\n                        targetTouch.offsetY = targetTouch.pageY - offset.Y;\n                    }\n                    for(i = 0; i < t1.changedTouches.length; i++){\n                        var changedTouch = t1.changedTouches[i];\n                        changedTouch.offsetX = changedTouch.pageX - offset.X;\n                        changedTouch.offsetY = changedTouch.pageY - offset.Y;\n                    }\n                    return t1;\n                }\n                /**\n   * Touch event support.\n   */ attachEventHandler(curElement, \"touchstart\", function(t1) {\n                    // Removes unwanted behaviour of the canvas when touching canvas\n                    curElement.setAttribute(\"style\", \"-webkit-user-select: none\");\n                    curElement.setAttribute(\"onclick\", \"void(0)\");\n                    curElement.setAttribute(\"style\", \"-webkit-tap-highlight-color:rgba(0,0,0,0)\");\n                    // Remove mouse-type event listeners\n                    detachEventHandlersByType(curElement, mouseTypes);\n                    // If there are any native touch events defined in the sketch, connect all of them\n                    // Otherwise, connect all of the emulated mouse events\n                    if (p.touchStart !== undef || p.touchMove !== undef || p.touchEnd !== undef || p.touchCancel !== undef) {\n                        attachEventHandler(curElement, \"touchstart\", function(t1) {\n                            if (p.touchStart !== undef) {\n                                t1 = addTouchEventOffset(t1);\n                                p.touchStart(t1);\n                            }\n                        });\n                        attachEventHandler(curElement, \"touchmove\", function(t1) {\n                            if (p.touchMove !== undef) {\n                                t1.preventDefault(); // Stop the viewport from scrolling\n                                t1 = addTouchEventOffset(t1);\n                                p.touchMove(t1);\n                            }\n                        });\n                        attachEventHandler(curElement, \"touchend\", function(t1) {\n                            if (p.touchEnd !== undef) {\n                                t1 = addTouchEventOffset(t1);\n                                p.touchEnd(t1);\n                            }\n                        });\n                        attachEventHandler(curElement, \"touchcancel\", function(t1) {\n                            if (p.touchCancel !== undef) {\n                                t1 = addTouchEventOffset(t1);\n                                p.touchCancel(t1);\n                            }\n                        });\n                    } else {\n                        // Emulated touch start/mouse down event\n                        attachEventHandler(curElement, \"touchstart\", function(e) {\n                            updateMousePosition(curElement, e.touches[0]);\n                            p.__mousePressed = true;\n                            p.mouseDragging = false;\n                            p.mouseButton = PConstants1.LEFT;\n                            if (typeof p.mousePressed === \"function\") p.mousePressed();\n                        });\n                        // Emulated touch move/mouse move event\n                        attachEventHandler(curElement, \"touchmove\", function(e) {\n                            e.preventDefault();\n                            updateMousePosition(curElement, e.touches[0]);\n                            if (typeof p.mouseMoved === \"function\" && !p.__mousePressed) p.mouseMoved();\n                            if (typeof p.mouseDragged === \"function\" && p.__mousePressed) {\n                                p.mouseDragged();\n                                p.mouseDragging = true;\n                            }\n                        });\n                        // Emulated touch up/mouse up event\n                        attachEventHandler(curElement, \"touchend\", function(e) {\n                            p.__mousePressed = false;\n                            if (typeof p.mouseClicked === \"function\" && !p.mouseDragging) p.mouseClicked();\n                            if (typeof p.mouseReleased === \"function\") p.mouseReleased();\n                        });\n                    }\n                });\n                /**\n   * Context menu toggles. Most often you will not want the\n   * browser's context menu to show on a right click, but\n   * sometimes, you do, so we add two unofficial functions\n   * that can be used to trigger context menu behaviour.\n   */ (function() {\n                    var enabled = true, contextMenu = function(e) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                    };\n                    p.disableContextMenu = function() {\n                        if (!enabled) return;\n                        attachEventHandler(curElement, \"contextmenu\", contextMenu);\n                        enabled = false;\n                    };\n                    p.enableContextMenu = function() {\n                        if (enabled) return;\n                        detachEventHandler({\n                            elem: curElement,\n                            type: \"contextmenu\",\n                            fn: contextMenu\n                        });\n                        enabled = true;\n                    };\n                })();\n                /**\n   * Mouse moved or dragged\n   */ attachEventHandler(curElement, \"mousemove\", function(e) {\n                    updateMousePosition(curElement, e);\n                    if (typeof p.mouseMoved === \"function\" && !p.__mousePressed) p.mouseMoved();\n                    if (typeof p.mouseDragged === \"function\" && p.__mousePressed) {\n                        p.mouseDragged();\n                        p.mouseDragging = true;\n                    }\n                });\n                /**\n   * Unofficial mouse-out handling\n   */ attachEventHandler(curElement, \"mouseout\", function(e) {\n                    if (typeof p.mouseOut === \"function\") p.mouseOut();\n                });\n                /**\n   * Mouse over\n   */ attachEventHandler(curElement, \"mouseover\", function(e) {\n                    updateMousePosition(curElement, e);\n                    if (typeof p.mouseOver === \"function\") p.mouseOver();\n                });\n                /**\n   * Disable browser's default handling for click-drag of a canvas.\n   */ curElement.onmousedown = function() {\n                    // make sure focus happens, but nothing else\n                    curElement.focus();\n                    return false;\n                };\n                /**\n   * Mouse pressed or drag\n   */ attachEventHandler(curElement, \"mousedown\", function(e) {\n                    p.__mousePressed = true;\n                    p.mouseDragging = false;\n                    switch(e.which){\n                        case 1:\n                            p.mouseButton = PConstants1.LEFT;\n                            break;\n                        case 2:\n                            p.mouseButton = PConstants1.CENTER;\n                            break;\n                        case 3:\n                            p.mouseButton = PConstants1.RIGHT;\n                            break;\n                    }\n                    if (typeof p.mousePressed === \"function\") p.mousePressed();\n                });\n                /**\n   * Mouse clicked or released\n   */ attachEventHandler(curElement, \"mouseup\", function(e) {\n                    p.__mousePressed = false;\n                    if (typeof p.mouseClicked === \"function\" && !p.mouseDragging) p.mouseClicked();\n                    if (typeof p.mouseReleased === \"function\") p.mouseReleased();\n                });\n                /**\n   * Unofficial scroll wheel handling.\n   */ var mouseWheelHandler = function(e) {\n                    // do not handle scroll wheel if initiated outside of the sketch\n                    if (e.target !== curElement) return;\n                    var delta = 0;\n                    if (e.wheelDelta) {\n                        delta = e.wheelDelta / 120;\n                        if (window.opera) delta = -delta;\n                    } else if (e.detail) delta = -e.detail / 3;\n                    p.mouseScroll = delta;\n                    if (delta && typeof p.mouseScrolled === \"function\") {\n                        // If this sketch has explicit scroll handling,\n                        // prevent scroll from kicking in globally before\n                        // calling the scroll handler.\n                        e.stopPropagation();\n                        e.preventDefault();\n                        p.mouseScrolled();\n                    }\n                };\n                // Support Gecko and non-Gecko scroll events\n                attachEventHandler(document1, \"DOMMouseScroll\", mouseWheelHandler);\n                attachEventHandler(document1, \"mousewheel\", mouseWheelHandler);\n            };\n        },\n        {}\n    ],\n    26: [\n        function(require1, module, exports) {\n            /**\n * The parser for turning Processing syntax into Pjs JavaScript.\n * This code is not trivial; unless you know what you're doing,\n * you shouldn't be changing things in here =)\n */ module.exports = function setupParser(Processing1, options) {\n                var defaultScope1 = options.defaultScope, PConstants1 = defaultScope1.PConstants, aFunctions = options.aFunctions, Browser = options.Browser, document1 = Browser.document, undef;\n                // Processing global methods and constants for the parser\n                function getGlobalMembers() {\n                    // The names array contains the names of everything that is inside \"p.\"\n                    // When something new is added to \"p.\" it must also be added to this list.\n                    var names = [\n                        /* this code is generated by jsglobals.js */ \"abs\",\n                        \"acos\",\n                        \"alpha\",\n                        \"ambient\",\n                        \"ambientLight\",\n                        \"append\",\n                        \"applyMatrix\",\n                        \"arc\",\n                        \"arrayCopy\",\n                        \"asin\",\n                        \"atan\",\n                        \"atan2\",\n                        \"background\",\n                        \"beginCamera\",\n                        \"beginDraw\",\n                        \"beginShape\",\n                        \"bezier\",\n                        \"bezierDetail\",\n                        \"bezierPoint\",\n                        \"bezierTangent\",\n                        \"bezierVertex\",\n                        \"binary\",\n                        \"blend\",\n                        \"blendColor\",\n                        \"blit_resize\",\n                        \"blue\",\n                        \"box\",\n                        \"breakShape\",\n                        \"brightness\",\n                        \"camera\",\n                        \"ceil\",\n                        \"Character\",\n                        \"color\",\n                        \"colorMode\",\n                        \"concat\",\n                        \"constrain\",\n                        \"copy\",\n                        \"cos\",\n                        \"createFont\",\n                        \"createGraphics\",\n                        \"createImage\",\n                        \"cursor\",\n                        \"curve\",\n                        \"curveDetail\",\n                        \"curvePoint\",\n                        \"curveTangent\",\n                        \"curveTightness\",\n                        \"curveVertex\",\n                        \"day\",\n                        \"degrees\",\n                        \"directionalLight\",\n                        \"disableContextMenu\",\n                        \"dist\",\n                        \"draw\",\n                        \"ellipse\",\n                        \"ellipseMode\",\n                        \"emissive\",\n                        \"enableContextMenu\",\n                        \"endCamera\",\n                        \"endDraw\",\n                        \"endShape\",\n                        \"exit\",\n                        \"exp\",\n                        \"expand\",\n                        \"externals\",\n                        \"fill\",\n                        \"filter\",\n                        \"floor\",\n                        \"focused\",\n                        \"frameCount\",\n                        \"frameRate\",\n                        \"frustum\",\n                        \"get\",\n                        \"glyphLook\",\n                        \"glyphTable\",\n                        \"green\",\n                        \"height\",\n                        \"hex\",\n                        \"hint\",\n                        \"hour\",\n                        \"hue\",\n                        \"image\",\n                        \"imageMode\",\n                        \"intersect\",\n                        \"join\",\n                        \"key\",\n                        \"keyCode\",\n                        \"keyPressed\",\n                        \"keyReleased\",\n                        \"keyTyped\",\n                        \"lerp\",\n                        \"lerpColor\",\n                        \"lightFalloff\",\n                        \"lights\",\n                        \"lightSpecular\",\n                        \"line\",\n                        \"link\",\n                        \"loadBytes\",\n                        \"loadFont\",\n                        \"loadGlyphs\",\n                        \"loadImage\",\n                        \"loadPixels\",\n                        \"loadShape\",\n                        \"loadXML\",\n                        \"loadStrings\",\n                        \"log\",\n                        \"loop\",\n                        \"mag\",\n                        \"map\",\n                        \"match\",\n                        \"matchAll\",\n                        \"max\",\n                        \"millis\",\n                        \"min\",\n                        \"minute\",\n                        \"mix\",\n                        \"modelX\",\n                        \"modelY\",\n                        \"modelZ\",\n                        \"modes\",\n                        \"month\",\n                        \"mouseButton\",\n                        \"mouseClicked\",\n                        \"mouseDragged\",\n                        \"mouseMoved\",\n                        \"mouseOut\",\n                        \"mouseOver\",\n                        \"mousePressed\",\n                        \"mouseReleased\",\n                        \"mouseScroll\",\n                        \"mouseScrolled\",\n                        \"mouseX\",\n                        \"mouseY\",\n                        \"name\",\n                        \"nf\",\n                        \"nfc\",\n                        \"nfp\",\n                        \"nfs\",\n                        \"noCursor\",\n                        \"noFill\",\n                        \"noise\",\n                        \"noiseDetail\",\n                        \"noiseSeed\",\n                        \"noLights\",\n                        \"noLoop\",\n                        \"norm\",\n                        \"normal\",\n                        \"noSmooth\",\n                        \"noStroke\",\n                        \"noTint\",\n                        \"ortho\",\n                        \"param\",\n                        \"parseBoolean\",\n                        \"parseByte\",\n                        \"parseChar\",\n                        \"parseFloat\",\n                        \"parseInt\",\n                        \"parseXML\",\n                        \"peg\",\n                        \"perspective\",\n                        \"PImage\",\n                        \"pixels\",\n                        \"PMatrix2D\",\n                        \"PMatrix3D\",\n                        \"PMatrixStack\",\n                        \"pmouseX\",\n                        \"pmouseY\",\n                        \"point\",\n                        \"pointLight\",\n                        \"popMatrix\",\n                        \"popStyle\",\n                        \"pow\",\n                        \"print\",\n                        \"printCamera\",\n                        \"println\",\n                        \"printMatrix\",\n                        \"printProjection\",\n                        \"PShape\",\n                        \"PShapeSVG\",\n                        \"pushMatrix\",\n                        \"pushStyle\",\n                        \"quad\",\n                        \"radians\",\n                        \"random\",\n                        \"randomGaussian\",\n                        \"randomSeed\",\n                        \"rect\",\n                        \"rectMode\",\n                        \"red\",\n                        \"redraw\",\n                        \"requestImage\",\n                        \"resetMatrix\",\n                        \"reverse\",\n                        \"rotate\",\n                        \"rotateX\",\n                        \"rotateY\",\n                        \"rotateZ\",\n                        \"round\",\n                        \"saturation\",\n                        \"save\",\n                        \"saveFrame\",\n                        \"saveStrings\",\n                        \"scale\",\n                        \"screenX\",\n                        \"screenY\",\n                        \"screenZ\",\n                        \"second\",\n                        \"set\",\n                        \"setup\",\n                        \"shape\",\n                        \"shapeMode\",\n                        \"shared\",\n                        \"shearX\",\n                        \"shearY\",\n                        \"shininess\",\n                        \"shorten\",\n                        \"sin\",\n                        \"size\",\n                        \"smooth\",\n                        \"sort\",\n                        \"specular\",\n                        \"sphere\",\n                        \"sphereDetail\",\n                        \"splice\",\n                        \"split\",\n                        \"splitTokens\",\n                        \"spotLight\",\n                        \"sq\",\n                        \"sqrt\",\n                        \"status\",\n                        \"str\",\n                        \"stroke\",\n                        \"strokeCap\",\n                        \"strokeJoin\",\n                        \"strokeWeight\",\n                        \"subset\",\n                        \"tan\",\n                        \"text\",\n                        \"textAlign\",\n                        \"textAscent\",\n                        \"textDescent\",\n                        \"textFont\",\n                        \"textLeading\",\n                        \"textMode\",\n                        \"textSize\",\n                        \"texture\",\n                        \"textureMode\",\n                        \"textWidth\",\n                        \"tint\",\n                        \"toImageData\",\n                        \"touchCancel\",\n                        \"touchEnd\",\n                        \"touchMove\",\n                        \"touchStart\",\n                        \"translate\",\n                        \"transform\",\n                        \"triangle\",\n                        \"trim\",\n                        \"unbinary\",\n                        \"unhex\",\n                        \"updatePixels\",\n                        \"use3DContext\",\n                        \"vertex\",\n                        \"width\",\n                        \"XMLElement\",\n                        \"XML\",\n                        \"year\",\n                        \"__contains\",\n                        \"__equals\",\n                        \"__equalsIgnoreCase\",\n                        \"__frameRate\",\n                        \"__hashCode\",\n                        \"__int_cast\",\n                        \"__instanceof\",\n                        \"__keyPressed\",\n                        \"__mousePressed\",\n                        \"__printStackTrace\",\n                        \"__replace\",\n                        \"__replaceAll\",\n                        \"__replaceFirst\",\n                        \"__toCharArray\",\n                        \"__split\",\n                        \"__codePointAt\",\n                        \"__startsWith\",\n                        \"__endsWith\",\n                        \"__matches\"\n                    ];\n                    // custom functions and properties are added here\n                    if (aFunctions) Object.keys(aFunctions).forEach(function(name) {\n                        names.push(name);\n                    });\n                    // custom libraries that were attached to Processing\n                    var members = {};\n                    var i, l;\n                    for(i = 0, l = names.length; i < l; ++i)members[names[i]] = null;\n                    for(var lib in Processing1.lib){\n                        if (Processing1.lib.hasOwnProperty(lib)) {\n                            if (Processing1.lib[lib].exports) {\n                                var exportedNames = Processing1.lib[lib].exports;\n                                for(i = 0, l = exportedNames.length; i < l; ++i)members[exportedNames[i]] = null;\n                            }\n                        }\n                    }\n                    return members;\n                }\n                /*\n\n    Parser converts Java-like syntax into JavaScript.\n    Creates an Abstract Syntax Tree -- \"Light AST\" from the Java-like code.\n\n    It is an object tree. The root object is created from the AstRoot class, which contains statements.\n\n    A statement object can be of type: AstForStatement, AstCatchStatement, AstPrefixStatement, AstMethod, AstClass,\n    AstInterface, AstFunction, AstStatementBlock and AstLabel.\n\n    AstPrefixStatement can be a statement of type: if, switch, while, with, do, else, finally, return, throw, try, break, and continue.\n\n    These object's toString function returns the JavaScript code for the statement.\n\n    Any processing calls need \"processing.\" prepended to them.\n\n    Similarly, calls from inside classes need \"$this_1.\", prepended to them,\n    with 1 being the depth level for inner classes.\n    This includes members passed down from inheritance.\n\n    The resulting code is then eval'd and run.\n\n  */ function parseProcessing(code) {\n                    var globalMembers = getGlobalMembers();\n                    // masks parentheses, brackets and braces with '\"A5\"'\n                    // where A is the bracket type, and 5 is the index in an array containing all brackets split into atoms\n                    // 'while(true){}' -> 'while\"B1\"\"A2\"'\n                    // parentheses() = B, brackets[] = C and braces{} = A\n                    function splitToAtoms(code) {\n                        var atoms = [];\n                        var items = code.split(/([\\{\\[\\(\\)\\]\\}])/);\n                        var result = items[0];\n                        var stack = [];\n                        for(var i = 1; i < items.length; i += 2){\n                            var item = items[i];\n                            if (item === \"[\" || item === \"{\" || item === \"(\") {\n                                stack.push(result);\n                                result = item;\n                            } else if (item === \"]\" || item === \"}\" || item === \")\") {\n                                var kind = item === \"}\" ? \"A\" : item === \")\" ? \"B\" : \"C\";\n                                var index = atoms.length;\n                                atoms.push(result + item);\n                                result = stack.pop() + '\"' + kind + (index + 1) + '\"';\n                            }\n                            result += items[i + 1];\n                        }\n                        atoms.unshift(result);\n                        return atoms;\n                    }\n                    // replaces strings and regexs keyed by index with an array of strings\n                    function injectStrings(code, strings) {\n                        return code.replace(/'(\\d+)'/g, function(all, index) {\n                            var val = strings[index];\n                            if (val.charAt(0) === \"/\") return val;\n                            return /^'((?:[^'\\\\\\n])|(?:\\\\.[0-9A-Fa-f]*))'$/.test(val) ? \"(new $p.Character(\" + val + \"))\" : val;\n                        });\n                    }\n                    // trims off leading and trailing spaces\n                    // returns an object. object.left, object.middle, object.right, object.untrim\n                    function trimSpaces(string) {\n                        var m1 = /^\\s*/.exec(string), result;\n                        if (m1[0].length === string.length) result = {\n                            left: m1[0],\n                            middle: \"\",\n                            right: \"\"\n                        };\n                        else {\n                            var m2 = /\\s*$/.exec(string);\n                            result = {\n                                left: m1[0],\n                                middle: string.substring(m1[0].length, m2.index),\n                                right: m2[0]\n                            };\n                        }\n                        result.untrim = function(t1) {\n                            return this.left + t1 + this.right;\n                        };\n                        return result;\n                    }\n                    // simple trim of leading and trailing spaces\n                    function trim(string) {\n                        return string.replace(/^\\s+/, \"\").replace(/\\s+$/, \"\");\n                    }\n                    function appendToLookupTable(table, array) {\n                        for(var i = 0, l = array.length; i < l; ++i)table[array[i]] = null;\n                        return table;\n                    }\n                    function isLookupTableEmpty(table) {\n                        for(var i in table){\n                            if (table.hasOwnProperty(i)) return false;\n                        }\n                        return true;\n                    }\n                    function getAtomIndex(templ) {\n                        return templ.substring(2, templ.length - 1);\n                    }\n                    // remove carriage returns \"\\r\"\n                    var codeWoExtraCr = code.replace(/\\r\\n?|\\n\\r/g, \"\\n\");\n                    // masks strings and regexs with \"'5'\", where 5 is the index in an array containing all strings and regexs\n                    // also removes all comments\n                    var strings = [];\n                    var codeWoStrings = codeWoExtraCr.replace(/(\"(?:[^\"\\\\\\n]|\\\\.)*\")|('(?:[^'\\\\\\n]|\\\\.)*')|(([\\[\\(=|&!\\^:?]\\s*)(\\/(?![*\\/])(?:[^\\/\\\\\\n]|\\\\.)*\\/[gim]*)\\b)|(\\/\\/[^\\n]*\\n)|(\\/\\*(?:(?!\\*\\/)(?:.|\\n))*\\*\\/)/g, function(all, quoted, aposed, regexCtx, prefix, regex, singleComment, comment) {\n                        var index;\n                        if (quoted || aposed) {\n                            index = strings.length;\n                            strings.push(all);\n                            return \"'\" + index + \"'\";\n                        }\n                        if (regexCtx) {\n                            index = strings.length;\n                            strings.push(regex);\n                            return prefix + \"'\" + index + \"'\";\n                        }\n                        // kill comments\n                        return comment !== \"\" ? \" \" : \"\\n\";\n                    });\n                    // protect character codes from namespace collision\n                    codeWoStrings = codeWoStrings.replace(/__x([0-9A-F]{4})/g, function(all, hexCode) {\n                        // $ = __x0024\n                        // _ = __x005F\n                        // this protects existing character codes from conversion\n                        // __x0024 = __x005F_x0024\n                        return \"__x005F_x\" + hexCode;\n                    });\n                    // convert dollar sign to character code\n                    codeWoStrings = codeWoStrings.replace(/\\$/g, \"__x0024\");\n                    // Remove newlines after return statements\n                    codeWoStrings = codeWoStrings.replace(/return\\s*[\\n\\r]+/g, \"return \");\n                    // removes generics\n                    var genericsWereRemoved;\n                    var codeWoGenerics = codeWoStrings;\n                    var replaceFunc = function(all, before, types, after) {\n                        if (!!before || !!after) return all;\n                        genericsWereRemoved = true;\n                        return \"\";\n                    };\n                    do {\n                        genericsWereRemoved = false;\n                        codeWoGenerics = codeWoGenerics.replace(/([<]?)<\\s*((?:\\?|[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)(?:\\[\\])*(?:\\s+(?:extends|super)\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)?(?:\\s*,\\s*(?:\\?|[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)(?:\\[\\])*(?:\\s+(?:extends|super)\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)?)*)\\s*>([=]?)/g, replaceFunc);\n                    }while (genericsWereRemoved);\n                    var atoms = splitToAtoms(codeWoGenerics);\n                    var replaceContext;\n                    var declaredClasses = {}, currentClassId, classIdSeed = 0;\n                    function addAtom(text, type) {\n                        var lastIndex = atoms.length;\n                        atoms.push(text);\n                        return '\"' + type + lastIndex + '\"';\n                    }\n                    function generateClassId() {\n                        return \"class\" + ++classIdSeed;\n                    }\n                    function appendClass(class_, classId, scopeId) {\n                        class_.classId = classId;\n                        class_.scopeId = scopeId;\n                        declaredClasses[classId] = class_;\n                    }\n                    // functions defined below\n                    var transformClassBody, transformInterfaceBody, transformStatementsBlock, transformStatements, transformMain, transformExpression;\n                    var classesRegex = /\\b((?:(?:public|private|final|protected|static|abstract)\\s+)*)(class|interface)\\s+([A-Za-z_$][\\w$]*\\b)(\\s+extends\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*,\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*\\b)*)?(\\s+implements\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*,\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*\\b)*)?\\s*(\"A\\d+\")/g;\n                    var methodsRegex = /\\b((?:(?:public|private|final|protected|static|abstract|synchronized)\\s+)*)((?!(?:else|new|return|throw|function|public|private|protected)\\b)[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*\"C\\d+\")*)\\s*([A-Za-z_$][\\w$]*\\b)\\s*(\"B\\d+\")(\\s*throws\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*,\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)*)?\\s*(\"A\\d+\"|;)/g;\n                    var fieldTest = /^((?:(?:public|private|final|protected|static)\\s+)*)((?!(?:else|new|return|throw)\\b)[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*\"C\\d+\")*)\\s*([A-Za-z_$][\\w$]*\\b)\\s*(?:\"C\\d+\"\\s*)*([=,]|$)/;\n                    var cstrsRegex = /\\b((?:(?:public|private|final|protected|static|abstract)\\s+)*)((?!(?:new|return|throw)\\b)[A-Za-z_$][\\w$]*\\b)\\s*(\"B\\d+\")(\\s*throws\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*,\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)*)?\\s*(\"A\\d+\")/g;\n                    var attrAndTypeRegex = /^((?:(?:public|private|final|protected|static)\\s+)*)((?!(?:new|return|throw)\\b)[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*\"C\\d+\")*)\\s*/;\n                    var functionsRegex = /\\bfunction(?:\\s+([A-Za-z_$][\\w$]*))?\\s*(\"B\\d+\")\\s*(\"A\\d+\")/g;\n                    // This converts classes, methods and functions into atoms, and adds them to the atoms array.\n                    // classes = E, methods = D and functions = H\n                    function extractClassesAndMethods(code) {\n                        var s = code;\n                        s = s.replace(classesRegex, function(all) {\n                            return addAtom(all, \"E\");\n                        });\n                        s = s.replace(methodsRegex, function(all) {\n                            return addAtom(all, \"D\");\n                        });\n                        s = s.replace(functionsRegex, function(all) {\n                            return addAtom(all, \"H\");\n                        });\n                        return s;\n                    }\n                    // This converts constructors into atoms, and adds them to the atoms array.\n                    // constructors = G\n                    function extractConstructors(code, className) {\n                        var result = code.replace(cstrsRegex, function(all, attr, name, params, throws_, body) {\n                            if (name !== className) return all;\n                            return addAtom(all, \"G\");\n                        });\n                        return result;\n                    }\n                    // AstParam contains the name of a parameter inside a function declaration\n                    function AstParam(name) {\n                        this.name = name;\n                    }\n                    AstParam.prototype.toString = function() {\n                        return this.name;\n                    };\n                    // AstParams contains an array of AstParam objects\n                    function AstParams(params, methodArgsParam) {\n                        this.params = params;\n                        this.methodArgsParam = methodArgsParam;\n                    }\n                    AstParams.prototype.getNames = function() {\n                        var names = [];\n                        for(var i = 0, l = this.params.length; i < l; ++i)names.push(this.params[i].name);\n                        return names;\n                    };\n                    AstParams.prototype.prependMethodArgs = function(body) {\n                        if (!this.methodArgsParam) return body;\n                        return \"{\\nvar \" + this.methodArgsParam.name + \" = Array.prototype.slice.call(arguments, \" + this.params.length + \");\\n\" + body.substring(1);\n                    };\n                    AstParams.prototype.toString = function() {\n                        if (this.params.length === 0) return \"()\";\n                        var result = \"(\";\n                        for(var i = 0, l = this.params.length; i < l; ++i)result += this.params[i] + \", \";\n                        return result.substring(0, result.length - 2) + \")\";\n                    };\n                    function transformParams(params) {\n                        var paramsWoPars = trim(params.substring(1, params.length - 1));\n                        var result = [], methodArgsParam = null;\n                        if (paramsWoPars !== \"\") {\n                            var paramList = paramsWoPars.split(\",\");\n                            for(var i = 0; i < paramList.length; ++i){\n                                var param = /\\b([A-Za-z_$][\\w$]*\\b)(\\s*\"[ABC][\\d]*\")*\\s*$/.exec(paramList[i]);\n                                if (i === paramList.length - 1 && paramList[i].indexOf(\"...\") >= 0) {\n                                    methodArgsParam = new AstParam(param[1]);\n                                    break;\n                                }\n                                result.push(new AstParam(param[1]));\n                            }\n                        }\n                        return new AstParams(result, methodArgsParam);\n                    }\n                    function preExpressionTransform(expr) {\n                        var s = expr;\n                        // new type[] {...} --> {...}\n                        s = s.replace(/\\bnew\\s+([A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)(?:\\s*\"C\\d+\")+\\s*(\"A\\d+\")/g, function(all, type, init) {\n                            return init;\n                        });\n                        // new Runnable() {...} --> \"F???\"\n                        s = s.replace(/\\bnew\\s+([A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)(?:\\s*\"B\\d+\")\\s*(\"A\\d+\")/g, function(all, type, init) {\n                            return addAtom(all, \"F\");\n                        });\n                        // function(...) { } --> \"H???\"\n                        s = s.replace(functionsRegex, function(all) {\n                            return addAtom(all, \"H\");\n                        });\n                        // new type[?] --> createJavaArray('type', [?])\n                        s = s.replace(/\\bnew\\s+([A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)\\s*(\"C\\d+\"(?:\\s*\"C\\d+\")*)/g, function(all, type, index) {\n                            var args = index.replace(/\"C(\\d+)\"/g, function(all, j) {\n                                return atoms[j];\n                            }).replace(/\\[\\s*\\]/g, \"[null]\").replace(/\\s*\\]\\s*\\[\\s*/g, \", \");\n                            var arrayInitializer = \"{\" + args.substring(1, args.length - 1) + \"}\";\n                            var createArrayArgs = \"('\" + type + \"', \" + addAtom(arrayInitializer, \"A\") + \")\";\n                            return \"$p.createJavaArray\" + addAtom(createArrayArgs, \"B\");\n                        });\n                        // .length() --> .length\n                        s = s.replace(/(\\.\\s*length)\\s*\"B\\d+\"/g, \"$1\");\n                        // #000000 --> 0x000000\n                        s = s.replace(/#([0-9A-Fa-f]{6})\\b/g, function(all, digits) {\n                            return \"0xFF\" + digits;\n                        });\n                        // delete (type)???, except (int)???\n                        s = s.replace(/\"B(\\d+)\"(\\s*(?:[\\w$']|\"B))/g, function(all, index, next) {\n                            var atom = atoms[index];\n                            if (!/^\\(\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*\\s*(?:\"C\\d+\"\\s*)*\\)$/.test(atom)) return all;\n                            if (/^\\(\\s*int\\s*\\)$/.test(atom)) return \"(int)\" + next;\n                            var indexParts = atom.split(/\"C(\\d+)\"/g);\n                            if (indexParts.length > 1) {\n                                // even items contains atom numbers, can check only first\n                                if (!/^\\[\\s*\\]$/.test(atoms[indexParts[1]])) return all; // fallback - not a cast\n                            }\n                            return \"\" + next;\n                        });\n                        // (int)??? -> __int_cast(???)\n                        s = s.replace(/\\(int\\)([^,\\]\\)\\}\\?\\:\\*\\+\\-\\/\\^\\|\\%\\&\\~<\\>\\=]+)/g, function(all, arg) {\n                            var trimmed = trimSpaces(arg);\n                            return trimmed.untrim(\"__int_cast(\" + trimmed.middle + \")\");\n                        });\n                        // super() -> $superCstr(), super. -> $super.;\n                        s = s.replace(/\\bsuper(\\s*\"B\\d+\")/g, \"$$superCstr$1\").replace(/\\bsuper(\\s*\\.)/g, \"$$super$1\");\n                        // 000.43->0.43 and 0010f->10, but not 0010\n                        s = s.replace(/\\b0+((\\d*)(?:\\.[\\d*])?(?:[eE][\\-\\+]?\\d+)?[fF]?)\\b/, function(all, numberWo0, intPart) {\n                            if (numberWo0 === intPart) return all;\n                            return intPart === \"\" ? \"0\" + numberWo0 : numberWo0;\n                        });\n                        // 3.0f -> 3.0\n                        s = s.replace(/\\b(\\.?\\d+\\.?)[fF]\\b/g, \"$1\");\n                        // Weird (?) parsing errors with %\n                        s = s.replace(/([^\\s])%([^=\\s])/g, \"$1 % $2\");\n                        // Since frameRate() and frameRate are different things,\n                        // we need to differentiate them somehow. So when we parse\n                        // the Processing.js source, replace frameRate so it isn't\n                        // confused with frameRate(), as well as keyPressed and mousePressed\n                        s = s.replace(/\\b(frameRate|keyPressed|mousePressed)\\b(?!\\s*\"B)/g, \"__$1\");\n                        // \"boolean\", \"byte\", \"int\", etc. => \"parseBoolean\", \"parseByte\", \"parseInt\", etc.\n                        s = s.replace(/\\b(boolean|byte|char|float|int)\\s*\"B/g, function(all, name) {\n                            return \"parse\" + name.substring(0, 1).toUpperCase() + name.substring(1) + '\"B';\n                        });\n                        // \"pixels\" replacements:\n                        //   pixels[i] = c => pixels.setPixel(i,c) | pixels[i] => pixels.getPixel(i)\n                        //   pixels.length => pixels.getLength()\n                        //   pixels = ar => pixels.set(ar) | pixels => pixels.toArray()\n                        s = s.replace(/\\bpixels\\b\\s*((\"C(\\d+)\")|\\.length)?(\\s*=(?!=)([^,\\]\\)\\}]+))?/g, function(all, indexOrLength, index, atomIndex, equalsPart, rightSide) {\n                            if (index) {\n                                var atom = atoms[atomIndex];\n                                if (equalsPart) return \"pixels.setPixel\" + addAtom(\"(\" + atom.substring(1, atom.length - 1) + \",\" + rightSide + \")\", \"B\");\n                                return \"pixels.getPixel\" + addAtom(\"(\" + atom.substring(1, atom.length - 1) + \")\", \"B\");\n                            }\n                            if (indexOrLength) // length\n                            return \"pixels.getLength\" + addAtom(\"()\", \"B\");\n                            if (equalsPart) return \"pixels.set\" + addAtom(\"(\" + rightSide + \")\", \"B\");\n                            return \"pixels.toArray\" + addAtom(\"()\", \"B\");\n                        });\n                        // Java method replacements for: replace, replaceAll, replaceFirst, equals, hashCode, etc.\n                        //   xxx.replace(yyy) -> __replace(xxx, yyy)\n                        //   \"xx\".replace(yyy) -> __replace(\"xx\", yyy)\n                        var repeatJavaReplacement;\n                        function replacePrototypeMethods(all, subject, method, atomIndex) {\n                            var atom = atoms[atomIndex];\n                            repeatJavaReplacement = true;\n                            var trimmed = trimSpaces(atom.substring(1, atom.length - 1));\n                            return \"__\" + method + (trimmed.middle === \"\" ? addAtom(\"(\" + subject.replace(/\\.\\s*$/, \"\") + \")\", \"B\") : addAtom(\"(\" + subject.replace(/\\.\\s*$/, \"\") + \",\" + trimmed.middle + \")\", \"B\"));\n                        }\n                        do {\n                            repeatJavaReplacement = false;\n                            s = s.replace(/((?:'\\d+'|\\b[A-Za-z_$][\\w$]*\\s*(?:\"[BC]\\d+\")*)\\s*\\.\\s*(?:[A-Za-z_$][\\w$]*\\s*(?:\"[BC]\\d+\"\\s*)*\\.\\s*)*)(replace|replaceAll|replaceFirst|contains|equals|equalsIgnoreCase|hashCode|toCharArray|printStackTrace|split|startsWith|endsWith|codePointAt|matches)\\s*\"B(\\d+)\"/g, replacePrototypeMethods);\n                        }while (repeatJavaReplacement);\n                        // xxx instanceof yyy -> __instanceof(xxx, yyy)\n                        function replaceInstanceof(all, subject, type) {\n                            repeatJavaReplacement = true;\n                            return \"__instanceof\" + addAtom(\"(\" + subject + \", \" + type + \")\", \"B\");\n                        }\n                        do {\n                            repeatJavaReplacement = false;\n                            s = s.replace(/((?:'\\d+'|\\b[A-Za-z_$][\\w$]*\\s*(?:\"[BC]\\d+\")*)\\s*(?:\\.\\s*[A-Za-z_$][\\w$]*\\s*(?:\"[BC]\\d+\"\\s*)*)*)instanceof\\s+([A-Za-z_$][\\w$]*\\s*(?:\\.\\s*[A-Za-z_$][\\w$]*)*)/g, replaceInstanceof);\n                        }while (repeatJavaReplacement);\n                        // this() -> $constr()\n                        s = s.replace(/\\bthis(\\s*\"B\\d+\")/g, \"$$constr$1\");\n                        return s;\n                    }\n                    function AstInlineClass(baseInterfaceName, body) {\n                        this.baseInterfaceName = baseInterfaceName;\n                        this.body = body;\n                        body.owner = this;\n                    }\n                    AstInlineClass.prototype.toString = function() {\n                        return \"new (\" + this.body + \")\";\n                    };\n                    function transformInlineClass(class_) {\n                        var m = new RegExp(/\\bnew\\s*([A-Za-z_$][\\w$]*\\s*(?:\\.\\s*[A-Za-z_$][\\w$]*)*)\\s*\"B\\d+\"\\s*\"A(\\d+)\"/).exec(class_);\n                        var oldClassId = currentClassId, newClassId = generateClassId();\n                        currentClassId = newClassId;\n                        var uniqueClassName = m[1] + \"$\" + newClassId;\n                        var inlineClass = new AstInlineClass(uniqueClassName, transformClassBody(atoms[m[2]], uniqueClassName, \"\", \"implements \" + m[1]));\n                        appendClass(inlineClass, newClassId, oldClassId);\n                        currentClassId = oldClassId;\n                        return inlineClass;\n                    }\n                    function AstFunction(name, params, body) {\n                        this.name = name;\n                        this.params = params;\n                        this.body = body;\n                    }\n                    AstFunction.prototype.toString = function() {\n                        var oldContext = replaceContext;\n                        // saving \"this.\" and parameters\n                        var names = appendToLookupTable({\n                            \"this\": null\n                        }, this.params.getNames());\n                        replaceContext = function(subject) {\n                            return names.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);\n                        };\n                        var result = \"function\";\n                        if (this.name) result += \" \" + this.name;\n                        var body = this.params.prependMethodArgs(this.body.toString());\n                        result += this.params + \" \" + body;\n                        replaceContext = oldContext;\n                        return result;\n                    };\n                    function transformFunction(class_) {\n                        var m = new RegExp(/\\b([A-Za-z_$][\\w$]*)\\s*\"B(\\d+)\"\\s*\"A(\\d+)\"/).exec(class_);\n                        return new AstFunction(m[1] !== \"function\" ? m[1] : null, transformParams(atoms[m[2]]), transformStatementsBlock(atoms[m[3]]));\n                    }\n                    function AstInlineObject(members) {\n                        this.members = members;\n                    }\n                    AstInlineObject.prototype.toString = function() {\n                        var oldContext = replaceContext;\n                        replaceContext = function(subject) {\n                            return subject.name === \"this\" ? \"this\" : oldContext(subject); // saving \"this.\"\n                        };\n                        var result = \"\";\n                        for(var i = 0, l = this.members.length; i < l; ++i){\n                            if (this.members[i].label) result += this.members[i].label + \": \";\n                            result += this.members[i].value.toString() + \", \";\n                        }\n                        replaceContext = oldContext;\n                        return result.substring(0, result.length - 2);\n                    };\n                    function transformInlineObject(obj) {\n                        var members = obj.split(\",\");\n                        for(var i = 0; i < members.length; ++i){\n                            var label = members[i].indexOf(\":\");\n                            if (label < 0) members[i] = {\n                                value: transformExpression(members[i])\n                            };\n                            else members[i] = {\n                                label: trim(members[i].substring(0, label)),\n                                value: transformExpression(trim(members[i].substring(label + 1)))\n                            };\n                        }\n                        return new AstInlineObject(members);\n                    }\n                    function expandExpression(expr) {\n                        if (expr.charAt(0) === \"(\" || expr.charAt(0) === \"[\") return expr.charAt(0) + expandExpression(expr.substring(1, expr.length - 1)) + expr.charAt(expr.length - 1);\n                        if (expr.charAt(0) === \"{\") {\n                            if (/^\\{\\s*(?:[A-Za-z_$][\\w$]*|'\\d+')\\s*:/.test(expr)) return \"{\" + addAtom(expr.substring(1, expr.length - 1), \"I\") + \"}\";\n                            return \"[\" + expandExpression(expr.substring(1, expr.length - 1)) + \"]\";\n                        }\n                        var trimmed = trimSpaces(expr);\n                        var result = preExpressionTransform(trimmed.middle);\n                        result = result.replace(/\"[ABC](\\d+)\"/g, function(all, index) {\n                            return expandExpression(atoms[index]);\n                        });\n                        return trimmed.untrim(result);\n                    }\n                    function replaceContextInVars(expr) {\n                        return expr.replace(/(\\.\\s*)?((?:\\b[A-Za-z_]|\\$)[\\w$]*)(\\s*\\.\\s*([A-Za-z_$][\\w$]*)(\\s*\\()?)?/g, function(all, memberAccessSign, identifier, suffix, subMember, callSign) {\n                            if (memberAccessSign) return all;\n                            var subject = {\n                                name: identifier,\n                                member: subMember,\n                                callSign: !!callSign\n                            };\n                            return replaceContext(subject) + (suffix === undef ? \"\" : suffix);\n                        });\n                    }\n                    function AstExpression(expr, transforms) {\n                        this.expr = expr;\n                        this.transforms = transforms;\n                    }\n                    AstExpression.prototype.toString = function() {\n                        var transforms = this.transforms;\n                        var expr = replaceContextInVars(this.expr);\n                        return expr.replace(/\"!(\\d+)\"/g, function(all, index) {\n                            return transforms[index].toString();\n                        });\n                    };\n                    transformExpression = function(expr) {\n                        var transforms = [];\n                        var s = expandExpression(expr);\n                        s = s.replace(/\"H(\\d+)\"/g, function(all, index) {\n                            transforms.push(transformFunction(atoms[index]));\n                            return '\"!' + (transforms.length - 1) + '\"';\n                        });\n                        s = s.replace(/\"F(\\d+)\"/g, function(all, index) {\n                            transforms.push(transformInlineClass(atoms[index]));\n                            return '\"!' + (transforms.length - 1) + '\"';\n                        });\n                        s = s.replace(/\"I(\\d+)\"/g, function(all, index) {\n                            transforms.push(transformInlineObject(atoms[index]));\n                            return '\"!' + (transforms.length - 1) + '\"';\n                        });\n                        return new AstExpression(s, transforms);\n                    };\n                    function AstVarDefinition(name, value, isDefault) {\n                        this.name = name;\n                        this.value = value;\n                        this.isDefault = isDefault;\n                    }\n                    AstVarDefinition.prototype.toString = function() {\n                        return this.name + \" = \" + this.value;\n                    };\n                    function transformVarDefinition(def, defaultTypeValue) {\n                        var eqIndex = def.indexOf(\"=\");\n                        var name, value, isDefault;\n                        if (eqIndex < 0) {\n                            name = def;\n                            value = defaultTypeValue;\n                            isDefault = true;\n                        } else {\n                            name = def.substring(0, eqIndex);\n                            value = transformExpression(def.substring(eqIndex + 1));\n                            isDefault = false;\n                        }\n                        return new AstVarDefinition(trim(name.replace(/(\\s*\"C\\d+\")+/g, \"\")), value, isDefault);\n                    }\n                    function getDefaultValueForType(type) {\n                        if (type === \"int\" || type === \"float\") return \"0\";\n                        if (type === \"boolean\") return \"false\";\n                        if (type === \"color\") return \"0x00000000\";\n                        return \"null\";\n                    }\n                    function AstVar(definitions, varType) {\n                        this.definitions = definitions;\n                        this.varType = varType;\n                    }\n                    AstVar.prototype.getNames = function() {\n                        var names = [];\n                        for(var i = 0, l = this.definitions.length; i < l; ++i)names.push(this.definitions[i].name);\n                        return names;\n                    };\n                    AstVar.prototype.toString = function() {\n                        return \"var \" + this.definitions.join(\",\");\n                    };\n                    function AstStatement(expression) {\n                        this.expression = expression;\n                    }\n                    AstStatement.prototype.toString = function() {\n                        return this.expression.toString();\n                    };\n                    function transformStatement(statement) {\n                        if (fieldTest.test(statement)) {\n                            var attrAndType = attrAndTypeRegex.exec(statement);\n                            var definitions = statement.substring(attrAndType[0].length).split(\",\");\n                            var defaultTypeValue = getDefaultValueForType(attrAndType[2]);\n                            for(var i = 0; i < definitions.length; ++i)definitions[i] = transformVarDefinition(definitions[i], defaultTypeValue);\n                            return new AstVar(definitions, attrAndType[2]);\n                        }\n                        return new AstStatement(transformExpression(statement));\n                    }\n                    function AstForExpression(initStatement, condition, step) {\n                        this.initStatement = initStatement;\n                        this.condition = condition;\n                        this.step = step;\n                    }\n                    AstForExpression.prototype.toString = function() {\n                        return \"(\" + this.initStatement + \"; \" + this.condition + \"; \" + this.step + \")\";\n                    };\n                    function AstForInExpression(initStatement, container) {\n                        this.initStatement = initStatement;\n                        this.container = container;\n                    }\n                    AstForInExpression.prototype.toString = function() {\n                        var init = this.initStatement.toString();\n                        if (init.indexOf(\"=\") >= 0) init = init.substring(0, init.indexOf(\"=\"));\n                        return \"(\" + init + \" in \" + this.container + \")\";\n                    };\n                    function AstForEachExpression(initStatement, container) {\n                        this.initStatement = initStatement;\n                        this.container = container;\n                    }\n                    AstForEachExpression.iteratorId = 0;\n                    AstForEachExpression.prototype.toString = function() {\n                        var init = this.initStatement.toString();\n                        var iterator = \"$it\" + AstForEachExpression.iteratorId++;\n                        var variableName = init.replace(/^\\s*var\\s*/, \"\").split(\"=\")[0];\n                        var initIteratorAndVariable = \"var \" + iterator + \" = new $p.ObjectIterator(\" + this.container + \"), \" + variableName + \" = void(0)\";\n                        var nextIterationCondition = iterator + \".hasNext() && ((\" + variableName + \" = \" + iterator + \".next()) || true)\";\n                        return \"(\" + initIteratorAndVariable + \"; \" + nextIterationCondition + \";)\";\n                    };\n                    function transformForExpression(expr) {\n                        var content;\n                        if (/\\bin\\b/.test(expr)) {\n                            content = expr.substring(1, expr.length - 1).split(/\\bin\\b/g);\n                            return new AstForInExpression(transformStatement(trim(content[0])), transformExpression(content[1]));\n                        }\n                        if (expr.indexOf(\":\") >= 0 && expr.indexOf(\";\") < 0) {\n                            content = expr.substring(1, expr.length - 1).split(\":\");\n                            return new AstForEachExpression(transformStatement(trim(content[0])), transformExpression(content[1]));\n                        }\n                        content = expr.substring(1, expr.length - 1).split(\";\");\n                        return new AstForExpression(transformStatement(trim(content[0])), transformExpression(content[1]), transformExpression(content[2]));\n                    }\n                    function sortByWeight(array) {\n                        array.sort(function(a, b) {\n                            return b.weight - a.weight;\n                        });\n                    }\n                    function AstInnerInterface(name, body, isStatic) {\n                        this.name = name;\n                        this.body = body;\n                        this.isStatic = isStatic;\n                        body.owner = this;\n                    }\n                    AstInnerInterface.prototype.toString = function() {\n                        return \"\" + this.body;\n                    };\n                    function AstInnerClass(name, body, isStatic) {\n                        this.name = name;\n                        this.body = body;\n                        this.isStatic = isStatic;\n                        body.owner = this;\n                    }\n                    AstInnerClass.prototype.toString = function() {\n                        return \"\" + this.body;\n                    };\n                    function transformInnerClass(class_) {\n                        var m = classesRegex.exec(class_); // 1 - attr, 2 - class|int, 3 - name, 4 - extends, 5 - implements, 6 - body\n                        classesRegex.lastIndex = 0;\n                        var isStatic = m[1].indexOf(\"static\") >= 0;\n                        var body = atoms[getAtomIndex(m[6])], innerClass;\n                        var oldClassId = currentClassId, newClassId = generateClassId();\n                        currentClassId = newClassId;\n                        if (m[2] === \"interface\") innerClass = new AstInnerInterface(m[3], transformInterfaceBody(body, m[3], m[4]), isStatic);\n                        else innerClass = new AstInnerClass(m[3], transformClassBody(body, m[3], m[4], m[5]), isStatic);\n                        appendClass(innerClass, newClassId, oldClassId);\n                        currentClassId = oldClassId;\n                        return innerClass;\n                    }\n                    function AstClassMethod(name, params, body, isStatic) {\n                        this.name = name;\n                        this.params = params;\n                        this.body = body;\n                        this.isStatic = isStatic;\n                    }\n                    AstClassMethod.prototype.toString = function() {\n                        var paramNames = appendToLookupTable({}, this.params.getNames());\n                        var oldContext = replaceContext;\n                        replaceContext = function(subject) {\n                            return paramNames.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);\n                        };\n                        var body = this.params.prependMethodArgs(this.body.toString());\n                        var result = \"function \" + this.methodId + this.params + \" \" + body + \"\\n\";\n                        replaceContext = oldContext;\n                        return result;\n                    };\n                    function transformClassMethod(method) {\n                        var m = methodsRegex.exec(method);\n                        methodsRegex.lastIndex = 0;\n                        var isStatic = m[1].indexOf(\"static\") >= 0;\n                        var body = m[6] !== \";\" ? atoms[getAtomIndex(m[6])] : \"{}\";\n                        return new AstClassMethod(m[3], transformParams(atoms[getAtomIndex(m[4])]), transformStatementsBlock(body), isStatic);\n                    }\n                    function AstClassField(definitions, fieldType, isStatic) {\n                        this.definitions = definitions;\n                        this.fieldType = fieldType;\n                        this.isStatic = isStatic;\n                    }\n                    AstClassField.prototype.getNames = function() {\n                        var names = [];\n                        for(var i = 0, l = this.definitions.length; i < l; ++i)names.push(this.definitions[i].name);\n                        return names;\n                    };\n                    AstClassField.prototype.toString = function() {\n                        var thisPrefix = replaceContext({\n                            name: \"[this]\"\n                        });\n                        if (this.isStatic) {\n                            var className = this.owner.name;\n                            var staticDeclarations = [];\n                            for(var i = 0, l = this.definitions.length; i < l; ++i){\n                                var definition = this.definitions[i];\n                                var name = definition.name, staticName = className + \".\" + name;\n                                var declaration = \"if(\" + staticName + \" === void(0)) {\\n\" + \" \" + staticName + \" = \" + definition.value + \"; }\\n\" + \"$p.defineProperty(\" + thisPrefix + \", \" + \"'\" + name + \"', { get: function(){return \" + staticName + \";}, \" + \"set: function(val){\" + staticName + \" = val;} });\\n\";\n                                staticDeclarations.push(declaration);\n                            }\n                            return staticDeclarations.join(\"\");\n                        }\n                        return thisPrefix + \".\" + this.definitions.join(\"; \" + thisPrefix + \".\");\n                    };\n                    function transformClassField(statement) {\n                        var attrAndType = attrAndTypeRegex.exec(statement);\n                        var isStatic = attrAndType[1].indexOf(\"static\") >= 0;\n                        var definitions = statement.substring(attrAndType[0].length).split(/,\\s*/g);\n                        var defaultTypeValue = getDefaultValueForType(attrAndType[2]);\n                        for(var i = 0; i < definitions.length; ++i)definitions[i] = transformVarDefinition(definitions[i], defaultTypeValue);\n                        return new AstClassField(definitions, attrAndType[2], isStatic);\n                    }\n                    function AstConstructor(params, body) {\n                        this.params = params;\n                        this.body = body;\n                    }\n                    AstConstructor.prototype.toString = function() {\n                        var paramNames = appendToLookupTable({}, this.params.getNames());\n                        var oldContext = replaceContext;\n                        replaceContext = function(subject) {\n                            return paramNames.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);\n                        };\n                        var prefix = \"function $constr_\" + this.params.params.length + this.params.toString();\n                        var body = this.params.prependMethodArgs(this.body.toString());\n                        if (!/\\$(superCstr|constr)\\b/.test(body)) body = \"{\\n$superCstr();\\n\" + body.substring(1);\n                        replaceContext = oldContext;\n                        return prefix + body + \"\\n\";\n                    };\n                    function transformConstructor(cstr) {\n                        var m = new RegExp(/\"B(\\d+)\"\\s*\"A(\\d+)\"/).exec(cstr);\n                        var params = transformParams(atoms[m[1]]);\n                        return new AstConstructor(params, transformStatementsBlock(atoms[m[2]]));\n                    }\n                    function AstInterfaceBody(name, interfacesNames, methodsNames, fields, innerClasses, misc) {\n                        var i, l;\n                        this.name = name;\n                        this.interfacesNames = interfacesNames;\n                        this.methodsNames = methodsNames;\n                        this.fields = fields;\n                        this.innerClasses = innerClasses;\n                        this.misc = misc;\n                        for(i = 0, l = fields.length; i < l; ++i)fields[i].owner = this;\n                    }\n                    AstInterfaceBody.prototype.getMembers = function(classFields, classMethods, classInners) {\n                        if (this.owner.base) this.owner.base.body.getMembers(classFields, classMethods, classInners);\n                        var i, j, l, m;\n                        for(i = 0, l = this.fields.length; i < l; ++i){\n                            var fieldNames = this.fields[i].getNames();\n                            for(j = 0, m = fieldNames.length; j < m; ++j)classFields[fieldNames[j]] = this.fields[i];\n                        }\n                        for(i = 0, l = this.methodsNames.length; i < l; ++i){\n                            var methodName = this.methodsNames[i];\n                            classMethods[methodName] = true;\n                        }\n                        for(i = 0, l = this.innerClasses.length; i < l; ++i){\n                            var innerClass = this.innerClasses[i];\n                            classInners[innerClass.name] = innerClass;\n                        }\n                    };\n                    AstInterfaceBody.prototype.toString = function() {\n                        function getScopeLevel(p) {\n                            var i = 0;\n                            while(p){\n                                ++i;\n                                p = p.scope;\n                            }\n                            return i;\n                        }\n                        var scopeLevel = getScopeLevel(this.owner);\n                        var className = this.name;\n                        var staticDefinitions = \"\";\n                        var metadata = \"\";\n                        var thisClassFields = {}, thisClassMethods = {}, thisClassInners = {};\n                        this.getMembers(thisClassFields, thisClassMethods, thisClassInners);\n                        var i, l, j, m;\n                        if (this.owner.interfaces) {\n                            // interface name can be present, but interface is not\n                            var resolvedInterfaces = [], resolvedInterface;\n                            for(i = 0, l = this.interfacesNames.length; i < l; ++i){\n                                if (!this.owner.interfaces[i]) continue;\n                                resolvedInterface = replaceContext({\n                                    name: this.interfacesNames[i]\n                                });\n                                resolvedInterfaces.push(resolvedInterface);\n                                staticDefinitions += \"$p.extendInterfaceMembers(\" + className + \", \" + resolvedInterface + \");\\n\";\n                            }\n                            metadata += className + \".$interfaces = [\" + resolvedInterfaces.join(\", \") + \"];\\n\";\n                        }\n                        metadata += className + \".$isInterface = true;\\n\";\n                        metadata += className + \".$methods = ['\" + this.methodsNames.join(\"', '\") + \"'];\\n\";\n                        sortByWeight(this.innerClasses);\n                        for(i = 0, l = this.innerClasses.length; i < l; ++i){\n                            var innerClass = this.innerClasses[i];\n                            if (innerClass.isStatic) staticDefinitions += className + \".\" + innerClass.name + \" = \" + innerClass + \";\\n\";\n                        }\n                        for(i = 0, l = this.fields.length; i < l; ++i){\n                            var field = this.fields[i];\n                            if (field.isStatic) staticDefinitions += className + \".\" + field.definitions.join(\";\\n\" + className + \".\") + \";\\n\";\n                        }\n                        return \"(function() {\\nfunction \" + className + \"() { throw 'Unable to create the interface'; }\\n\" + staticDefinitions + metadata + \"return \" + className + \";\\n\" + \"})()\";\n                    };\n                    transformInterfaceBody = function(body, name, baseInterfaces) {\n                        var declarations = body.substring(1, body.length - 1);\n                        declarations = extractClassesAndMethods(declarations);\n                        declarations = extractConstructors(declarations, name);\n                        var methodsNames = [], classes = [];\n                        declarations = declarations.replace(/\"([DE])(\\d+)\"/g, function(all, type, index) {\n                            if (type === \"D\") methodsNames.push(index);\n                            else if (type === \"E\") classes.push(index);\n                            return \"\";\n                        });\n                        var fields = declarations.split(/;(?:\\s*;)*/g);\n                        var baseInterfaceNames;\n                        var i, l;\n                        if (baseInterfaces !== undef) baseInterfaceNames = baseInterfaces.replace(/^\\s*extends\\s+(.+?)\\s*$/g, \"$1\").split(/\\s*,\\s*/g);\n                        for(i = 0, l = methodsNames.length; i < l; ++i){\n                            var method = transformClassMethod(atoms[methodsNames[i]]);\n                            methodsNames[i] = method.name;\n                        }\n                        for(i = 0, l = fields.length - 1; i < l; ++i){\n                            var field = trimSpaces(fields[i]);\n                            fields[i] = transformClassField(field.middle);\n                        }\n                        var tail = fields.pop();\n                        for(i = 0, l = classes.length; i < l; ++i)classes[i] = transformInnerClass(atoms[classes[i]]);\n                        return new AstInterfaceBody(name, baseInterfaceNames, methodsNames, fields, classes, {\n                            tail: tail\n                        });\n                    };\n                    function AstClassBody(name, baseClassName, interfacesNames, functions, methods, fields, cstrs, innerClasses, misc) {\n                        var i, l;\n                        this.name = name;\n                        this.baseClassName = baseClassName;\n                        this.interfacesNames = interfacesNames;\n                        this.functions = functions;\n                        this.methods = methods;\n                        this.fields = fields;\n                        this.cstrs = cstrs;\n                        this.innerClasses = innerClasses;\n                        this.misc = misc;\n                        for(i = 0, l = fields.length; i < l; ++i)fields[i].owner = this;\n                    }\n                    AstClassBody.prototype.getMembers = function(classFields, classMethods, classInners) {\n                        if (this.owner.base) this.owner.base.body.getMembers(classFields, classMethods, classInners);\n                        var i, j, l, m;\n                        for(i = 0, l = this.fields.length; i < l; ++i){\n                            var fieldNames = this.fields[i].getNames();\n                            for(j = 0, m = fieldNames.length; j < m; ++j)classFields[fieldNames[j]] = this.fields[i];\n                        }\n                        for(i = 0, l = this.methods.length; i < l; ++i){\n                            var method = this.methods[i];\n                            classMethods[method.name] = method;\n                        }\n                        for(i = 0, l = this.innerClasses.length; i < l; ++i){\n                            var innerClass = this.innerClasses[i];\n                            classInners[innerClass.name] = innerClass;\n                        }\n                    };\n                    AstClassBody.prototype.toString = function() {\n                        function getScopeLevel(p) {\n                            var i = 0;\n                            while(p){\n                                ++i;\n                                p = p.scope;\n                            }\n                            return i;\n                        }\n                        var scopeLevel = getScopeLevel(this.owner);\n                        var selfId = \"$this_\" + scopeLevel;\n                        var className = this.name;\n                        var result = \"var \" + selfId + \" = this;\\n\";\n                        var staticDefinitions = \"\";\n                        var metadata = \"\";\n                        var thisClassFields = {}, thisClassMethods = {}, thisClassInners = {};\n                        this.getMembers(thisClassFields, thisClassMethods, thisClassInners);\n                        var oldContext = replaceContext;\n                        replaceContext = function(subject) {\n                            var name = subject.name;\n                            if (name === \"this\") // returns \"$this_N.$self\" pointer instead of \"this\" in cases:\n                            // \"this()\", \"this.XXX()\", \"this\", but not for \"this.XXX\"\n                            return subject.callSign || !subject.member ? selfId + \".$self\" : selfId;\n                            if (thisClassFields.hasOwnProperty(name)) return thisClassFields[name].isStatic ? className + \".\" + name : selfId + \".\" + name;\n                            if (thisClassInners.hasOwnProperty(name)) return selfId + \".\" + name;\n                            if (thisClassMethods.hasOwnProperty(name)) return thisClassMethods[name].isStatic ? className + \".\" + name : selfId + \".$self.\" + name;\n                            return oldContext(subject);\n                        };\n                        var resolvedBaseClassName;\n                        if (this.baseClassName) {\n                            resolvedBaseClassName = oldContext({\n                                name: this.baseClassName\n                            });\n                            result += \"var $super = { $upcast: \" + selfId + \" };\\n\";\n                            result += \"function $superCstr(){\" + resolvedBaseClassName + \".apply($super,arguments);if(!('$self' in $super)) $p.extendClassChain($super)}\\n\";\n                            metadata += className + \".$base = \" + resolvedBaseClassName + \";\\n\";\n                        } else result += \"function $superCstr(){$p.extendClassChain(\" + selfId + \")}\\n\";\n                        if (this.owner.base) // base class name can be present, but class is not\n                        staticDefinitions += \"$p.extendStaticMembers(\" + className + \", \" + resolvedBaseClassName + \");\\n\";\n                        var i, l, j, m;\n                        if (this.owner.interfaces) {\n                            // interface name can be present, but interface is not\n                            var resolvedInterfaces = [], resolvedInterface;\n                            for(i = 0, l = this.interfacesNames.length; i < l; ++i){\n                                if (!this.owner.interfaces[i]) continue;\n                                resolvedInterface = oldContext({\n                                    name: this.interfacesNames[i]\n                                });\n                                resolvedInterfaces.push(resolvedInterface);\n                                staticDefinitions += \"$p.extendInterfaceMembers(\" + className + \", \" + resolvedInterface + \");\\n\";\n                            }\n                            metadata += className + \".$interfaces = [\" + resolvedInterfaces.join(\", \") + \"];\\n\";\n                        }\n                        if (this.functions.length > 0) result += this.functions.join(\"\\n\") + \"\\n\";\n                        sortByWeight(this.innerClasses);\n                        for(i = 0, l = this.innerClasses.length; i < l; ++i){\n                            var innerClass = this.innerClasses[i];\n                            if (innerClass.isStatic) {\n                                staticDefinitions += className + \".\" + innerClass.name + \" = \" + innerClass + \";\\n\";\n                                result += selfId + \".\" + innerClass.name + \" = \" + className + \".\" + innerClass.name + \";\\n\";\n                            } else result += selfId + \".\" + innerClass.name + \" = \" + innerClass + \";\\n\";\n                        }\n                        for(i = 0, l = this.fields.length; i < l; ++i){\n                            var field = this.fields[i];\n                            if (field.isStatic) {\n                                staticDefinitions += className + \".\" + field.definitions.join(\";\\n\" + className + \".\") + \";\\n\";\n                                for(j = 0, m = field.definitions.length; j < m; ++j){\n                                    var fieldName = field.definitions[j].name, staticName = className + \".\" + fieldName;\n                                    result += \"$p.defineProperty(\" + selfId + \", '\" + fieldName + \"', {\" + \"get: function(){return \" + staticName + \"}, \" + \"set: function(val){\" + staticName + \" = val}});\\n\";\n                                }\n                            } else result += selfId + \".\" + field.definitions.join(\";\\n\" + selfId + \".\") + \";\\n\";\n                        }\n                        var methodOverloads = {};\n                        for(i = 0, l = this.methods.length; i < l; ++i){\n                            var method = this.methods[i];\n                            var overload = methodOverloads[method.name];\n                            var methodId = method.name + \"$\" + method.params.params.length;\n                            var hasMethodArgs = !!method.params.methodArgsParam;\n                            if (overload) {\n                                ++overload;\n                                methodId += \"_\" + overload;\n                            } else overload = 1;\n                            method.methodId = methodId;\n                            methodOverloads[method.name] = overload;\n                            if (method.isStatic) {\n                                staticDefinitions += method;\n                                staticDefinitions += \"$p.addMethod(\" + className + \", '\" + method.name + \"', \" + methodId + \", \" + hasMethodArgs + \");\\n\";\n                                result += \"$p.addMethod(\" + selfId + \", '\" + method.name + \"', \" + methodId + \", \" + hasMethodArgs + \");\\n\";\n                            } else {\n                                result += method;\n                                result += \"$p.addMethod(\" + selfId + \", '\" + method.name + \"', \" + methodId + \", \" + hasMethodArgs + \");\\n\";\n                            }\n                        }\n                        result += trim(this.misc.tail);\n                        if (this.cstrs.length > 0) result += this.cstrs.join(\"\\n\") + \"\\n\";\n                        result += \"function $constr() {\\n\";\n                        var cstrsIfs = [];\n                        for(i = 0, l = this.cstrs.length; i < l; ++i){\n                            var paramsLength = this.cstrs[i].params.params.length;\n                            var methodArgsPresent = !!this.cstrs[i].params.methodArgsParam;\n                            cstrsIfs.push(\"if(arguments.length \" + (methodArgsPresent ? \">=\" : \"===\") + \" \" + paramsLength + \") { \" + \"$constr_\" + paramsLength + \".apply(\" + selfId + \", arguments); }\");\n                        }\n                        if (cstrsIfs.length > 0) result += cstrsIfs.join(\" else \") + \" else \";\n                        // ??? add check if length is 0, otherwise fail\n                        result += \"$superCstr();\\n}\\n\";\n                        result += \"$constr.apply(null, arguments);\\n\";\n                        replaceContext = oldContext;\n                        return \"(function() {\\nfunction \" + className + \"() {\\n\" + result + \"}\\n\" + staticDefinitions + metadata + \"return \" + className + \";\\n\" + \"})()\";\n                    };\n                    transformClassBody = function(body, name, baseName, interfaces) {\n                        var declarations = body.substring(1, body.length - 1);\n                        declarations = extractClassesAndMethods(declarations);\n                        declarations = extractConstructors(declarations, name);\n                        var methods = [], classes = [], cstrs = [], functions = [];\n                        declarations = declarations.replace(/\"([DEGH])(\\d+)\"/g, function(all, type, index) {\n                            if (type === \"D\") methods.push(index);\n                            else if (type === \"E\") classes.push(index);\n                            else if (type === \"H\") functions.push(index);\n                            else cstrs.push(index);\n                            return \"\";\n                        });\n                        var fields = declarations.replace(/^(?:\\s*;)+/, \"\").split(/;(?:\\s*;)*/g);\n                        var baseClassName, interfacesNames;\n                        var i;\n                        if (baseName !== undef) baseClassName = baseName.replace(/^\\s*extends\\s+([A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)\\s*$/g, \"$1\");\n                        if (interfaces !== undef) interfacesNames = interfaces.replace(/^\\s*implements\\s+(.+?)\\s*$/g, \"$1\").split(/\\s*,\\s*/g);\n                        for(i = 0; i < functions.length; ++i)functions[i] = transformFunction(atoms[functions[i]]);\n                        for(i = 0; i < methods.length; ++i)methods[i] = transformClassMethod(atoms[methods[i]]);\n                        for(i = 0; i < fields.length - 1; ++i){\n                            var field = trimSpaces(fields[i]);\n                            fields[i] = transformClassField(field.middle);\n                        }\n                        var tail = fields.pop();\n                        for(i = 0; i < cstrs.length; ++i)cstrs[i] = transformConstructor(atoms[cstrs[i]]);\n                        for(i = 0; i < classes.length; ++i)classes[i] = transformInnerClass(atoms[classes[i]]);\n                        return new AstClassBody(name, baseClassName, interfacesNames, functions, methods, fields, cstrs, classes, {\n                            tail: tail\n                        });\n                    };\n                    function AstInterface(name, body) {\n                        this.name = name;\n                        this.body = body;\n                        body.owner = this;\n                    }\n                    AstInterface.prototype.toString = function() {\n                        return \"var \" + this.name + \" = \" + this.body + \";\\n\" + \"$p.\" + this.name + \" = \" + this.name + \";\\n\";\n                    };\n                    function AstClass(name, body) {\n                        this.name = name;\n                        this.body = body;\n                        body.owner = this;\n                    }\n                    AstClass.prototype.toString = function() {\n                        return \"var \" + this.name + \" = \" + this.body + \";\\n\" + \"$p.\" + this.name + \" = \" + this.name + \";\\n\";\n                    };\n                    function transformGlobalClass(class_) {\n                        var m = classesRegex.exec(class_); // 1 - attr, 2 - class|int, 3 - name, 4 - extends, 5 - implements, 6 - body\n                        classesRegex.lastIndex = 0;\n                        var body = atoms[getAtomIndex(m[6])];\n                        var oldClassId = currentClassId, newClassId = generateClassId();\n                        currentClassId = newClassId;\n                        var globalClass;\n                        if (m[2] === \"interface\") globalClass = new AstInterface(m[3], transformInterfaceBody(body, m[3], m[4]));\n                        else globalClass = new AstClass(m[3], transformClassBody(body, m[3], m[4], m[5]));\n                        appendClass(globalClass, newClassId, oldClassId);\n                        currentClassId = oldClassId;\n                        return globalClass;\n                    }\n                    function AstMethod(name, params, body) {\n                        this.name = name;\n                        this.params = params;\n                        this.body = body;\n                    }\n                    AstMethod.prototype.toString = function() {\n                        var paramNames = appendToLookupTable({}, this.params.getNames());\n                        var oldContext = replaceContext;\n                        replaceContext = function(subject) {\n                            return paramNames.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);\n                        };\n                        var body = this.params.prependMethodArgs(this.body.toString());\n                        var result = \"function \" + this.name + this.params + \" \" + body + \"\\n\" + \"$p.\" + this.name + \" = \" + this.name + \";\\n\" + this.name + \" = \" + this.name + \".bind($p);\";\n                        //        \"$p.\" + this.name + \" = \" + this.name + \";\";\n                        replaceContext = oldContext;\n                        return result;\n                    };\n                    function transformGlobalMethod(method) {\n                        var m = methodsRegex.exec(method);\n                        var result = methodsRegex.lastIndex = 0;\n                        return new AstMethod(m[3], transformParams(atoms[getAtomIndex(m[4])]), transformStatementsBlock(atoms[getAtomIndex(m[6])]));\n                    }\n                    function preStatementsTransform(statements) {\n                        var s = statements;\n                        // turns multiple catch blocks into one, because we have no way to properly get into them anyway.\n                        s = s.replace(/\\b(catch\\s*\"B\\d+\"\\s*\"A\\d+\")(\\s*catch\\s*\"B\\d+\"\\s*\"A\\d+\")+/g, \"$1\");\n                        return s;\n                    }\n                    function AstForStatement(argument, misc) {\n                        this.argument = argument;\n                        this.misc = misc;\n                    }\n                    AstForStatement.prototype.toString = function() {\n                        return this.misc.prefix + this.argument.toString();\n                    };\n                    function AstCatchStatement(argument, misc) {\n                        this.argument = argument;\n                        this.misc = misc;\n                    }\n                    AstCatchStatement.prototype.toString = function() {\n                        return this.misc.prefix + this.argument.toString();\n                    };\n                    function AstPrefixStatement(name, argument, misc) {\n                        this.name = name;\n                        this.argument = argument;\n                        this.misc = misc;\n                    }\n                    AstPrefixStatement.prototype.toString = function() {\n                        var result = this.misc.prefix;\n                        if (this.argument !== undef) result += this.argument.toString();\n                        return result;\n                    };\n                    function AstSwitchCase(expr) {\n                        this.expr = expr;\n                    }\n                    AstSwitchCase.prototype.toString = function() {\n                        return \"case \" + this.expr + \":\";\n                    };\n                    function AstLabel(label) {\n                        this.label = label;\n                    }\n                    AstLabel.prototype.toString = function() {\n                        return this.label;\n                    };\n                    transformStatements = function(statements, transformMethod, transformClass) {\n                        var nextStatement = new RegExp(/\\b(catch|for|if|switch|while|with)\\s*\"B(\\d+)\"|\\b(do|else|finally|return|throw|try|break|continue)\\b|(\"[ADEH](\\d+)\")|\\b(case)\\s+([^:]+):|\\b([A-Za-z_$][\\w$]*\\s*:)|(;)/g);\n                        var res = [];\n                        statements = preStatementsTransform(statements);\n                        var lastIndex = 0, m, space;\n                        // m contains the matches from the nextStatement regexp, null if there are no matches.\n                        // nextStatement.exec starts searching at nextStatement.lastIndex.\n                        while((m = nextStatement.exec(statements)) !== null){\n                            if (m[1] !== undef) {\n                                var i = statements.lastIndexOf('\"B', nextStatement.lastIndex);\n                                var statementsPrefix = statements.substring(lastIndex, i);\n                                if (m[1] === \"for\") res.push(new AstForStatement(transformForExpression(atoms[m[2]]), {\n                                    prefix: statementsPrefix\n                                }));\n                                else if (m[1] === \"catch\") res.push(new AstCatchStatement(transformParams(atoms[m[2]]), {\n                                    prefix: statementsPrefix\n                                }));\n                                else res.push(new AstPrefixStatement(m[1], transformExpression(atoms[m[2]]), {\n                                    prefix: statementsPrefix\n                                }));\n                            } else if (m[3] !== undef) res.push(new AstPrefixStatement(m[3], undef, {\n                                prefix: statements.substring(lastIndex, nextStatement.lastIndex)\n                            }));\n                            else if (m[4] !== undef) {\n                                space = statements.substring(lastIndex, nextStatement.lastIndex - m[4].length);\n                                if (trim(space).length !== 0) continue;\n                                 // avoiding new type[] {} construct\n                                res.push(space);\n                                var kind = m[4].charAt(1), atomIndex = m[5];\n                                if (kind === \"D\") res.push(transformMethod(atoms[atomIndex]));\n                                else if (kind === \"E\") res.push(transformClass(atoms[atomIndex]));\n                                else if (kind === \"H\") res.push(transformFunction(atoms[atomIndex]));\n                                else res.push(transformStatementsBlock(atoms[atomIndex]));\n                            } else if (m[6] !== undef) res.push(new AstSwitchCase(transformExpression(trim(m[7]))));\n                            else if (m[8] !== undef) {\n                                space = statements.substring(lastIndex, nextStatement.lastIndex - m[8].length);\n                                if (trim(space).length !== 0) continue;\n                                 // avoiding ?: construct\n                                res.push(new AstLabel(statements.substring(lastIndex, nextStatement.lastIndex)));\n                            } else {\n                                var statement = trimSpaces(statements.substring(lastIndex, nextStatement.lastIndex - 1));\n                                res.push(statement.left);\n                                res.push(transformStatement(statement.middle));\n                                res.push(statement.right + \";\");\n                            }\n                            lastIndex = nextStatement.lastIndex;\n                        }\n                        var statementsTail = trimSpaces(statements.substring(lastIndex));\n                        res.push(statementsTail.left);\n                        if (statementsTail.middle !== \"\") {\n                            res.push(transformStatement(statementsTail.middle));\n                            res.push(\";\" + statementsTail.right);\n                        }\n                        return res;\n                    };\n                    function getLocalNames(statements) {\n                        var localNames = [];\n                        for(var i = 0, l = statements.length; i < l; ++i){\n                            var statement = statements[i];\n                            if (statement instanceof AstVar) localNames = localNames.concat(statement.getNames());\n                            else if (statement instanceof AstForStatement && statement.argument.initStatement instanceof AstVar) localNames = localNames.concat(statement.argument.initStatement.getNames());\n                            else if (statement instanceof AstInnerInterface || statement instanceof AstInnerClass || statement instanceof AstInterface || statement instanceof AstClass || statement instanceof AstMethod || statement instanceof AstFunction) localNames.push(statement.name);\n                        }\n                        return appendToLookupTable({}, localNames);\n                    }\n                    function AstStatementsBlock(statements) {\n                        this.statements = statements;\n                    }\n                    AstStatementsBlock.prototype.toString = function() {\n                        var localNames = getLocalNames(this.statements);\n                        var oldContext = replaceContext;\n                        // replacing context only when necessary\n                        if (!isLookupTableEmpty(localNames)) replaceContext = function(subject) {\n                            return localNames.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);\n                        };\n                        var result = \"{\\n\" + this.statements.join(\"\") + \"\\n}\";\n                        replaceContext = oldContext;\n                        return result;\n                    };\n                    transformStatementsBlock = function(block) {\n                        var content = trimSpaces(block.substring(1, block.length - 1));\n                        return new AstStatementsBlock(transformStatements(content.middle));\n                    };\n                    function AstRoot(statements) {\n                        this.statements = statements;\n                    }\n                    AstRoot.prototype.toString = function() {\n                        var classes = [], otherStatements = [], statement;\n                        for(var i = 0, len = this.statements.length; i < len; ++i){\n                            statement = this.statements[i];\n                            if (statement instanceof AstClass || statement instanceof AstInterface) classes.push(statement);\n                            else otherStatements.push(statement);\n                        }\n                        sortByWeight(classes);\n                        var localNames = getLocalNames(this.statements);\n                        replaceContext = function(subject) {\n                            var name = subject.name;\n                            if (localNames.hasOwnProperty(name)) return name;\n                            if (globalMembers.hasOwnProperty(name) || PConstants1.hasOwnProperty(name) || defaultScope1.hasOwnProperty(name)) return \"$p.\" + name;\n                            return name;\n                        };\n                        var result = \"// this code was autogenerated from PJS\\n(function($p) {\\n\" + classes.join(\"\") + \"\\n\" + otherStatements.join(\"\") + \"\\n})\";\n                        replaceContext = null;\n                        return result;\n                    };\n                    transformMain = function() {\n                        var statements = extractClassesAndMethods(atoms[0]);\n                        statements = statements.replace(/\\bimport\\s+[^;]+;/g, \"\");\n                        return new AstRoot(transformStatements(statements, transformGlobalMethod, transformGlobalClass));\n                    };\n                    function generateMetadata(ast) {\n                        var globalScope = {};\n                        var id, class_;\n                        for(id in declaredClasses)if (declaredClasses.hasOwnProperty(id)) {\n                            class_ = declaredClasses[id];\n                            var scopeId = class_.scopeId, name = class_.name;\n                            if (scopeId) {\n                                var scope = declaredClasses[scopeId];\n                                class_.scope = scope;\n                                if (scope.inScope === undef) scope.inScope = {};\n                                scope.inScope[name] = class_;\n                            } else globalScope[name] = class_;\n                        }\n                        function findInScopes(class_, name) {\n                            var parts = name.split(\".\");\n                            var currentScope = class_.scope, found;\n                            while(currentScope){\n                                if (currentScope.hasOwnProperty(parts[0])) {\n                                    found = currentScope[parts[0]];\n                                    break;\n                                }\n                                currentScope = currentScope.scope;\n                            }\n                            if (found === undef) found = globalScope[parts[0]];\n                            for(var i = 1, l = parts.length; i < l && found; ++i)found = found.inScope[parts[i]];\n                            return found;\n                        }\n                        for(id in declaredClasses)if (declaredClasses.hasOwnProperty(id)) {\n                            class_ = declaredClasses[id];\n                            var baseClassName = class_.body.baseClassName;\n                            if (baseClassName) {\n                                var parent = findInScopes(class_, baseClassName);\n                                if (parent) {\n                                    class_.base = parent;\n                                    if (!parent.derived) parent.derived = [];\n                                    parent.derived.push(class_);\n                                }\n                            }\n                            var interfacesNames = class_.body.interfacesNames, interfaces = [], i, l;\n                            if (interfacesNames && interfacesNames.length > 0) {\n                                for(i = 0, l = interfacesNames.length; i < l; ++i){\n                                    var interface_ = findInScopes(class_, interfacesNames[i]);\n                                    interfaces.push(interface_);\n                                    if (!interface_) continue;\n                                    if (!interface_.derived) interface_.derived = [];\n                                    interface_.derived.push(class_);\n                                }\n                                if (interfaces.length > 0) class_.interfaces = interfaces;\n                            }\n                        }\n                    }\n                    function setWeight(ast) {\n                        var queue = [], tocheck = {};\n                        var id, scopeId, class_;\n                        // queue most inner and non-inherited\n                        for(id in declaredClasses)if (declaredClasses.hasOwnProperty(id)) {\n                            class_ = declaredClasses[id];\n                            if (!class_.inScope && !class_.derived) {\n                                queue.push(id);\n                                class_.weight = 0;\n                            } else {\n                                var dependsOn = [];\n                                if (class_.inScope) {\n                                    for(scopeId in class_.inScope)if (class_.inScope.hasOwnProperty(scopeId)) dependsOn.push(class_.inScope[scopeId]);\n                                }\n                                if (class_.derived) dependsOn = dependsOn.concat(class_.derived);\n                                tocheck[id] = dependsOn;\n                            }\n                        }\n                        function removeDependentAndCheck(targetId, from) {\n                            var dependsOn = tocheck[targetId];\n                            if (!dependsOn) return false; // no need to process\n                            var i = dependsOn.indexOf(from);\n                            if (i < 0) return false;\n                            dependsOn.splice(i, 1);\n                            if (dependsOn.length > 0) return false;\n                            delete tocheck[targetId];\n                            return true;\n                        }\n                        while(queue.length > 0){\n                            id = queue.shift();\n                            class_ = declaredClasses[id];\n                            if (class_.scopeId && removeDependentAndCheck(class_.scopeId, class_)) {\n                                queue.push(class_.scopeId);\n                                declaredClasses[class_.scopeId].weight = class_.weight + 1;\n                            }\n                            if (class_.base && removeDependentAndCheck(class_.base.classId, class_)) {\n                                queue.push(class_.base.classId);\n                                class_.base.weight = class_.weight + 1;\n                            }\n                            if (class_.interfaces) {\n                                var i, l;\n                                for(i = 0, l = class_.interfaces.length; i < l; ++i){\n                                    if (!class_.interfaces[i] || !removeDependentAndCheck(class_.interfaces[i].classId, class_)) continue;\n                                    queue.push(class_.interfaces[i].classId);\n                                    class_.interfaces[i].weight = class_.weight + 1;\n                                }\n                            }\n                        }\n                    }\n                    var transformed = transformMain();\n                    generateMetadata(transformed);\n                    setWeight(transformed);\n                    var redendered = transformed.toString();\n                    // remove empty extra lines with space\n                    redendered = redendered.replace(/\\s*\\n(?:[\\t ]*\\n)+/g, \"\\n\\n\");\n                    // convert character codes to characters\n                    redendered = redendered.replace(/__x([0-9A-F]{4})/g, function(all, hexCode) {\n                        return String.fromCharCode(parseInt(hexCode, 16));\n                    });\n                    return injectStrings(redendered, strings);\n                } // Parser ends\n                function preprocessCode(aCode, sketch) {\n                    // Parse out @pjs directive, if any.\n                    var dm = new RegExp(/\\/\\*\\s*@pjs\\s+((?:[^\\*]|\\*+[^\\*\\/])*)\\*\\//g).exec(aCode);\n                    if (dm && dm.length === 2) {\n                        // masks contents of a JSON to be replaced later\n                        // to protect the contents from further parsing\n                        var jsonItems = [], directives = dm.splice(1, 2)[0].replace(/\\{([\\s\\S]*?)\\}/g, function() {\n                            return function(all, item) {\n                                jsonItems.push(item);\n                                return \"{\" + (jsonItems.length - 1) + \"}\";\n                            };\n                        }()).replace(\"\\n\", \"\").replace(\"\\r\", \"\").split(\";\");\n                        // We'll L/RTrim, and also remove any surrounding double quotes (e.g., just take string contents)\n                        var clean = function(s) {\n                            return s.replace(/^\\s*[\"']?/, \"\").replace(/[\"']?\\s*$/, \"\");\n                        };\n                        for(var i = 0, dl = directives.length; i < dl; i++){\n                            var pair = directives[i].split(\"=\");\n                            if (pair && pair.length === 2) {\n                                var key = clean(pair[0]), value = clean(pair[1]), list = [];\n                                // A few directives require work beyond storying key/value pairings\n                                if (key === \"preload\") {\n                                    list = value.split(\",\");\n                                    // All pre-loaded images will get put in imageCache, keyed on filename\n                                    for(var j = 0, jl = list.length; j < jl; j++){\n                                        var imageName = clean(list[j]);\n                                        sketch.imageCache.add(imageName);\n                                    }\n                                // fonts can be declared as a string containing a url,\n                                // or a JSON object, containing a font name, and a url\n                                } else if (key === \"font\") {\n                                    list = value.split(\",\");\n                                    for(var x = 0, xl = list.length; x < xl; x++){\n                                        var fontName = clean(list[x]), index = /^\\{(\\d*?)\\}$/.exec(fontName);\n                                        // if index is not null, send JSON, otherwise, send string\n                                        PFont.preloading.add(index ? JSON.parse(\"{\" + jsonItems[index[1]] + \"}\") : fontName);\n                                    }\n                                } else if (key === \"pauseOnBlur\") sketch.options.pauseOnBlur = value === \"true\";\n                                else if (key === \"globalKeyEvents\") sketch.options.globalKeyEvents = value === \"true\";\n                                else if (key.substring(0, 6) === \"param-\") sketch.params[key.substring(6)] = value;\n                                else sketch.options[key] = value;\n                            }\n                        }\n                    }\n                    return aCode;\n                }\n                // Parse/compiles Processing (Java-like) syntax to JavaScript syntax\n                Processing1.compile = function(pdeCode) {\n                    var sketch = new Processing1.Sketch();\n                    var code = preprocessCode(pdeCode, sketch);\n                    var compiledPde = parseProcessing(code);\n                    sketch.sourceCode = compiledPde;\n                    return sketch;\n                };\n                var PjsConsole = require1(\"../Helpers/PjsConsole\");\n                Processing1.logger = new PjsConsole(document1);\n                // done\n                return Processing1;\n            };\n        },\n        {\n            \"../Helpers/PjsConsole\": 5\n        }\n    ],\n    27: [\n        function(require1, module, exports) {\n            /**\n * Processing.js object\n */ module.exports = function(options, undef) {\n                var defaultScope1 = options.defaultScope, extend = options.extend, Browser = options.Browser, ajax = Browser.ajax, navigator1 = Browser.navigator, window1 = Browser.window, XMLHttpRequest1 = window1.XMLHttpRequest, document1 = Browser.document, noop = options.noop, PConstants1 = defaultScope1.PConstants;\n                PFont = defaultScope1.PFont, PShapeSVG = defaultScope1.PShapeSVG, PVector = defaultScope1.PVector, Char = Character = defaultScope1.Char, ObjectIterator = defaultScope1.ObjectIterator, XMLElement = defaultScope1.XMLElement, XML = defaultScope1.XML;\n                // fascinating \"read only\" jshint error if we don't start a new var block here.\n                var HTMLCanvasElement = window1.HTMLCanvasElement, HTMLImageElement = window1.HTMLImageElement;\n                // window.localStorage cannot be accessed if a user is blocking cookies.\n                // In that case, we make it a temporary source cache object.\n                var localStorage;\n                try {\n                    localStorage = window1.localStorage;\n                } catch (e) {\n                    localStorage = {};\n                }\n                var isDOMPresent = \"document\" in this && !(\"fake\" in this.document);\n                // document.head polyfill for the benefit of Firefox 3.6\n                if (!document1.head) document1.head = document1.getElementsByTagName(\"head\")[0];\n                var Float32Array = setupTypedArray(\"Float32Array\", \"WebGLFloatArray\"), Int32Array = setupTypedArray(\"Int32Array\", \"WebGLIntArray\"), Uint16Array = setupTypedArray(\"Uint16Array\", \"WebGLUnsignedShortArray\"), Uint8Array1 = setupTypedArray(\"Uint8Array\", \"WebGLUnsignedByteArray\");\n                // Typed Arrays: fallback to WebGL arrays or Native JS arrays if unavailable\n                function setupTypedArray(name, fallback) {\n                    // Check if TypedArray exists, and use if so.\n                    if (name in window1) return window1[name];\n                    // Check if WebGLArray exists\n                    if (typeof window1[fallback] === \"function\") return window1[fallback];\n                    // Use Native JS array\n                    return function(obj) {\n                        if (obj instanceof Array) return obj;\n                        if (typeof obj === \"number\") {\n                            var arr = [];\n                            arr.length = obj;\n                            return arr;\n                        }\n                    };\n                }\n                /* IE9+ quirks mode check - ticket #1606 */ if (document1.documentMode >= 9 && !document1.doctype) throw \"The doctype directive is missing. The recommended doctype in Internet Explorer is the HTML5 doctype: <!DOCTYPE html>\";\n                // Manage multiple Processing instances\n                var processingInstances = [];\n                var processingInstanceIds = {};\n                /**\n   * instance tracking - adding new instances\n   */ var addInstance = function(processing) {\n                    if (processing.externals.canvas.id === undef || !processing.externals.canvas.id.length) processing.externals.canvas.id = \"__processing\" + processingInstances.length;\n                    processingInstanceIds[processing.externals.canvas.id] = processingInstances.length;\n                    processingInstances.push(processing);\n                };\n                /**\n   * instance tracking - removal\n   */ var removeInstance = function(id) {\n                    processingInstances.splice(processingInstanceIds[id], 1);\n                    delete processingInstanceIds[id];\n                };\n                /**\n   * The Processing object\n   */ var Processing1 = this.Processing = function(aCanvas, aCode, aFunctions) {\n                    if (!(this instanceof Processing1)) throw \"called Processing constructor as if it were a function: missing 'new'.\";\n                    var curElement = {}, pgraphicsMode = aCanvas === undef && aCode === undef;\n                    if (pgraphicsMode) curElement = document1.createElement(\"canvas\");\n                    else // We'll take a canvas element or a string for a canvas element's id\n                    curElement = typeof aCanvas === \"string\" ? document1.getElementById(aCanvas) : aCanvas;\n                    if (!(\"getContext\" in curElement)) throw \"called Processing constructor without passing canvas element reference or id.\";\n                    function unimplemented1(s) {\n                        Processing1.debug(\"Unimplemented - \" + s);\n                    }\n                    ////////////////////////////////////////////////////////////////////////////\n                    // JavaScript event binding and releasing\n                    ////////////////////////////////////////////////////////////////////////////\n                    var eventHandlers = [];\n                    function attachEventHandler(elem, type, fn) {\n                        if (elem.addEventListener) elem.addEventListener(type, fn, false);\n                        else elem.attachEvent(\"on\" + type, fn);\n                        eventHandlers.push({\n                            elem: elem,\n                            type: type,\n                            fn: fn\n                        });\n                    }\n                    function detachEventHandler1(eventHandler) {\n                        var elem = eventHandler.elem, type = eventHandler.type, fn = eventHandler.fn;\n                        if (elem.removeEventListener) elem.removeEventListener(type, fn, false);\n                        else if (elem.detachEvent) elem.detachEvent(\"on\" + type, fn);\n                    }\n                    function detachEventHandlersByType(element, types) {\n                        Object.keys(eventHandlers).forEach(function(eventHandler) {\n                            if (types.indexOf(eventHandler.type) > -1 && eventHandler.elem == element) detachEventHandler1(eventHandler.type);\n                        });\n                    }\n                    function removeFirstArgument(args) {\n                        return Array.prototype.slice.call(args, 1);\n                    }\n                    // When something new is added to \"p.\" it must also be added to the \"names\" array.\n                    // The names array contains the names of everything that is inside \"p.\"\n                    var p = this;\n                    p.Char = p.Character = Char;\n                    // add in the Processing API functions\n                    eventHandlers = [];\n                    extend.withCommonFunctions(p);\n                    extend.withMath(p);\n                    extend.withProxyFunctions(p, removeFirstArgument);\n                    extend.withTouch(p, curElement, attachEventHandler, detachEventHandlersByType, document1, PConstants1);\n                    // custom functions and properties are added here\n                    if (aFunctions) Object.keys(aFunctions).forEach(function(name) {\n                        p[name] = aFunctions[name];\n                    });\n                    // PJS specific (non-p5) methods and properties to externalize\n                    p.externals = {\n                        canvas: curElement,\n                        context: undef,\n                        sketch: undef,\n                        window: window1\n                    };\n                    p.name = \"Processing.js Instance\"; // Set Processing defaults / environment variables\n                    p.use3DContext = false; // default '2d' canvas context\n                    /**\n     * Confirms if a Processing program is \"focused\", meaning that it is\n     * active and will accept input from mouse or keyboard. This variable\n     * is \"true\" if it is focused and \"false\" if not. This variable is\n     * often used when you want to warn people they need to click on the\n     * browser before it will work.\n    */ p.focused = false;\n                    p.breakShape = false;\n                    // Glyph path storage for textFonts\n                    p.glyphTable = {};\n                    // Global vars for tracking mouse position\n                    p.pmouseX = 0;\n                    p.pmouseY = 0;\n                    p.mouseX = 0;\n                    p.mouseY = 0;\n                    p.mouseButton = 0;\n                    p.mouseScroll = 0;\n                    // Undefined event handlers to be replaced by user when needed\n                    p.mouseClicked = undef;\n                    p.mouseDragged = undef;\n                    p.mouseMoved = undef;\n                    p.mousePressed = undef;\n                    p.mouseReleased = undef;\n                    p.mouseScrolled = undef;\n                    p.mouseOver = undef;\n                    p.mouseOut = undef;\n                    p.touchStart = undef;\n                    p.touchEnd = undef;\n                    p.touchMove = undef;\n                    p.touchCancel = undef;\n                    p.key = undef;\n                    p.keyCode = undef;\n                    p.keyPressed = noop; // needed to remove function checks\n                    p.keyReleased = noop;\n                    p.keyTyped = noop;\n                    p.draw = undef;\n                    p.setup = undef;\n                    // Remapped vars\n                    p.__mousePressed = false;\n                    p.__keyPressed = false;\n                    p.__frameRate = 60;\n                    // The current animation frame\n                    p.frameCount = 0;\n                    // The height/width of the canvas\n                    p.width = 100;\n                    p.height = 100;\n                    // \"Private\" variables used to maintain state\n                    var curContext, curSketch, drawing, doFill = true, fillStyle = [\n                        1.0,\n                        1.0,\n                        1.0,\n                        1.0\n                    ], currentFillColor = 0xFFFFFFFF, isFillDirty = true, doStroke = true, strokeStyle = [\n                        0.0,\n                        0.0,\n                        0.0,\n                        1.0\n                    ], currentStrokeColor = 0xFF000000, isStrokeDirty = true, lineWidth = 1, loopStarted = false, renderSmooth = false, doLoop = true, looping = 0, curRectMode = PConstants1.CORNER, curEllipseMode1 = PConstants1.CENTER, normalX = 0, normalY = 0, normalZ = 0, normalMode = PConstants1.NORMAL_MODE_AUTO, curFrameRate = 60, curMsPerFrame = 1000 / curFrameRate, curCursor = PConstants1.ARROW, oldCursor = curElement.style.cursor, curShape = PConstants1.POLYGON, curShapeCount = 0, curvePoints = [], curTightness = 0, curveDet = 20, curveInited = false, backgroundObj = -3355444, bezDetail = 20, colorModeA = 255, colorModeX = 255, colorModeY = 255, colorModeZ = 255, pathOpen = false, mouseDragging = false, pmouseXLastFrame = 0, pmouseYLastFrame = 0, curColorMode = PConstants1.RGB, curTint = null, curTint3d = null, getLoaded = false, start = Date.now(), timeSinceLastFPS = start, framesSinceLastFPS = 0, textcanvas, curveBasisMatrix, curveToBezierMatrix, curveDrawMatrix, bezierDrawMatrix, bezierBasisInverse, bezierBasisMatrix, curContextCache = {\n                        attributes: {},\n                        locations: {}\n                    }, // Shaders\n                    programObject3D, programObject2D, programObjectUnlitShape, boxBuffer, boxNormBuffer, boxOutlineBuffer, rectBuffer, rectNormBuffer, sphereBuffer, lineBuffer, fillBuffer, fillColorBuffer, strokeColorBuffer, pointBuffer, shapeTexVBO, canTex, textTex, curTexture = {\n                        width: 0,\n                        height: 0\n                    }, curTextureMode = PConstants1.IMAGE, usingTexture = false, textBuffer, textureBuffer, indexBuffer, // Text alignment\n                    horizontalTextAlignment = PConstants1.LEFT, verticalTextAlignment = PConstants1.BASELINE, textMode = PConstants1.MODEL, // Font state\n                    curFontName = \"Arial\", curTextSize = 12, curTextAscent = 9, curTextDescent = 2, curTextLeading = 14, curTextFont = PFont.get(curFontName, curTextSize), // Pixels cache\n                    originalContext, proxyContext = null, isContextReplaced = false, setPixelsCached, maxPixelsCached = 1000, pressedKeysMap = [], lastPressedKeyCode = null, codedKeys = [\n                        PConstants1.SHIFT,\n                        PConstants1.CONTROL,\n                        PConstants1.ALT,\n                        PConstants1.CAPSLK,\n                        PConstants1.PGUP,\n                        PConstants1.PGDN,\n                        PConstants1.END,\n                        PConstants1.HOME,\n                        PConstants1.LEFT,\n                        PConstants1.UP,\n                        PConstants1.RIGHT,\n                        PConstants1.DOWN,\n                        PConstants1.NUMLK,\n                        PConstants1.INSERT,\n                        PConstants1.F1,\n                        PConstants1.F2,\n                        PConstants1.F3,\n                        PConstants1.F4,\n                        PConstants1.F5,\n                        PConstants1.F6,\n                        PConstants1.F7,\n                        PConstants1.F8,\n                        PConstants1.F9,\n                        PConstants1.F10,\n                        PConstants1.F11,\n                        PConstants1.F12,\n                        PConstants1.META\n                    ];\n                    // User can only have MAX_LIGHTS lights\n                    var lightCount = 0;\n                    //sphere stuff\n                    var sphereDetailV = 0, sphereDetailU = 0, sphereX = [], sphereY = [], sphereZ = [], sinLUT = new Float32Array(PConstants1.SINCOS_LENGTH), cosLUT = new Float32Array(PConstants1.SINCOS_LENGTH), sphereVerts, sphereNorms;\n                    // Camera defaults and settings\n                    var cam, cameraInv, modelView, modelViewInv, userMatrixStack, userReverseMatrixStack, inverseCopy1, projection, manipulatingCamera = false, frustumMode = false, cameraFOV = 60 * (Math.PI / 180), cameraX = p.width / 2, cameraY = p.height / 2, cameraZ = cameraY / Math.tan(cameraFOV / 2), cameraNear = cameraZ / 10, cameraFar = cameraZ * 10, cameraAspect = p.width / p.height;\n                    var vertArray1 = [], curveVertArray = [], curveVertCount = 0, isCurve = false, isBezier = false, firstVert = true;\n                    //PShape stuff\n                    var curShapeMode = PConstants1.CORNER;\n                    // Stores states for pushStyle() and popStyle().\n                    var styleArray = [];\n                    // The vertices for the box cannot be specified using a triangle strip since each\n                    // side of the cube must have its own set of normals.\n                    // Vertices are specified in a counter-clockwise order.\n                    // Triangles are in this order: back, front, right, bottom, left, top.\n                    var boxVerts = new Float32Array([\n                        0.5,\n                        0.5,\n                        -0.5,\n                        0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        0.5,\n                        -0.5,\n                        0.5,\n                        0.5,\n                        -0.5,\n                        0.5,\n                        0.5,\n                        0.5,\n                        -0.5,\n                        0.5,\n                        0.5,\n                        -0.5,\n                        -0.5,\n                        0.5,\n                        -0.5,\n                        -0.5,\n                        0.5,\n                        0.5,\n                        -0.5,\n                        0.5,\n                        0.5,\n                        0.5,\n                        0.5,\n                        0.5,\n                        0.5,\n                        -0.5,\n                        0.5,\n                        0.5,\n                        0.5,\n                        0.5,\n                        -0.5,\n                        0.5,\n                        0.5,\n                        -0.5,\n                        0.5,\n                        0.5,\n                        -0.5,\n                        -0.5,\n                        0.5,\n                        0.5,\n                        -0.5,\n                        0.5,\n                        -0.5,\n                        -0.5,\n                        0.5,\n                        -0.5,\n                        0.5,\n                        -0.5,\n                        -0.5,\n                        0.5,\n                        -0.5,\n                        -0.5,\n                        0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        0.5,\n                        -0.5,\n                        0.5,\n                        0.5,\n                        -0.5,\n                        0.5,\n                        0.5,\n                        -0.5,\n                        0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        0.5,\n                        0.5,\n                        0.5,\n                        0.5,\n                        0.5,\n                        -0.5,\n                        -0.5,\n                        0.5,\n                        -0.5,\n                        -0.5,\n                        0.5,\n                        -0.5,\n                        -0.5,\n                        0.5,\n                        0.5,\n                        0.5,\n                        0.5,\n                        0.5\n                    ]);\n                    var boxOutlineVerts = new Float32Array([\n                        0.5,\n                        0.5,\n                        0.5,\n                        0.5,\n                        -0.5,\n                        0.5,\n                        0.5,\n                        0.5,\n                        -0.5,\n                        0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        0.5,\n                        0.5,\n                        -0.5,\n                        -0.5,\n                        0.5,\n                        0.5,\n                        0.5,\n                        0.5,\n                        0.5,\n                        0.5,\n                        -0.5,\n                        0.5,\n                        0.5,\n                        -0.5,\n                        -0.5,\n                        0.5,\n                        -0.5,\n                        -0.5,\n                        0.5,\n                        -0.5,\n                        -0.5,\n                        0.5,\n                        0.5,\n                        -0.5,\n                        0.5,\n                        0.5,\n                        0.5,\n                        0.5,\n                        0.5,\n                        0.5,\n                        -0.5,\n                        0.5,\n                        0.5,\n                        -0.5,\n                        -0.5,\n                        0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        -0.5,\n                        0.5,\n                        -0.5,\n                        -0.5,\n                        0.5,\n                        0.5,\n                        -0.5,\n                        0.5\n                    ]);\n                    var boxNorms = new Float32Array([\n                        0,\n                        0,\n                        -1,\n                        0,\n                        0,\n                        -1,\n                        0,\n                        0,\n                        -1,\n                        0,\n                        0,\n                        -1,\n                        0,\n                        0,\n                        -1,\n                        0,\n                        0,\n                        -1,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        1,\n                        1,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        -1,\n                        0,\n                        0,\n                        -1,\n                        0,\n                        0,\n                        -1,\n                        0,\n                        0,\n                        -1,\n                        0,\n                        0,\n                        -1,\n                        0,\n                        0,\n                        -1,\n                        0,\n                        -1,\n                        0,\n                        0,\n                        -1,\n                        0,\n                        0,\n                        -1,\n                        0,\n                        0,\n                        -1,\n                        0,\n                        0,\n                        -1,\n                        0,\n                        0,\n                        -1,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        1,\n                        0\n                    ]);\n                    // These verts are used for the fill and stroke using TRIANGLE_FAN and LINE_LOOP.\n                    var rectVerts = new Float32Array([\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        1,\n                        1,\n                        0,\n                        1,\n                        0,\n                        0\n                    ]);\n                    var rectNorms = new Float32Array([\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        1\n                    ]);\n                    // Shader for points and lines in begin/endShape.\n                    var vertexShaderSrcUnlitShape = \"varying vec4 vFrontColor;attribute vec3 aVertex;attribute vec4 aColor;uniform mat4 uView;uniform mat4 uProjection;uniform float uPointSize;void main(void) {  vFrontColor = aColor;  gl_PointSize = uPointSize;  gl_Position = uProjection * uView * vec4(aVertex, 1.0);}\";\n                    var fragmentShaderSrcUnlitShape = \"#ifdef GL_ES\\nprecision highp float;\\n#endif\\nvarying vec4 vFrontColor;uniform bool uSmooth;void main(void){  if(uSmooth == true){    float dist = distance(gl_PointCoord, vec2(0.5));    if(dist > 0.5){      discard;    }  }  gl_FragColor = vFrontColor;}\";\n                    // Shader for rect, text, box outlines, sphere outlines, point() and line().\n                    var vertexShaderSrc2D = \"varying vec4 vFrontColor;attribute vec3 aVertex;attribute vec2 aTextureCoord;uniform vec4 uColor;uniform mat4 uModel;uniform mat4 uView;uniform mat4 uProjection;uniform float uPointSize;varying vec2 vTextureCoord;void main(void) {  gl_PointSize = uPointSize;  vFrontColor = uColor;  gl_Position = uProjection * uView * uModel * vec4(aVertex, 1.0);  vTextureCoord = aTextureCoord;}\";\n                    var fragmentShaderSrc2D = \"#ifdef GL_ES\\nprecision highp float;\\n#endif\\nvarying vec4 vFrontColor;varying vec2 vTextureCoord;uniform sampler2D uSampler;uniform int uIsDrawingText;uniform bool uSmooth;void main(void){  if(uSmooth == true){    float dist = distance(gl_PointCoord, vec2(0.5));    if(dist > 0.5){      discard;    }  }  if(uIsDrawingText == 1){    float alpha = texture2D(uSampler, vTextureCoord).a;    gl_FragColor = vec4(vFrontColor.rgb * alpha, alpha);  }  else{    gl_FragColor = vFrontColor;  }}\";\n                    var webglMaxTempsWorkaround = /Windows/.test(navigator1.userAgent);\n                    // Vertex shader for boxes and spheres.\n                    var vertexShaderSrc3D = \"varying vec4 vFrontColor;attribute vec3 aVertex;attribute vec3 aNormal;attribute vec4 aColor;attribute vec2 aTexture;varying   vec2 vTexture;uniform vec4 uColor;uniform bool uUsingMat;uniform vec3 uSpecular;uniform vec3 uMaterialEmissive;uniform vec3 uMaterialAmbient;uniform vec3 uMaterialSpecular;uniform float uShininess;uniform mat4 uModel;uniform mat4 uView;uniform mat4 uProjection;uniform mat4 uNormalTransform;uniform int uLightCount;uniform vec3 uFalloff;struct Light {  int type;  vec3 color;  vec3 position;  vec3 direction;  float angle;  vec3 halfVector;  float concentration;};uniform Light uLights0;uniform Light uLights1;uniform Light uLights2;uniform Light uLights3;uniform Light uLights4;uniform Light uLights5;uniform Light uLights6;uniform Light uLights7;Light getLight(int index){  if(index == 0) return uLights0;  if(index == 1) return uLights1;  if(index == 2) return uLights2;  if(index == 3) return uLights3;  if(index == 4) return uLights4;  if(index == 5) return uLights5;  if(index == 6) return uLights6;  return uLights7;}void AmbientLight( inout vec3 totalAmbient, in vec3 ecPos, in Light light ) {  float d = length( light.position - ecPos );  float attenuation = 1.0 / ( uFalloff[0] + ( uFalloff[1] * d ) + ( uFalloff[2] * d * d ));  totalAmbient += light.color * attenuation;}void DirectionalLight( inout vec3 col, inout vec3 spec, in vec3 vertNormal, in vec3 ecPos, in Light light ) {  float powerFactor = 0.0;  float nDotVP = max(0.0, dot( vertNormal, normalize(-light.position) ));  float nDotVH = max(0.0, dot( vertNormal, normalize(-light.position-normalize(ecPos) )));  if( nDotVP != 0.0 ){    powerFactor = pow( nDotVH, uShininess );  }  col += light.color * nDotVP;  spec += uSpecular * powerFactor;}void PointLight( inout vec3 col, inout vec3 spec, in vec3 vertNormal, in vec3 ecPos, in Light light ) {  float powerFactor;   vec3 VP = light.position - ecPos;  float d = length( VP );   VP = normalize( VP );  float attenuation = 1.0 / ( uFalloff[0] + ( uFalloff[1] * d ) + ( uFalloff[2] * d * d ));  float nDotVP = max( 0.0, dot( vertNormal, VP ));  vec3 halfVector = normalize( VP - normalize(ecPos) );  float nDotHV = max( 0.0, dot( vertNormal, halfVector ));  if( nDotVP == 0.0 ) {    powerFactor = 0.0;  }  else {    powerFactor = pow( nDotHV, uShininess );  }  spec += uSpecular * powerFactor * attenuation;  col += light.color * nDotVP * attenuation;}void SpotLight( inout vec3 col, inout vec3 spec, in vec3 vertNormal, in vec3 ecPos, in Light light ) {  float spotAttenuation;  float powerFactor = 0.0;  vec3 VP = light.position - ecPos;  vec3 ldir = normalize( -light.direction );  float d = length( VP );  VP = normalize( VP );  float attenuation = 1.0 / ( uFalloff[0] + ( uFalloff[1] * d ) + ( uFalloff[2] * d * d ) );  float spotDot = dot( VP, ldir );\" + // If the vertex falls inside the cone\n                    (webglMaxTempsWorkaround ? \"  spotAttenuation = 1.0; \" : \"  if( spotDot > cos( light.angle ) ) {    spotAttenuation = pow( spotDot, light.concentration );  }  else{    spotAttenuation = 0.0;  }  attenuation *= spotAttenuation;\") + \"  float nDotVP = max( 0.0, dot( vertNormal, VP ) );\" + \"  vec3 halfVector = normalize( VP - normalize(ecPos) );\" + \"  float nDotHV = max( 0.0, dot( vertNormal, halfVector ) );\" + \"  if( nDotVP != 0.0 ) {\" + \"    powerFactor = pow( nDotHV, uShininess );\" + \"  }\" + \"  spec += uSpecular * powerFactor * attenuation;\" + \"  col += light.color * nDotVP * attenuation;\" + \"}\" + \"void main(void) {\" + \"  vec3 finalAmbient = vec3( 0.0 );\" + \"  vec3 finalDiffuse = vec3( 0.0 );\" + \"  vec3 finalSpecular = vec3( 0.0 );\" + \"  vec4 col = uColor;\" + \"  if ( uColor[0] == -1.0 ){\" + \"    col = aColor;\" + \"  }\" + // We use the sphere vertices as the normals when we create the sphere buffer.\n                    // But this only works if the sphere vertices are unit length, so we\n                    // have to normalize the normals here. Since this is only required for spheres\n                    // we could consider placing this in a conditional later on.\n                    \"  vec3 norm = normalize(vec3( uNormalTransform * vec4( aNormal, 0.0 ) ));\" + \"  vec4 ecPos4 = uView * uModel * vec4(aVertex, 1.0);\" + \"  vec3 ecPos = (vec3(ecPos4))/ecPos4.w;\" + // If there were no lights this draw call, just use the\n                    // assigned fill color of the shape and the specular value.\n                    \"  if( uLightCount == 0 ) {\" + \"    vFrontColor = col + vec4(uMaterialSpecular, 1.0);\" + \"  }\" + \"  else {\" + // WebGL forces us to iterate over a constant value\n                    // so we can't iterate using lightCount.\n                    \"    for( int i = 0; i < 8; i++ ) {\" + \"      Light l = getLight(i);\" + // We can stop iterating if we know we have gone past\n                    // the number of lights which are actually on. This gives us a\n                    // significant performance increase with high vertex counts.\n                    \"      if( i >= uLightCount ){\" + \"        break;\" + \"      }\" + \"      if( l.type == 0 ) {\" + \"        AmbientLight( finalAmbient, ecPos, l );\" + \"      }\" + \"      else if( l.type == 1 ) {\" + \"        DirectionalLight( finalDiffuse, finalSpecular, norm, ecPos, l );\" + \"      }\" + \"      else if( l.type == 2 ) {\" + \"        PointLight( finalDiffuse, finalSpecular, norm, ecPos, l );\" + \"      }\" + \"      else {\" + \"        SpotLight( finalDiffuse, finalSpecular, norm, ecPos, l );\" + \"      }\" + \"    }\" + \"   if( uUsingMat == false ) {\" + \"     vFrontColor = vec4(\" + \"       vec3( col ) * finalAmbient +\" + \"       vec3( col ) * finalDiffuse +\" + \"       vec3( col ) * finalSpecular,\" + \"       col[3] );\" + \"   }\" + \"   else{\" + \"     vFrontColor = vec4( \" + \"       uMaterialEmissive + \" + \"       (vec3(col) * uMaterialAmbient * finalAmbient ) + \" + \"       (vec3(col) * finalDiffuse) + \" + \"       (uMaterialSpecular * finalSpecular), \" + \"       col[3] );\" + \"    }\" + \"  }\" + \"  vTexture.xy = aTexture.xy;\" + \"  gl_Position = uProjection * uView * uModel * vec4( aVertex, 1.0 );\" + \"}\";\n                    var fragmentShaderSrc3D = \"#ifdef GL_ES\\nprecision highp float;\\n#endif\\nvarying vec4 vFrontColor;uniform sampler2D uSampler;uniform bool uUsingTexture;varying vec2 vTexture;void main(void){  if( uUsingTexture ){    gl_FragColor = vec4(texture2D(uSampler, vTexture.xy)) * vFrontColor;  }  else{    gl_FragColor = vFrontColor;  }}\";\n                    ////////////////////////////////////////////////////////////////////////////\n                    // 3D Functions\n                    ////////////////////////////////////////////////////////////////////////////\n                    /*\n     * Sets a uniform variable in a program object to a particular\n     * value. Before calling this function, ensure the correct\n     * program object has been installed as part of the current\n     * rendering state by calling useProgram.\n     *\n     * On some systems, if the variable exists in the shader but isn't used,\n     * the compiler will optimize it out and this function will fail.\n     *\n     * @param {String} cacheId\n     * @param {WebGLProgram} programObj program object returned from\n     * createProgramObject\n     * @param {String} varName the name of the variable in the shader\n     * @param {float | Array} varValue either a scalar value or an Array\n     *\n     * @returns none\n     *\n     * @see uniformi\n     * @see uniformMatrix\n    */ function uniformf(cacheId, programObj, varName, varValue) {\n                        var varLocation = curContextCache.locations[cacheId];\n                        if (varLocation === undef) {\n                            varLocation = curContext.getUniformLocation(programObj, varName);\n                            curContextCache.locations[cacheId] = varLocation;\n                        }\n                        // the variable won't be found if it was optimized out.\n                        if (varLocation !== null) {\n                            if (varValue.length === 4) curContext.uniform4fv(varLocation, varValue);\n                            else if (varValue.length === 3) curContext.uniform3fv(varLocation, varValue);\n                            else if (varValue.length === 2) curContext.uniform2fv(varLocation, varValue);\n                            else curContext.uniform1f(varLocation, varValue);\n                        }\n                    }\n                    /**\n     * Sets a uniform int or int array in a program object to a particular\n     * value. Before calling this function, ensure the correct\n     * program object has been installed as part of the current\n     * rendering state.\n     *\n     * On some systems, if the variable exists in the shader but isn't used,\n     * the compiler will optimize it out and this function will fail.\n     *\n     * @param {String} cacheId\n     * @param {WebGLProgram} programObj program object returned from\n     * createProgramObject\n     * @param {String} varName the name of the variable in the shader\n     * @param {int | Array} varValue either a scalar value or an Array\n     *\n     * @returns none\n     *\n     * @see uniformf\n     * @see uniformMatrix\n    */ function uniformi(cacheId, programObj, varName, varValue) {\n                        var varLocation = curContextCache.locations[cacheId];\n                        if (varLocation === undef) {\n                            varLocation = curContext.getUniformLocation(programObj, varName);\n                            curContextCache.locations[cacheId] = varLocation;\n                        }\n                        // the variable won't be found if it was optimized out.\n                        if (varLocation !== null) {\n                            if (varValue.length === 4) curContext.uniform4iv(varLocation, varValue);\n                            else if (varValue.length === 3) curContext.uniform3iv(varLocation, varValue);\n                            else if (varValue.length === 2) curContext.uniform2iv(varLocation, varValue);\n                            else curContext.uniform1i(varLocation, varValue);\n                        }\n                    }\n                    /**\n     * Sets the value of a uniform matrix variable in a program\n     * object. Before calling this function, ensure the correct\n     * program object has been installed as part of the current\n     * rendering state.\n     *\n     * On some systems, if the variable exists in the shader but\n     * isn't used, the compiler will optimize it out and this\n     * function will fail.\n     *\n     * @param {String} cacheId\n     * @param {WebGLProgram} programObj program object returned from\n     * createProgramObject\n     * @param {String} varName the name of the variable in the shader\n     * @param {boolean} transpose must be false\n     * @param {Array} matrix an array of 4, 9 or 16 values\n     *\n     * @returns none\n     *\n     * @see uniformi\n     * @see uniformf\n    */ function uniformMatrix(cacheId, programObj, varName, transpose, matrix) {\n                        var varLocation = curContextCache.locations[cacheId];\n                        if (varLocation === undef) {\n                            varLocation = curContext.getUniformLocation(programObj, varName);\n                            curContextCache.locations[cacheId] = varLocation;\n                        }\n                        // The variable won't be found if it was optimized out.\n                        if (varLocation !== -1) {\n                            if (matrix.length === 16) curContext.uniformMatrix4fv(varLocation, transpose, matrix);\n                            else if (matrix.length === 9) curContext.uniformMatrix3fv(varLocation, transpose, matrix);\n                            else curContext.uniformMatrix2fv(varLocation, transpose, matrix);\n                        }\n                    }\n                    /**\n     * Binds the VBO, sets the vertex attribute data for the program\n     * object and enables the attribute.\n     *\n     * On some systems, if the attribute exists in the shader but\n     * isn't used, the compiler will optimize it out and this\n     * function will fail.\n     *\n     * @param {String} cacheId\n     * @param {WebGLProgram} programObj program object returned from\n     * createProgramObject\n     * @param {String} varName the name of the variable in the shader\n     * @param {int} size the number of components per vertex attribute\n     * @param {WebGLBuffer} VBO Vertex Buffer Object\n     *\n     * @returns none\n     *\n     * @see disableVertexAttribPointer\n    */ function vertexAttribPointer(cacheId, programObj, varName, size, VBO) {\n                        var varLocation = curContextCache.attributes[cacheId];\n                        if (varLocation === undef) {\n                            varLocation = curContext.getAttribLocation(programObj, varName);\n                            curContextCache.attributes[cacheId] = varLocation;\n                        }\n                        if (varLocation !== -1) {\n                            curContext.bindBuffer(curContext.ARRAY_BUFFER, VBO);\n                            curContext.vertexAttribPointer(varLocation, size, curContext.FLOAT, false, 0, 0);\n                            curContext.enableVertexAttribArray(varLocation);\n                        }\n                    }\n                    /**\n     * Disables a program object attribute from being sent to WebGL.\n     *\n     * @param {String} cacheId\n     * @param {WebGLProgram} programObj program object returned from\n     * createProgramObject\n     * @param {String} varName name of the attribute\n     *\n     * @returns none\n     *\n     * @see vertexAttribPointer\n    */ function disableVertexAttribPointer(cacheId, programObj, varName) {\n                        var varLocation = curContextCache.attributes[cacheId];\n                        if (varLocation === undef) {\n                            varLocation = curContext.getAttribLocation(programObj, varName);\n                            curContextCache.attributes[cacheId] = varLocation;\n                        }\n                        if (varLocation !== -1) curContext.disableVertexAttribArray(varLocation);\n                    }\n                    /**\n     * Creates a WebGL program object.\n     *\n     * @param {String} vetexShaderSource\n     * @param {String} fragmentShaderSource\n     *\n     * @returns {WebGLProgram} A program object\n    */ var createProgramObject = function(curContext, vetexShaderSource, fragmentShaderSource) {\n                        var vertexShaderObject = curContext.createShader(curContext.VERTEX_SHADER);\n                        curContext.shaderSource(vertexShaderObject, vetexShaderSource);\n                        curContext.compileShader(vertexShaderObject);\n                        if (!curContext.getShaderParameter(vertexShaderObject, curContext.COMPILE_STATUS)) throw curContext.getShaderInfoLog(vertexShaderObject);\n                        var fragmentShaderObject = curContext.createShader(curContext.FRAGMENT_SHADER);\n                        curContext.shaderSource(fragmentShaderObject, fragmentShaderSource);\n                        curContext.compileShader(fragmentShaderObject);\n                        if (!curContext.getShaderParameter(fragmentShaderObject, curContext.COMPILE_STATUS)) throw curContext.getShaderInfoLog(fragmentShaderObject);\n                        var programObject = curContext.createProgram();\n                        curContext.attachShader(programObject, vertexShaderObject);\n                        curContext.attachShader(programObject, fragmentShaderObject);\n                        curContext.linkProgram(programObject);\n                        if (!curContext.getProgramParameter(programObject, curContext.LINK_STATUS)) throw \"Error linking shaders.\";\n                        return programObject;\n                    };\n                    ////////////////////////////////////////////////////////////////////////////\n                    // 2D/3D drawing handling\n                    ////////////////////////////////////////////////////////////////////////////\n                    var imageModeCorner = function(x, y, w, h, whAreSizes) {\n                        return {\n                            x: x,\n                            y: y,\n                            w: w,\n                            h: h\n                        };\n                    };\n                    var imageModeConvert1 = imageModeCorner;\n                    var imageModeCorners = function(x, y, w, h, whAreSizes) {\n                        return {\n                            x: x,\n                            y: y,\n                            w: whAreSizes ? w : w - x,\n                            h: whAreSizes ? h : h - y\n                        };\n                    };\n                    var imageModeCenter = function(x, y, w, h, whAreSizes) {\n                        return {\n                            x: x - w / 2,\n                            y: y - h / 2,\n                            w: w,\n                            h: h\n                        };\n                    };\n                    // Objects for shared, 2D and 3D contexts\n                    var DrawingShared = function() {};\n                    var Drawing2D = function() {};\n                    var Drawing3D = function() {};\n                    var DrawingPre = function() {};\n                    // Setup the prototype chain\n                    Drawing2D.prototype = new DrawingShared();\n                    Drawing2D.prototype.constructor = Drawing2D;\n                    Drawing3D.prototype = new DrawingShared();\n                    Drawing3D.prototype.constructor = Drawing3D;\n                    DrawingPre.prototype = new DrawingShared();\n                    DrawingPre.prototype.constructor = DrawingPre;\n                    // A no-op function for when the user calls 3D functions from a 2D sketch\n                    // We can change this to a throw or console.error() later if we want\n                    DrawingShared.prototype.a3DOnlyFunction = noop;\n                    /**\n     * The shape() function displays shapes to the screen.\n     * Processing currently works with SVG shapes only.\n     * The <b>shape</b> parameter specifies the shape to display and the <b>x</b>\n     * and <b>y</b> parameters define the location of the shape from its\n     * upper-left corner.\n     * The shape is displayed at its original size unless the <b>width</b>\n     * and <b>height</b> parameters specify a different size.\n     * The <b>shapeMode()</b> function changes the way the parameters work.\n     * A call to <b>shapeMode(CORNERS)</b>, for example, will change the width\n     * and height parameters to define the x and y values of the opposite corner\n     * of the shape.\n     * <br><br>\n     * Note complex shapes may draw awkwardly with P2D, P3D, and OPENGL. Those\n     * renderers do not yet support shapes that have holes or complicated breaks.\n     *\n     * @param {PShape} shape       the shape to display\n     * @param {int|float} x        x-coordinate of the shape\n     * @param {int|float} y        y-coordinate of the shape\n     * @param {int|float} width    width to display the shape\n     * @param {int|float} height   height to display the shape\n     *\n     * @see PShape\n     * @see loadShape()\n     * @see shapeMode()\n     */ p.shape = function(shape, x, y, width, height) {\n                        if (arguments.length >= 1 && arguments[0] !== null) {\n                            if (shape.isVisible()) {\n                                p.pushMatrix();\n                                if (curShapeMode === PConstants1.CENTER) {\n                                    if (arguments.length === 5) {\n                                        p.translate(x - width / 2, y - height / 2);\n                                        p.scale(width / shape.getWidth(), height / shape.getHeight());\n                                    } else if (arguments.length === 3) p.translate(x - shape.getWidth() / 2, -shape.getHeight() / 2);\n                                    else p.translate(-shape.getWidth() / 2, -shape.getHeight() / 2);\n                                } else if (curShapeMode === PConstants1.CORNER) {\n                                    if (arguments.length === 5) {\n                                        p.translate(x, y);\n                                        p.scale(width / shape.getWidth(), height / shape.getHeight());\n                                    } else if (arguments.length === 3) p.translate(x, y);\n                                } else if (curShapeMode === PConstants1.CORNERS) {\n                                    if (arguments.length === 5) {\n                                        width -= x;\n                                        height -= y;\n                                        p.translate(x, y);\n                                        p.scale(width / shape.getWidth(), height / shape.getHeight());\n                                    } else if (arguments.length === 3) p.translate(x, y);\n                                }\n                                shape.draw(p);\n                                if (arguments.length === 1 && curShapeMode === PConstants1.CENTER || arguments.length > 1) p.popMatrix();\n                            }\n                        }\n                    };\n                    /**\n     * The shapeMode() function modifies the location from which shapes draw.\n     * The default mode is <b>shapeMode(CORNER)</b>, which specifies the\n     * location to be the upper left corner of the shape and uses the third\n     * and fourth parameters of <b>shape()</b> to specify the width and height.\n     * The syntax <b>shapeMode(CORNERS)</b> uses the first and second parameters\n     * of <b>shape()</b> to set the location of one corner and uses the third\n     * and fourth parameters to set the opposite corner.\n     * The syntax <b>shapeMode(CENTER)</b> draws the shape from its center point\n     * and uses the third and forth parameters of <b>shape()</b> to specify the\n     * width and height.\n     * The parameter must be written in \"ALL CAPS\" because Processing syntax\n     * is case sensitive.\n     *\n     * @param {int} mode One of CORNER, CORNERS, CENTER\n     *\n     * @see shape()\n     * @see rectMode()\n     */ p.shapeMode = function(mode) {\n                        curShapeMode = mode;\n                    };\n                    /**\n     * The loadShape() function loads vector shapes into a variable of type PShape. Currently, only SVG files may be loaded.\n     * In most cases, <b>loadShape()</b> should be used inside <b>setup()</b> because loading shapes inside <b>draw()</b> will reduce the speed of a sketch.\n     *\n     * @param {String} filename     an SVG file\n     *\n     * @return {PShape} a object of type PShape or null\n     * @see PShape\n     * @see PApplet#shape()\n     * @see PApplet#shapeMode()\n     */ p.loadShape = function(filename) {\n                        if (arguments.length === 1) {\n                            if (filename.indexOf(\".svg\") > -1) return new PShapeSVG(null, filename);\n                        }\n                        return null;\n                    };\n                    /**\n     * Processing 2.0 function for loading XML files.\n     *\n     * @param {String} uri The uri for the xml file to load.\n     *\n     * @return {XML} An XML object representing the xml data.\n     */ p.loadXML = function(uri) {\n                        return new XML(p, uri);\n                    };\n                    /**\n     * Processing 2.0 function for creating XML elements from string\n     *\n     * @param {String} xml the XML source code\n     *\n     * @return {XML} An XML object representation of the input XML markup.\n     */ p.parseXML = function(xmlstring) {\n                        var element = new XML();\n                        element.parse(xmlstring);\n                        return element;\n                    };\n                    ////////////////////////////////////////////////////////////////////////////\n                    // 2D Matrix\n                    ////////////////////////////////////////////////////////////////////////////\n                    /**\n     * Helper function for printMatrix(). Finds the largest scalar\n     * in the matrix, then number of digits left of the decimal.\n     * Call from PMatrix2D and PMatrix3D's print() function.\n     */ var printMatrixHelper1 = function(elements) {\n                        var big = 0;\n                        for(var i = 0; i < elements.length; i++)if (i !== 0) big = Math.max(big, Math.abs(elements[i]));\n                        else big = Math.abs(elements[i]);\n                        var digits = (big + \"\").indexOf(\".\");\n                        if (digits === 0) digits = 1;\n                        else if (digits === -1) digits = (big + \"\").length;\n                        return digits;\n                    };\n                    /**\n     * PMatrix2D is a 3x2 affine matrix implementation. The constructor accepts another PMatrix2D or a list of six float elements.\n     * If no parameters are provided the matrix is set to the identity matrix.\n     *\n     * @param {PMatrix2D} matrix  the initial matrix to set to\n     * @param {float} m00         the first element of the matrix\n     * @param {float} m01         the second element of the matrix\n     * @param {float} m02         the third element of the matrix\n     * @param {float} m10         the fourth element of the matrix\n     * @param {float} m11         the fifth element of the matrix\n     * @param {float} m12         the sixth element of the matrix\n     */ var PMatrix2D = p.PMatrix2D = function() {\n                        if (arguments.length === 0) this.reset();\n                        else if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) this.set(arguments[0].array());\n                        else if (arguments.length === 6) this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);\n                    };\n                    /**\n     * PMatrix2D methods\n     */ PMatrix2D.prototype = {\n                        /**\n       * @member PMatrix2D\n       * The set() function sets the matrix elements. The function accepts either another PMatrix2D, an array of elements, or a list of six floats.\n       *\n       * @param {PMatrix2D} matrix    the matrix to set this matrix to\n       * @param {float[]} elements    an array of elements to set this matrix to\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the third element of the matrix\n       * @param {float} m10           the fourth element of the matrix\n       * @param {float} m11           the fith element of the matrix\n       * @param {float} m12           the sixth element of the matrix\n       */ set: function() {\n                            if (arguments.length === 6) {\n                                var a = arguments;\n                                this.set([\n                                    a[0],\n                                    a[1],\n                                    a[2],\n                                    a[3],\n                                    a[4],\n                                    a[5]\n                                ]);\n                            } else if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) this.elements = arguments[0].array();\n                            else if (arguments.length === 1 && arguments[0] instanceof Array) this.elements = arguments[0].slice();\n                        },\n                        /**\n       * @member PMatrix2D\n       * The get() function returns a copy of this PMatrix2D.\n       *\n       * @return {PMatrix2D} a copy of this PMatrix2D\n       */ get: function() {\n                            var outgoing = new PMatrix2D();\n                            outgoing.set(this.elements);\n                            return outgoing;\n                        },\n                        /**\n       * @member PMatrix2D\n       * The reset() function sets this PMatrix2D to the identity matrix.\n       */ reset: function() {\n                            this.set([\n                                1,\n                                0,\n                                0,\n                                0,\n                                1,\n                                0\n                            ]);\n                        },\n                        /**\n       * @member PMatrix2D\n       * The array() function returns a copy of the element values.\n       * @addon\n       *\n       * @return {float[]} returns a copy of the element values\n       */ array: function array() {\n                            return this.elements.slice();\n                        },\n                        /**\n       * @member PMatrix2D\n       * The translate() function translates this matrix by moving the current coordinates to the location specified by tx and ty.\n       *\n       * @param {float} tx  the x-axis coordinate to move to\n       * @param {float} ty  the y-axis coordinate to move to\n       */ translate: function(tx, ty) {\n                            this.elements[2] = tx * this.elements[0] + ty * this.elements[1] + this.elements[2];\n                            this.elements[5] = tx * this.elements[3] + ty * this.elements[4] + this.elements[5];\n                        },\n                        /**\n       * @member PMatrix2D\n       * The invTranslate() function translates this matrix by moving the current coordinates to the negative location specified by tx and ty.\n       *\n       * @param {float} tx  the x-axis coordinate to move to\n       * @param {float} ty  the y-axis coordinate to move to\n       */ invTranslate: function(tx, ty) {\n                            this.translate(-tx, -ty);\n                        },\n                        /**\n       * @member PMatrix2D\n       * The transpose() function is not used in processingjs.\n       */ transpose: function() {\n                        // Does nothing in Processing.\n                        },\n                        /**\n       * @member PMatrix2D\n       * The mult() function multiplied this matrix.\n       * If two array elements are passed in the function will multiply a two element vector against this matrix.\n       * If target is null or not length four, a new float array will be returned.\n       * The values for vec and target can be the same (though that's less efficient).\n       * If two PVectors are passed in the function multiply the x and y coordinates of a PVector against this matrix.\n       *\n       * @param {PVector} source, target  the PVectors used to multiply this matrix\n       * @param {float[]} source, target  the arrays used to multiply this matrix\n       *\n       * @return {PVector|float[]} returns a PVector or an array representing the new matrix\n       */ mult: function(source, target) {\n                            var x, y;\n                            if (source instanceof PVector) {\n                                x = source.x;\n                                y = source.y;\n                                if (!target) target = new PVector();\n                            } else if (source instanceof Array) {\n                                x = source[0];\n                                y = source[1];\n                                if (!target) target = [];\n                            }\n                            if (target instanceof Array) {\n                                target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2];\n                                target[1] = this.elements[3] * x + this.elements[4] * y + this.elements[5];\n                            } else if (target instanceof PVector) {\n                                target.x = this.elements[0] * x + this.elements[1] * y + this.elements[2];\n                                target.y = this.elements[3] * x + this.elements[4] * y + this.elements[5];\n                                target.z = 0;\n                            }\n                            return target;\n                        },\n                        /**\n       * @member PMatrix2D\n       * The multX() function calculates the x component of a vector from a transformation.\n       *\n       * @param {float} x the x component of the vector being transformed\n       * @param {float} y the y component of the vector being transformed\n       *\n       * @return {float} returnes the result of the calculation\n       */ multX: function(x, y) {\n                            return x * this.elements[0] + y * this.elements[1] + this.elements[2];\n                        },\n                        /**\n       * @member PMatrix2D\n       * The multY() function calculates the y component of a vector from a transformation.\n       *\n       * @param {float} x the x component of the vector being transformed\n       * @param {float} y the y component of the vector being transformed\n       *\n       * @return {float} returnes the result of the calculation\n       */ multY: function(x, y) {\n                            return x * this.elements[3] + y * this.elements[4] + this.elements[5];\n                        },\n                        /**\n       * @member PMatrix2D\n       * The skewX() function skews the matrix along the x-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of skew specified in radians\n       */ skewX: function(angle) {\n                            this.apply(1, 0, 1, angle, 0, 0);\n                        },\n                        /**\n       * @member PMatrix2D\n       * The skewY() function skews the matrix along the y-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of skew specified in radians\n       */ skewY: function(angle) {\n                            this.apply(1, 0, 1, 0, angle, 0);\n                        },\n                        /**\n       * @member PMatrix2D\n       * The shearX() function shears the matrix along the x-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of skew specified in radians\n       */ shearX: function(angle) {\n                            this.apply(1, 0, 1, Math.tan(angle), 0, 0);\n                        },\n                        /**\n       * @member PMatrix2D\n       * The shearY() function shears the matrix along the y-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of skew specified in radians\n       */ shearY: function(angle) {\n                            this.apply(1, 0, 1, 0, Math.tan(angle), 0);\n                        },\n                        /**\n       * @member PMatrix2D\n       * The determinant() function calvculates the determinant of this matrix.\n       *\n       * @return {float} the determinant of the matrix\n       */ determinant: function() {\n                            return this.elements[0] * this.elements[4] - this.elements[1] * this.elements[3];\n                        },\n                        /**\n       * @member PMatrix2D\n       * The invert() function inverts this matrix\n       *\n       * @return {boolean} true if successful\n       */ invert: function() {\n                            var d = this.determinant();\n                            if (Math.abs(d) > PConstants1.MIN_INT) {\n                                var old00 = this.elements[0];\n                                var old01 = this.elements[1];\n                                var old02 = this.elements[2];\n                                var old10 = this.elements[3];\n                                var old11 = this.elements[4];\n                                var old12 = this.elements[5];\n                                this.elements[0] = old11 / d;\n                                this.elements[3] = -old10 / d;\n                                this.elements[1] = -old01 / d;\n                                this.elements[4] = old00 / d;\n                                this.elements[2] = (old01 * old12 - old11 * old02) / d;\n                                this.elements[5] = (old10 * old02 - old00 * old12) / d;\n                                return true;\n                            }\n                            return false;\n                        },\n                        /**\n       * @member PMatrix2D\n       * The scale() function increases or decreases the size of a shape by expanding and contracting vertices. When only one parameter is specified scale will occur in all dimensions.\n       * This is equivalent to a two parameter call.\n       *\n       * @param {float} sx  the amount to scale on the x-axis\n       * @param {float} sy  the amount to scale on the y-axis\n       */ scale: function(sx, sy) {\n                            if (sx && !sy) sy = sx;\n                            if (sx && sy) {\n                                this.elements[0] *= sx;\n                                this.elements[1] *= sy;\n                                this.elements[3] *= sx;\n                                this.elements[4] *= sy;\n                            }\n                        },\n                        /**\n        * @member PMatrix2D\n        * The invScale() function decreases or increases the size of a shape by contracting and expanding vertices. When only one parameter is specified scale will occur in all dimensions.\n        * This is equivalent to a two parameter call.\n        *\n        * @param {float} sx  the amount to scale on the x-axis\n        * @param {float} sy  the amount to scale on the y-axis\n        */ invScale: function(sx, sy) {\n                            if (sx && !sy) sy = sx;\n                            this.scale(1 / sx, 1 / sy);\n                        },\n                        /**\n       * @member PMatrix2D\n       * The apply() function multiplies the current matrix by the one specified through the parameters. Note that either a PMatrix2D or a list of floats can be passed in.\n       *\n       * @param {PMatrix2D} matrix    the matrix to apply this matrix to\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the third element of the matrix\n       * @param {float} m10           the fourth element of the matrix\n       * @param {float} m11           the fith element of the matrix\n       * @param {float} m12           the sixth element of the matrix\n       */ apply: function() {\n                            var source;\n                            if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) source = arguments[0].array();\n                            else if (arguments.length === 6) source = Array.prototype.slice.call(arguments);\n                            else if (arguments.length === 1 && arguments[0] instanceof Array) source = arguments[0];\n                            var result = [\n                                0,\n                                0,\n                                this.elements[2],\n                                0,\n                                0,\n                                this.elements[5]\n                            ];\n                            var e = 0;\n                            for(var row = 0; row < 2; row++)for(var col = 0; col < 3; col++, e++)result[e] += this.elements[row * 3 + 0] * source[col + 0] + this.elements[row * 3 + 1] * source[col + 3];\n                            this.elements = result.slice();\n                        },\n                        /**\n       * @member PMatrix2D\n       * The preApply() function applies another matrix to the left of this one. Note that either a PMatrix2D or elements of a matrix can be passed in.\n       *\n       * @param {PMatrix2D} matrix    the matrix to apply this matrix to\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the third element of the matrix\n       * @param {float} m10           the fourth element of the matrix\n       * @param {float} m11           the fith element of the matrix\n       * @param {float} m12           the sixth element of the matrix\n       */ preApply: function() {\n                            var source;\n                            if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) source = arguments[0].array();\n                            else if (arguments.length === 6) source = Array.prototype.slice.call(arguments);\n                            else if (arguments.length === 1 && arguments[0] instanceof Array) source = arguments[0];\n                            var result = [\n                                0,\n                                0,\n                                source[2],\n                                0,\n                                0,\n                                source[5]\n                            ];\n                            result[2] = source[2] + this.elements[2] * source[0] + this.elements[5] * source[1];\n                            result[5] = source[5] + this.elements[2] * source[3] + this.elements[5] * source[4];\n                            result[0] = this.elements[0] * source[0] + this.elements[3] * source[1];\n                            result[3] = this.elements[0] * source[3] + this.elements[3] * source[4];\n                            result[1] = this.elements[1] * source[0] + this.elements[4] * source[1];\n                            result[4] = this.elements[1] * source[3] + this.elements[4] * source[4];\n                            this.elements = result.slice();\n                        },\n                        /**\n       * @member PMatrix2D\n       * The rotate() function rotates the matrix.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */ rotate: function(angle) {\n                            var c = Math.cos(angle);\n                            var s = Math.sin(angle);\n                            var temp1 = this.elements[0];\n                            var temp2 = this.elements[1];\n                            this.elements[0] = c * temp1 + s * temp2;\n                            this.elements[1] = -s * temp1 + c * temp2;\n                            temp1 = this.elements[3];\n                            temp2 = this.elements[4];\n                            this.elements[3] = c * temp1 + s * temp2;\n                            this.elements[4] = -s * temp1 + c * temp2;\n                        },\n                        /**\n       * @member PMatrix2D\n       * The rotateZ() function rotates the matrix.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */ rotateZ: function(angle) {\n                            this.rotate(angle);\n                        },\n                        /**\n       * @member PMatrix2D\n       * The invRotateZ() function rotates the matrix in opposite direction.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */ invRotateZ: function(angle) {\n                            this.rotateZ(angle - Math.PI);\n                        },\n                        /**\n       * @member PMatrix2D\n       * The print() function prints out the elements of this matrix\n       */ print: function() {\n                            var digits = printMatrixHelper1(this.elements);\n                            var output = \"\" + p.nfs(this.elements[0], digits, 4) + \" \" + p.nfs(this.elements[1], digits, 4) + \" \" + p.nfs(this.elements[2], digits, 4) + \"\\n\" + p.nfs(this.elements[3], digits, 4) + \" \" + p.nfs(this.elements[4], digits, 4) + \" \" + p.nfs(this.elements[5], digits, 4) + \"\\n\\n\";\n                            p.println(output);\n                        }\n                    };\n                    /**\n     * PMatrix3D is a 4x4  matrix implementation. The constructor accepts another PMatrix3D or a list of six or sixteen float elements.\n     * If no parameters are provided the matrix is set to the identity matrix.\n     */ var PMatrix3D = p.PMatrix3D = function() {\n                        // When a matrix is created, it is set to an identity matrix\n                        this.reset();\n                    };\n                    /**\n     * PMatrix3D methods\n     */ PMatrix3D.prototype = {\n                        /**\n       * @member PMatrix2D\n       * The set() function sets the matrix elements. The function accepts either another PMatrix3D, an array of elements, or a list of six or sixteen floats.\n       *\n       * @param {PMatrix3D} matrix    the initial matrix to set to\n       * @param {float[]} elements    an array of elements to set this matrix to\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the second element of the matrix\n       * @param {float} m02           the third element of the matrix\n       * @param {float} m03           the fourth element of the matrix\n       * @param {float} m10           the fifth element of the matrix\n       * @param {float} m11           the sixth element of the matrix\n       * @param {float} m12           the seventh element of the matrix\n       * @param {float} m13           the eight element of the matrix\n       * @param {float} m20           the nineth element of the matrix\n       * @param {float} m21           the tenth element of the matrix\n       * @param {float} m22           the eleventh element of the matrix\n       * @param {float} m23           the twelveth element of the matrix\n       * @param {float} m30           the thirteenth element of the matrix\n       * @param {float} m31           the fourtheenth element of the matrix\n       * @param {float} m32           the fivetheenth element of the matrix\n       * @param {float} m33           the sixteenth element of the matrix\n       */ set: function() {\n                            if (arguments.length === 16) this.elements = Array.prototype.slice.call(arguments);\n                            else if (arguments.length === 1 && arguments[0] instanceof PMatrix3D) this.elements = arguments[0].array();\n                            else if (arguments.length === 1 && arguments[0] instanceof Array) this.elements = arguments[0].slice();\n                        },\n                        /**\n       * @member PMatrix3D\n       * The get() function returns a copy of this PMatrix3D.\n       *\n       * @return {PMatrix3D} a copy of this PMatrix3D\n       */ get: function() {\n                            var outgoing = new PMatrix3D();\n                            outgoing.set(this.elements);\n                            return outgoing;\n                        },\n                        /**\n       * @member PMatrix3D\n       * The reset() function sets this PMatrix3D to the identity matrix.\n       */ reset: function() {\n                            this.elements = [\n                                1,\n                                0,\n                                0,\n                                0,\n                                0,\n                                1,\n                                0,\n                                0,\n                                0,\n                                0,\n                                1,\n                                0,\n                                0,\n                                0,\n                                0,\n                                1\n                            ];\n                        },\n                        /**\n       * @member PMatrix3D\n       * The array() function returns a copy of the element values.\n       * @addon\n       *\n       * @return {float[]} returns a copy of the element values\n       */ array: function array() {\n                            return this.elements.slice();\n                        },\n                        /**\n       * @member PMatrix3D\n       * The translate() function translates this matrix by moving the current coordinates to the location specified by tx, ty, and tz.\n       *\n       * @param {float} tx  the x-axis coordinate to move to\n       * @param {float} ty  the y-axis coordinate to move to\n       * @param {float} tz  the z-axis coordinate to move to\n       */ translate: function(tx, ty, tz) {\n                            if (tz === undef) tz = 0;\n                            this.elements[3] += tx * this.elements[0] + ty * this.elements[1] + tz * this.elements[2];\n                            this.elements[7] += tx * this.elements[4] + ty * this.elements[5] + tz * this.elements[6];\n                            this.elements[11] += tx * this.elements[8] + ty * this.elements[9] + tz * this.elements[10];\n                            this.elements[15] += tx * this.elements[12] + ty * this.elements[13] + tz * this.elements[14];\n                        },\n                        /**\n       * @member PMatrix3D\n       * The transpose() function transpose this matrix.\n       */ transpose: function() {\n                            var temp = this.elements[4];\n                            this.elements[4] = this.elements[1];\n                            this.elements[1] = temp;\n                            temp = this.elements[8];\n                            this.elements[8] = this.elements[2];\n                            this.elements[2] = temp;\n                            temp = this.elements[6];\n                            this.elements[6] = this.elements[9];\n                            this.elements[9] = temp;\n                            temp = this.elements[3];\n                            this.elements[3] = this.elements[12];\n                            this.elements[12] = temp;\n                            temp = this.elements[7];\n                            this.elements[7] = this.elements[13];\n                            this.elements[13] = temp;\n                            temp = this.elements[11];\n                            this.elements[11] = this.elements[14];\n                            this.elements[14] = temp;\n                        },\n                        /**\n       * @member PMatrix3D\n       * The mult() function multiplied this matrix.\n       * If two array elements are passed in the function will multiply a two element vector against this matrix.\n       * If target is null or not length four, a new float array will be returned.\n       * The values for vec and target can be the same (though that's less efficient).\n       * If two PVectors are passed in the function multiply the x and y coordinates of a PVector against this matrix.\n       *\n       * @param {PVector} source, target  the PVectors used to multiply this matrix\n       * @param {float[]} source, target  the arrays used to multiply this matrix\n       *\n       * @return {PVector|float[]} returns a PVector or an array representing the new matrix\n       */ mult: function(source, target) {\n                            var x, y, z, w;\n                            if (source instanceof PVector) {\n                                x = source.x;\n                                y = source.y;\n                                z = source.z;\n                                w = 1;\n                                if (!target) target = new PVector();\n                            } else if (source instanceof Array) {\n                                x = source[0];\n                                y = source[1];\n                                z = source[2];\n                                w = source[3] || 1;\n                                if (!target || target.length !== 3 && target.length !== 4) target = [\n                                    0,\n                                    0,\n                                    0\n                                ];\n                            }\n                            if (target instanceof Array) {\n                                if (target.length === 3) {\n                                    target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];\n                                    target[1] = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];\n                                    target[2] = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];\n                                } else if (target.length === 4) {\n                                    target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3] * w;\n                                    target[1] = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7] * w;\n                                    target[2] = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11] * w;\n                                    target[3] = this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15] * w;\n                                }\n                            }\n                            if (target instanceof PVector) {\n                                target.x = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];\n                                target.y = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];\n                                target.z = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];\n                            }\n                            return target;\n                        },\n                        /**\n       * @member PMatrix3D\n       * The preApply() function applies another matrix to the left of this one. Note that either a PMatrix3D or elements of a matrix can be passed in.\n       *\n       * @param {PMatrix3D} matrix    the matrix to apply this matrix to\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the second element of the matrix\n       * @param {float} m02           the third element of the matrix\n       * @param {float} m03           the fourth element of the matrix\n       * @param {float} m10           the fifth element of the matrix\n       * @param {float} m11           the sixth element of the matrix\n       * @param {float} m12           the seventh element of the matrix\n       * @param {float} m13           the eight element of the matrix\n       * @param {float} m20           the nineth element of the matrix\n       * @param {float} m21           the tenth element of the matrix\n       * @param {float} m22           the eleventh element of the matrix\n       * @param {float} m23           the twelveth element of the matrix\n       * @param {float} m30           the thirteenth element of the matrix\n       * @param {float} m31           the fourtheenth element of the matrix\n       * @param {float} m32           the fivetheenth element of the matrix\n       * @param {float} m33           the sixteenth element of the matrix\n       */ preApply: function() {\n                            var source;\n                            if (arguments.length === 1 && arguments[0] instanceof PMatrix3D) source = arguments[0].array();\n                            else if (arguments.length === 16) source = Array.prototype.slice.call(arguments);\n                            else if (arguments.length === 1 && arguments[0] instanceof Array) source = arguments[0];\n                            var result = [\n                                0,\n                                0,\n                                0,\n                                0,\n                                0,\n                                0,\n                                0,\n                                0,\n                                0,\n                                0,\n                                0,\n                                0,\n                                0,\n                                0,\n                                0,\n                                0\n                            ];\n                            var e = 0;\n                            for(var row = 0; row < 4; row++)for(var col = 0; col < 4; col++, e++)result[e] += this.elements[col + 0] * source[row * 4 + 0] + this.elements[col + 4] * source[row * 4 + 1] + this.elements[col + 8] * source[row * 4 + 2] + this.elements[col + 12] * source[row * 4 + 3];\n                            this.elements = result.slice();\n                        },\n                        /**\n       * @member PMatrix3D\n       * The apply() function multiplies the current matrix by the one specified through the parameters. Note that either a PMatrix3D or a list of floats can be passed in.\n       *\n       * @param {PMatrix3D} matrix    the matrix to apply this matrix to\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the second element of the matrix\n       * @param {float} m02           the third element of the matrix\n       * @param {float} m03           the fourth element of the matrix\n       * @param {float} m10           the fifth element of the matrix\n       * @param {float} m11           the sixth element of the matrix\n       * @param {float} m12           the seventh element of the matrix\n       * @param {float} m13           the eight element of the matrix\n       * @param {float} m20           the nineth element of the matrix\n       * @param {float} m21           the tenth element of the matrix\n       * @param {float} m22           the eleventh element of the matrix\n       * @param {float} m23           the twelveth element of the matrix\n       * @param {float} m30           the thirteenth element of the matrix\n       * @param {float} m31           the fourtheenth element of the matrix\n       * @param {float} m32           the fivetheenth element of the matrix\n       * @param {float} m33           the sixteenth element of the matrix\n       */ apply: function() {\n                            var source;\n                            if (arguments.length === 1 && arguments[0] instanceof PMatrix3D) source = arguments[0].array();\n                            else if (arguments.length === 16) source = Array.prototype.slice.call(arguments);\n                            else if (arguments.length === 1 && arguments[0] instanceof Array) source = arguments[0];\n                            var result = [\n                                0,\n                                0,\n                                0,\n                                0,\n                                0,\n                                0,\n                                0,\n                                0,\n                                0,\n                                0,\n                                0,\n                                0,\n                                0,\n                                0,\n                                0,\n                                0\n                            ];\n                            var e = 0;\n                            for(var row = 0; row < 4; row++)for(var col = 0; col < 4; col++, e++)result[e] += this.elements[row * 4 + 0] * source[col + 0] + this.elements[row * 4 + 1] * source[col + 4] + this.elements[row * 4 + 2] * source[col + 8] + this.elements[row * 4 + 3] * source[col + 12];\n                            this.elements = result.slice();\n                        },\n                        /**\n       * @member PMatrix3D\n       * The rotate() function rotates the matrix.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */ rotate: function(angle, v0, v1, v2) {\n                            if (arguments.length < 4) this.rotateZ(angle);\n                            else {\n                                var v = new PVector(v0, v1, v2);\n                                var m = v.mag();\n                                if (m === 0) return;\n                                else if (m != 1) {\n                                    v.normalize();\n                                    v0 = v.x;\n                                    v1 = v.y;\n                                    v2 = v.z;\n                                }\n                                var c = p.cos(angle);\n                                var s = p.sin(angle);\n                                var t1 = 1.0 - c;\n                                this.apply(t1 * v0 * v0 + c, t1 * v0 * v1 - s * v2, t1 * v0 * v2 + s * v1, 0, t1 * v0 * v1 + s * v2, t1 * v1 * v1 + c, t1 * v1 * v2 - s * v0, 0, t1 * v0 * v2 - s * v1, t1 * v1 * v2 + s * v0, t1 * v2 * v2 + c, 0, 0, 0, 0, 1);\n                            }\n                        },\n                        /**\n       * @member PMatrix3D\n       * The invApply() function applies the inverted matrix to this matrix.\n       *\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the second element of the matrix\n       * @param {float} m02           the third element of the matrix\n       * @param {float} m03           the fourth element of the matrix\n       * @param {float} m10           the fifth element of the matrix\n       * @param {float} m11           the sixth element of the matrix\n       * @param {float} m12           the seventh element of the matrix\n       * @param {float} m13           the eight element of the matrix\n       * @param {float} m20           the nineth element of the matrix\n       * @param {float} m21           the tenth element of the matrix\n       * @param {float} m22           the eleventh element of the matrix\n       * @param {float} m23           the twelveth element of the matrix\n       * @param {float} m30           the thirteenth element of the matrix\n       * @param {float} m31           the fourtheenth element of the matrix\n       * @param {float} m32           the fivetheenth element of the matrix\n       * @param {float} m33           the sixteenth element of the matrix\n       *\n       * @return {boolean} returns true if the operation was successful.\n       */ invApply: function() {\n                            if (inverseCopy1 === undef) inverseCopy1 = new PMatrix3D();\n                            var a = arguments;\n                            inverseCopy1.set(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n                            if (!inverseCopy1.invert()) return false;\n                            this.preApply(inverseCopy1);\n                            return true;\n                        },\n                        /**\n       * @member PMatrix3D\n       * The rotateZ() function rotates the matrix.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */ rotateX: function(angle) {\n                            var c = p.cos(angle);\n                            var s = p.sin(angle);\n                            this.apply([\n                                1,\n                                0,\n                                0,\n                                0,\n                                0,\n                                c,\n                                -s,\n                                0,\n                                0,\n                                s,\n                                c,\n                                0,\n                                0,\n                                0,\n                                0,\n                                1\n                            ]);\n                        },\n                        /**\n       * @member PMatrix3D\n       * The rotateY() function rotates the matrix.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */ rotateY: function(angle) {\n                            var c = p.cos(angle);\n                            var s = p.sin(angle);\n                            this.apply([\n                                c,\n                                0,\n                                s,\n                                0,\n                                0,\n                                1,\n                                0,\n                                0,\n                                -s,\n                                0,\n                                c,\n                                0,\n                                0,\n                                0,\n                                0,\n                                1\n                            ]);\n                        },\n                        /**\n       * @member PMatrix3D\n       * The rotateZ() function rotates the matrix.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */ rotateZ: function(angle) {\n                            var c = Math.cos(angle);\n                            var s = Math.sin(angle);\n                            this.apply([\n                                c,\n                                -s,\n                                0,\n                                0,\n                                s,\n                                c,\n                                0,\n                                0,\n                                0,\n                                0,\n                                1,\n                                0,\n                                0,\n                                0,\n                                0,\n                                1\n                            ]);\n                        },\n                        /**\n       * @member PMatrix3D\n       * The scale() function increases or decreases the size of a matrix by expanding and contracting vertices. When only one parameter is specified scale will occur in all dimensions.\n       * This is equivalent to a three parameter call.\n       *\n       * @param {float} sx  the amount to scale on the x-axis\n       * @param {float} sy  the amount to scale on the y-axis\n       * @param {float} sz  the amount to scale on the z-axis\n       */ scale: function(sx, sy, sz) {\n                            if (sx && !sy && !sz) sy = sz = sx;\n                            else if (sx && sy && !sz) sz = 1;\n                            if (sx && sy && sz) {\n                                this.elements[0] *= sx;\n                                this.elements[1] *= sy;\n                                this.elements[2] *= sz;\n                                this.elements[4] *= sx;\n                                this.elements[5] *= sy;\n                                this.elements[6] *= sz;\n                                this.elements[8] *= sx;\n                                this.elements[9] *= sy;\n                                this.elements[10] *= sz;\n                                this.elements[12] *= sx;\n                                this.elements[13] *= sy;\n                                this.elements[14] *= sz;\n                            }\n                        },\n                        /**\n       * @member PMatrix3D\n       * The skewX() function skews the matrix along the x-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of skew specified in radians\n       */ skewX: function(angle) {\n                            var t1 = Math.tan(angle);\n                            this.apply(1, t1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n                        },\n                        /**\n       * @member PMatrix3D\n       * The skewY() function skews the matrix along the y-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of skew specified in radians\n       */ skewY: function(angle) {\n                            var t1 = Math.tan(angle);\n                            this.apply(1, 0, 0, 0, t1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n                        },\n                        /**\n       * @member PMatrix3D\n       * The shearX() function shears the matrix along the x-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of shear specified in radians\n       */ shearX: function(angle) {\n                            var t1 = Math.tan(angle);\n                            this.apply(1, t1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n                        },\n                        /**\n       * @member PMatrix3D\n       * The shearY() function shears the matrix along the y-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of shear specified in radians\n       */ shearY: function(angle) {\n                            var t1 = Math.tan(angle);\n                            this.apply(1, 0, 0, 0, t1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n                        },\n                        multX: function(x, y, z, w) {\n                            if (!z) return this.elements[0] * x + this.elements[1] * y + this.elements[3];\n                            if (!w) return this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];\n                            return this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3] * w;\n                        },\n                        multY: function(x, y, z, w) {\n                            if (!z) return this.elements[4] * x + this.elements[5] * y + this.elements[7];\n                            if (!w) return this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];\n                            return this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7] * w;\n                        },\n                        multZ: function(x, y, z, w) {\n                            if (!w) return this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];\n                            return this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11] * w;\n                        },\n                        multW: function(x, y, z, w) {\n                            if (!w) return this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15];\n                            return this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15] * w;\n                        },\n                        /**\n       * @member PMatrix3D\n       * The invert() function inverts this matrix\n       *\n       * @return {boolean} true if successful\n       */ invert: function() {\n                            var fA0 = this.elements[0] * this.elements[5] - this.elements[1] * this.elements[4];\n                            var fA1 = this.elements[0] * this.elements[6] - this.elements[2] * this.elements[4];\n                            var fA2 = this.elements[0] * this.elements[7] - this.elements[3] * this.elements[4];\n                            var fA3 = this.elements[1] * this.elements[6] - this.elements[2] * this.elements[5];\n                            var fA4 = this.elements[1] * this.elements[7] - this.elements[3] * this.elements[5];\n                            var fA5 = this.elements[2] * this.elements[7] - this.elements[3] * this.elements[6];\n                            var fB0 = this.elements[8] * this.elements[13] - this.elements[9] * this.elements[12];\n                            var fB1 = this.elements[8] * this.elements[14] - this.elements[10] * this.elements[12];\n                            var fB2 = this.elements[8] * this.elements[15] - this.elements[11] * this.elements[12];\n                            var fB3 = this.elements[9] * this.elements[14] - this.elements[10] * this.elements[13];\n                            var fB4 = this.elements[9] * this.elements[15] - this.elements[11] * this.elements[13];\n                            var fB5 = this.elements[10] * this.elements[15] - this.elements[11] * this.elements[14];\n                            // Determinant\n                            var fDet = fA0 * fB5 - fA1 * fB4 + fA2 * fB3 + fA3 * fB2 - fA4 * fB1 + fA5 * fB0;\n                            // Account for a very small value\n                            // return false if not successful.\n                            if (Math.abs(fDet) <= 1e-9) return false;\n                            var kInv = [];\n                            kInv[0] = +this.elements[5] * fB5 - this.elements[6] * fB4 + this.elements[7] * fB3;\n                            kInv[4] = -this.elements[4] * fB5 + this.elements[6] * fB2 - this.elements[7] * fB1;\n                            kInv[8] = +this.elements[4] * fB4 - this.elements[5] * fB2 + this.elements[7] * fB0;\n                            kInv[12] = -this.elements[4] * fB3 + this.elements[5] * fB1 - this.elements[6] * fB0;\n                            kInv[1] = -this.elements[1] * fB5 + this.elements[2] * fB4 - this.elements[3] * fB3;\n                            kInv[5] = +this.elements[0] * fB5 - this.elements[2] * fB2 + this.elements[3] * fB1;\n                            kInv[9] = -this.elements[0] * fB4 + this.elements[1] * fB2 - this.elements[3] * fB0;\n                            kInv[13] = +this.elements[0] * fB3 - this.elements[1] * fB1 + this.elements[2] * fB0;\n                            kInv[2] = +this.elements[13] * fA5 - this.elements[14] * fA4 + this.elements[15] * fA3;\n                            kInv[6] = -this.elements[12] * fA5 + this.elements[14] * fA2 - this.elements[15] * fA1;\n                            kInv[10] = +this.elements[12] * fA4 - this.elements[13] * fA2 + this.elements[15] * fA0;\n                            kInv[14] = -this.elements[12] * fA3 + this.elements[13] * fA1 - this.elements[14] * fA0;\n                            kInv[3] = -this.elements[9] * fA5 + this.elements[10] * fA4 - this.elements[11] * fA3;\n                            kInv[7] = +this.elements[8] * fA5 - this.elements[10] * fA2 + this.elements[11] * fA1;\n                            kInv[11] = -this.elements[8] * fA4 + this.elements[9] * fA2 - this.elements[11] * fA0;\n                            kInv[15] = +this.elements[8] * fA3 - this.elements[9] * fA1 + this.elements[10] * fA0;\n                            // Inverse using Determinant\n                            var fInvDet = 1.0 / fDet;\n                            kInv[0] *= fInvDet;\n                            kInv[1] *= fInvDet;\n                            kInv[2] *= fInvDet;\n                            kInv[3] *= fInvDet;\n                            kInv[4] *= fInvDet;\n                            kInv[5] *= fInvDet;\n                            kInv[6] *= fInvDet;\n                            kInv[7] *= fInvDet;\n                            kInv[8] *= fInvDet;\n                            kInv[9] *= fInvDet;\n                            kInv[10] *= fInvDet;\n                            kInv[11] *= fInvDet;\n                            kInv[12] *= fInvDet;\n                            kInv[13] *= fInvDet;\n                            kInv[14] *= fInvDet;\n                            kInv[15] *= fInvDet;\n                            this.elements = kInv.slice();\n                            return true;\n                        },\n                        toString: function() {\n                            var str = \"\";\n                            for(var i = 0; i < 15; i++)str += this.elements[i] + \", \";\n                            str += this.elements[15];\n                            return str;\n                        },\n                        /**\n       * @member PMatrix3D\n       * The print() function prints out the elements of this matrix\n       */ print: function() {\n                            var digits = printMatrixHelper1(this.elements);\n                            var output = \"\" + p.nfs(this.elements[0], digits, 4) + \" \" + p.nfs(this.elements[1], digits, 4) + \" \" + p.nfs(this.elements[2], digits, 4) + \" \" + p.nfs(this.elements[3], digits, 4) + \"\\n\" + p.nfs(this.elements[4], digits, 4) + \" \" + p.nfs(this.elements[5], digits, 4) + \" \" + p.nfs(this.elements[6], digits, 4) + \" \" + p.nfs(this.elements[7], digits, 4) + \"\\n\" + p.nfs(this.elements[8], digits, 4) + \" \" + p.nfs(this.elements[9], digits, 4) + \" \" + p.nfs(this.elements[10], digits, 4) + \" \" + p.nfs(this.elements[11], digits, 4) + \"\\n\" + p.nfs(this.elements[12], digits, 4) + \" \" + p.nfs(this.elements[13], digits, 4) + \" \" + p.nfs(this.elements[14], digits, 4) + \" \" + p.nfs(this.elements[15], digits, 4) + \"\\n\\n\";\n                            p.println(output);\n                        },\n                        invTranslate: function(tx, ty, tz) {\n                            this.preApply(1, 0, 0, -tx, 0, 1, 0, -ty, 0, 0, 1, -tz, 0, 0, 0, 1);\n                        },\n                        invRotateX: function(angle) {\n                            var c = Math.cos(-angle);\n                            var s = Math.sin(-angle);\n                            this.preApply([\n                                1,\n                                0,\n                                0,\n                                0,\n                                0,\n                                c,\n                                -s,\n                                0,\n                                0,\n                                s,\n                                c,\n                                0,\n                                0,\n                                0,\n                                0,\n                                1\n                            ]);\n                        },\n                        invRotateY: function(angle) {\n                            var c = Math.cos(-angle);\n                            var s = Math.sin(-angle);\n                            this.preApply([\n                                c,\n                                0,\n                                s,\n                                0,\n                                0,\n                                1,\n                                0,\n                                0,\n                                -s,\n                                0,\n                                c,\n                                0,\n                                0,\n                                0,\n                                0,\n                                1\n                            ]);\n                        },\n                        invRotateZ: function(angle) {\n                            var c = Math.cos(-angle);\n                            var s = Math.sin(-angle);\n                            this.preApply([\n                                c,\n                                -s,\n                                0,\n                                0,\n                                s,\n                                c,\n                                0,\n                                0,\n                                0,\n                                0,\n                                1,\n                                0,\n                                0,\n                                0,\n                                0,\n                                1\n                            ]);\n                        },\n                        invScale: function(x, y, z) {\n                            this.preApply([\n                                1 / x,\n                                0,\n                                0,\n                                0,\n                                0,\n                                1 / y,\n                                0,\n                                0,\n                                0,\n                                0,\n                                1 / z,\n                                0,\n                                0,\n                                0,\n                                0,\n                                1\n                            ]);\n                        }\n                    };\n                    /**\n     * @private\n     * The matrix stack stores the transformations and translations that occur within the space.\n     */ var PMatrixStack = p.PMatrixStack = function() {\n                        this.matrixStack = [];\n                    };\n                    /**\n     * @member PMatrixStack\n     * load pushes the matrix given in the function into the stack\n     *\n     * @param {Object | Array} matrix the matrix to be pushed into the stack\n     */ PMatrixStack.prototype.load = function() {\n                        var tmpMatrix = drawing.$newPMatrix();\n                        if (arguments.length === 1) tmpMatrix.set(arguments[0]);\n                        else tmpMatrix.set(arguments);\n                        this.matrixStack.push(tmpMatrix);\n                    };\n                    Drawing2D.prototype.$newPMatrix = function() {\n                        return new PMatrix2D();\n                    };\n                    Drawing3D.prototype.$newPMatrix = function() {\n                        return new PMatrix3D();\n                    };\n                    /**\n     * @member PMatrixStack\n     * push adds a duplicate of the top of the stack onto the stack - uses the peek function\n     */ PMatrixStack.prototype.push = function() {\n                        this.matrixStack.push(this.peek());\n                    };\n                    /**\n     * @member PMatrixStack\n     * pop removes returns the matrix at the top of the stack\n     *\n     * @returns {Object} the matrix at the top of the stack\n     */ PMatrixStack.prototype.pop = function() {\n                        return this.matrixStack.pop();\n                    };\n                    /**\n     * @member PMatrixStack\n     * peek returns but doesn't remove the matrix at the top of the stack\n     *\n     * @returns {Object} the matrix at the top of the stack\n     */ PMatrixStack.prototype.peek = function() {\n                        var tmpMatrix = drawing.$newPMatrix();\n                        tmpMatrix.set(this.matrixStack[this.matrixStack.length - 1]);\n                        return tmpMatrix;\n                    };\n                    /**\n     * @member PMatrixStack\n     * this function multiplies the matrix at the top of the stack with the matrix given as a parameter\n     *\n     * @param {Object | Array} matrix the matrix to be multiplied into the stack\n     */ PMatrixStack.prototype.mult = function(matrix) {\n                        this.matrixStack[this.matrixStack.length - 1].apply(matrix);\n                    };\n                    ////////////////////////////////////////////////////////////////////////////\n                    // Array handling\n                    ////////////////////////////////////////////////////////////////////////////\n                    /**\n    * The split() function breaks a string into pieces using a character or string\n    * as the divider. The delim  parameter specifies the character or characters that\n    * mark the boundaries between each piece. A String[] array is returned that contains\n    * each of the pieces.\n    * If the result is a set of numbers, you can convert the String[] array to to a float[]\n    * or int[] array using the datatype conversion functions int() and float() (see example above).\n    * The splitTokens() function works in a similar fashion, except that it splits using a range\n    * of characters instead of a specific character or sequence.\n    *\n    * @param {String} str       the String to be split\n    * @param {String} delim     the character or String used to separate the data\n    *\n    * @returns {string[]} The new string array\n    *\n    * @see splitTokens\n    * @see join\n    * @see trim\n    */ p.split = function(str, delim) {\n                        return str.split(delim);\n                    };\n                    /**\n    * The splitTokens() function splits a String at one or many character \"tokens.\" The tokens\n    * parameter specifies the character or characters to be used as a boundary.\n    * If no tokens character is specified, any whitespace character is used to split.\n    * Whitespace characters include tab (\\t), line feed (\\n), carriage return (\\r), form\n    * feed (\\f), and space. To convert a String to an array of integers or floats, use the\n    * datatype conversion functions int() and float() to convert the array of Strings.\n    *\n    * @param {String} str       the String to be split\n    * @param {Char[]} tokens    list of individual characters that will be used as separators\n    *\n    * @returns {string[]} The new string array\n    *\n    * @see split\n    * @see join\n    * @see trim\n    */ p.splitTokens = function(str, tokens) {\n                        if (tokens === undef) return str.split(/\\s+/g);\n                        var chars = tokens.split(/()/g), buffer = \"\", len = str.length, i, c, tokenized = [];\n                        for(i = 0; i < len; i++){\n                            c = str[i];\n                            if (chars.indexOf(c) > -1) {\n                                if (buffer !== \"\") tokenized.push(buffer);\n                                buffer = \"\";\n                            } else buffer += c;\n                        }\n                        if (buffer !== \"\") tokenized.push(buffer);\n                        return tokenized;\n                    };\n                    /**\n    * Expands an array by one element and adds data to the new position. The datatype of\n    * the element parameter must be the same as the datatype of the array.\n    * When using an array of objects, the data returned from the function must be cast to\n    * the object array's data type. For example: SomeClass[] items = (SomeClass[])\n    * append(originalArray, element).\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} array boolean[],\n    * byte[], char[], int[], float[], or String[], or an array of objects\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} element new data for the array\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see shorten\n    * @see expand\n    */ p.append = function(array, element) {\n                        array[array.length] = element;\n                        return array;\n                    };\n                    /**\n    * Concatenates two arrays. For example, concatenating the array { 1, 2, 3 } and the\n    * array { 4, 5, 6 } yields { 1, 2, 3, 4, 5, 6 }. Both parameters must be arrays of the\n    * same datatype.\n    * When using an array of objects, the data returned from the function must be cast to the\n    * object array's data type. For example: SomeClass[] items = (SomeClass[]) concat(array1, array2).\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} array1 boolean[],\n    * byte[], char[], int[], float[], String[], or an array of objects\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} array2 boolean[],\n    * byte[], char[], int[], float[], String[], or an array of objects\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see splice\n    */ p.concat = function(array1, array2) {\n                        return array1.concat(array2);\n                    };\n                    /**\n     * Sorts an array of numbers from smallest to largest and puts an array of\n     * words in alphabetical order. The original array is not modified, a\n     * re-ordered array is returned. The count parameter states the number of\n     * elements to sort. For example if there are 12 elements in an array and\n     * if count is the value 5, only the first five elements on the array will\n     * be sorted. Alphabetical ordering is case insensitive.\n     *\n     * @param {String[] | int[] | float[]}  array Array of elements to sort\n     * @param {int}                         numElem Number of elements to sort\n     *\n     * @returns {String[] | int[] | float[]} Array (same datatype as the input)\n     *\n     * @see reverse\n    */ p.sort = function(array, numElem) {\n                        var ret = [];\n                        // depending on the type used (int, float) or string\n                        // we'll need to use a different compare function\n                        if (array.length > 0) {\n                            // copy since we need to return another array\n                            var elemsToCopy = numElem > 0 ? numElem : array.length;\n                            for(var i = 0; i < elemsToCopy; i++)ret.push(array[i]);\n                            if (typeof array[0] === \"string\") ret.sort();\n                            else ret.sort(function(a, b) {\n                                return a - b;\n                            });\n                            // copy on the rest of the elements that were not sorted in case the user\n                            // only wanted a subset of an array to be sorted.\n                            if (numElem > 0) for(var j = ret.length; j < array.length; j++)ret.push(array[j]);\n                        }\n                        return ret;\n                    };\n                    /**\n    * Inserts a value or array of values into an existing array. The first two parameters must\n    * be of the same datatype. The array parameter defines the array which will be modified\n    * and the second parameter defines the data which will be inserted. When using an array\n    * of objects, the data returned from the function must be cast to the object array's data\n    * type. For example: SomeClass[] items = (SomeClass[]) splice(array1, array2, index).\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} array boolean[],\n    * byte[], char[], int[], float[], String[], or an array of objects\n    * @param {boolean|byte|char|int|float|String|boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects}\n    * value boolean, byte, char, int, float, String, boolean[], byte[], char[], int[],\n    * float[], String[], or other Object: value or an array of objects to be spliced in\n    * @param {int} index                position in the array from which to insert data\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see contract\n    * @see subset\n    */ p.splice = function(array, value, index) {\n                        // Trying to splice an empty array into \"array\" in P5 won't do\n                        // anything, just return the original.\n                        if (value.length === 0) return array;\n                        // If the second argument was an array, we'll need to iterate over all\n                        // the \"value\" elements and add one by one because\n                        // array.splice(index, 0, value);\n                        // would create a multi-dimensional array which isn't what we want.\n                        if (value instanceof Array) for(var i = 0, j = index; i < value.length; j++, i++)array.splice(j, 0, value[i]);\n                        else array.splice(index, 0, value);\n                        return array;\n                    };\n                    /**\n    * Extracts an array of elements from an existing array. The array parameter defines the\n    * array from which the elements will be copied and the offset and length parameters determine\n    * which elements to extract. If no length is given, elements will be extracted from the offset\n    * to the end of the array. When specifying the offset remember the first array element is 0.\n    * This function does not change the source array.\n    * When using an array of objects, the data returned from the function must be cast to the\n    * object array's data type.\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} array boolean[],\n    * byte[], char[], int[], float[], String[], or an array of objects\n    * @param {int} offset         position to begin\n    * @param {int} length         number of values to extract\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see splice\n    */ p.subset = function(array, offset, length) {\n                        var end = length !== undef ? offset + length : array.length;\n                        return array.slice(offset, end);\n                    };\n                    /**\n    * Combines an array of Strings into one String, each separated by the character(s) used for\n    * the separator parameter. To join arrays of ints or floats, it's necessary to first convert\n    * them to strings using nf() or nfs().\n    *\n    * @param {Array} array              array of Strings\n    * @param {char|String} separator    char or String to be placed between each item\n    *\n    * @returns {String} The combined string\n    *\n    * @see split\n    * @see trim\n    * @see nf\n    * @see nfs\n    */ p.join = function(array, seperator) {\n                        return array.join(seperator);\n                    };\n                    /**\n    * Decreases an array by one element and returns the shortened array. When using an\n    * array of objects, the data returned from the function must be cast to the object array's\n    * data type. For example: SomeClass[] items = (SomeClass[]) shorten(originalArray).\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} array\n    * boolean[], byte[], char[], int[], float[], or String[], or an array of objects\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see append\n    * @see expand\n    */ p.shorten = function(ary) {\n                        var newary = [];\n                        // copy array into new array\n                        var len = ary.length;\n                        for(var i = 0; i < len; i++)newary[i] = ary[i];\n                        newary.pop();\n                        return newary;\n                    };\n                    /**\n    * Increases the size of an array. By default, this function doubles the size of the array,\n    * but the optional newSize parameter provides precise control over the increase in size.\n    * When using an array of objects, the data returned from the function must be cast to the\n    * object array's data type. For example: SomeClass[] items = (SomeClass[]) expand(originalArray).\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} ary\n    * boolean[], byte[], char[], int[], float[], String[], or an array of objects\n    * @param {int} newSize              positive int: new size for the array\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see contract\n    */ p.expand = function(ary, targetSize) {\n                        var temp = ary.slice(0), newSize = targetSize || ary.length * 2;\n                        temp.length = newSize;\n                        return temp;\n                    };\n                    /**\n    * Copies an array (or part of an array) to another array. The src array is copied to the\n    * dst array, beginning at the position specified by srcPos and into the position specified\n    * by dstPos. The number of elements to copy is determined by length. The simplified version\n    * with two arguments copies an entire array to another of the same size. It is equivalent\n    * to \"arrayCopy(src, 0, dst, 0, src.length)\". This function is far more efficient for copying\n    * array data than iterating through a for and copying each element.\n    *\n    * @param {Array} src an array of any data type: the source array\n    * @param {Array} dest an array of any data type (as long as it's the same as src): the destination array\n    * @param {int} srcPos     starting position in the source array\n    * @param {int} destPos    starting position in the destination array\n    * @param {int} length     number of array elements to be copied\n    *\n    * @returns none\n    */ p.arrayCopy = function() {\n                        var src, srcPos = 0, dest, destPos = 0, length;\n                        if (arguments.length === 2) {\n                            // recall itself and copy src to dest from start index 0 to 0 of src.length\n                            src = arguments[0];\n                            dest = arguments[1];\n                            length = src.length;\n                        } else if (arguments.length === 3) {\n                            // recall itself and copy src to dest from start index 0 to 0 of length\n                            src = arguments[0];\n                            dest = arguments[1];\n                            length = arguments[2];\n                        } else if (arguments.length === 5) {\n                            src = arguments[0];\n                            srcPos = arguments[1];\n                            dest = arguments[2];\n                            destPos = arguments[3];\n                            length = arguments[4];\n                        }\n                        // copy src to dest from index srcPos to index destPos of length recursivly on objects\n                        for(var i = srcPos, j = destPos; i < length + srcPos; i++, j++){\n                            if (dest[j] !== undef) dest[j] = src[i];\n                            else throw \"array index out of bounds exception\";\n                        }\n                    };\n                    /**\n    * Reverses the order of an array.\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]} array\n    * boolean[], byte[], char[], int[], float[], or String[]\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see sort\n    */ p.reverse = function(array) {\n                        return array.reverse();\n                    };\n                    ////////////////////////////////////////////////////////////////////////////\n                    // Color functions\n                    ////////////////////////////////////////////////////////////////////////////\n                    // helper functions for internal blending modes\n                    p.mix = function(a, b, f) {\n                        return a + ((b - a) * f >> 8);\n                    };\n                    p.peg = function(n) {\n                        return n < 0 ? 0 : n > 255 ? 255 : n;\n                    };\n                    // blending modes\n                    /**\n    * These are internal blending modes used for BlendColor()\n    *\n    * @param {Color} c1       First Color to blend\n    * @param {Color} c2       Second Color to blend\n    *\n    * @returns {Color}        The blended Color\n    *\n    * @see BlendColor\n    * @see Blend\n    */ p.modes = function() {\n                        var ALPHA_MASK = PConstants1.ALPHA_MASK, RED_MASK = PConstants1.RED_MASK, GREEN_MASK = PConstants1.GREEN_MASK, BLUE_MASK = PConstants1.BLUE_MASK, min = Math.min, max = Math.max;\n                        function applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb) {\n                            var a = min(((c1 & 0xff000000) >>> 24) + f, 0xff) << 24;\n                            var r = ar + ((cr - ar) * f >> 8);\n                            r = (r < 0 ? 0 : r > 255 ? 255 : r) << 16;\n                            var g = ag + ((cg - ag) * f >> 8);\n                            g = (g < 0 ? 0 : g > 255 ? 255 : g) << 8;\n                            var b = ab + ((cb - ab) * f >> 8);\n                            b = b < 0 ? 0 : b > 255 ? 255 : b;\n                            return a | r | g | b;\n                        }\n                        return {\n                            replace: function(c1, c2) {\n                                return c2;\n                            },\n                            blend: function(c1, c2) {\n                                var f = (c2 & ALPHA_MASK) >>> 24, ar = c1 & RED_MASK, ag = c1 & GREEN_MASK, ab = c1 & BLUE_MASK, br = c2 & RED_MASK, bg = c2 & GREEN_MASK, bb = c2 & BLUE_MASK;\n                                return min(((c1 & ALPHA_MASK) >>> 24) + f, 0xff) << 24 | ar + ((br - ar) * f >> 8) & RED_MASK | ag + ((bg - ag) * f >> 8) & GREEN_MASK | ab + ((bb - ab) * f >> 8) & BLUE_MASK;\n                            },\n                            add: function(c1, c2) {\n                                var f = (c2 & ALPHA_MASK) >>> 24;\n                                return min(((c1 & ALPHA_MASK) >>> 24) + f, 0xff) << 24 | min((c1 & RED_MASK) + ((c2 & RED_MASK) >> 8) * f, RED_MASK) & RED_MASK | min((c1 & GREEN_MASK) + ((c2 & GREEN_MASK) >> 8) * f, GREEN_MASK) & GREEN_MASK | min((c1 & BLUE_MASK) + ((c2 & BLUE_MASK) * f >> 8), BLUE_MASK);\n                            },\n                            subtract: function(c1, c2) {\n                                var f = (c2 & ALPHA_MASK) >>> 24;\n                                return min(((c1 & ALPHA_MASK) >>> 24) + f, 0xff) << 24 | max((c1 & RED_MASK) - ((c2 & RED_MASK) >> 8) * f, GREEN_MASK) & RED_MASK | max((c1 & GREEN_MASK) - ((c2 & GREEN_MASK) >> 8) * f, BLUE_MASK) & GREEN_MASK | max((c1 & BLUE_MASK) - ((c2 & BLUE_MASK) * f >> 8), 0);\n                            },\n                            lightest: function(c1, c2) {\n                                var f = (c2 & ALPHA_MASK) >>> 24;\n                                return min(((c1 & ALPHA_MASK) >>> 24) + f, 0xff) << 24 | max(c1 & RED_MASK, ((c2 & RED_MASK) >> 8) * f) & RED_MASK | max(c1 & GREEN_MASK, ((c2 & GREEN_MASK) >> 8) * f) & GREEN_MASK | max(c1 & BLUE_MASK, (c2 & BLUE_MASK) * f >> 8);\n                            },\n                            darkest: function(c1, c2) {\n                                var f = (c2 & ALPHA_MASK) >>> 24, ar = c1 & RED_MASK, ag = c1 & GREEN_MASK, ab = c1 & BLUE_MASK, br = min(c1 & RED_MASK, ((c2 & RED_MASK) >> 8) * f), bg = min(c1 & GREEN_MASK, ((c2 & GREEN_MASK) >> 8) * f), bb = min(c1 & BLUE_MASK, (c2 & BLUE_MASK) * f >> 8);\n                                return min(((c1 & ALPHA_MASK) >>> 24) + f, 0xff) << 24 | ar + ((br - ar) * f >> 8) & RED_MASK | ag + ((bg - ag) * f >> 8) & GREEN_MASK | ab + ((bb - ab) * f >> 8) & BLUE_MASK;\n                            },\n                            difference: function(c1, c2) {\n                                var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK, cr = ar > br ? ar - br : br - ar, cg = ag > bg ? ag - bg : bg - ag, cb = ab > bb ? ab - bb : bb - ab;\n                                return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n                            },\n                            exclusion: function(c1, c2) {\n                                var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK, cr = ar + br - (ar * br >> 7), cg = ag + bg - (ag * bg >> 7), cb = ab + bb - (ab * bb >> 7);\n                                return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n                            },\n                            multiply: function(c1, c2) {\n                                var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK, cr = ar * br >> 8, cg = ag * bg >> 8, cb = ab * bb >> 8;\n                                return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n                            },\n                            screen: function(c1, c2) {\n                                var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK, cr = 255 - ((255 - ar) * (255 - br) >> 8), cg = 255 - ((255 - ag) * (255 - bg) >> 8), cb = 255 - ((255 - ab) * (255 - bb) >> 8);\n                                return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n                            },\n                            hard_light: function(c1, c2) {\n                                var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK, cr = br < 128 ? ar * br >> 7 : 255 - ((255 - ar) * (255 - br) >> 7), cg = bg < 128 ? ag * bg >> 7 : 255 - ((255 - ag) * (255 - bg) >> 7), cb = bb < 128 ? ab * bb >> 7 : 255 - ((255 - ab) * (255 - bb) >> 7);\n                                return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n                            },\n                            soft_light: function(c1, c2) {\n                                var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK, cr = (ar * br >> 7) + (ar * ar >> 8) - (ar * ar * br >> 15), cg = (ag * bg >> 7) + (ag * ag >> 8) - (ag * ag * bg >> 15), cb = (ab * bb >> 7) + (ab * ab >> 8) - (ab * ab * bb >> 15);\n                                return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n                            },\n                            overlay: function(c1, c2) {\n                                var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK, cr = ar < 128 ? ar * br >> 7 : 255 - ((255 - ar) * (255 - br) >> 7), cg = ag < 128 ? ag * bg >> 7 : 255 - ((255 - ag) * (255 - bg) >> 7), cb = ab < 128 ? ab * bb >> 7 : 255 - ((255 - ab) * (255 - bb) >> 7);\n                                return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n                            },\n                            dodge: function(c1, c2) {\n                                var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK;\n                                var cr = 255;\n                                if (br !== 255) {\n                                    cr = (ar << 8) / (255 - br);\n                                    cr = cr < 0 ? 0 : cr > 255 ? 255 : cr;\n                                }\n                                var cg = 255;\n                                if (bg !== 255) {\n                                    cg = (ag << 8) / (255 - bg);\n                                    cg = cg < 0 ? 0 : cg > 255 ? 255 : cg;\n                                }\n                                var cb = 255;\n                                if (bb !== 255) {\n                                    cb = (ab << 8) / (255 - bb);\n                                    cb = cb < 0 ? 0 : cb > 255 ? 255 : cb;\n                                }\n                                return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n                            },\n                            burn: function(c1, c2) {\n                                var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK;\n                                var cr = 0;\n                                if (br !== 0) {\n                                    cr = (255 - ar << 8) / br;\n                                    cr = 255 - (cr < 0 ? 0 : cr > 255 ? 255 : cr);\n                                }\n                                var cg = 0;\n                                if (bg !== 0) {\n                                    cg = (255 - ag << 8) / bg;\n                                    cg = 255 - (cg < 0 ? 0 : cg > 255 ? 255 : cg);\n                                }\n                                var cb = 0;\n                                if (bb !== 0) {\n                                    cb = (255 - ab << 8) / bb;\n                                    cb = 255 - (cb < 0 ? 0 : cb > 255 ? 255 : cb);\n                                }\n                                return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n                            }\n                        };\n                    }();\n                    function color$4(aValue1, aValue2, aValue3, aValue4) {\n                        var r, g, b, a;\n                        if (curColorMode === PConstants1.HSB) {\n                            var rgb = p.color.toRGB(aValue1, aValue2, aValue3);\n                            r = rgb[0];\n                            g = rgb[1];\n                            b = rgb[2];\n                        } else {\n                            r = Math.round(255 * (aValue1 / colorModeX));\n                            g = Math.round(255 * (aValue2 / colorModeY));\n                            b = Math.round(255 * (aValue3 / colorModeZ));\n                        }\n                        a = Math.round(255 * (aValue4 / colorModeA));\n                        // Limit values less than 0 and greater than 255\n                        r = r < 0 ? 0 : r;\n                        g = g < 0 ? 0 : g;\n                        b = b < 0 ? 0 : b;\n                        a = a < 0 ? 0 : a;\n                        r = r > 255 ? 255 : r;\n                        g = g > 255 ? 255 : g;\n                        b = b > 255 ? 255 : b;\n                        a = a > 255 ? 255 : a;\n                        // Create color int\n                        return a << 24 & PConstants1.ALPHA_MASK | r << 16 & PConstants1.RED_MASK | g << 8 & PConstants1.GREEN_MASK | b & PConstants1.BLUE_MASK;\n                    }\n                    function color$2(aValue1, aValue2) {\n                        var a;\n                        // Color int and alpha\n                        if (aValue1 & PConstants1.ALPHA_MASK) {\n                            a = Math.round(255 * (aValue2 / colorModeA));\n                            // Limit values less than 0 and greater than 255\n                            a = a > 255 ? 255 : a;\n                            a = a < 0 ? 0 : a;\n                            return aValue1 - (aValue1 & PConstants1.ALPHA_MASK) + (a << 24 & PConstants1.ALPHA_MASK);\n                        }\n                        // Grayscale and alpha\n                        if (curColorMode === PConstants1.RGB) return color$4(aValue1, aValue1, aValue1, aValue2);\n                        if (curColorMode === PConstants1.HSB) return color$4(0, 0, aValue1 / colorModeX * colorModeZ, aValue2);\n                    }\n                    function color$1(aValue1) {\n                        // Grayscale\n                        if (aValue1 <= colorModeX && aValue1 >= 0) {\n                            if (curColorMode === PConstants1.RGB) return color$4(aValue1, aValue1, aValue1, colorModeA);\n                            if (curColorMode === PConstants1.HSB) return color$4(0, 0, aValue1 / colorModeX * colorModeZ, colorModeA);\n                        }\n                        // Color int\n                        if (aValue1) {\n                            if (aValue1 > 2147483647) // Java Overflow\n                            aValue1 -= 4294967296;\n                            return aValue1;\n                        }\n                    }\n                    /**\n    * Creates colors for storing in variables of the color datatype. The parameters are\n    * interpreted as RGB or HSB values depending on the current colorMode(). The default\n    * mode is RGB values from 0 to 255 and therefore, the function call color(255, 204, 0)\n    * will return a bright yellow color. More about how colors are stored can be found in\n    * the reference for the color datatype.\n    *\n    * @param {int|float} aValue1        red or hue or grey values relative to the current color range.\n    * Also can be color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)\n    * @param {int|float} aValue2        green or saturation values relative to the current color range\n    * @param {int|float} aValue3        blue or brightness values relative to the current color range\n    * @param {int|float} aValue4        relative to current color range. Represents alpha\n    *\n    * @returns {color} the color\n    *\n    * @see colorMode\n    */ p.color = function(aValue1, aValue2, aValue3, aValue4) {\n                        // 4 arguments: (R, G, B, A) or (H, S, B, A)\n                        if (aValue1 !== undef && aValue2 !== undef && aValue3 !== undef && aValue4 !== undef) return color$4(aValue1, aValue2, aValue3, aValue4);\n                        // 3 arguments: (R, G, B) or (H, S, B)\n                        if (aValue1 !== undef && aValue2 !== undef && aValue3 !== undef) return color$4(aValue1, aValue2, aValue3, colorModeA);\n                        // 2 arguments: (Color, A) or (Grayscale, A)\n                        if (aValue1 !== undef && aValue2 !== undef) return color$2(aValue1, aValue2);\n                        // 1 argument: (Grayscale) or (Color)\n                        if (typeof aValue1 === \"number\") return color$1(aValue1);\n                        // Default\n                        return color$4(colorModeX, colorModeY, colorModeZ, colorModeA);\n                    };\n                    // Ease of use function to extract the colour bits into a string\n                    p.color.toString = function(colorInt) {\n                        return \"rgba(\" + ((colorInt & PConstants1.RED_MASK) >>> 16) + \",\" + ((colorInt & PConstants1.GREEN_MASK) >>> 8) + \",\" + (colorInt & PConstants1.BLUE_MASK) + \",\" + ((colorInt & PConstants1.ALPHA_MASK) >>> 24) / 255 + \")\";\n                    };\n                    // Easy of use function to pack rgba values into a single bit-shifted color int.\n                    p.color.toInt = function(r, g, b, a) {\n                        return a << 24 & PConstants1.ALPHA_MASK | r << 16 & PConstants1.RED_MASK | g << 8 & PConstants1.GREEN_MASK | b & PConstants1.BLUE_MASK;\n                    };\n                    // Creates a simple array in [R, G, B, A] format, [255, 255, 255, 255]\n                    p.color.toArray = function(colorInt) {\n                        return [\n                            (colorInt & PConstants1.RED_MASK) >>> 16,\n                            (colorInt & PConstants1.GREEN_MASK) >>> 8,\n                            colorInt & PConstants1.BLUE_MASK,\n                            (colorInt & PConstants1.ALPHA_MASK) >>> 24\n                        ];\n                    };\n                    // Creates a WebGL color array in [R, G, B, A] format. WebGL wants the color ranges between 0 and 1, [1, 1, 1, 1]\n                    p.color.toGLArray = function(colorInt) {\n                        return [\n                            ((colorInt & PConstants1.RED_MASK) >>> 16) / 255,\n                            ((colorInt & PConstants1.GREEN_MASK) >>> 8) / 255,\n                            (colorInt & PConstants1.BLUE_MASK) / 255,\n                            ((colorInt & PConstants1.ALPHA_MASK) >>> 24) / 255\n                        ];\n                    };\n                    // HSB conversion function from Mootools, MIT Licensed\n                    p.color.toRGB = function(h, s, b) {\n                        // Limit values greater than range\n                        h = h > colorModeX ? colorModeX : h;\n                        s = s > colorModeY ? colorModeY : s;\n                        b = b > colorModeZ ? colorModeZ : b;\n                        // Limit values smaller than range\n                        h = h < 0 ? 0 : h;\n                        h = h / colorModeX * 360;\n                        s = s / colorModeY * 100;\n                        b = b / colorModeZ * 100;\n                        var br = Math.round(b / 100 * 255);\n                        if (s === 0) return [\n                            br,\n                            br,\n                            br\n                        ];\n                        var hue = h % 360;\n                        var f = hue % 60;\n                        var p = Math.round(b * (100 - s) / 10000 * 255);\n                        var q = Math.round(b * (6000 - s * f) / 600000 * 255);\n                        var t1 = Math.round(b * (6000 - s * (60 - f)) / 600000 * 255);\n                        switch(Math.floor(hue / 60)){\n                            case 0:\n                                return [\n                                    br,\n                                    t1,\n                                    p\n                                ];\n                            case 1:\n                                return [\n                                    q,\n                                    br,\n                                    p\n                                ];\n                            case 2:\n                                return [\n                                    p,\n                                    br,\n                                    t1\n                                ];\n                            case 3:\n                                return [\n                                    p,\n                                    q,\n                                    br\n                                ];\n                            case 4:\n                                return [\n                                    t1,\n                                    p,\n                                    br\n                                ];\n                            case 5:\n                                return [\n                                    br,\n                                    p,\n                                    q\n                                ];\n                            default:\n                                Processing1.debug(\"Unexpectedly hit default case in toRGB function.\");\n                        }\n                    };\n                    function colorToHSB(colorInt) {\n                        var red, green, blue;\n                        red = ((colorInt & PConstants1.RED_MASK) >>> 16) / 255;\n                        green = ((colorInt & PConstants1.GREEN_MASK) >>> 8) / 255;\n                        blue = (colorInt & PConstants1.BLUE_MASK) / 255;\n                        var max = p.max(p.max(red, green), blue), min = p.min(p.min(red, green), blue), hue, saturation;\n                        if (min === max) return [\n                            0,\n                            0,\n                            max * colorModeZ\n                        ];\n                        saturation = (max - min) / max;\n                        if (red === max) hue = (green - blue) / (max - min);\n                        else if (green === max) hue = 2 + (blue - red) / (max - min);\n                        else hue = 4 + (red - green) / (max - min);\n                        hue /= 6;\n                        if (hue < 0) hue += 1;\n                        else if (hue > 1) hue -= 1;\n                        return [\n                            hue * colorModeX,\n                            saturation * colorModeY,\n                            max * colorModeZ\n                        ];\n                    }\n                    /**\n    * Extracts the brightness value from a color.\n    *\n    * @param {color} colInt any value of the color datatype\n    *\n    * @returns {float} The brightness color value.\n    *\n    * @see red\n    * @see green\n    * @see blue\n    * @see hue\n    * @see saturation\n    */ p.brightness = function(colInt) {\n                        return colorToHSB(colInt)[2];\n                    };\n                    /**\n    * Extracts the saturation value from a color.\n    *\n    * @param {color} colInt any value of the color datatype\n    *\n    * @returns {float} The saturation color value.\n    *\n    * @see red\n    * @see green\n    * @see blue\n    * @see hue\n    * @see brightness\n    */ p.saturation = function(colInt) {\n                        return colorToHSB(colInt)[1];\n                    };\n                    /**\n    * Extracts the hue value from a color.\n    *\n    * @param {color} colInt any value of the color datatype\n    *\n    * @returns {float} The hue color value.\n    *\n    * @see red\n    * @see green\n    * @see blue\n    * @see saturation\n    * @see brightness\n    */ p.hue = function(colInt) {\n                        return colorToHSB(colInt)[0];\n                    };\n                    /**\n    * Extracts the red value from a color, scaled to match current colorMode().\n    * This value is always returned as a float so be careful not to assign it to an int value.\n    *\n    * @param {color} aColor any value of the color datatype\n    *\n    * @returns {float} The red color value.\n    *\n    * @see green\n    * @see blue\n    * @see alpha\n    * @see >> right shift\n    * @see hue\n    * @see saturation\n    * @see brightness\n    */ p.red = function(aColor) {\n                        return ((aColor & PConstants1.RED_MASK) >>> 16) / 255 * colorModeX;\n                    };\n                    /**\n    * Extracts the green value from a color, scaled to match current colorMode().\n    * This value is always returned as a float so be careful not to assign it to an int value.\n    *\n    * @param {color} aColor any value of the color datatype\n    *\n    * @returns {float} The green color value.\n    *\n    * @see red\n    * @see blue\n    * @see alpha\n    * @see >> right shift\n    * @see hue\n    * @see saturation\n    * @see brightness\n    */ p.green = function(aColor) {\n                        return ((aColor & PConstants1.GREEN_MASK) >>> 8) / 255 * colorModeY;\n                    };\n                    /**\n    * Extracts the blue value from a color, scaled to match current colorMode().\n    * This value is always returned as a float so be careful not to assign it to an int value.\n    *\n    * @param {color} aColor any value of the color datatype\n    *\n    * @returns {float} The blue color value.\n    *\n    * @see red\n    * @see green\n    * @see alpha\n    * @see >> right shift\n    * @see hue\n    * @see saturation\n    * @see brightness\n    */ p.blue = function(aColor) {\n                        return (aColor & PConstants1.BLUE_MASK) / 255 * colorModeZ;\n                    };\n                    /**\n    * Extracts the alpha value from a color, scaled to match current colorMode().\n    * This value is always returned as a float so be careful not to assign it to an int value.\n    *\n    * @param {color} aColor any value of the color datatype\n    *\n    * @returns {float} The alpha color value.\n    *\n    * @see red\n    * @see green\n    * @see blue\n    * @see >> right shift\n    * @see hue\n    * @see saturation\n    * @see brightness\n    */ p.alpha = function(aColor) {\n                        return ((aColor & PConstants1.ALPHA_MASK) >>> 24) / 255 * colorModeA;\n                    };\n                    /**\n    * Calculates a color or colors between two colors at a specific increment.\n    * The amt parameter is the amount to interpolate between the two values where 0.0\n    * equal to the first point, 0.1 is very near the first point, 0.5 is half-way in between, etc.\n    *\n    * @param {color} c1     interpolate from this color\n    * @param {color} c2     interpolate to this color\n    * @param {float} amt    between 0.0 and 1.0\n    *\n    * @returns {float} The blended color.\n    *\n    * @see blendColor\n    * @see color\n    */ p.lerpColor = function(c1, c2, amt) {\n                        var r, g, b, a, r1, g1, b1, a1, r2, g2, b2, a2;\n                        var hsb1, hsb2, rgb, h, s;\n                        var colorBits1 = p.color(c1);\n                        var colorBits2 = p.color(c2);\n                        if (curColorMode === PConstants1.HSB) {\n                            // Special processing for HSB mode.\n                            // Get HSB and Alpha values for Color 1 and 2\n                            hsb1 = colorToHSB(colorBits1);\n                            a1 = ((colorBits1 & PConstants1.ALPHA_MASK) >>> 24) / colorModeA;\n                            hsb2 = colorToHSB(colorBits2);\n                            a2 = ((colorBits2 & PConstants1.ALPHA_MASK) >>> 24) / colorModeA;\n                            // Return lerp value for each channel, for HSB components\n                            h = p.lerp(hsb1[0], hsb2[0], amt);\n                            s = p.lerp(hsb1[1], hsb2[1], amt);\n                            b = p.lerp(hsb1[2], hsb2[2], amt);\n                            rgb = p.color.toRGB(h, s, b);\n                            // ... and for Alpha-range\n                            a = p.lerp(a1, a2, amt) * colorModeA + 0.5 | 0;\n                            return a << 24 & PConstants1.ALPHA_MASK | rgb[0] << 16 & PConstants1.RED_MASK | rgb[1] << 8 & PConstants1.GREEN_MASK | rgb[2] & PConstants1.BLUE_MASK;\n                        }\n                        // Get RGBA values for Color 1 to floats\n                        r1 = (colorBits1 & PConstants1.RED_MASK) >>> 16;\n                        g1 = (colorBits1 & PConstants1.GREEN_MASK) >>> 8;\n                        b1 = colorBits1 & PConstants1.BLUE_MASK;\n                        a1 = ((colorBits1 & PConstants1.ALPHA_MASK) >>> 24) / colorModeA;\n                        // Get RGBA values for Color 2 to floats\n                        r2 = (colorBits2 & PConstants1.RED_MASK) >>> 16;\n                        g2 = (colorBits2 & PConstants1.GREEN_MASK) >>> 8;\n                        b2 = colorBits2 & PConstants1.BLUE_MASK;\n                        a2 = ((colorBits2 & PConstants1.ALPHA_MASK) >>> 24) / colorModeA;\n                        // Return lerp value for each channel, INT for color, Float for Alpha-range\n                        r = p.lerp(r1, r2, amt) + 0.5 | 0;\n                        g = p.lerp(g1, g2, amt) + 0.5 | 0;\n                        b = p.lerp(b1, b2, amt) + 0.5 | 0;\n                        a = p.lerp(a1, a2, amt) * colorModeA + 0.5 | 0;\n                        return a << 24 & PConstants1.ALPHA_MASK | r << 16 & PConstants1.RED_MASK | g << 8 & PConstants1.GREEN_MASK | b & PConstants1.BLUE_MASK;\n                    };\n                    /**\n    * Changes the way Processing interprets color data. By default, fill(), stroke(), and background()\n    * colors are set by values between 0 and 255 using the RGB color model. It is possible to change the\n    * numerical range used for specifying colors and to switch color systems. For example, calling colorMode(RGB, 1.0)\n    * will specify that values are specified between 0 and 1. The limits for defining colors are altered by setting the\n    * parameters range1, range2, range3, and range 4.\n    *\n    * @param {MODE} mode Either RGB or HSB, corresponding to Red/Green/Blue and Hue/Saturation/Brightness\n    * @param {int|float} range              range for all color elements\n    * @param {int|float} range1             range for the red or hue depending on the current color mode\n    * @param {int|float} range2             range for the green or saturation depending on the current color mode\n    * @param {int|float} range3             range for the blue or brightness depending on the current color mode\n    * @param {int|float} range4             range for the alpha\n    *\n    * @returns none\n    *\n    * @see background\n    * @see fill\n    * @see stroke\n    */ p.colorMode = function() {\n                        curColorMode = arguments[0];\n                        if (arguments.length > 1) {\n                            colorModeX = arguments[1];\n                            colorModeY = arguments[2] || arguments[1];\n                            colorModeZ = arguments[3] || arguments[1];\n                            colorModeA = arguments[4] || arguments[1];\n                        }\n                    };\n                    /**\n    * Blends two color values together based on the blending mode given as the MODE parameter.\n    * The possible modes are described in the reference for the blend() function.\n    *\n    * @param {color} c1 color: the first color to blend\n    * @param {color} c2 color: the second color to blend\n    * @param {MODE} MODE Either BLEND, ADD, SUBTRACT, DARKEST, LIGHTEST, DIFFERENCE, EXCLUSION, MULTIPLY,\n    * SCREEN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, or BURN\n    *\n    * @returns {float} The blended color.\n    *\n    * @see blend\n    * @see color\n    */ p.blendColor = function(c1, c2, mode) {\n                        if (mode === PConstants1.REPLACE) return p.modes.replace(c1, c2);\n                        else if (mode === PConstants1.BLEND) return p.modes.blend(c1, c2);\n                        else if (mode === PConstants1.ADD) return p.modes.add(c1, c2);\n                        else if (mode === PConstants1.SUBTRACT) return p.modes.subtract(c1, c2);\n                        else if (mode === PConstants1.LIGHTEST) return p.modes.lightest(c1, c2);\n                        else if (mode === PConstants1.DARKEST) return p.modes.darkest(c1, c2);\n                        else if (mode === PConstants1.DIFFERENCE) return p.modes.difference(c1, c2);\n                        else if (mode === PConstants1.EXCLUSION) return p.modes.exclusion(c1, c2);\n                        else if (mode === PConstants1.MULTIPLY) return p.modes.multiply(c1, c2);\n                        else if (mode === PConstants1.SCREEN) return p.modes.screen(c1, c2);\n                        else if (mode === PConstants1.HARD_LIGHT) return p.modes.hard_light(c1, c2);\n                        else if (mode === PConstants1.SOFT_LIGHT) return p.modes.soft_light(c1, c2);\n                        else if (mode === PConstants1.OVERLAY) return p.modes.overlay(c1, c2);\n                        else if (mode === PConstants1.DODGE) return p.modes.dodge(c1, c2);\n                        else if (mode === PConstants1.BURN) return p.modes.burn(c1, c2);\n                    };\n                    ////////////////////////////////////////////////////////////////////////////\n                    // Canvas-Matrix manipulation\n                    ////////////////////////////////////////////////////////////////////////////\n                    function saveContext() {\n                        curContext.save();\n                    }\n                    function restoreContext() {\n                        curContext.restore();\n                        isStrokeDirty = true;\n                        isFillDirty = true;\n                    }\n                    /**\n    * Prints the current matrix to the text window.\n    *\n    * @returns none\n    *\n    * @see pushMatrix\n    * @see popMatrix\n    * @see resetMatrix\n    * @see applyMatrix\n    */ p.printMatrix = function() {\n                        modelView.print();\n                    };\n                    /**\n    * Specifies an amount to displace objects within the display window. The x parameter specifies left/right translation,\n    * the y parameter specifies up/down translation, and the z parameter specifies translations toward/away from the screen.\n    * Using this function with the z  parameter requires using the P3D or OPENGL parameter in combination with size as shown\n    * in the above example. Transformations apply to everything that happens after and subsequent calls to the function\n    * accumulates the effect. For example, calling translate(50, 0) and then translate(20, 0) is the same as translate(70, 0).\n    * If translate() is called within draw(), the transformation is reset when the loop begins again.\n    * This function can be further controlled by the pushMatrix() and popMatrix().\n    *\n    * @param {int|float} x        left/right translation\n    * @param {int|float} y        up/down translation\n    * @param {int|float} z        forward/back translation\n    *\n    * @returns none\n    *\n    * @see pushMatrix\n    * @see popMatrix\n    * @see scale\n    * @see rotate\n    * @see rotateX\n    * @see rotateY\n    * @see rotateZ\n    */ Drawing2D.prototype.translate = function(x, y) {\n                        modelView.translate(x, y);\n                        modelViewInv.invTranslate(x, y);\n                        curContext.translate(x, y);\n                    };\n                    Drawing3D.prototype.translate = function(x, y, z) {\n                        modelView.translate(x, y, z);\n                        modelViewInv.invTranslate(x, y, z);\n                    };\n                    /**\n    * Increases or decreases the size of a shape by expanding and contracting vertices. Objects always scale from their\n    * relative origin to the coordinate system. Scale values are specified as decimal percentages. For example, the\n    * function call scale(2.0) increases the dimension of a shape by 200%. Transformations apply to everything that\n    * happens after and subsequent calls to the function multiply the effect. For example, calling scale(2.0) and\n    * then scale(1.5) is the same as scale(3.0). If scale() is called within draw(), the transformation is reset when\n    * the loop begins again. Using this fuction with the z  parameter requires passing P3D or OPENGL into the size()\n    * parameter as shown in the example above. This function can be further controlled by pushMatrix() and popMatrix().\n    *\n    * @param {int|float} size     percentage to scale the object\n    * @param {int|float} x        percentage to scale the object in the x-axis\n    * @param {int|float} y        percentage to scale the object in the y-axis\n    * @param {int|float} z        percentage to scale the object in the z-axis\n    *\n    * @returns none\n    *\n    * @see pushMatrix\n    * @see popMatrix\n    * @see translate\n    * @see rotate\n    * @see rotateX\n    * @see rotateY\n    * @see rotateZ\n    */ Drawing2D.prototype.scale = function(x, y) {\n                        modelView.scale(x, y);\n                        modelViewInv.invScale(x, y);\n                        curContext.scale(x, y || x);\n                    };\n                    Drawing3D.prototype.scale = function(x, y, z) {\n                        modelView.scale(x, y, z);\n                        modelViewInv.invScale(x, y, z);\n                    };\n                    /**\n     * helper function for applying a transfrom matrix to a 2D context.\n     */ Drawing2D.prototype.transform = function(pmatrix) {\n                        var e = pmatrix.array();\n                        curContext.transform(e[0], e[3], e[1], e[4], e[2], e[5]);\n                    };\n                    /**\n     * helper function for applying a transfrom matrix to a 3D context.\n     * not currently implemented.\n     */ Drawing3D.prototype.transformm = function(pmatrix3d) {\n                        throw \"p.transform is currently not supported in 3D mode\";\n                    };\n                    /**\n    * Pushes the current transformation matrix onto the matrix stack. Understanding pushMatrix() and popMatrix()\n    * requires understanding the concept of a matrix stack. The pushMatrix() function saves the current coordinate\n    * system to the stack and popMatrix() restores the prior coordinate system. pushMatrix() and popMatrix() are\n    * used in conjuction with the other transformation methods and may be embedded to control the scope of\n    * the transformations.\n    *\n    * @returns none\n    *\n    * @see popMatrix\n    * @see translate\n    * @see rotate\n    * @see rotateX\n    * @see rotateY\n    * @see rotateZ\n    */ Drawing2D.prototype.pushMatrix = function() {\n                        userMatrixStack.load(modelView);\n                        userReverseMatrixStack.load(modelViewInv);\n                        saveContext();\n                    };\n                    Drawing3D.prototype.pushMatrix = function() {\n                        userMatrixStack.load(modelView);\n                        userReverseMatrixStack.load(modelViewInv);\n                    };\n                    /**\n    * Pops the current transformation matrix off the matrix stack. Understanding pushing and popping requires\n    * understanding the concept of a matrix stack. The pushMatrix() function saves the current coordinate system to\n    * the stack and popMatrix() restores the prior coordinate system. pushMatrix() and popMatrix() are used in\n    * conjuction with the other transformation methods and may be embedded to control the scope of the transformations.\n    *\n    * @returns none\n    *\n    * @see popMatrix\n    * @see pushMatrix\n    */ Drawing2D.prototype.popMatrix = function() {\n                        modelView.set(userMatrixStack.pop());\n                        modelViewInv.set(userReverseMatrixStack.pop());\n                        restoreContext();\n                    };\n                    Drawing3D.prototype.popMatrix = function() {\n                        modelView.set(userMatrixStack.pop());\n                        modelViewInv.set(userReverseMatrixStack.pop());\n                    };\n                    /**\n    * Replaces the current matrix with the identity matrix. The equivalent function in OpenGL is glLoadIdentity().\n    *\n    * @returns none\n    *\n    * @see popMatrix\n    * @see pushMatrix\n    * @see applyMatrix\n    * @see printMatrix\n    */ Drawing2D.prototype.resetMatrix = function() {\n                        modelView.reset();\n                        modelViewInv.reset();\n                        curContext.setTransform(1, 0, 0, 1, 0, 0);\n                    };\n                    Drawing3D.prototype.resetMatrix = function() {\n                        modelView.reset();\n                        modelViewInv.reset();\n                    };\n                    /**\n    * Multiplies the current matrix by the one specified through the parameters. This is very slow because it will\n    * try to calculate the inverse of the transform, so avoid it whenever possible. The equivalent function\n    * in OpenGL is glMultMatrix().\n    *\n    * @param {int|float} n00-n15      numbers which define the 4x4 matrix to be multiplied\n    *\n    * @returns none\n    *\n    * @see popMatrix\n    * @see pushMatrix\n    * @see resetMatrix\n    * @see printMatrix\n    */ DrawingShared.prototype.applyMatrix = function() {\n                        var a = arguments;\n                        modelView.apply(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n                        modelViewInv.invApply(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n                    };\n                    Drawing2D.prototype.applyMatrix = function() {\n                        var a = arguments;\n                        for(var cnt = a.length; cnt < 16; cnt++)a[cnt] = 0;\n                        a[10] = a[15] = 1;\n                        DrawingShared.prototype.applyMatrix.apply(this, a);\n                    };\n                    /**\n    * Rotates a shape around the x-axis the amount specified by the angle parameter. Angles should be\n    * specified in radians (values from 0 to PI*2) or converted to radians with the radians()  function.\n    * Objects are always rotated around their relative position to the origin and positive numbers\n    * rotate objects in a counterclockwise direction. Transformations apply to everything that happens\n    * after and subsequent calls to the function accumulates the effect. For example, calling rotateX(PI/2)\n    * and then rotateX(PI/2) is the same as rotateX(PI). If rotateX() is called within the draw(), the\n    * transformation is reset when the loop begins again. This function requires passing P3D or OPENGL\n    * into the size() parameter as shown in the example above.\n    *\n    * @param {int|float} angleInRadians     angle of rotation specified in radians\n    *\n    * @returns none\n    *\n    * @see rotateY\n    * @see rotateZ\n    * @see rotate\n    * @see translate\n    * @see scale\n    * @see popMatrix\n    * @see pushMatrix\n    */ p.rotateX = function(angleInRadians) {\n                        modelView.rotateX(angleInRadians);\n                        modelViewInv.invRotateX(angleInRadians);\n                    };\n                    /**\n    * Rotates a shape around the z-axis the amount specified by the angle parameter. Angles should be\n    * specified in radians (values from 0 to PI*2) or converted to radians with the radians()  function.\n    * Objects are always rotated around their relative position to the origin and positive numbers\n    * rotate objects in a counterclockwise direction. Transformations apply to everything that happens\n    * after and subsequent calls to the function accumulates the effect. For example, calling rotateZ(PI/2)\n    * and then rotateZ(PI/2) is the same as rotateZ(PI). If rotateZ() is called within the draw(), the\n    * transformation is reset when the loop begins again. This function requires passing P3D or OPENGL\n    * into the size() parameter as shown in the example above.\n    *\n    * @param {int|float} angleInRadians     angle of rotation specified in radians\n    *\n    * @returns none\n    *\n    * @see rotateX\n    * @see rotateY\n    * @see rotate\n    * @see translate\n    * @see scale\n    * @see popMatrix\n    * @see pushMatrix\n    */ Drawing2D.prototype.rotateZ = function() {\n                        throw \"rotateZ() is not supported in 2D mode. Use rotate(float) instead.\";\n                    };\n                    Drawing3D.prototype.rotateZ = function(angleInRadians) {\n                        modelView.rotateZ(angleInRadians);\n                        modelViewInv.invRotateZ(angleInRadians);\n                    };\n                    /**\n    * Rotates a shape around the y-axis the amount specified by the angle parameter. Angles should be\n    * specified in radians (values from 0 to PI*2) or converted to radians with the radians()  function.\n    * Objects are always rotated around their relative position to the origin and positive numbers\n    * rotate objects in a counterclockwise direction. Transformations apply to everything that happens\n    * after and subsequent calls to the function accumulates the effect. For example, calling rotateY(PI/2)\n    * and then rotateY(PI/2) is the same as rotateY(PI). If rotateY() is called within the draw(), the\n    * transformation is reset when the loop begins again. This function requires passing P3D or OPENGL\n    * into the size() parameter as shown in the example above.\n    *\n    * @param {int|float} angleInRadians     angle of rotation specified in radians\n    *\n    * @returns none\n    *\n    * @see rotateX\n    * @see rotateZ\n    * @see rotate\n    * @see translate\n    * @see scale\n    * @see popMatrix\n    * @see pushMatrix\n    */ p.rotateY = function(angleInRadians) {\n                        modelView.rotateY(angleInRadians);\n                        modelViewInv.invRotateY(angleInRadians);\n                    };\n                    /**\n    * Rotates a shape the amount specified by the angle parameter. Angles should be specified in radians\n    * (values from 0 to TWO_PI) or converted to radians with the radians() function. Objects are always\n    * rotated around their relative position to the origin and positive numbers rotate objects in a\n    * clockwise direction. Transformations apply to everything that happens after and subsequent calls\n    * to the function accumulates the effect. For example, calling rotate(HALF_PI) and then rotate(HALF_PI)\n    * is the same as rotate(PI). All tranformations are reset when draw() begins again. Technically,\n    * rotate() multiplies the current transformation matrix by a rotation matrix. This function can be\n    * further controlled by the pushMatrix() and popMatrix().\n    *\n    * @param {int|float} angleInRadians     angle of rotation specified in radians\n    *\n    * @returns none\n    *\n    * @see rotateX\n    * @see rotateY\n    * @see rotateZ\n    * @see rotate\n    * @see translate\n    * @see scale\n    * @see popMatrix\n    * @see pushMatrix\n    */ Drawing2D.prototype.rotate = function(angleInRadians) {\n                        modelView.rotateZ(angleInRadians);\n                        modelViewInv.invRotateZ(angleInRadians);\n                        curContext.rotate(angleInRadians);\n                    };\n                    Drawing3D.prototype.rotate = function(angleInRadians) {\n                        if (arguments.length < 4) p.rotateZ(angleInRadians);\n                        else {\n                            modelView.rotate(angleInRadians, arguments[1], arguments[2], arguments[3]);\n                            modelViewInv.rotate(-angleInRadians, arguments[1], arguments[2], arguments[3]);\n                        }\n                    };\n                    /**\n    * Shears a shape around the x-axis the amount specified by the angle parameter.\n    * Angles should be specified in radians (values from 0 to PI*2) or converted to radians\n    * with the radians() function. Objects are always sheared around their relative position\n    * to the origin and positive numbers shear objects in a clockwise direction. Transformations\n    * apply to everything that happens after and subsequent calls to the function accumulates the\n    * effect. For example, calling shearX(PI/2) and then shearX(PI/2) is the same as shearX(PI)\n    *\n    * @param {int|float} angleInRadians     angle of rotation specified in radians\n    *\n    * @returns none\n    *\n    * @see rotateX\n    * @see rotateY\n    * @see rotateZ\n    * @see rotate\n    * @see translate\n    * @see scale\n    * @see popMatrix\n    * @see pushMatrix\n    */ Drawing2D.prototype.shearX = function(angleInRadians) {\n                        modelView.shearX(angleInRadians);\n                        curContext.transform(1, 0, angleInRadians, 1, 0, 0);\n                    };\n                    Drawing3D.prototype.shearX = function(angleInRadians) {\n                        modelView.shearX(angleInRadians);\n                    };\n                    /**\n    * Shears a shape around the y-axis the amount specified by the angle parameter.\n    * Angles should be specified in radians (values from 0 to PI*2) or converted to\n    * radians with the radians() function. Objects are always sheared around their\n    * relative position to the origin and positive numbers shear objects in a\n    * clockwise direction. Transformations apply to everything that happens after\n    * and subsequent calls to the function accumulates the effect. For example,\n    * calling shearY(PI/2) and then shearY(PI/2) is the same as shearY(PI).\n    *\n    * @param {int|float} angleInRadians     angle of rotation specified in radians\n    *\n    * @returns none\n    *\n    * @see rotateX\n    * @see rotateY\n    * @see rotateZ\n    * @see rotate\n    * @see translate\n    * @see scale\n    * @see popMatrix\n    * @see pushMatrix\n    * @see shearX\n    */ Drawing2D.prototype.shearY = function(angleInRadians) {\n                        modelView.shearY(angleInRadians);\n                        curContext.transform(1, angleInRadians, 0, 1, 0, 0);\n                    };\n                    Drawing3D.prototype.shearY = function(angleInRadians) {\n                        modelView.shearY(angleInRadians);\n                    };\n                    /**\n    * The pushStyle() function saves the current style settings and popStyle()  restores the prior settings.\n    * Note that these functions are always used together. They allow you to change the style settings and later\n    * return to what you had. When a new style is started with pushStyle(), it builds on the current style information.\n    * The pushStyle() and popStyle() functions can be embedded to provide more control (see the second example\n    * above for a demonstration.)\n    * The style information controlled by the following functions are included in the style: fill(), stroke(), tint(),\n    * strokeWeight(), strokeCap(), strokeJoin(), imageMode(), rectMode(), ellipseMode(), shapeMode(), colorMode(),\n    * textAlign(), textFont(), textMode(), textSize(), textLeading(), emissive(), specular(), shininess(), ambient()\n    *\n    * @returns none\n    *\n    * @see popStyle\n    */ p.pushStyle = function() {\n                        // Save the canvas state.\n                        saveContext();\n                        p.pushMatrix();\n                        var newState = {\n                            \"doFill\": doFill,\n                            \"currentFillColor\": currentFillColor,\n                            \"doStroke\": doStroke,\n                            \"currentStrokeColor\": currentStrokeColor,\n                            \"curTint\": curTint,\n                            \"curRectMode\": curRectMode,\n                            \"curColorMode\": curColorMode,\n                            \"colorModeX\": colorModeX,\n                            \"colorModeZ\": colorModeZ,\n                            \"colorModeY\": colorModeY,\n                            \"colorModeA\": colorModeA,\n                            \"curTextFont\": curTextFont,\n                            \"horizontalTextAlignment\": horizontalTextAlignment,\n                            \"verticalTextAlignment\": verticalTextAlignment,\n                            \"textMode\": textMode,\n                            \"curFontName\": curFontName,\n                            \"curTextSize\": curTextSize,\n                            \"curTextAscent\": curTextAscent,\n                            \"curTextDescent\": curTextDescent,\n                            \"curTextLeading\": curTextLeading\n                        };\n                        styleArray.push(newState);\n                    };\n                    /**\n    * The pushStyle() function saves the current style settings and popStyle()  restores the prior settings; these\n    * functions are always used together. They allow you to change the style settings and later return to what you had.\n    * When a new style is started with pushStyle(), it builds on the current style information. The pushStyle() and\n    * popStyle() functions can be embedded to provide more control (see the second example above for a demonstration.)\n    *\n    * @returns none\n    *\n    * @see pushStyle\n    */ p.popStyle = function() {\n                        var oldState = styleArray.pop();\n                        if (oldState) {\n                            restoreContext();\n                            p.popMatrix();\n                            doFill = oldState.doFill;\n                            currentFillColor = oldState.currentFillColor;\n                            doStroke = oldState.doStroke;\n                            currentStrokeColor = oldState.currentStrokeColor;\n                            curTint = oldState.curTint;\n                            curRectMode = oldState.curRectMode;\n                            curColorMode = oldState.curColorMode;\n                            colorModeX = oldState.colorModeX;\n                            colorModeZ = oldState.colorModeZ;\n                            colorModeY = oldState.colorModeY;\n                            colorModeA = oldState.colorModeA;\n                            curTextFont = oldState.curTextFont;\n                            curFontName = oldState.curFontName;\n                            curTextSize = oldState.curTextSize;\n                            horizontalTextAlignment = oldState.horizontalTextAlignment;\n                            verticalTextAlignment = oldState.verticalTextAlignment;\n                            textMode = oldState.textMode;\n                            curTextAscent = oldState.curTextAscent;\n                            curTextDescent = oldState.curTextDescent;\n                            curTextLeading = oldState.curTextLeading;\n                        } else throw \"Too many popStyle() without enough pushStyle()\";\n                    };\n                    ////////////////////////////////////////////////////////////////////////////\n                    // Time based functions\n                    ////////////////////////////////////////////////////////////////////////////\n                    /**\n    * Processing communicates with the clock on your computer.\n    * The year() function returns the current year as an integer (2003, 2004, 2005, etc).\n    *\n    * @returns {float} The current year.\n    *\n    * @see millis\n    * @see second\n    * @see minute\n    * @see hour\n    * @see day\n    * @see month\n    */ p.year = function() {\n                        return new Date().getFullYear();\n                    };\n                    /**\n    * Processing communicates with the clock on your computer.\n    * The month() function returns the current month as a value from 1 - 12.\n    *\n    * @returns {float} The current month.\n    *\n    * @see millis\n    * @see second\n    * @see minute\n    * @see hour\n    * @see day\n    * @see year\n    */ p.month = function() {\n                        return new Date().getMonth() + 1;\n                    };\n                    /**\n    * Processing communicates with the clock on your computer.\n    * The day() function returns the current day as a value from 1 - 31.\n    *\n    * @returns {float} The current day.\n    *\n    * @see millis\n    * @see second\n    * @see minute\n    * @see hour\n    * @see month\n    * @see year\n    */ p.day = function() {\n                        return new Date().getDate();\n                    };\n                    /**\n    * Processing communicates with the clock on your computer.\n    * The hour() function returns the current hour as a value from 0 - 23.\n    *\n    * @returns {float} The current hour.\n    *\n    * @see millis\n    * @see second\n    * @see minute\n    * @see month\n    * @see day\n    * @see year\n    */ p.hour = function() {\n                        return new Date().getHours();\n                    };\n                    /**\n    * Processing communicates with the clock on your computer.\n    * The minute() function returns the current minute as a value from 0 - 59.\n    *\n    * @returns {float} The current minute.\n    *\n    * @see millis\n    * @see second\n    * @see month\n    * @see hour\n    * @see day\n    * @see year\n    */ p.minute = function() {\n                        return new Date().getMinutes();\n                    };\n                    /**\n    * Processing communicates with the clock on your computer.\n    * The second() function returns the current second as a value from 0 - 59.\n    *\n    * @returns {float} The current minute.\n    *\n    * @see millis\n    * @see month\n    * @see minute\n    * @see hour\n    * @see day\n    * @see year\n    */ p.second = function() {\n                        return new Date().getSeconds();\n                    };\n                    /**\n    * Returns the number of milliseconds (thousandths of a second) since starting a sketch.\n    * This information is often used for timing animation sequences.\n    *\n    * @returns {long} The number of milliseconds since starting the sketch.\n    *\n    * @see month\n    * @see second\n    * @see minute\n    * @see hour\n    * @see day\n    * @see year\n    */ p.millis = function() {\n                        return Date.now() - start;\n                    };\n                    /**\n    * Executes the code within draw() one time. This functions allows the program to update\n    * the display window only when necessary, for example when an event registered by\n    * mousePressed() or keyPressed() occurs.\n    * In structuring a program, it only makes sense to call redraw() within events such as\n    * mousePressed(). This is because redraw() does not run draw() immediately (it only sets\n    * a flag that indicates an update is needed).\n    * Calling redraw() within draw() has no effect because draw() is continuously called anyway.\n    *\n    * @returns none\n    *\n    * @see noLoop\n    * @see loop\n    */ function redrawHelper() {\n                        var sec = (Date.now() - timeSinceLastFPS) / 1000;\n                        framesSinceLastFPS++;\n                        var fps = framesSinceLastFPS / sec;\n                        // recalculate FPS every half second for better accuracy.\n                        if (sec > 0.5) {\n                            timeSinceLastFPS = Date.now();\n                            framesSinceLastFPS = 0;\n                            p.__frameRate = fps;\n                        }\n                        p.frameCount++;\n                    }\n                    Drawing2D.prototype.redraw = function() {\n                        redrawHelper();\n                        curContext.lineWidth = lineWidth;\n                        var pmouseXLastEvent = p.pmouseX, pmouseYLastEvent = p.pmouseY;\n                        p.pmouseX = pmouseXLastFrame;\n                        p.pmouseY = pmouseYLastFrame;\n                        saveContext();\n                        p.draw();\n                        restoreContext();\n                        pmouseXLastFrame = p.mouseX;\n                        pmouseYLastFrame = p.mouseY;\n                        p.pmouseX = pmouseXLastEvent;\n                        p.pmouseY = pmouseYLastEvent;\n                    };\n                    Drawing3D.prototype.redraw = function() {\n                        redrawHelper();\n                        var pmouseXLastEvent = p.pmouseX, pmouseYLastEvent = p.pmouseY;\n                        p.pmouseX = pmouseXLastFrame;\n                        p.pmouseY = pmouseYLastFrame;\n                        // even if the color buffer isn't cleared with background(),\n                        // the depth buffer needs to be cleared regardless.\n                        curContext.clear(curContext.DEPTH_BUFFER_BIT);\n                        curContextCache = {\n                            attributes: {},\n                            locations: {}\n                        };\n                        // Delete all the lighting states and the materials the\n                        // user set in the last draw() call.\n                        p.noLights();\n                        p.lightFalloff(1, 0, 0);\n                        p.shininess(1);\n                        p.ambient(255, 255, 255);\n                        p.specular(0, 0, 0);\n                        p.emissive(0, 0, 0);\n                        p.camera();\n                        p.draw();\n                        pmouseXLastFrame = p.mouseX;\n                        pmouseYLastFrame = p.mouseY;\n                        p.pmouseX = pmouseXLastEvent;\n                        p.pmouseY = pmouseYLastEvent;\n                    };\n                    /**\n    * Stops Processing from continuously executing the code within draw(). If loop() is\n    * called, the code in draw() begin to run continuously again. If using noLoop() in\n    * setup(), it should be the last line inside the block.\n    * When noLoop() is used, it's not possible to manipulate or access the screen inside event\n    * handling functions such as mousePressed() or keyPressed(). Instead, use those functions\n    * to call redraw() or loop(), which will run draw(), which can update the screen properly.\n    * This means that when noLoop() has been called, no drawing can happen, and functions like\n    * saveFrame() or loadPixels() may not be used.\n    * Note that if the sketch is resized, redraw() will be called to update the sketch, even\n    * after noLoop() has been specified. Otherwise, the sketch would enter an odd state until\n    * loop() was called.\n    *\n    * @returns none\n    *\n    * @see redraw\n    * @see draw\n    * @see loop\n    */ p.noLoop = function() {\n                        doLoop = false;\n                        loopStarted = false;\n                        clearInterval(looping);\n                        curSketch.onPause();\n                    };\n                    /**\n    * Causes Processing to continuously execute the code within draw(). If noLoop() is called,\n    * the code in draw() stops executing.\n    *\n    * @returns none\n    *\n    * @see noLoop\n    */ p.loop = function() {\n                        if (loopStarted) return;\n                        timeSinceLastFPS = Date.now();\n                        framesSinceLastFPS = 0;\n                        looping = window1.setInterval(function() {\n                            try {\n                                curSketch.onFrameStart();\n                                p.redraw();\n                                curSketch.onFrameEnd();\n                            } catch (e_loop) {\n                                window1.clearInterval(looping);\n                                throw e_loop;\n                            }\n                        }, curMsPerFrame);\n                        doLoop = true;\n                        loopStarted = true;\n                        curSketch.onLoop();\n                    };\n                    /**\n    * Specifies the number of frames to be displayed every second. If the processor is not\n    * fast enough to maintain the specified rate, it will not be achieved. For example, the\n    * function call frameRate(30) will attempt to refresh 30 times a second. It is recommended\n    * to set the frame rate within setup(). The default rate is 60 frames per second.\n    *\n    * @param {int} aRate        number of frames per second.\n    *\n    * @returns none\n    *\n    * @see delay\n    */ p.frameRate = function(aRate) {\n                        curFrameRate = aRate;\n                        curMsPerFrame = 1000 / curFrameRate;\n                        // clear and reset interval\n                        if (doLoop) {\n                            p.noLoop();\n                            p.loop();\n                        }\n                    };\n                    /**\n    * Quits/stops/exits the program.\n    * Rather than terminating immediately, exit() will cause the sketch to exit after draw()\n    * has completed (or after setup() completes if called during the setup() method).\n    *\n    * @returns none\n    */ p.exit = function() {\n                        // cleanup\n                        window1.clearInterval(looping);\n                        removeInstance(p.externals.canvas.id);\n                        delete curElement.onmousedown;\n                        // Step through the libraries to detach them\n                        for(var lib in Processing1.lib){\n                            if (Processing1.lib.hasOwnProperty(lib)) {\n                                if (Processing1.lib[lib].hasOwnProperty(\"detach\")) Processing1.lib[lib].detach(p);\n                            }\n                        }\n                        // clean up all event handling\n                        var i = eventHandlers.length;\n                        while(i--)detachEventHandler1(eventHandlers[i]);\n                        curSketch.onExit();\n                    };\n                    ////////////////////////////////////////////////////////////////////////////\n                    // MISC functions\n                    ////////////////////////////////////////////////////////////////////////////\n                    /**\n    * Sets the cursor to a predefined symbol, an image, or turns it on if already hidden.\n    * If you are trying to set an image as the cursor, it is recommended to make the size\n    * 16x16 or 32x32 pixels. It is not possible to load an image as the cursor if you are\n    * exporting your program for the Web. The values for parameters x and y must be less\n    * than the dimensions of the image.\n    *\n    * @param {MODE} MODE either ARROW, CROSS, HAND, MOVE, TEXT, WAIT\n    * @param {PImage} image       any variable of type PImage\n    * @param {int}    x           the horizonal active spot of the cursor\n    * @param {int}    y           the vertical active spot of the cursor\n    *\n    * @returns none\n    *\n    * @see noCursor\n    */ p.cursor = function() {\n                        if (arguments.length > 1 || arguments.length === 1 && arguments[0] instanceof p.PImage) {\n                            var image = arguments[0], x, y;\n                            if (arguments.length >= 3) {\n                                x = arguments[1];\n                                y = arguments[2];\n                                if (x < 0 || y < 0 || y >= image.height || x >= image.width) throw \"x and y must be non-negative and less than the dimensions of the image\";\n                            } else {\n                                x = image.width >>> 1;\n                                y = image.height >>> 1;\n                            }\n                            // see https://developer.mozilla.org/en/Using_URL_values_for_the_cursor_property\n                            var imageDataURL = image.toDataURL();\n                            var style = 'url(\"' + imageDataURL + '\") ' + x + \" \" + y + \", default\";\n                            curCursor = curElement.style.cursor = style;\n                        } else if (arguments.length === 1) {\n                            var mode = arguments[0];\n                            curCursor = curElement.style.cursor = mode;\n                        } else curCursor = curElement.style.cursor = oldCursor;\n                    };\n                    /**\n    * Hides the cursor from view.\n    *\n    * @returns none\n    *\n    * @see cursor\n    */ p.noCursor = function() {\n                        curCursor = curElement.style.cursor = PConstants1.NOCURSOR;\n                    };\n                    /**\n    * Links to a webpage either in the same window or in a new window. The complete URL\n    * must be specified.\n    *\n    * @param {String} href      complete url as a String in quotes\n    * @param {String} target    name of the window to load the URL as a string in quotes\n    *\n    * @returns none\n    */ p.link = function(href, target) {\n                        if (target !== undef) window1.open(href, target);\n                        else window1.location = href;\n                    };\n                    // PGraphics methods\n                    // These functions exist only for compatibility with P5\n                    p.beginDraw = noop;\n                    p.endDraw = noop;\n                    /**\n     * This function takes content from a canvas and turns it into an ImageData object to be used with a PImage\n     *\n     * @returns {ImageData}        ImageData object to attach to a PImage (1D array of pixel data)\n     *\n     * @see PImage\n     */ Drawing2D.prototype.toImageData = function(x, y, w, h) {\n                        x = x !== undef ? x : 0;\n                        y = y !== undef ? y : 0;\n                        w = w !== undef ? w : p.width;\n                        h = h !== undef ? h : p.height;\n                        return curContext.getImageData(x, y, w, h);\n                    };\n                    Drawing3D.prototype.toImageData = function(x, y, w, h) {\n                        x = x !== undef ? x : 0;\n                        y = y !== undef ? y : 0;\n                        w = w !== undef ? w : p.width;\n                        h = h !== undef ? h : p.height;\n                        var c = document1.createElement(\"canvas\"), ctx = c.getContext(\"2d\"), obj = ctx.createImageData(w, h), uBuff = new Uint8Array1(w * h * 4);\n                        curContext.readPixels(x, y, w, h, curContext.RGBA, curContext.UNSIGNED_BYTE, uBuff);\n                        for(var i = 0, ul = uBuff.length, obj_data = obj.data; i < ul; i++)obj_data[i] = uBuff[(h - 1 - Math.floor(i / 4 / w)) * w * 4 + i % (w * 4)];\n                        return obj;\n                    };\n                    /**\n    * Displays message in the browser's status area. This is the text area in the lower\n    * left corner of the browser. The status() function will only work when the\n    * Processing program is running in a web browser.\n    *\n    * @param {String} text      any valid String\n    *\n    * @returns none\n    */ p.status = function(text) {\n                        window1.status = text;\n                    };\n                    ////////////////////////////////////////////////////////////////////////////\n                    // Binary Functions\n                    ////////////////////////////////////////////////////////////////////////////\n                    /**\n    * Converts a byte, char, int, or color to a String containing the equivalent binary\n    * notation. For example color(0, 102, 153, 255) will convert to the String\n    * \"11111111000000000110011010011001\". This function can help make your geeky debugging\n    * sessions much happier.\n    *\n    * @param {byte|char|int|color} num          byte, char, int, color: value to convert\n    * @param {int} numBits                      number of digits to return\n    *\n    * @returns {String}\n    *\n    * @see unhex\n    * @see hex\n    * @see unbinary\n    */ p.binary = function(num, numBits) {\n                        var bit;\n                        if (numBits > 0) bit = numBits;\n                        else if (num instanceof Char) {\n                            bit = 16;\n                            num |= 0; // making it int\n                        } else {\n                            // autodetect, skipping zeros\n                            bit = 32;\n                            while(bit > 1 && !(num >>> bit - 1 & 1))bit--;\n                        }\n                        var result = \"\";\n                        while(bit > 0)result += num >>> --bit & 1 ? \"1\" : \"0\";\n                        return result;\n                    };\n                    /**\n    * Converts a String representation of a binary number to its equivalent integer value.\n    * For example, unbinary(\"00001000\") will return 8.\n    *\n    * @param {String} binaryString String\n    *\n    * @returns {Int}\n    *\n    * @see hex\n    * @see binary\n    * @see unbinary\n    */ p.unbinary = function(binaryString) {\n                        var i = binaryString.length - 1, mask = 1, result = 0;\n                        while(i >= 0){\n                            var ch = binaryString[i--];\n                            if (ch !== \"0\" && ch !== \"1\") throw \"the value passed into unbinary was not an 8 bit binary number\";\n                            if (ch === \"1\") result += mask;\n                            mask <<= 1;\n                        }\n                        return result;\n                    };\n                    var decimalToHex = function(d, padding) {\n                        //if there is no padding value added, default padding to 8 else go into while statement.\n                        padding = padding === undef || padding === null ? padding = 8 : padding;\n                        if (d < 0) d = 0xFFFFFFFF + d + 1;\n                        var hex = Number(d).toString(16).toUpperCase();\n                        while(hex.length < padding)hex = \"0\" + hex;\n                        if (hex.length >= padding) hex = hex.substring(hex.length - padding, hex.length);\n                        return hex;\n                    };\n                    // note: since we cannot keep track of byte, int types by default the returned string is 8 chars long\n                    // if no 2nd argument is passed.  closest compromise we can use to match java implementation Feb 5 2010\n                    // also the char parser has issues with chars that are not digits or letters IE: !@#$%^&*\n                    /**\n    * Converts a byte, char, int, or color to a String containing the equivalent hexadecimal notation.\n    * For example color(0, 102, 153, 255) will convert to the String \"FF006699\". This function can help\n    * make your geeky debugging sessions much happier.\n    *\n    * @param {byte|char|int|Color} value   the value to turn into a hex string\n    * @param {int} digits                 the number of digits to return\n    *\n    * @returns {String}\n    *\n    * @see unhex\n    * @see binary\n    * @see unbinary\n    */ p.hex = function(value, len) {\n                        if (arguments.length === 1) {\n                            if (value instanceof Char) len = 4;\n                            else len = 8;\n                        }\n                        return decimalToHex(value, len);\n                    };\n                    function unhexScalar(hex) {\n                        var value = parseInt(\"0x\" + hex, 16);\n                        // correct for int overflow java expectation\n                        if (value > 2147483647) value -= 4294967296;\n                        return value;\n                    }\n                    /**\n    * Converts a String representation of a hexadecimal number to its equivalent integer value.\n    *\n    * @param {String} hex   the hex string to convert to an int\n    *\n    * @returns {int}\n    *\n    * @see hex\n    * @see binary\n    * @see unbinary\n    */ p.unhex = function(hex) {\n                        if (hex instanceof Array) {\n                            var arr = [];\n                            for(var i = 0; i < hex.length; i++)arr.push(unhexScalar(hex[i]));\n                            return arr;\n                        }\n                        return unhexScalar(hex);\n                    };\n                    // Load a file or URL into strings\n                    /**\n    * Reads the contents of a file or url and creates a String array of its individual lines.\n    * The filename parameter can also be a URL to a file found online.  If the file is not available or an error occurs,\n    * null will be returned and an error message will be printed to the console. The error message does not halt\n    * the program.\n    *\n    * @param {String} filename    name of the file or url to load\n    *\n    * @returns {String[]}\n    *\n    * @see loadBytes\n    * @see saveStrings\n    * @see saveBytes\n    */ p.loadStrings = function(filename) {\n                        if (localStorage[filename]) return localStorage[filename].split(\"\\n\");\n                        var filecontent = ajax(filename);\n                        if (typeof filecontent !== \"string\" || filecontent === \"\") return [];\n                        // deal with the fact that Windows uses \\r\\n, Unix uses \\n,\n                        // Mac uses \\r, and we actually expect \\n\n                        filecontent = filecontent.replace(/(\\r\\n?)/g, \"\\n\").replace(/\\n$/, \"\");\n                        return filecontent.split(\"\\n\");\n                    };\n                    // Writes an array of strings to a file, one line per string\n                    /**\n    * Writes an array of strings to a file, one line per string. This file is saved to the localStorage.\n    *\n    * @param {String} filename    name of the file to save to localStorage\n    * @param {String[]} strings   string array to be written\n    *\n    * @see loadBytes\n    * @see loadStrings\n    * @see saveBytes\n    */ p.saveStrings = function(filename, strings) {\n                        localStorage[filename] = strings.join(\"\\n\");\n                    };\n                    /**\n    * Reads the contents of a file or url and places it in a byte array. If a file is specified, it must be located in the localStorage.\n    * The filename parameter can also be a URL to a file found online.\n    *\n    * @param {String} filename   name of a file in the localStorage or a URL.\n    *\n    * @returns {byte[]}\n    *\n    * @see loadStrings\n    * @see saveStrings\n    * @see saveBytes\n    */ p.loadBytes = function(url) {\n                        var string = ajax(url);\n                        var ret = [];\n                        for(var i = 0; i < string.length; i++)ret.push(string.charCodeAt(i));\n                        return ret;\n                    };\n                    ////////////////////////////////////////////////////////////////////////////\n                    // String Functions\n                    ////////////////////////////////////////////////////////////////////////////\n                    /**\n     * The matchAll() function is identical to match(), except that it returns an array of all matches in\n     * the specified String, rather than just the first.\n     *\n     * @param {String} aString  the String to search inside\n     * @param {String} aRegExp  the regexp to be used for matching\n     *\n     * @return {String[]} returns an array of matches\n     *\n     * @see #match\n     */ p.matchAll = function(aString, aRegExp) {\n                        var results = [], latest;\n                        var regexp = new RegExp(aRegExp, \"g\");\n                        while((latest = regexp.exec(aString)) !== null){\n                            results.push(latest);\n                            if (latest[0].length === 0) ++regexp.lastIndex;\n                        }\n                        return results.length > 0 ? results : null;\n                    };\n                    /**\n     * The match() function matches a string with a regular expression, and returns the match as an\n     * array. The first index is the matching expression, and array elements\n     * [1] and higher represent each of the groups (sequences found in parens).\n     *\n     * @param {String} str      the String to be searched\n     * @param {String} regexp   the regexp to be used for matching\n     *\n     * @return {String[]} an array of matching strings\n     */ p.match = function(str, regexp) {\n                        return str.match(regexp);\n                    };\n                    ////////////////////////////////////////////////////////////////////////////\n                    // Other java specific functions\n                    ////////////////////////////////////////////////////////////////////////////\n                    var logBuffer = [];\n                    /**\n     * The println() function writes to the console area of the Processing environment.\n     * Each call to this function creates a new line of output. Individual elements can be separated with quotes (\"\") and joined with the string concatenation operator (+).\n     *\n     * @param {String} message the string to write to the console\n     *\n     * @see #join\n     * @see #print\n     */ p.println = function() {\n                        Processing1.logger.println.apply(Processing1.logger, arguments);\n                    };\n                    /**\n     * The print() function writes to the console area of the Processing environment.\n     *\n     * @param {String} message the string to write to the console\n     *\n     * @see #join\n     */ p.print = function() {\n                        Processing1.logger.print.apply(Processing1.logger, arguments);\n                    };\n                    // Alphanumeric chars arguments automatically converted to numbers when\n                    // passed in, and will come out as numbers.\n                    p.str = function(val) {\n                        if (val instanceof Array) {\n                            var arr = [];\n                            for(var i = 0; i < val.length; i++)arr.push(val[i].toString() + \"\");\n                            return arr;\n                        }\n                        return val.toString() + \"\";\n                    };\n                    // Conversion\n                    function booleanScalar(val) {\n                        if (typeof val === \"number\") return val !== 0;\n                        if (typeof val === \"boolean\") return val;\n                        if (typeof val === \"string\") return val.toLowerCase() === \"true\";\n                        if (val instanceof Char) // 1, T or t\n                        return val.code === 49 || val.code === 84 || val.code === 116;\n                    }\n                    /**\n     * Converts the passed parameter to the function to its boolean value.\n     * It will return an array of booleans if an array is passed in.\n     *\n     * @param {int, byte, string} val          the parameter to be converted to boolean\n     * @param {int[], byte[], string[]} val    the array to be converted to boolean[]\n     *\n     * @return {boolean|boolean[]} returns a boolean or an array of booleans\n     */ p.parseBoolean = function(val) {\n                        if (val instanceof Array) {\n                            var ret = [];\n                            for(var i = 0; i < val.length; i++)ret.push(booleanScalar(val[i]));\n                            return ret;\n                        }\n                        return booleanScalar(val);\n                    };\n                    /**\n     * Converts the passed parameter to the function to its byte value.\n     * A byte is a number between -128 and 127.\n     * It will return an array of bytes if an array is passed in.\n     *\n     * @param {int, char} what        the parameter to be conveted to byte\n     * @param {int[], char[]} what    the array to be converted to byte[]\n     *\n     * @return {byte|byte[]} returns a byte or an array of bytes\n     */ p.parseByte = function(what) {\n                        if (what instanceof Array) {\n                            var bytes = [];\n                            for(var i = 0; i < what.length; i++)bytes.push(0 - (what[i] & 0x80) | what[i] & 0x7F);\n                            return bytes;\n                        }\n                        return 0 - (what & 0x80) | what & 0x7F;\n                    };\n                    /**\n     * Converts the passed parameter to the function to its char value.\n     * It will return an array of chars if an array is passed in.\n     *\n     * @param {int, byte} key        the parameter to be conveted to char\n     * @param {int[], byte[]} key    the array to be converted to char[]\n     *\n     * @return {char|char[]} returns a char or an array of chars\n     */ p.parseChar = function(key) {\n                        if (typeof key === \"number\") return new Char(String.fromCharCode(key & 0xFFFF));\n                        if (key instanceof Array) {\n                            var ret = [];\n                            for(var i = 0; i < key.length; i++)ret.push(new Char(String.fromCharCode(key[i] & 0xFFFF)));\n                            return ret;\n                        }\n                        throw \"char() may receive only one argument of type int, byte, int[], or byte[].\";\n                    };\n                    // Processing doc claims good argument types are: int, char, byte, boolean,\n                    // String, int[], char[], byte[], boolean[], String[].\n                    // floats should not work. However, floats with only zeroes right of the\n                    // decimal will work because JS converts those to int.\n                    function floatScalar(val) {\n                        if (typeof val === \"number\") return val;\n                        if (typeof val === \"boolean\") return val ? 1 : 0;\n                        if (typeof val === \"string\") return parseFloat(val);\n                        if (val instanceof Char) return val.code;\n                    }\n                    /**\n     * Converts the passed parameter to the function to its float value.\n     * It will return an array of floats if an array is passed in.\n     *\n     * @param {int, char, boolean, string} val            the parameter to be conveted to float\n     * @param {int[], char[], boolean[], string[]} val    the array to be converted to float[]\n     *\n     * @return {float|float[]} returns a float or an array of floats\n     */ p.parseFloat = function(val) {\n                        if (val instanceof Array) {\n                            var ret = [];\n                            for(var i = 0; i < val.length; i++)ret.push(floatScalar(val[i]));\n                            return ret;\n                        }\n                        return floatScalar(val);\n                    };\n                    function intScalar(val, radix) {\n                        if (typeof val === \"number\") return val & 0xFFFFFFFF;\n                        if (typeof val === \"boolean\") return val ? 1 : 0;\n                        if (typeof val === \"string\") {\n                            var number = parseInt(val, radix || 10); // Default to decimal radix.\n                            return number & 0xFFFFFFFF;\n                        }\n                        if (val instanceof Char) return val.code;\n                    }\n                    /**\n     * Converts the passed parameter to the function to its int value.\n     * It will return an array of ints if an array is passed in.\n     *\n     * @param {string, char, boolean, float} val            the parameter to be conveted to int\n     * @param {string[], char[], boolean[], float[]} val    the array to be converted to int[]\n     * @param {int} radix                                   optional the radix of the number (for js compatibility)\n     *\n     * @return {int|int[]} returns a int or an array of ints\n     */ p.parseInt = function(val, radix) {\n                        if (val instanceof Array) {\n                            var ret = [];\n                            for(var i = 0; i < val.length; i++)if (typeof val[i] === \"string\" && !/^\\s*[+\\-]?\\d+\\s*$/.test(val[i])) ret.push(0);\n                            else ret.push(intScalar(val[i], radix));\n                            return ret;\n                        }\n                        return intScalar(val, radix);\n                    };\n                    p.__int_cast = function(val) {\n                        return 0 | val;\n                    };\n                    p.__instanceof = function(obj, type) {\n                        if (typeof type !== \"function\") throw \"Function is expected as type argument for instanceof operator\";\n                        if (typeof obj === \"string\") // special case for strings\n                        return type === Object || type === String;\n                        if (obj instanceof type) // fast check if obj is already of type instance\n                        return true;\n                        if (typeof obj !== \"object\" || obj === null) return false; // not an object or null\n                        var objType = obj.constructor;\n                        if (type.$isInterface) {\n                            // expecting the interface\n                            // queueing interfaces from type and its base classes\n                            var interfaces = [];\n                            while(objType){\n                                if (objType.$interfaces) interfaces = interfaces.concat(objType.$interfaces);\n                                objType = objType.$base;\n                            }\n                            while(interfaces.length > 0){\n                                var i = interfaces.shift();\n                                if (i === type) return true;\n                                // wide search in base interfaces\n                                if (i.$interfaces) interfaces = interfaces.concat(i.$interfaces);\n                            }\n                            return false;\n                        }\n                        while(objType.hasOwnProperty(\"$base\")){\n                            objType = objType.$base;\n                            if (objType === type) return true; // object was found\n                        }\n                        return false;\n                    };\n                    /**\n    * Defines the dimension of the display window in units of pixels. The size() function must\n    * be the first line in setup(). If size() is not called, the default size of the window is\n    * 100x100 pixels. The system variables width and height are set by the parameters passed to\n    * the size() function.\n    *\n    * @param {int} aWidth     width of the display window in units of pixels\n    * @param {int} aHeight    height of the display window in units of pixels\n    * @param {MODE} aMode     Either P2D, P3D, JAVA2D, or OPENGL\n    *\n    * @see createGraphics\n    * @see screen\n    */ DrawingShared.prototype.size = function(aWidth, aHeight, aMode) {\n                        if (doStroke) p.stroke(0);\n                        if (doFill) p.fill(255);\n                        // The default 2d context has already been created in the p.init() stage if\n                        // a 3d context was not specified. This is so that a 2d context will be\n                        // available if size() was not called.\n                        var savedProperties = {\n                            fillStyle: curContext.fillStyle,\n                            strokeStyle: curContext.strokeStyle,\n                            lineCap: curContext.lineCap,\n                            lineJoin: curContext.lineJoin\n                        };\n                        // remove the style width and height properties to ensure that the canvas gets set to\n                        // aWidth and aHeight coming in\n                        if (curElement.style.length > 0) {\n                            curElement.style.removeProperty(\"width\");\n                            curElement.style.removeProperty(\"height\");\n                        }\n                        curElement.width = p.width = aWidth || 100;\n                        curElement.height = p.height = aHeight || 100;\n                        for(var prop in savedProperties)if (savedProperties.hasOwnProperty(prop)) curContext[prop] = savedProperties[prop];\n                        // make sure to set the default font the first time round.\n                        p.textFont(curTextFont);\n                        // Set the background to whatever it was called last as if background() was called before size()\n                        // If background() hasn't been called before, set background() to a light gray\n                        p.background();\n                        // set 5% for pixels to cache (or 1000)\n                        maxPixelsCached = Math.max(1000, aWidth * aHeight * 0.05);\n                        // Externalize the context\n                        p.externals.context = curContext;\n                        for(var i = 0; i < PConstants1.SINCOS_LENGTH; i++){\n                            sinLUT[i] = p.sin(i * (PConstants1.PI / 180) * 0.5);\n                            cosLUT[i] = p.cos(i * (PConstants1.PI / 180) * 0.5);\n                        }\n                    };\n                    Drawing2D.prototype.size = function(aWidth, aHeight, aMode) {\n                        if (curContext === undef) {\n                            // size() was called without p.init() default context, i.e. p.createGraphics()\n                            curContext = curElement.getContext(\"2d\");\n                            userMatrixStack = new PMatrixStack();\n                            userReverseMatrixStack = new PMatrixStack();\n                            modelView = new PMatrix2D();\n                            modelViewInv = new PMatrix2D();\n                        }\n                        DrawingShared.prototype.size.apply(this, arguments);\n                    };\n                    Drawing3D.prototype.size = function() {\n                        var size3DCalled = false;\n                        return function size(aWidth, aHeight, aMode) {\n                            if (size3DCalled) throw \"Multiple calls to size() for 3D renders are not allowed.\";\n                            size3DCalled = true;\n                            function getGLContext(canvas) {\n                                var ctxNames = [\n                                    \"experimental-webgl\",\n                                    \"webgl\",\n                                    \"webkit-3d\"\n                                ], gl;\n                                for(var i = 0, l = ctxNames.length; i < l; i++){\n                                    gl = canvas.getContext(ctxNames[i], {\n                                        antialias: false,\n                                        preserveDrawingBuffer: true\n                                    });\n                                    if (gl) break;\n                                }\n                                return gl;\n                            }\n                            // Get the 3D rendering context.\n                            try {\n                                // If the HTML <canvas> dimensions differ from the\n                                // dimensions specified in the size() call in the sketch, for\n                                // 3D sketches, browsers will either not render or render the\n                                // scene incorrectly. To fix this, we need to adjust the\n                                // width and height attributes of the canvas.\n                                curElement.width = p.width = aWidth || 100;\n                                curElement.height = p.height = aHeight || 100;\n                                curContext = getGLContext(curElement);\n                                canTex = curContext.createTexture();\n                                textTex = curContext.createTexture();\n                            } catch (e_size) {\n                                Processing1.debug(e_size);\n                            }\n                            if (!curContext) throw \"WebGL context is not supported on this browser.\";\n                            // Set defaults\n                            curContext.viewport(0, 0, curElement.width, curElement.height);\n                            curContext.enable(curContext.DEPTH_TEST);\n                            curContext.enable(curContext.BLEND);\n                            curContext.blendFunc(curContext.SRC_ALPHA, curContext.ONE_MINUS_SRC_ALPHA);\n                            // Create the program objects to render 2D (points, lines) and\n                            // 3D (spheres, boxes) shapes. Because 2D shapes are not lit,\n                            // lighting calculations are ommitted from this program object.\n                            programObject2D = createProgramObject(curContext, vertexShaderSrc2D, fragmentShaderSrc2D);\n                            programObjectUnlitShape = createProgramObject(curContext, vertexShaderSrcUnlitShape, fragmentShaderSrcUnlitShape);\n                            // Set the default point and line width for the 2D and unlit shapes.\n                            p.strokeWeight(1);\n                            // Now that the programs have been compiled, we can set the default\n                            // states for the lights.\n                            programObject3D = createProgramObject(curContext, vertexShaderSrc3D, fragmentShaderSrc3D);\n                            curContext.useProgram(programObject3D);\n                            // Assume we aren't using textures by default.\n                            uniformi(\"usingTexture3d\", programObject3D, \"usingTexture\", usingTexture);\n                            // Set some defaults.\n                            p.lightFalloff(1, 0, 0);\n                            p.shininess(1);\n                            p.ambient(255, 255, 255);\n                            p.specular(0, 0, 0);\n                            p.emissive(0, 0, 0);\n                            // Create buffers for 3D primitives\n                            boxBuffer = curContext.createBuffer();\n                            curContext.bindBuffer(curContext.ARRAY_BUFFER, boxBuffer);\n                            curContext.bufferData(curContext.ARRAY_BUFFER, boxVerts, curContext.STATIC_DRAW);\n                            boxNormBuffer = curContext.createBuffer();\n                            curContext.bindBuffer(curContext.ARRAY_BUFFER, boxNormBuffer);\n                            curContext.bufferData(curContext.ARRAY_BUFFER, boxNorms, curContext.STATIC_DRAW);\n                            boxOutlineBuffer = curContext.createBuffer();\n                            curContext.bindBuffer(curContext.ARRAY_BUFFER, boxOutlineBuffer);\n                            curContext.bufferData(curContext.ARRAY_BUFFER, boxOutlineVerts, curContext.STATIC_DRAW);\n                            // used to draw the rectangle and the outline\n                            rectBuffer = curContext.createBuffer();\n                            curContext.bindBuffer(curContext.ARRAY_BUFFER, rectBuffer);\n                            curContext.bufferData(curContext.ARRAY_BUFFER, rectVerts, curContext.STATIC_DRAW);\n                            rectNormBuffer = curContext.createBuffer();\n                            curContext.bindBuffer(curContext.ARRAY_BUFFER, rectNormBuffer);\n                            curContext.bufferData(curContext.ARRAY_BUFFER, rectNorms, curContext.STATIC_DRAW);\n                            // The sphere vertices are specified dynamically since the user\n                            // can change the level of detail. Everytime the user does that\n                            // using sphereDetail(), the new vertices are calculated.\n                            sphereBuffer = curContext.createBuffer();\n                            lineBuffer = curContext.createBuffer();\n                            // Shape buffers\n                            fillBuffer = curContext.createBuffer();\n                            fillColorBuffer = curContext.createBuffer();\n                            strokeColorBuffer = curContext.createBuffer();\n                            shapeTexVBO = curContext.createBuffer();\n                            pointBuffer = curContext.createBuffer();\n                            curContext.bindBuffer(curContext.ARRAY_BUFFER, pointBuffer);\n                            curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array([\n                                0,\n                                0,\n                                0\n                            ]), curContext.STATIC_DRAW);\n                            textBuffer = curContext.createBuffer();\n                            curContext.bindBuffer(curContext.ARRAY_BUFFER, textBuffer);\n                            curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array([\n                                1,\n                                1,\n                                0,\n                                -1,\n                                1,\n                                0,\n                                -1,\n                                -1,\n                                0,\n                                1,\n                                -1,\n                                0\n                            ]), curContext.STATIC_DRAW);\n                            textureBuffer = curContext.createBuffer();\n                            curContext.bindBuffer(curContext.ARRAY_BUFFER, textureBuffer);\n                            curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array([\n                                0,\n                                0,\n                                1,\n                                0,\n                                1,\n                                1,\n                                0,\n                                1\n                            ]), curContext.STATIC_DRAW);\n                            indexBuffer = curContext.createBuffer();\n                            curContext.bindBuffer(curContext.ELEMENT_ARRAY_BUFFER, indexBuffer);\n                            curContext.bufferData(curContext.ELEMENT_ARRAY_BUFFER, new Uint16Array([\n                                0,\n                                1,\n                                2,\n                                2,\n                                3,\n                                0\n                            ]), curContext.STATIC_DRAW);\n                            cam = new PMatrix3D();\n                            cameraInv = new PMatrix3D();\n                            modelView = new PMatrix3D();\n                            modelViewInv = new PMatrix3D();\n                            projection = new PMatrix3D();\n                            p.camera();\n                            p.perspective();\n                            userMatrixStack = new PMatrixStack();\n                            userReverseMatrixStack = new PMatrixStack();\n                            // used by both curve and bezier, so just init here\n                            curveBasisMatrix = new PMatrix3D();\n                            curveToBezierMatrix = new PMatrix3D();\n                            curveDrawMatrix = new PMatrix3D();\n                            bezierDrawMatrix = new PMatrix3D();\n                            bezierBasisInverse = new PMatrix3D();\n                            bezierBasisMatrix = new PMatrix3D();\n                            bezierBasisMatrix.set(-1, 3, -3, 1, 3, -6, 3, 0, -3, 3, 0, 0, 1, 0, 0, 0);\n                            DrawingShared.prototype.size.apply(this, arguments);\n                        };\n                    }();\n                    ////////////////////////////////////////////////////////////////////////////\n                    // Lights\n                    ////////////////////////////////////////////////////////////////////////////\n                    /**\n     * Adds an ambient light. Ambient light doesn't come from a specific direction,\n     * the rays have light have bounced around so much that objects are evenly lit\n     * from all sides. Ambient lights are almost always used in combination with\n     * other types of lights. Lights need to be included in the <b>draw()</b> to\n     * remain persistent in a looping program. Placing them in the <b>setup()</b>\n     * of a looping program will cause them to only have an effect the first time\n     * through the loop. The effect of the parameters is determined by the current\n     * color mode.\n     *\n     * @param {int | float} r red or hue value\n     * @param {int | float} g green or hue value\n     * @param {int | float} b blue or hue value\n     *\n     * @param {int | float} x x position of light (used for falloff)\n     * @param {int | float} y y position of light (used for falloff)\n     * @param {int | float} z z position of light (used for falloff)\n     *\n     * @returns none\n     *\n     * @see lights\n     * @see directionalLight\n     * @see pointLight\n     * @see spotLight\n    */ Drawing2D.prototype.ambientLight = DrawingShared.prototype.a3DOnlyFunction;\n                    Drawing3D.prototype.ambientLight = function(r, g, b, x, y, z) {\n                        if (lightCount === PConstants1.MAX_LIGHTS) throw \"can only create \" + PConstants1.MAX_LIGHTS + \" lights\";\n                        var pos = new PVector(x, y, z);\n                        var view = new PMatrix3D();\n                        view.scale(1, -1, 1);\n                        view.apply(modelView.array());\n                        view.mult(pos, pos);\n                        // Instead of calling p.color, we do the calculations ourselves to\n                        // reduce property lookups.\n                        var col = color$4(r, g, b, 0);\n                        var normalizedCol = [\n                            ((col & PConstants1.RED_MASK) >>> 16) / 255,\n                            ((col & PConstants1.GREEN_MASK) >>> 8) / 255,\n                            (col & PConstants1.BLUE_MASK) / 255\n                        ];\n                        curContext.useProgram(programObject3D);\n                        uniformf(\"uLights.color.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".color\", normalizedCol);\n                        uniformf(\"uLights.position.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".position\", pos.array());\n                        uniformi(\"uLights.type.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".type\", 0);\n                        uniformi(\"uLightCount3d\", programObject3D, \"uLightCount\", ++lightCount);\n                    };\n                    /**\n     * Adds a directional light. Directional light comes from one direction and\n     * is stronger when hitting a surface squarely and weaker if it hits at a\n     * gentle angle. After hitting a surface, a directional lights scatters in\n     * all directions. Lights need to be included in the <b>draw()</b> to remain\n     * persistent in a looping program. Placing them in the <b>setup()</b> of a\n     * looping program will cause them to only have an effect the first time\n     * through the loop. The affect of the <br>r</b>, <br>g</b>, and <br>b</b>\n     * parameters is determined by the current color mode. The <b>nx</b>,\n     * <b>ny</b>, and <b>nz</b> parameters specify the direction the light is\n     * facing. For example, setting <b>ny</b> to -1 will cause the geometry to be\n     * lit from below (the light is facing directly upward).\n     *\n     * @param {int | float} r red or hue value\n     * @param {int | float} g green or hue value\n     * @param {int | float} b blue or hue value\n     *\n     * @param {int | float} nx direction along the x axis\n     * @param {int | float} ny direction along the y axis\n     * @param {int | float} nz direction along the z axis\n     *\n     * @returns none\n     *\n     * @see lights\n     * @see ambientLight\n     * @see pointLight\n     * @see spotLight\n    */ Drawing2D.prototype.directionalLight = DrawingShared.prototype.a3DOnlyFunction;\n                    Drawing3D.prototype.directionalLight = function(r, g, b, nx, ny, nz) {\n                        if (lightCount === PConstants1.MAX_LIGHTS) throw \"can only create \" + PConstants1.MAX_LIGHTS + \" lights\";\n                        curContext.useProgram(programObject3D);\n                        var mvm = new PMatrix3D();\n                        mvm.scale(1, -1, 1);\n                        mvm.apply(modelView.array());\n                        mvm = mvm.array();\n                        // We need to multiply the direction by the model view matrix, but\n                        // the mult function checks the w component of the vector, if it isn't\n                        // present, it uses 1, so we manually multiply.\n                        var dir = [\n                            mvm[0] * nx + mvm[4] * ny + mvm[8] * nz,\n                            mvm[1] * nx + mvm[5] * ny + mvm[9] * nz,\n                            mvm[2] * nx + mvm[6] * ny + mvm[10] * nz\n                        ];\n                        // Instead of calling p.color, we do the calculations ourselves to\n                        // reduce property lookups.\n                        var col = color$4(r, g, b, 0);\n                        var normalizedCol = [\n                            ((col & PConstants1.RED_MASK) >>> 16) / 255,\n                            ((col & PConstants1.GREEN_MASK) >>> 8) / 255,\n                            (col & PConstants1.BLUE_MASK) / 255\n                        ];\n                        uniformf(\"uLights.color.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".color\", normalizedCol);\n                        uniformf(\"uLights.position.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".position\", dir);\n                        uniformi(\"uLights.type.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".type\", 1);\n                        uniformi(\"uLightCount3d\", programObject3D, \"uLightCount\", ++lightCount);\n                    };\n                    /**\n     * Sets the falloff rates for point lights, spot lights, and ambient lights.\n     * The parameters are used to determine the falloff with the following equation:\n     *\n     * d = distance from light position to vertex position\n     * falloff = 1 / (CONSTANT + d * LINEAR + (d*d) * QUADRATIC)\n     *\n     * Like <b>fill()</b>, it affects only the elements which are created after it in the\n     * code. The default value if <b>LightFalloff(1.0, 0.0, 0.0)</b>. Thinking about an\n     * ambient light with a falloff can be tricky. It is used, for example, if you\n     * wanted a region of your scene to be lit ambiently one color and another region\n     * to be lit ambiently by another color, you would use an ambient light with location\n     * and falloff. You can think of it as a point light that doesn't care which direction\n     * a surface is facing.\n     *\n     * @param {int | float} constant constant value for determining falloff\n     * @param {int | float} linear linear value for determining falloff\n     * @param {int | float} quadratic quadratic value for determining falloff\n     *\n     * @returns none\n     *\n     * @see lights\n     * @see ambientLight\n     * @see pointLight\n     * @see spotLight\n     * @see lightSpecular\n    */ Drawing2D.prototype.lightFalloff = DrawingShared.prototype.a3DOnlyFunction;\n                    Drawing3D.prototype.lightFalloff = function(constant, linear, quadratic) {\n                        curContext.useProgram(programObject3D);\n                        uniformf(\"uFalloff3d\", programObject3D, \"uFalloff\", [\n                            constant,\n                            linear,\n                            quadratic\n                        ]);\n                    };\n                    /**\n     * Sets the specular color for lights. Like <b>fill()</b>, it affects only the\n     * elements which are created after it in the code. Specular refers to light\n     * which bounces off a surface in a perferred direction (rather than bouncing\n     * in all directions like a diffuse light) and is used for creating highlights.\n     * The specular quality of a light interacts with the specular material qualities\n     * set through the <b>specular()</b> and <b>shininess()</b> functions.\n     *\n     * @param {int | float} r red or hue value\n     * @param {int | float} g green or hue value\n     * @param {int | float} b blue or hue value\n     *\n     * @returns none\n     *\n     * @see lights\n     * @see ambientLight\n     * @see pointLight\n     * @see spotLight\n    */ Drawing2D.prototype.lightSpecular = DrawingShared.prototype.a3DOnlyFunction;\n                    Drawing3D.prototype.lightSpecular = function(r, g, b) {\n                        // Instead of calling p.color, we do the calculations ourselves to\n                        // reduce property lookups.\n                        var col = color$4(r, g, b, 0);\n                        var normalizedCol = [\n                            ((col & PConstants1.RED_MASK) >>> 16) / 255,\n                            ((col & PConstants1.GREEN_MASK) >>> 8) / 255,\n                            (col & PConstants1.BLUE_MASK) / 255\n                        ];\n                        curContext.useProgram(programObject3D);\n                        uniformf(\"uSpecular3d\", programObject3D, \"uSpecular\", normalizedCol);\n                    };\n                    /**\n     * Sets the default ambient light, directional light, falloff, and specular\n     * values. The defaults are ambientLight(128, 128, 128) and\n     * directionalLight(128, 128, 128, 0, 0, -1), lightFalloff(1, 0, 0), and\n     * lightSpecular(0, 0, 0). Lights need to be included in the draw() to remain\n     * persistent in a looping program. Placing them in the setup() of a looping\n     * program will cause them to only have an effect the first time through the\n     * loop.\n     *\n     * @returns none\n     *\n     * @see ambientLight\n     * @see directionalLight\n     * @see pointLight\n     * @see spotLight\n     * @see noLights\n     *\n    */ p.lights = function() {\n                        p.ambientLight(128, 128, 128);\n                        p.directionalLight(128, 128, 128, 0, 0, -1);\n                        p.lightFalloff(1, 0, 0);\n                        p.lightSpecular(0, 0, 0);\n                    };\n                    /**\n     * Adds a point light. Lights need to be included in the <b>draw()</b> to remain\n     * persistent in a looping program. Placing them in the <b>setup()</b> of a\n     * looping program will cause them to only have an effect the first time through\n     * the loop. The affect of the <b>r</b>, <b>g</b>, and <b>b</b> parameters\n     * is determined by the current color mode. The <b>x</b>, <b>y</b>, and <b>z</b>\n     * parameters set the position of the light.\n     *\n     * @param {int | float} r red or hue value\n     * @param {int | float} g green or hue value\n     * @param {int | float} b blue or hue value\n     * @param {int | float} x x coordinate of the light\n     * @param {int | float} y y coordinate of the light\n     * @param {int | float} z z coordinate of the light\n     *\n     * @returns none\n     *\n     * @see lights\n     * @see directionalLight\n     * @see ambientLight\n     * @see spotLight\n    */ Drawing2D.prototype.pointLight = DrawingShared.prototype.a3DOnlyFunction;\n                    Drawing3D.prototype.pointLight = function(r, g, b, x, y, z) {\n                        if (lightCount === PConstants1.MAX_LIGHTS) throw \"can only create \" + PConstants1.MAX_LIGHTS + \" lights\";\n                        // Place the point in view space once instead of once per vertex\n                        // in the shader.\n                        var pos = new PVector(x, y, z);\n                        var view = new PMatrix3D();\n                        view.scale(1, -1, 1);\n                        view.apply(modelView.array());\n                        view.mult(pos, pos);\n                        // Instead of calling p.color, we do the calculations ourselves to\n                        // reduce property lookups.\n                        var col = color$4(r, g, b, 0);\n                        var normalizedCol = [\n                            ((col & PConstants1.RED_MASK) >>> 16) / 255,\n                            ((col & PConstants1.GREEN_MASK) >>> 8) / 255,\n                            (col & PConstants1.BLUE_MASK) / 255\n                        ];\n                        curContext.useProgram(programObject3D);\n                        uniformf(\"uLights.color.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".color\", normalizedCol);\n                        uniformf(\"uLights.position.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".position\", pos.array());\n                        uniformi(\"uLights.type.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".type\", 2);\n                        uniformi(\"uLightCount3d\", programObject3D, \"uLightCount\", ++lightCount);\n                    };\n                    /**\n     * Disable all lighting. Lighting is turned off by default and enabled with\n     * the lights() method. This function can be used to disable lighting so\n     * that 2D geometry (which does not require lighting) can be drawn after a\n     * set of lighted 3D geometry.\n     *\n     * @returns none\n     *\n     * @see lights\n    */ Drawing2D.prototype.noLights = DrawingShared.prototype.a3DOnlyFunction;\n                    Drawing3D.prototype.noLights = function() {\n                        lightCount = 0;\n                        curContext.useProgram(programObject3D);\n                        uniformi(\"uLightCount3d\", programObject3D, \"uLightCount\", lightCount);\n                    };\n                    /**\n     * Adds a spot light. Lights need to be included in the <b>draw()</b> to\n     * remain persistent in a looping program. Placing them in the <b>setup()</b>\n     * of a looping program will cause them to only have an effect the first time\n     * through the loop. The affect of the <b>r</b>, <b>g</b>, and <b>b</b> parameters\n     * is determined by the current color mode. The <b>x</b>, <b>y</b>, and <b>z</b>\n     * parameters specify the position of the light and <b>nx</b>, <b>ny</b>, <b>nz</b>\n     * specify the direction or light. The angle parameter affects <b>angle</b> of the\n     * spotlight cone.\n     *\n     * @param {int | float} r red or hue value\n     * @param {int | float} g green or hue value\n     * @param {int | float} b blue or hue value\n     * @param {int | float} x coordinate of the light\n     * @param {int | float} y coordinate of the light\n     * @param {int | float} z coordinate of the light\n     * @param {int | float} nx direction along the x axis\n     * @param {int | float} ny direction along the y axis\n     * @param {int | float} nz direction along the z axis\n     * @param {float} angle angle of the spotlight cone\n     * @param {float} concentration exponent determining the center bias of the cone\n     *\n     * @returns none\n     *\n     * @see lights\n     * @see directionalLight\n     * @see ambientLight\n     * @see pointLight\n    */ Drawing2D.prototype.spotLight = DrawingShared.prototype.a3DOnlyFunction;\n                    Drawing3D.prototype.spotLight = function(r, g, b, x, y, z, nx, ny, nz, angle, concentration) {\n                        if (lightCount === PConstants1.MAX_LIGHTS) throw \"can only create \" + PConstants1.MAX_LIGHTS + \" lights\";\n                        curContext.useProgram(programObject3D);\n                        // multiply the position and direction by the model view matrix\n                        // once per object rather than once per vertex.\n                        var pos = new PVector(x, y, z);\n                        var mvm = new PMatrix3D();\n                        mvm.scale(1, -1, 1);\n                        mvm.apply(modelView.array());\n                        mvm.mult(pos, pos);\n                        // Convert to array since we need to directly access the elements.\n                        mvm = mvm.array();\n                        // We need to multiply the direction by the model view matrix, but\n                        // the mult function checks the w component of the vector, if it isn't\n                        // present, it uses 1, so we use a very small value as a work around.\n                        var dir = [\n                            mvm[0] * nx + mvm[4] * ny + mvm[8] * nz,\n                            mvm[1] * nx + mvm[5] * ny + mvm[9] * nz,\n                            mvm[2] * nx + mvm[6] * ny + mvm[10] * nz\n                        ];\n                        // Instead of calling p.color, we do the calculations ourselves to\n                        // reduce property lookups.\n                        var col = color$4(r, g, b, 0);\n                        var normalizedCol = [\n                            ((col & PConstants1.RED_MASK) >>> 16) / 255,\n                            ((col & PConstants1.GREEN_MASK) >>> 8) / 255,\n                            (col & PConstants1.BLUE_MASK) / 255\n                        ];\n                        uniformf(\"uLights.color.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".color\", normalizedCol);\n                        uniformf(\"uLights.position.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".position\", pos.array());\n                        uniformf(\"uLights.direction.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".direction\", dir);\n                        uniformf(\"uLights.concentration.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".concentration\", concentration);\n                        uniformf(\"uLights.angle.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".angle\", angle);\n                        uniformi(\"uLights.type.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".type\", 3);\n                        uniformi(\"uLightCount3d\", programObject3D, \"uLightCount\", ++lightCount);\n                    };\n                    ////////////////////////////////////////////////////////////////////////////\n                    // Camera functions\n                    ////////////////////////////////////////////////////////////////////////////\n                    /**\n     * The <b>beginCamera()</b> and <b>endCamera()</b> functions enable advanced customization of the camera space.\n     * The functions are useful if you want to more control over camera movement, however for most users, the <b>camera()</b>\n     * function will be sufficient.<br /><br />The camera functions will replace any transformations (such as <b>rotate()</b>\n     * or <b>translate()</b>) that occur before them in <b>draw()</b>, but they will not automatically replace the camera\n     * transform itself. For this reason, camera functions should be placed at the beginning of <b>draw()</b> (so that\n     * transformations happen afterwards), and the <b>camera()</b> function can be used after <b>beginCamera()</b> if\n     * you want to reset the camera before applying transformations.<br /><br />This function sets the matrix mode to the\n     * camera matrix so calls such as <b>translate()</b>, <b>rotate()</b>, applyMatrix() and resetMatrix() affect the camera.\n     * <b>beginCamera()</b> should always be used with a following <b>endCamera()</b> and pairs of <b>beginCamera()</b> and\n     * <b>endCamera()</b> cannot be nested.\n     *\n     * @see camera\n     * @see endCamera\n     * @see applyMatrix\n     * @see resetMatrix\n     * @see translate\n     * @see rotate\n     * @see scale\n     */ Drawing2D.prototype.beginCamera = function() {\n                        throw \"beginCamera() is not available in 2D mode\";\n                    };\n                    Drawing3D.prototype.beginCamera = function() {\n                        if (manipulatingCamera) throw \"You cannot call beginCamera() again before calling endCamera()\";\n                        manipulatingCamera = true;\n                        modelView = cameraInv;\n                        modelViewInv = cam;\n                    };\n                    /**\n     * The <b>beginCamera()</b> and <b>endCamera()</b> functions enable advanced customization of the camera space.\n     * Please see the reference for <b>beginCamera()</b> for a description of how the functions are used.\n     *\n     * @see beginCamera\n     */ Drawing2D.prototype.endCamera = function() {\n                        throw \"endCamera() is not available in 2D mode\";\n                    };\n                    Drawing3D.prototype.endCamera = function() {\n                        if (!manipulatingCamera) throw \"You cannot call endCamera() before calling beginCamera()\";\n                        modelView.set(cam);\n                        modelViewInv.set(cameraInv);\n                        manipulatingCamera = false;\n                    };\n                    /**\n     * Sets the position of the camera through setting the eye position, the center of the scene, and which axis is facing\n     * upward. Moving the eye position and the direction it is pointing (the center of the scene) allows the images to be\n     * seen from different angles. The version without any parameters sets the camera to the default position, pointing to\n     * the center of the display window with the Y axis as up. The default values are camera(width/2.0, height/2.0,\n     * (height/2.0) / tan(PI*60.0 / 360.0), width/2.0, height/2.0, 0, 0, 1, 0). This function is similar to gluLookAt()\n     * in OpenGL, but it first clears the current camera settings.\n     *\n     * @param {float} eyeX    x-coordinate for the eye\n     * @param {float} eyeY    y-coordinate for the eye\n     * @param {float} eyeZ    z-coordinate for the eye\n     * @param {float} centerX x-coordinate for the center of the scene\n     * @param {float} centerY y-coordinate for the center of the scene\n     * @param {float} centerZ z-coordinate for the center of the scene\n     * @param {float} upX     usually 0.0, 1.0, -1.0\n     * @param {float} upY     usually 0.0, 1.0, -1.0\n     * @param {float} upZ     usually 0.0, 1.0, -1.0\n     *\n     * @see beginCamera\n     * @see endCamera\n     * @see frustum\n     */ p.camera = function(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {\n                        if (eyeX === undef) {\n                            // Workaround if createGraphics is used.\n                            cameraX = p.width / 2;\n                            cameraY = p.height / 2;\n                            cameraZ = cameraY / Math.tan(cameraFOV / 2);\n                            eyeX = cameraX;\n                            eyeY = cameraY;\n                            eyeZ = cameraZ;\n                            centerX = cameraX;\n                            centerY = cameraY;\n                            centerZ = 0;\n                            upX = 0;\n                            upY = 1;\n                            upZ = 0;\n                        }\n                        var z = new PVector(eyeX - centerX, eyeY - centerY, eyeZ - centerZ);\n                        var y = new PVector(upX, upY, upZ);\n                        z.normalize();\n                        var x = PVector.cross(y, z);\n                        y = PVector.cross(z, x);\n                        x.normalize();\n                        y.normalize();\n                        var xX = x.x, xY = x.y, xZ = x.z;\n                        var yX = y.x, yY = y.y, yZ = y.z;\n                        var zX = z.x, zY = z.y, zZ = z.z;\n                        cam.set(xX, xY, xZ, 0, yX, yY, yZ, 0, zX, zY, zZ, 0, 0, 0, 0, 1);\n                        cam.translate(-eyeX, -eyeY, -eyeZ);\n                        cameraInv.reset();\n                        cameraInv.invApply(xX, xY, xZ, 0, yX, yY, yZ, 0, zX, zY, zZ, 0, 0, 0, 0, 1);\n                        cameraInv.translate(eyeX, eyeY, eyeZ);\n                        modelView.set(cam);\n                        modelViewInv.set(cameraInv);\n                    };\n                    /**\n     * Sets a perspective projection applying foreshortening, making distant objects appear smaller than closer ones. The\n     * parameters define a viewing volume with the shape of truncated pyramid. Objects near to the front of the volume appear\n     * their actual size, while farther objects appear smaller. This projection simulates the perspective of the world more\n     * accurately than orthographic projection. The version of perspective without parameters sets the default perspective and\n     * the version with four parameters allows the programmer to set the area precisely. The default values are:\n     * perspective(PI/3.0, width/height, cameraZ/10.0, cameraZ*10.0) where cameraZ is ((height/2.0) / tan(PI*60.0/360.0));\n     *\n     * @param {float} fov     field-of-view angle (in radians) for vertical direction\n     * @param {float} aspect  ratio of width to height\n     * @param {float} zNear   z-position of nearest clipping plane\n     * @param {float} zFar    z-positions of farthest clipping plane\n     */ p.perspective = function(fov, aspect, near, far) {\n                        if (arguments.length === 0) {\n                            //in case canvas is resized\n                            cameraY = curElement.height / 2;\n                            cameraZ = cameraY / Math.tan(cameraFOV / 2);\n                            cameraNear = cameraZ / 10;\n                            cameraFar = cameraZ * 10;\n                            cameraAspect = p.width / p.height;\n                            fov = cameraFOV;\n                            aspect = cameraAspect;\n                            near = cameraNear;\n                            far = cameraFar;\n                        }\n                        var yMax, yMin, xMax, xMin;\n                        yMax = near * Math.tan(fov / 2);\n                        yMin = -yMax;\n                        xMax = yMax * aspect;\n                        xMin = yMin * aspect;\n                        p.frustum(xMin, xMax, yMin, yMax, near, far);\n                    };\n                    /**\n     * Sets a perspective matrix defined through the parameters. Works like glFrustum, except it wipes out the current\n     * perspective matrix rather than muliplying itself with it.\n     *\n     * @param {float} left   left coordinate of the clipping plane\n     * @param {float} right  right coordinate of the clipping plane\n     * @param {float} bottom bottom coordinate of the clipping plane\n     * @param {float} top    top coordinate of the clipping plane\n     * @param {float} near   near coordinate of the clipping plane\n     * @param {float} far    far coordinate of the clipping plane\n     *\n     * @see beginCamera\n     * @see camera\n     * @see endCamera\n     * @see perspective\n     */ Drawing2D.prototype.frustum = function() {\n                        throw \"Processing.js: frustum() is not supported in 2D mode\";\n                    };\n                    Drawing3D.prototype.frustum = function(left, right, bottom, top, near, far) {\n                        frustumMode = true;\n                        projection = new PMatrix3D();\n                        projection.set(2 * near / (right - left), 0, (right + left) / (right - left), 0, 0, 2 * near / (top - bottom), (top + bottom) / (top - bottom), 0, 0, 0, -(far + near) / (far - near), -(2 * far * near) / (far - near), 0, 0, -1, 0);\n                        var proj = new PMatrix3D();\n                        proj.set(projection);\n                        proj.transpose();\n                        curContext.useProgram(programObject2D);\n                        uniformMatrix(\"projection2d\", programObject2D, \"uProjection\", false, proj.array());\n                        curContext.useProgram(programObject3D);\n                        uniformMatrix(\"projection3d\", programObject3D, \"uProjection\", false, proj.array());\n                        curContext.useProgram(programObjectUnlitShape);\n                        uniformMatrix(\"uProjectionUS\", programObjectUnlitShape, \"uProjection\", false, proj.array());\n                    };\n                    /**\n     * Sets an orthographic projection and defines a parallel clipping volume. All objects with the same dimension appear\n     * the same size, regardless of whether they are near or far from the camera. The parameters to this function specify\n     * the clipping volume where left and right are the minimum and maximum x values, top and bottom are the minimum and\n     * maximum y values, and near and far are the minimum and maximum z values. If no parameters are given, the default\n     * is used: ortho(0, width, 0, height, -10, 10).\n     *\n     * @param {float} left   left plane of the clipping volume\n     * @param {float} right  right plane of the clipping volume\n     * @param {float} bottom bottom plane of the clipping volume\n     * @param {float} top    top plane of the clipping volume\n     * @param {float} near   maximum distance from the origin to the viewer\n     * @param {float} far    maximum distance from the origin away from the viewer\n     */ p.ortho = function(left, right, bottom, top, near, far) {\n                        if (arguments.length === 0) {\n                            left = 0;\n                            right = p.width;\n                            bottom = 0;\n                            top = p.height;\n                            near = -10;\n                            far = 10;\n                        }\n                        var x = 2 / (right - left);\n                        var y = 2 / (top - bottom);\n                        var z = -2 / (far - near);\n                        var tx = -(right + left) / (right - left);\n                        var ty = -(top + bottom) / (top - bottom);\n                        var tz = -(far + near) / (far - near);\n                        projection = new PMatrix3D();\n                        projection.set(x, 0, 0, tx, 0, y, 0, ty, 0, 0, z, tz, 0, 0, 0, 1);\n                        var proj = new PMatrix3D();\n                        proj.set(projection);\n                        proj.transpose();\n                        curContext.useProgram(programObject2D);\n                        uniformMatrix(\"projection2d\", programObject2D, \"uProjection\", false, proj.array());\n                        curContext.useProgram(programObject3D);\n                        uniformMatrix(\"projection3d\", programObject3D, \"uProjection\", false, proj.array());\n                        curContext.useProgram(programObjectUnlitShape);\n                        uniformMatrix(\"uProjectionUS\", programObjectUnlitShape, \"uProjection\", false, proj.array());\n                        frustumMode = false;\n                    };\n                    /**\n     * The printProjection() prints the current projection matrix to the text window.\n     */ p.printProjection = function() {\n                        projection.print();\n                    };\n                    /**\n     * The printCamera() function prints the current camera matrix.\n     */ p.printCamera = function() {\n                        cam.print();\n                    };\n                    ////////////////////////////////////////////////////////////////////////////\n                    // Shapes\n                    ////////////////////////////////////////////////////////////////////////////\n                    /**\n     * The box() function renders a box. A box is an extruded rectangle. A box with equal dimension on all sides is a cube.\n     * Calling this function with only one parameter will create a cube.\n     *\n     * @param {int|float} w  dimension of the box in the x-dimension\n     * @param {int|float} h  dimension of the box in the y-dimension\n     * @param {int|float} d  dimension of the box in the z-dimension\n     */ Drawing2D.prototype.box = DrawingShared.prototype.a3DOnlyFunction;\n                    Drawing3D.prototype.box = function(w, h, d) {\n                        // user can uniformly scale the box by\n                        // passing in only one argument.\n                        if (!h || !d) h = d = w;\n                        // Modeling transformation\n                        var model = new PMatrix3D();\n                        model.scale(w, h, d);\n                        // Viewing transformation needs to have Y flipped\n                        // becuase that's what Processing does.\n                        var view = new PMatrix3D();\n                        view.scale(1, -1, 1);\n                        view.apply(modelView.array());\n                        view.transpose();\n                        if (doFill) {\n                            curContext.useProgram(programObject3D);\n                            uniformMatrix(\"model3d\", programObject3D, \"uModel\", false, model.array());\n                            uniformMatrix(\"view3d\", programObject3D, \"uView\", false, view.array());\n                            // Fix stitching problems. (lines get occluded by triangles\n                            // since they share the same depth values). This is not entirely\n                            // working, but it's a start for drawing the outline. So\n                            // developers can start playing around with styles.\n                            curContext.enable(curContext.POLYGON_OFFSET_FILL);\n                            curContext.polygonOffset(1, 1);\n                            uniformf(\"color3d\", programObject3D, \"uColor\", fillStyle);\n                            // Calculating the normal matrix can be expensive, so only\n                            // do it if it's necessary.\n                            if (lightCount > 0) {\n                                // Create the normal transformation matrix.\n                                var v = new PMatrix3D();\n                                v.set(view);\n                                var m = new PMatrix3D();\n                                m.set(model);\n                                v.mult(m);\n                                var normalMatrix = new PMatrix3D();\n                                normalMatrix.set(v);\n                                normalMatrix.invert();\n                                normalMatrix.transpose();\n                                uniformMatrix(\"uNormalTransform3d\", programObject3D, \"uNormalTransform\", false, normalMatrix.array());\n                                vertexAttribPointer(\"aNormal3d\", programObject3D, \"aNormal\", 3, boxNormBuffer);\n                            } else disableVertexAttribPointer(\"aNormal3d\", programObject3D, \"aNormal\");\n                            vertexAttribPointer(\"aVertex3d\", programObject3D, \"aVertex\", 3, boxBuffer);\n                            // Turn off per vertex colors.\n                            disableVertexAttribPointer(\"aColor3d\", programObject3D, \"aColor\");\n                            disableVertexAttribPointer(\"aTexture3d\", programObject3D, \"aTexture\");\n                            curContext.drawArrays(curContext.TRIANGLES, 0, boxVerts.length / 3);\n                            curContext.disable(curContext.POLYGON_OFFSET_FILL);\n                        }\n                        // Draw the box outline.\n                        if (lineWidth > 0 && doStroke) {\n                            curContext.useProgram(programObject2D);\n                            uniformMatrix(\"uModel2d\", programObject2D, \"uModel\", false, model.array());\n                            uniformMatrix(\"uView2d\", programObject2D, \"uView\", false, view.array());\n                            uniformf(\"uColor2d\", programObject2D, \"uColor\", strokeStyle);\n                            uniformi(\"uIsDrawingText2d\", programObject2D, \"uIsDrawingText\", false);\n                            vertexAttribPointer(\"vertex2d\", programObject2D, \"aVertex\", 3, boxOutlineBuffer);\n                            disableVertexAttribPointer(\"aTextureCoord2d\", programObject2D, \"aTextureCoord\");\n                            curContext.drawArrays(curContext.LINES, 0, boxOutlineVerts.length / 3);\n                        }\n                    };\n                    /**\n     * The initSphere() function is a helper function used by <b>sphereDetail()</b>\n     * This function creates and stores sphere vertices every time the user changes sphere detail.\n     *\n     * @see #sphereDetail\n     */ var initSphere = function() {\n                        var i;\n                        sphereVerts = [];\n                        for(i = 0; i < sphereDetailU; i++){\n                            sphereVerts.push(0);\n                            sphereVerts.push(-1);\n                            sphereVerts.push(0);\n                            sphereVerts.push(sphereX[i]);\n                            sphereVerts.push(sphereY[i]);\n                            sphereVerts.push(sphereZ[i]);\n                        }\n                        sphereVerts.push(0);\n                        sphereVerts.push(-1);\n                        sphereVerts.push(0);\n                        sphereVerts.push(sphereX[0]);\n                        sphereVerts.push(sphereY[0]);\n                        sphereVerts.push(sphereZ[0]);\n                        var v1, v11, v2;\n                        // middle rings\n                        var voff = 0;\n                        for(i = 2; i < sphereDetailV; i++){\n                            v1 = v11 = voff;\n                            voff += sphereDetailU;\n                            v2 = voff;\n                            for(var j = 0; j < sphereDetailU; j++){\n                                sphereVerts.push(sphereX[v1]);\n                                sphereVerts.push(sphereY[v1]);\n                                sphereVerts.push(sphereZ[v1++]);\n                                sphereVerts.push(sphereX[v2]);\n                                sphereVerts.push(sphereY[v2]);\n                                sphereVerts.push(sphereZ[v2++]);\n                            }\n                            // close each ring\n                            v1 = v11;\n                            v2 = voff;\n                            sphereVerts.push(sphereX[v1]);\n                            sphereVerts.push(sphereY[v1]);\n                            sphereVerts.push(sphereZ[v1]);\n                            sphereVerts.push(sphereX[v2]);\n                            sphereVerts.push(sphereY[v2]);\n                            sphereVerts.push(sphereZ[v2]);\n                        }\n                        // add the northern cap\n                        for(i = 0; i < sphereDetailU; i++){\n                            v2 = voff + i;\n                            sphereVerts.push(sphereX[v2]);\n                            sphereVerts.push(sphereY[v2]);\n                            sphereVerts.push(sphereZ[v2]);\n                            sphereVerts.push(0);\n                            sphereVerts.push(1);\n                            sphereVerts.push(0);\n                        }\n                        sphereVerts.push(sphereX[voff]);\n                        sphereVerts.push(sphereY[voff]);\n                        sphereVerts.push(sphereZ[voff]);\n                        sphereVerts.push(0);\n                        sphereVerts.push(1);\n                        sphereVerts.push(0);\n                        //set the buffer data\n                        curContext.bindBuffer(curContext.ARRAY_BUFFER, sphereBuffer);\n                        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(sphereVerts), curContext.STATIC_DRAW);\n                    };\n                    /**\n     * The sphereDetail() function controls the detail used to render a sphere by adjusting the number of\n     * vertices of the sphere mesh. The default resolution is 30, which creates\n     * a fairly detailed sphere definition with vertices every 360/30 = 12\n     * degrees. If you're going to render a great number of spheres per frame,\n     * it is advised to reduce the level of detail using this function.\n     * The setting stays active until <b>sphereDetail()</b> is called again with\n     * a new parameter and so should <i>not</i> be called prior to every\n     * <b>sphere()</b> statement, unless you wish to render spheres with\n     * different settings, e.g. using less detail for smaller spheres or ones\n     * further away from the camera. To control the detail of the horizontal\n     * and vertical resolution independently, use the version of the functions\n     * with two parameters. Calling this function with one parameter sets the number of segments\n     *(minimum of 3) used per full circle revolution. This is equivalent to calling the function with\n     * two identical values.\n     *\n     * @param {int} ures    number of segments used horizontally (longitudinally) per full circle revolution\n     * @param {int} vres    number of segments used vertically (latitudinally) from top to bottom\n     *\n     * @see #sphere()\n     */ p.sphereDetail = function(ures, vres) {\n                        var i;\n                        if (arguments.length === 1) ures = vres = arguments[0];\n                        if (ures < 3) ures = 3;\n                         // force a minimum res\n                        if (vres < 2) vres = 2;\n                         // force a minimum res\n                        // if it hasn't changed do nothing\n                        if (ures === sphereDetailU && vres === sphereDetailV) return;\n                        var delta = PConstants1.SINCOS_LENGTH / ures;\n                        var cx = new Float32Array(ures);\n                        var cz = new Float32Array(ures);\n                        // calc unit circle in XZ plane\n                        for(i = 0; i < ures; i++){\n                            cx[i] = cosLUT[i * delta % PConstants1.SINCOS_LENGTH | 0];\n                            cz[i] = sinLUT[i * delta % PConstants1.SINCOS_LENGTH | 0];\n                        }\n                        // computing vertexlist\n                        // vertexlist starts at south pole\n                        var vertCount = ures * (vres - 1) + 2;\n                        var currVert = 0;\n                        // re-init arrays to store vertices\n                        sphereX = new Float32Array(vertCount);\n                        sphereY = new Float32Array(vertCount);\n                        sphereZ = new Float32Array(vertCount);\n                        var angle_step = PConstants1.SINCOS_LENGTH * 0.5 / vres;\n                        var angle = angle_step;\n                        // step along Y axis\n                        for(i = 1; i < vres; i++){\n                            var curradius = sinLUT[angle % PConstants1.SINCOS_LENGTH | 0];\n                            var currY = -cosLUT[angle % PConstants1.SINCOS_LENGTH | 0];\n                            for(var j = 0; j < ures; j++){\n                                sphereX[currVert] = cx[j] * curradius;\n                                sphereY[currVert] = currY;\n                                sphereZ[currVert++] = cz[j] * curradius;\n                            }\n                            angle += angle_step;\n                        }\n                        sphereDetailU = ures;\n                        sphereDetailV = vres;\n                        // make the sphere verts and norms\n                        initSphere();\n                    };\n                    /**\n     * The sphere() function draws a sphere with radius r centered at coordinate 0, 0, 0.\n     * A sphere is a hollow ball made from tessellated triangles.\n     *\n     * @param {int|float} r the radius of the sphere\n     */ Drawing2D.prototype.sphere = DrawingShared.prototype.a3DOnlyFunction;\n                    Drawing3D.prototype.sphere = function() {\n                        var sRad = arguments[0];\n                        if (sphereDetailU < 3 || sphereDetailV < 2) p.sphereDetail(30);\n                        // Modeling transformation.\n                        var model = new PMatrix3D();\n                        model.scale(sRad, sRad, sRad);\n                        // viewing transformation needs to have Y flipped\n                        // becuase that's what Processing does.\n                        var view = new PMatrix3D();\n                        view.scale(1, -1, 1);\n                        view.apply(modelView.array());\n                        view.transpose();\n                        if (doFill) {\n                            // Calculating the normal matrix can be expensive, so only\n                            // do it if it's necessary.\n                            if (lightCount > 0) {\n                                // Create a normal transformation matrix.\n                                var v = new PMatrix3D();\n                                v.set(view);\n                                var m = new PMatrix3D();\n                                m.set(model);\n                                v.mult(m);\n                                var normalMatrix = new PMatrix3D();\n                                normalMatrix.set(v);\n                                normalMatrix.invert();\n                                normalMatrix.transpose();\n                                uniformMatrix(\"uNormalTransform3d\", programObject3D, \"uNormalTransform\", false, normalMatrix.array());\n                                vertexAttribPointer(\"aNormal3d\", programObject3D, \"aNormal\", 3, sphereBuffer);\n                            } else disableVertexAttribPointer(\"aNormal3d\", programObject3D, \"aNormal\");\n                            curContext.useProgram(programObject3D);\n                            disableVertexAttribPointer(\"aTexture3d\", programObject3D, \"aTexture\");\n                            uniformMatrix(\"uModel3d\", programObject3D, \"uModel\", false, model.array());\n                            uniformMatrix(\"uView3d\", programObject3D, \"uView\", false, view.array());\n                            vertexAttribPointer(\"aVertex3d\", programObject3D, \"aVertex\", 3, sphereBuffer);\n                            // Turn off per vertex colors.\n                            disableVertexAttribPointer(\"aColor3d\", programObject3D, \"aColor\");\n                            // fix stitching problems. (lines get occluded by triangles\n                            // since they share the same depth values). This is not entirely\n                            // working, but it's a start for drawing the outline. So\n                            // developers can start playing around with styles.\n                            curContext.enable(curContext.POLYGON_OFFSET_FILL);\n                            curContext.polygonOffset(1, 1);\n                            uniformf(\"uColor3d\", programObject3D, \"uColor\", fillStyle);\n                            curContext.drawArrays(curContext.TRIANGLE_STRIP, 0, sphereVerts.length / 3);\n                            curContext.disable(curContext.POLYGON_OFFSET_FILL);\n                        }\n                        // Draw the sphere outline.\n                        if (lineWidth > 0 && doStroke) {\n                            curContext.useProgram(programObject2D);\n                            uniformMatrix(\"uModel2d\", programObject2D, \"uModel\", false, model.array());\n                            uniformMatrix(\"uView2d\", programObject2D, \"uView\", false, view.array());\n                            vertexAttribPointer(\"aVertex2d\", programObject2D, \"aVertex\", 3, sphereBuffer);\n                            disableVertexAttribPointer(\"aTextureCoord2d\", programObject2D, \"aTextureCoord\");\n                            uniformf(\"uColor2d\", programObject2D, \"uColor\", strokeStyle);\n                            uniformi(\"uIsDrawingText\", programObject2D, \"uIsDrawingText\", false);\n                            curContext.drawArrays(curContext.LINE_STRIP, 0, sphereVerts.length / 3);\n                        }\n                    };\n                    ////////////////////////////////////////////////////////////////////////////\n                    // Coordinates\n                    ////////////////////////////////////////////////////////////////////////////\n                    /**\n     * Returns the three-dimensional X, Y, Z position in model space. This returns\n     * the X value for a given coordinate based on the current set of transformations\n     * (scale, rotate, translate, etc.) The X value can be used to place an object\n     * in space relative to the location of the original point once the transformations\n     * are no longer in use.<br />\n     * <br />\n     *\n     * @param {int | float} x 3D x coordinate to be mapped\n     * @param {int | float} y 3D y coordinate to be mapped\n     * @param {int | float} z 3D z coordinate to be mapped\n     *\n     * @returns {float}\n     *\n     * @see modelY\n     * @see modelZ\n    */ p.modelX = function(x, y, z) {\n                        var mv = modelView.array();\n                        var ci = cameraInv.array();\n                        var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];\n                        var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];\n                        var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];\n                        var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];\n                        var ox = ci[0] * ax + ci[1] * ay + ci[2] * az + ci[3] * aw;\n                        var ow = ci[12] * ax + ci[13] * ay + ci[14] * az + ci[15] * aw;\n                        return ow !== 0 ? ox / ow : ox;\n                    };\n                    /**\n     * Returns the three-dimensional X, Y, Z position in model space. This returns\n     * the Y value for a given coordinate based on the current set of transformations\n     * (scale, rotate, translate, etc.) The Y value can be used to place an object in\n     * space relative to the location of the original point once the transformations\n     * are no longer in use.<br />\n     * <br />\n     *\n     * @param {int | float} x 3D x coordinate to be mapped\n     * @param {int | float} y 3D y coordinate to be mapped\n     * @param {int | float} z 3D z coordinate to be mapped\n     *\n     * @returns {float}\n     *\n     * @see modelX\n     * @see modelZ\n    */ p.modelY = function(x, y, z) {\n                        var mv = modelView.array();\n                        var ci = cameraInv.array();\n                        var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];\n                        var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];\n                        var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];\n                        var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];\n                        var oy = ci[4] * ax + ci[5] * ay + ci[6] * az + ci[7] * aw;\n                        var ow = ci[12] * ax + ci[13] * ay + ci[14] * az + ci[15] * aw;\n                        return ow !== 0 ? oy / ow : oy;\n                    };\n                    /**\n     * Returns the three-dimensional X, Y, Z position in model space. This returns\n     * the Z value for a given coordinate based on the current set of transformations\n     * (scale, rotate, translate, etc.) The Z value can be used to place an object in\n     * space relative to the location of the original point once the transformations\n     * are no longer in use.\n     *\n     * @param {int | float} x 3D x coordinate to be mapped\n     * @param {int | float} y 3D y coordinate to be mapped\n     * @param {int | float} z 3D z coordinate to be mapped\n     *\n     * @returns {float}\n     *\n     * @see modelX\n     * @see modelY\n    */ p.modelZ = function(x, y, z) {\n                        var mv = modelView.array();\n                        var ci = cameraInv.array();\n                        var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];\n                        var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];\n                        var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];\n                        var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];\n                        var oz = ci[8] * ax + ci[9] * ay + ci[10] * az + ci[11] * aw;\n                        var ow = ci[12] * ax + ci[13] * ay + ci[14] * az + ci[15] * aw;\n                        return ow !== 0 ? oz / ow : oz;\n                    };\n                    ////////////////////////////////////////////////////////////////////////////\n                    // Material Properties\n                    ////////////////////////////////////////////////////////////////////////////\n                    /**\n     * Sets the ambient reflectance for shapes drawn to the screen. This is\n     * combined with the ambient light component of environment. The color\n     * components set through the parameters define the reflectance. For example in\n     * the default color mode, setting v1=255, v2=126, v3=0, would cause all the\n     * red light to reflect and half of the green light to reflect. Used in combination\n     * with <b>emissive()</b>, <b>specular()</b>, and <b>shininess()</b> in setting\n     * the materal properties of shapes.\n     *\n     * @param {int | float} gray\n     *\n     * @returns none\n     *\n     * @see emissive\n     * @see specular\n     * @see shininess\n    */ Drawing2D.prototype.ambient = DrawingShared.prototype.a3DOnlyFunction;\n                    Drawing3D.prototype.ambient = function(v1, v2, v3) {\n                        curContext.useProgram(programObject3D);\n                        uniformi(\"uUsingMat3d\", programObject3D, \"uUsingMat\", true);\n                        var col = p.color(v1, v2, v3);\n                        uniformf(\"uMaterialAmbient3d\", programObject3D, \"uMaterialAmbient\", p.color.toGLArray(col).slice(0, 3));\n                    };\n                    /**\n     * Sets the emissive color of the material used for drawing shapes\n     * drawn to the screen. Used in combination with ambient(), specular(),\n     * and shininess() in setting the material properties of shapes.\n     *\n     * Can be called in the following ways:\n     *\n     * emissive(gray)\n     * @param {int | float} gray number specifying value between white and black\n     *\n     * emissive(color)\n     * @param {color} color any value of the color datatype\n     *\n     * emissive(v1, v2, v3)\n     * @param {int | float} v1 red or hue value\n     * @param {int | float} v2 green or saturation value\n     * @param {int | float} v3 blue or brightness value\n     *\n     * @returns none\n     *\n     * @see ambient\n     * @see specular\n     * @see shininess\n    */ Drawing2D.prototype.emissive = DrawingShared.prototype.a3DOnlyFunction;\n                    Drawing3D.prototype.emissive = function(v1, v2, v3) {\n                        curContext.useProgram(programObject3D);\n                        uniformi(\"uUsingMat3d\", programObject3D, \"uUsingMat\", true);\n                        var col = p.color(v1, v2, v3);\n                        uniformf(\"uMaterialEmissive3d\", programObject3D, \"uMaterialEmissive\", p.color.toGLArray(col).slice(0, 3));\n                    };\n                    /**\n     * Sets the amount of gloss in the surface of shapes. Used in combination with\n     * <b>ambient()</b>, <b>specular()</b>, and <b>emissive()</b> in setting the\n     * material properties of shapes.\n     *\n     * @param {float} shine degree of shininess\n     *\n     * @returns none\n    */ Drawing2D.prototype.shininess = DrawingShared.prototype.a3DOnlyFunction;\n                    Drawing3D.prototype.shininess = function(shine) {\n                        curContext.useProgram(programObject3D);\n                        uniformi(\"uUsingMat3d\", programObject3D, \"uUsingMat\", true);\n                        uniformf(\"uShininess3d\", programObject3D, \"uShininess\", shine);\n                    };\n                    /**\n     * Sets the specular color of the materials used for shapes drawn to the screen,\n     * which sets the color of hightlights. Specular refers to light which bounces\n     * off a surface in a perferred direction (rather than bouncing in all directions\n     * like a diffuse light). Used in combination with emissive(), ambient(), and\n     * shininess() in setting the material properties of shapes.\n     *\n     * Can be called in the following ways:\n     *\n     * specular(gray)\n     * @param {int | float} gray number specifying value between white and black\n     *\n     * specular(gray, alpha)\n     * @param {int | float} gray number specifying value between white and black\n     * @param {int | float} alpha opacity\n     *\n     * specular(color)\n     * @param {color} color any value of the color datatype\n     *\n     * specular(v1, v2, v3)\n     * @param {int | float} v1 red or hue value\n     * @param {int | float} v2 green or saturation value\n     * @param {int | float} v3 blue or brightness value\n     *\n     * specular(v1, v2, v3, alpha)\n     * @param {int | float} v1 red or hue value\n     * @param {int | float} v2 green or saturation value\n     * @param {int | float} v3 blue or brightness value\n     * @param {int | float} alpha opacity\n     *\n     * @returns none\n     *\n     * @see ambient\n     * @see emissive\n     * @see shininess\n    */ Drawing2D.prototype.specular = DrawingShared.prototype.a3DOnlyFunction;\n                    Drawing3D.prototype.specular = function(v1, v2, v3) {\n                        curContext.useProgram(programObject3D);\n                        uniformi(\"uUsingMat3d\", programObject3D, \"uUsingMat\", true);\n                        var col = p.color(v1, v2, v3);\n                        uniformf(\"uMaterialSpecular3d\", programObject3D, \"uMaterialSpecular\", p.color.toGLArray(col).slice(0, 3));\n                    };\n                    ////////////////////////////////////////////////////////////////////////////\n                    // Coordinates\n                    ////////////////////////////////////////////////////////////////////////////\n                    /**\n     * Takes a three-dimensional X, Y, Z position and returns the X value for\n     * where it will appear on a (two-dimensional) screen.\n     *\n     * @param {int | float} x 3D x coordinate to be mapped\n     * @param {int | float} y 3D y coordinate to be mapped\n     * @param {int | float} z 3D z optional coordinate to be mapped\n     *\n     * @returns {float}\n     *\n     * @see screenY\n     * @see screenZ\n    */ p.screenX = function(x, y, z) {\n                        var mv = modelView.array();\n                        if (mv.length === 16) {\n                            var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];\n                            var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];\n                            var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];\n                            var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];\n                            var pj = projection.array();\n                            var ox = pj[0] * ax + pj[1] * ay + pj[2] * az + pj[3] * aw;\n                            var ow = pj[12] * ax + pj[13] * ay + pj[14] * az + pj[15] * aw;\n                            if (ow !== 0) ox /= ow;\n                            return p.width * (1 + ox) / 2.0;\n                        }\n                        // We assume that we're in 2D\n                        return modelView.multX(x, y);\n                    };\n                    /**\n     * Takes a three-dimensional X, Y, Z position and returns the Y value for\n     * where it will appear on a (two-dimensional) screen.\n     *\n     * @param {int | float} x 3D x coordinate to be mapped\n     * @param {int | float} y 3D y coordinate to be mapped\n     * @param {int | float} z 3D z optional coordinate to be mapped\n     *\n     * @returns {float}\n     *\n     * @see screenX\n     * @see screenZ\n    */ p.screenY = function screenY(x, y, z) {\n                        var mv = modelView.array();\n                        if (mv.length === 16) {\n                            var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];\n                            var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];\n                            var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];\n                            var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];\n                            var pj = projection.array();\n                            var oy = pj[4] * ax + pj[5] * ay + pj[6] * az + pj[7] * aw;\n                            var ow = pj[12] * ax + pj[13] * ay + pj[14] * az + pj[15] * aw;\n                            if (ow !== 0) oy /= ow;\n                            return p.height * (1 + oy) / 2.0;\n                        }\n                        // We assume that we're in 2D\n                        return modelView.multY(x, y);\n                    };\n                    /**\n     * Takes a three-dimensional X, Y, Z position and returns the Z value for\n     * where it will appear on a (two-dimensional) screen.\n     *\n     * @param {int | float} x 3D x coordinate to be mapped\n     * @param {int | float} y 3D y coordinate to be mapped\n     * @param {int | float} z 3D z coordinate to be mapped\n     *\n     * @returns {float}\n     *\n     * @see screenX\n     * @see screenY\n    */ p.screenZ = function screenZ(x, y, z) {\n                        var mv = modelView.array();\n                        if (mv.length !== 16) return 0;\n                        var pj = projection.array();\n                        var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];\n                        var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];\n                        var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];\n                        var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];\n                        var oz = pj[8] * ax + pj[9] * ay + pj[10] * az + pj[11] * aw;\n                        var ow = pj[12] * ax + pj[13] * ay + pj[14] * az + pj[15] * aw;\n                        if (ow !== 0) oz /= ow;\n                        return (oz + 1) / 2.0;\n                    };\n                    ////////////////////////////////////////////////////////////////////////////\n                    // Style functions\n                    ////////////////////////////////////////////////////////////////////////////\n                    /**\n     * The fill() function sets the color used to fill shapes. For example, if you run <b>fill(204, 102, 0)</b>, all subsequent shapes will be filled with orange.\n     * This color is either specified in terms of the RGB or HSB color depending on the current <b>colorMode()</b>\n     *(the default color space is RGB, with each value in the range from 0 to 255).\n     * <br><br>When using hexadecimal notation to specify a color, use \"#\" or \"0x\" before the values (e.g. #CCFFAA, 0xFFCCFFAA).\n     * The # syntax uses six digits to specify a color (the way colors are specified in HTML and CSS). When using the hexadecimal notation starting with \"0x\",\n     * the hexadecimal value must be specified with eight characters; the first two characters define the alpha component and the remainder the red, green, and blue components.\n     * <br><br>The value for the parameter \"gray\" must be less than or equal to the current maximum value as specified by <b>colorMode()</b>. The default maximum value is 255.\n     * <br><br>To change the color of an image (or a texture), use tint().\n     *\n     * @param {int|float} gray    number specifying value between white and black\n     * @param {int|float} value1  red or hue value\n     * @param {int|float} value2  green or saturation value\n     * @param {int|float} value3  blue or brightness value\n     * @param {int|float} alpha   opacity of the fill\n     * @param {Color} color       any value of the color datatype\n     * @param {int} hex           color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)\n     *\n     * @see #noFill()\n     * @see #stroke()\n     * @see #tint()\n     * @see #background()\n     * @see #colorMode()\n     */ DrawingShared.prototype.fill = function() {\n                        var color = p.color.apply(this, arguments);\n                        if (color === currentFillColor && doFill) return;\n                        doFill = true;\n                        currentFillColor = color;\n                    };\n                    Drawing2D.prototype.fill = function() {\n                        DrawingShared.prototype.fill.apply(this, arguments);\n                        isFillDirty = true;\n                    };\n                    Drawing3D.prototype.fill = function() {\n                        DrawingShared.prototype.fill.apply(this, arguments);\n                        fillStyle = p.color.toGLArray(currentFillColor);\n                    };\n                    function executeContextFill() {\n                        if (doFill) {\n                            if (isFillDirty) {\n                                curContext.fillStyle = p.color.toString(currentFillColor);\n                                isFillDirty = false;\n                            }\n                            curContext.fill();\n                        }\n                    }\n                    /**\n     * The noFill() function disables filling geometry. If both <b>noStroke()</b> and <b>noFill()</b>\n     * are called, no shapes will be drawn to the screen.\n     *\n     * @see #fill()\n     *\n     */ p.noFill = function() {\n                        doFill = false;\n                    };\n                    /**\n     * The stroke() function sets the color used to draw lines and borders around shapes. This color\n     * is either specified in terms of the RGB or HSB color depending on the\n     * current <b>colorMode()</b> (the default color space is RGB, with each\n     * value in the range from 0 to 255).\n     * <br><br>When using hexadecimal notation to specify a color, use \"#\" or\n     * \"0x\" before the values (e.g. #CCFFAA, 0xFFCCFFAA). The # syntax uses six\n     * digits to specify a color (the way colors are specified in HTML and CSS).\n     * When using the hexadecimal notation starting with \"0x\", the hexadecimal\n     * value must be specified with eight characters; the first two characters\n     * define the alpha component and the remainder the red, green, and blue\n     * components.\n     * <br><br>The value for the parameter \"gray\" must be less than or equal\n     * to the current maximum value as specified by <b>colorMode()</b>.\n     * The default maximum value is 255.\n     *\n     * @param {int|float} gray    number specifying value between white and black\n     * @param {int|float} value1  red or hue value\n     * @param {int|float} value2  green or saturation value\n     * @param {int|float} value3  blue or brightness value\n     * @param {int|float} alpha   opacity of the stroke\n     * @param {Color} color       any value of the color datatype\n     * @param {int} hex           color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)\n     *\n     * @see #fill()\n     * @see #noStroke()\n     * @see #tint()\n     * @see #background()\n     * @see #colorMode()\n     */ DrawingShared.prototype.stroke = function() {\n                        var color = p.color.apply(this, arguments);\n                        if (color === currentStrokeColor && doStroke) return;\n                        doStroke = true;\n                        currentStrokeColor = color;\n                    };\n                    Drawing2D.prototype.stroke = function() {\n                        DrawingShared.prototype.stroke.apply(this, arguments);\n                        isStrokeDirty = true;\n                    };\n                    Drawing3D.prototype.stroke = function() {\n                        DrawingShared.prototype.stroke.apply(this, arguments);\n                        strokeStyle = p.color.toGLArray(currentStrokeColor);\n                    };\n                    function executeContextStroke() {\n                        if (doStroke) {\n                            if (isStrokeDirty) {\n                                curContext.strokeStyle = p.color.toString(currentStrokeColor);\n                                isStrokeDirty = false;\n                            }\n                            curContext.stroke();\n                        }\n                    }\n                    /**\n     * The noStroke() function disables drawing the stroke (outline). If both <b>noStroke()</b> and\n     * <b>noFill()</b> are called, no shapes will be drawn to the screen.\n     *\n     * @see #stroke()\n     */ p.noStroke = function() {\n                        doStroke = false;\n                    };\n                    /**\n     * The strokeWeight() function sets the width of the stroke used for lines, points, and the border around shapes.\n     * All widths are set in units of pixels.\n     *\n     * @param {int|float} w the weight (in pixels) of the stroke\n     */ DrawingShared.prototype.strokeWeight = function(w) {\n                        lineWidth = w;\n                    };\n                    Drawing2D.prototype.strokeWeight = function(w) {\n                        DrawingShared.prototype.strokeWeight.apply(this, arguments);\n                        curContext.lineWidth = w;\n                    };\n                    Drawing3D.prototype.strokeWeight = function(w) {\n                        DrawingShared.prototype.strokeWeight.apply(this, arguments);\n                        // Processing groups the weight of points and lines under this one function,\n                        // but for WebGL, we need to set a uniform for points and call a function for line.\n                        curContext.useProgram(programObject2D);\n                        uniformf(\"pointSize2d\", programObject2D, \"uPointSize\", w);\n                        curContext.useProgram(programObjectUnlitShape);\n                        uniformf(\"pointSizeUnlitShape\", programObjectUnlitShape, \"uPointSize\", w);\n                        curContext.lineWidth(w);\n                    };\n                    /**\n     * The strokeCap() function sets the style for rendering line endings. These ends are either squared, extended, or rounded and\n     * specified with the corresponding parameters SQUARE, PROJECT, and ROUND. The default cap is ROUND.\n     * This function is not available with the P2D, P3D, or OPENGL renderers\n     *\n     * @param {int} value Either SQUARE, PROJECT, or ROUND\n     */ p.strokeCap = function(value) {\n                        drawing.$ensureContext().lineCap = value;\n                    };\n                    /**\n     * The strokeJoin() function sets the style of the joints which connect line segments.\n     * These joints are either mitered, beveled, or rounded and specified with the corresponding parameters MITER, BEVEL, and ROUND. The default joint is MITER.\n     * This function is not available with the P2D, P3D, or OPENGL renderers\n     *\n     * @param {int} value Either SQUARE, PROJECT, or ROUND\n     */ p.strokeJoin = function(value) {\n                        drawing.$ensureContext().lineJoin = value;\n                    };\n                    /**\n     * The smooth() function draws all geometry with smooth (anti-aliased) edges. This will slow down the frame rate of the application,\n     * but will enhance the visual refinement. <br/><br/>\n     * Note that smooth() will also improve image quality of resized images, and noSmooth() will disable image (and font) smoothing altogether.\n     * When working with a 3D sketch, smooth will draw points as circles rather than squares.\n     *\n     * @see #noSmooth()\n     * @see #hint()\n     * @see #size()\n     */ Drawing2D.prototype.smooth = function() {\n                        renderSmooth = true;\n                        var style = curElement.style;\n                        style.setProperty(\"image-rendering\", \"optimizeQuality\", \"important\");\n                        style.setProperty(\"-ms-interpolation-mode\", \"bicubic\", \"important\");\n                        if (curContext.hasOwnProperty(\"mozImageSmoothingEnabled\")) curContext.mozImageSmoothingEnabled = true;\n                    };\n                    Drawing3D.prototype.smooth = function() {\n                        renderSmooth = true;\n                    };\n                    /**\n     * The noSmooth() function draws all geometry with jagged (aliased) edges.\n     *\n     * @see #smooth()\n     */ Drawing2D.prototype.noSmooth = function() {\n                        renderSmooth = false;\n                        var style = curElement.style;\n                        style.setProperty(\"image-rendering\", \"optimizeSpeed\", \"important\");\n                        style.setProperty(\"image-rendering\", \"-moz-crisp-edges\", \"important\");\n                        style.setProperty(\"image-rendering\", \"-webkit-optimize-contrast\", \"important\");\n                        style.setProperty(\"image-rendering\", \"optimize-contrast\", \"important\");\n                        style.setProperty(\"-ms-interpolation-mode\", \"nearest-neighbor\", \"important\");\n                        if (curContext.hasOwnProperty(\"mozImageSmoothingEnabled\")) curContext.mozImageSmoothingEnabled = false;\n                    };\n                    Drawing3D.prototype.noSmooth = function() {\n                        renderSmooth = false;\n                    };\n                    ////////////////////////////////////////////////////////////////////////////\n                    // Vector drawing functions\n                    ////////////////////////////////////////////////////////////////////////////\n                    /**\n     * The point() function draws a point, a coordinate in space at the dimension of one pixel.\n     * The first parameter is the horizontal value for the point, the second\n     * value is the vertical value for the point, and the optional third value\n     * is the depth value. Drawing this shape in 3D using the <b>z</b>\n     * parameter requires the P3D or OPENGL parameter in combination with\n     * size as shown in the above example.\n     *\n     * @param {int|float} x x-coordinate of the point\n     * @param {int|float} y y-coordinate of the point\n     * @param {int|float} z z-coordinate of the point\n     *\n     * @see #beginShape()\n     */ Drawing2D.prototype.point = function(x, y) {\n                        if (!doStroke) return;\n                        if (!renderSmooth) {\n                            x = Math.round(x);\n                            y = Math.round(y);\n                        }\n                        curContext.fillStyle = p.color.toString(currentStrokeColor);\n                        isFillDirty = true;\n                        // Draw a circle for any point larger than 1px\n                        if (lineWidth > 1) {\n                            curContext.beginPath();\n                            curContext.arc(x, y, lineWidth / 2, 0, PConstants1.TWO_PI, false);\n                            curContext.fill();\n                        } else curContext.fillRect(x, y, 1, 1);\n                    };\n                    Drawing3D.prototype.point = function(x, y, z) {\n                        var model = new PMatrix3D();\n                        // move point to position\n                        model.translate(x, y, z || 0);\n                        model.transpose();\n                        var view = new PMatrix3D();\n                        view.scale(1, -1, 1);\n                        view.apply(modelView.array());\n                        view.transpose();\n                        curContext.useProgram(programObject2D);\n                        uniformMatrix(\"uModel2d\", programObject2D, \"uModel\", false, model.array());\n                        uniformMatrix(\"uView2d\", programObject2D, \"uView\", false, view.array());\n                        if (lineWidth > 0 && doStroke) {\n                            // this will be replaced with the new bit shifting color code\n                            uniformf(\"uColor2d\", programObject2D, \"uColor\", strokeStyle);\n                            uniformi(\"uIsDrawingText2d\", programObject2D, \"uIsDrawingText\", false);\n                            uniformi(\"uSmooth2d\", programObject2D, \"uSmooth\", renderSmooth);\n                            vertexAttribPointer(\"aVertex2d\", programObject2D, \"aVertex\", 3, pointBuffer);\n                            disableVertexAttribPointer(\"aTextureCoord2d\", programObject2D, \"aTextureCoord\");\n                            curContext.drawArrays(curContext.POINTS, 0, 1);\n                        }\n                    };\n                    /**\n     * Using the <b>beginShape()</b> and <b>endShape()</b> functions allow creating more complex forms.\n     * <b>beginShape()</b> begins recording vertices for a shape and <b>endShape()</b> stops recording.\n     * The value of the <b>MODE</b> parameter tells it which types of shapes to create from the provided vertices.\n     * With no mode specified, the shape can be any irregular polygon. After calling the <b>beginShape()</b> function,\n     * a series of <b>vertex()</b> commands must follow. To stop drawing the shape, call <b>endShape()</b>.\n     * The <b>vertex()</b> function with two parameters specifies a position in 2D and the <b>vertex()</b>\n     * function with three parameters specifies a position in 3D. Each shape will be outlined with the current\n     * stroke color and filled with the fill color.\n     *\n     * @param {int} MODE either POINTS, LINES, TRIANGLES, TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, and QUAD_STRIP.\n     *\n     * @see endShape\n     * @see vertex\n     * @see curveVertex\n     * @see bezierVertex\n     */ p.beginShape = function(type) {\n                        curShape = type;\n                        curvePoints = [];\n                        vertArray1 = [];\n                    };\n                    /**\n     * All shapes are constructed by connecting a series of vertices. <b>vertex()</b> is used to specify the vertex\n     * coordinates for points, lines, triangles, quads, and polygons and is used exclusively within the <b>beginShape()</b>\n     * and <b>endShape()</b> function. <br /><br />Drawing a vertex in 3D using the <b>z</b> parameter requires the P3D or\n     * OPENGL parameter in combination with size as shown in the above example.<br /><br />This function is also used to map a\n     * texture onto the geometry. The <b>texture()</b> function declares the texture to apply to the geometry and the <b>u</b>\n     * and <b>v</b> coordinates set define the mapping of this texture to the form. By default, the coordinates used for\n     * <b>u</b> and <b>v</b> are specified in relation to the image's size in pixels, but this relation can be changed with\n     * <b>textureMode()</b>.\n     *\n     * @param {int | float} x x-coordinate of the vertex\n     * @param {int | float} y y-coordinate of the vertex\n     * @param {boolean} moveto flag to indicate whether this is a new subpath\n     *\n     * @see beginShape\n     * @see endShape\n     * @see bezierVertex\n     * @see curveVertex\n     * @see texture\n     */ Drawing2D.prototype.vertex = function(x, y, moveTo) {\n                        var vert = [];\n                        if (firstVert) firstVert = false;\n                        vert.isVert = true;\n                        vert[0] = x;\n                        vert[1] = y;\n                        vert[2] = 0;\n                        vert[3] = 0;\n                        vert[4] = 0;\n                        // fill and stroke color\n                        vert[5] = currentFillColor;\n                        vert[6] = currentStrokeColor;\n                        vertArray1.push(vert);\n                        if (moveTo) vertArray1[vertArray1.length - 1].moveTo = moveTo;\n                    };\n                    Drawing3D.prototype.vertex = function(x, y, z, u, v) {\n                        var vert = [];\n                        if (firstVert) firstVert = false;\n                        vert.isVert = true;\n                        if (v === undef && usingTexture) {\n                            v = u;\n                            u = z;\n                            z = 0;\n                        }\n                        // Convert u and v to normalized coordinates\n                        if (u !== undef && v !== undef) {\n                            if (curTextureMode === PConstants1.IMAGE) {\n                                u /= curTexture.width;\n                                v /= curTexture.height;\n                            }\n                            u = u > 1 ? 1 : u;\n                            u = u < 0 ? 0 : u;\n                            v = v > 1 ? 1 : v;\n                            v = v < 0 ? 0 : v;\n                        }\n                        vert[0] = x;\n                        vert[1] = y;\n                        vert[2] = z || 0;\n                        vert[3] = u || 0;\n                        vert[4] = v || 0;\n                        // fill rgba\n                        vert[5] = fillStyle[0];\n                        vert[6] = fillStyle[1];\n                        vert[7] = fillStyle[2];\n                        vert[8] = fillStyle[3];\n                        // stroke rgba\n                        vert[9] = strokeStyle[0];\n                        vert[10] = strokeStyle[1];\n                        vert[11] = strokeStyle[2];\n                        vert[12] = strokeStyle[3];\n                        //normals\n                        vert[13] = normalX;\n                        vert[14] = normalY;\n                        vert[15] = normalZ;\n                        vertArray1.push(vert);\n                    };\n                    /**\n     * @private\n     * Renders 3D points created from calls to vertex and beginShape/endShape\n     *\n     * @param {Array} vArray an array of vertex coordinate\n     * @param {Array} cArray an array of colours used for the vertices\n     *\n     * @see beginShape\n     * @see endShape\n     * @see vertex\n     */ var point3D = function(vArray, cArray) {\n                        var view = new PMatrix3D();\n                        view.scale(1, -1, 1);\n                        view.apply(modelView.array());\n                        view.transpose();\n                        curContext.useProgram(programObjectUnlitShape);\n                        uniformMatrix(\"uViewUS\", programObjectUnlitShape, \"uView\", false, view.array());\n                        uniformi(\"uSmoothUS\", programObjectUnlitShape, \"uSmooth\", renderSmooth);\n                        vertexAttribPointer(\"aVertexUS\", programObjectUnlitShape, \"aVertex\", 3, pointBuffer);\n                        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(vArray), curContext.STREAM_DRAW);\n                        vertexAttribPointer(\"aColorUS\", programObjectUnlitShape, \"aColor\", 4, fillColorBuffer);\n                        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(cArray), curContext.STREAM_DRAW);\n                        curContext.drawArrays(curContext.POINTS, 0, vArray.length / 3);\n                    };\n                    /**\n     * @private\n     * Renders 3D lines created from calls to beginShape/vertex/endShape - based on the mode specified LINES, LINE_LOOP, etc.\n     *\n     * @param {Array} vArray an array of vertex coordinate\n     * @param {String} mode  either LINES, LINE_LOOP, or LINE_STRIP\n     * @param {Array} cArray an array of colours used for the vertices\n     *\n     * @see beginShape\n     * @see endShape\n     * @see vertex\n     */ var line3D = function(vArray, mode, cArray) {\n                        var ctxMode;\n                        if (mode === \"LINES\") ctxMode = curContext.LINES;\n                        else if (mode === \"LINE_LOOP\") ctxMode = curContext.LINE_LOOP;\n                        else ctxMode = curContext.LINE_STRIP;\n                        var view = new PMatrix3D();\n                        view.scale(1, -1, 1);\n                        view.apply(modelView.array());\n                        view.transpose();\n                        curContext.useProgram(programObjectUnlitShape);\n                        uniformMatrix(\"uViewUS\", programObjectUnlitShape, \"uView\", false, view.array());\n                        vertexAttribPointer(\"aVertexUS\", programObjectUnlitShape, \"aVertex\", 3, lineBuffer);\n                        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(vArray), curContext.STREAM_DRAW);\n                        vertexAttribPointer(\"aColorUS\", programObjectUnlitShape, \"aColor\", 4, strokeColorBuffer);\n                        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(cArray), curContext.STREAM_DRAW);\n                        curContext.drawArrays(ctxMode, 0, vArray.length / 3);\n                    };\n                    /**\n     * @private\n     * Render filled shapes created from calls to beginShape/vertex/endShape - based on the mode specified TRIANGLES, etc.\n     *\n     * @param {Array} vArray an array of vertex coordinate\n     * @param {String} mode  either LINES, LINE_LOOP, or LINE_STRIP\n     * @param {Array} cArray an array of colours used for the vertices\n     * @param {Array} tArray an array of u,v coordinates for textures\n     *\n     * @see beginShape\n     * @see endShape\n     * @see vertex\n     */ var fill3D = function(vArray, mode, cArray, tArray) {\n                        var ctxMode;\n                        if (mode === \"TRIANGLES\") ctxMode = curContext.TRIANGLES;\n                        else if (mode === \"TRIANGLE_FAN\") ctxMode = curContext.TRIANGLE_FAN;\n                        else ctxMode = curContext.TRIANGLE_STRIP;\n                        var view = new PMatrix3D();\n                        view.scale(1, -1, 1);\n                        view.apply(modelView.array());\n                        view.transpose();\n                        curContext.useProgram(programObject3D);\n                        uniformMatrix(\"model3d\", programObject3D, \"uModel\", false, [\n                            1,\n                            0,\n                            0,\n                            0,\n                            0,\n                            1,\n                            0,\n                            0,\n                            0,\n                            0,\n                            1,\n                            0,\n                            0,\n                            0,\n                            0,\n                            1\n                        ]);\n                        uniformMatrix(\"view3d\", programObject3D, \"uView\", false, view.array());\n                        curContext.enable(curContext.POLYGON_OFFSET_FILL);\n                        curContext.polygonOffset(1, 1);\n                        uniformf(\"color3d\", programObject3D, \"uColor\", [\n                            -1,\n                            0,\n                            0,\n                            0\n                        ]);\n                        vertexAttribPointer(\"vertex3d\", programObject3D, \"aVertex\", 3, fillBuffer);\n                        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(vArray), curContext.STREAM_DRAW);\n                        // if we are using a texture and a tint, then overwrite the\n                        // contents of the color buffer with the current tint\n                        if (usingTexture && curTint !== null) curTint3d(cArray);\n                        vertexAttribPointer(\"aColor3d\", programObject3D, \"aColor\", 4, fillColorBuffer);\n                        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(cArray), curContext.STREAM_DRAW);\n                        // No support for lights....yet\n                        disableVertexAttribPointer(\"aNormal3d\", programObject3D, \"aNormal\");\n                        if (usingTexture) {\n                            uniformi(\"uUsingTexture3d\", programObject3D, \"uUsingTexture\", usingTexture);\n                            vertexAttribPointer(\"aTexture3d\", programObject3D, \"aTexture\", 2, shapeTexVBO);\n                            curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(tArray), curContext.STREAM_DRAW);\n                        }\n                        curContext.drawArrays(ctxMode, 0, vArray.length / 3);\n                        curContext.disable(curContext.POLYGON_OFFSET_FILL);\n                    };\n                    /**\n     * this series of three operations is used a lot in Drawing2D.prototype.endShape\n     * and has been split off as its own function, to tighten the code and allow for\n     * fewer bugs.\n     */ function fillStrokeClose() {\n                        executeContextFill();\n                        executeContextStroke();\n                        curContext.closePath();\n                    }\n                    /**\n     * The endShape() function is the companion to beginShape() and may only be called after beginShape().\n     * When endshape() is called, all of image data defined since the previous call to beginShape() is written\n     * into the image buffer.\n     *\n     * @param {int} MODE Use CLOSE to close the shape\n     *\n     * @see beginShape\n     */ Drawing2D.prototype.endShape = function(mode) {\n                        // Duplicated in Drawing3D; too many variables used\n                        if (vertArray1.length === 0) return;\n                        var closeShape = mode === PConstants1.CLOSE;\n                        // if the shape is closed, the first element is also the last element\n                        if (closeShape) vertArray1.push(vertArray1[0]);\n                        var lineVertArray = [];\n                        var fillVertArray = [];\n                        var colorVertArray = [];\n                        var strokeVertArray = [];\n                        var texVertArray = [];\n                        var cachedVertArray;\n                        firstVert = true;\n                        var i, j, k;\n                        var vertArrayLength = vertArray1.length;\n                        for(i = 0; i < vertArrayLength; i++){\n                            cachedVertArray = vertArray1[i];\n                            for(j = 0; j < 3; j++)fillVertArray.push(cachedVertArray[j]);\n                        }\n                        // 5,6,7,8\n                        // R,G,B,A - fill colour\n                        for(i = 0; i < vertArrayLength; i++){\n                            cachedVertArray = vertArray1[i];\n                            for(j = 5; j < 9; j++)colorVertArray.push(cachedVertArray[j]);\n                        }\n                        // 9,10,11,12\n                        // R, G, B, A - stroke colour\n                        for(i = 0; i < vertArrayLength; i++){\n                            cachedVertArray = vertArray1[i];\n                            for(j = 9; j < 13; j++)strokeVertArray.push(cachedVertArray[j]);\n                        }\n                        // texture u,v\n                        for(i = 0; i < vertArrayLength; i++){\n                            cachedVertArray = vertArray1[i];\n                            texVertArray.push(cachedVertArray[3]);\n                            texVertArray.push(cachedVertArray[4]);\n                        }\n                        // curveVertex\n                        if (isCurve && (curShape === PConstants1.POLYGON || curShape === undef)) {\n                            if (vertArrayLength > 3) {\n                                var b = [], s = 1 - curTightness;\n                                curContext.beginPath();\n                                curContext.moveTo(vertArray1[1][0], vertArray1[1][1]);\n                                /*\n            * Matrix to convert from Catmull-Rom to cubic Bezier\n            * where t = curTightness\n            * |0         1          0         0       |\n            * |(t-1)/6   1          (1-t)/6   0       |\n            * |0         (1-t)/6    1         (t-1)/6 |\n            * |0         0          0         0       |\n            */ for(i = 1; i + 2 < vertArrayLength; i++){\n                                    cachedVertArray = vertArray1[i];\n                                    b[0] = [\n                                        cachedVertArray[0],\n                                        cachedVertArray[1]\n                                    ];\n                                    b[1] = [\n                                        cachedVertArray[0] + (s * vertArray1[i + 1][0] - s * vertArray1[i - 1][0]) / 6,\n                                        cachedVertArray[1] + (s * vertArray1[i + 1][1] - s * vertArray1[i - 1][1]) / 6\n                                    ];\n                                    b[2] = [\n                                        vertArray1[i + 1][0] + (s * vertArray1[i][0] - s * vertArray1[i + 2][0]) / 6,\n                                        vertArray1[i + 1][1] + (s * vertArray1[i][1] - s * vertArray1[i + 2][1]) / 6\n                                    ];\n                                    b[3] = [\n                                        vertArray1[i + 1][0],\n                                        vertArray1[i + 1][1]\n                                    ];\n                                    curContext.bezierCurveTo(b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]);\n                                }\n                                fillStrokeClose();\n                            }\n                        } else if (isBezier && (curShape === PConstants1.POLYGON || curShape === undef)) {\n                            curContext.beginPath();\n                            for(i = 0; i < vertArrayLength; i++){\n                                cachedVertArray = vertArray1[i];\n                                if (vertArray1[i].isVert) {\n                                    if (vertArray1[i].moveTo) curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);\n                                    else curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n                                } else curContext.bezierCurveTo(vertArray1[i][0], vertArray1[i][1], vertArray1[i][2], vertArray1[i][3], vertArray1[i][4], vertArray1[i][5]);\n                            }\n                            fillStrokeClose();\n                        } else {\n                            if (curShape === PConstants1.POINTS) for(i = 0; i < vertArrayLength; i++){\n                                cachedVertArray = vertArray1[i];\n                                if (doStroke) p.stroke(cachedVertArray[6]);\n                                p.point(cachedVertArray[0], cachedVertArray[1]);\n                            }\n                            else if (curShape === PConstants1.LINES) for(i = 0; i + 1 < vertArrayLength; i += 2){\n                                cachedVertArray = vertArray1[i];\n                                if (doStroke) p.stroke(vertArray1[i + 1][6]);\n                                p.line(cachedVertArray[0], cachedVertArray[1], vertArray1[i + 1][0], vertArray1[i + 1][1]);\n                            }\n                            else if (curShape === PConstants1.TRIANGLES) for(i = 0; i + 2 < vertArrayLength; i += 3){\n                                cachedVertArray = vertArray1[i];\n                                curContext.beginPath();\n                                curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);\n                                curContext.lineTo(vertArray1[i + 1][0], vertArray1[i + 1][1]);\n                                curContext.lineTo(vertArray1[i + 2][0], vertArray1[i + 2][1]);\n                                curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n                                if (doFill) {\n                                    p.fill(vertArray1[i + 2][5]);\n                                    executeContextFill();\n                                }\n                                if (doStroke) {\n                                    p.stroke(vertArray1[i + 2][6]);\n                                    executeContextStroke();\n                                }\n                                curContext.closePath();\n                            }\n                            else if (curShape === PConstants1.TRIANGLE_STRIP) for(i = 0; i + 1 < vertArrayLength; i++){\n                                cachedVertArray = vertArray1[i];\n                                curContext.beginPath();\n                                curContext.moveTo(vertArray1[i + 1][0], vertArray1[i + 1][1]);\n                                curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n                                if (doStroke) p.stroke(vertArray1[i + 1][6]);\n                                if (doFill) p.fill(vertArray1[i + 1][5]);\n                                if (i + 2 < vertArrayLength) {\n                                    curContext.lineTo(vertArray1[i + 2][0], vertArray1[i + 2][1]);\n                                    if (doStroke) p.stroke(vertArray1[i + 2][6]);\n                                    if (doFill) p.fill(vertArray1[i + 2][5]);\n                                }\n                                fillStrokeClose();\n                            }\n                            else if (curShape === PConstants1.TRIANGLE_FAN) {\n                                if (vertArrayLength > 2) {\n                                    curContext.beginPath();\n                                    curContext.moveTo(vertArray1[0][0], vertArray1[0][1]);\n                                    curContext.lineTo(vertArray1[1][0], vertArray1[1][1]);\n                                    curContext.lineTo(vertArray1[2][0], vertArray1[2][1]);\n                                    if (doFill) {\n                                        p.fill(vertArray1[2][5]);\n                                        executeContextFill();\n                                    }\n                                    if (doStroke) {\n                                        p.stroke(vertArray1[2][6]);\n                                        executeContextStroke();\n                                    }\n                                    curContext.closePath();\n                                    for(i = 3; i < vertArrayLength; i++){\n                                        cachedVertArray = vertArray1[i];\n                                        curContext.beginPath();\n                                        curContext.moveTo(vertArray1[0][0], vertArray1[0][1]);\n                                        curContext.lineTo(vertArray1[i - 1][0], vertArray1[i - 1][1]);\n                                        curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n                                        if (doFill) {\n                                            p.fill(cachedVertArray[5]);\n                                            executeContextFill();\n                                        }\n                                        if (doStroke) {\n                                            p.stroke(cachedVertArray[6]);\n                                            executeContextStroke();\n                                        }\n                                        curContext.closePath();\n                                    }\n                                }\n                            } else if (curShape === PConstants1.QUADS) for(i = 0; i + 3 < vertArrayLength; i += 4){\n                                cachedVertArray = vertArray1[i];\n                                curContext.beginPath();\n                                curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);\n                                for(j = 1; j < 4; j++)curContext.lineTo(vertArray1[i + j][0], vertArray1[i + j][1]);\n                                curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n                                if (doFill) {\n                                    p.fill(vertArray1[i + 3][5]);\n                                    executeContextFill();\n                                }\n                                if (doStroke) {\n                                    p.stroke(vertArray1[i + 3][6]);\n                                    executeContextStroke();\n                                }\n                                curContext.closePath();\n                            }\n                            else if (curShape === PConstants1.QUAD_STRIP) {\n                                if (vertArrayLength > 3) for(i = 0; i + 1 < vertArrayLength; i += 2){\n                                    cachedVertArray = vertArray1[i];\n                                    curContext.beginPath();\n                                    if (i + 3 < vertArrayLength) {\n                                        curContext.moveTo(vertArray1[i + 2][0], vertArray1[i + 2][1]);\n                                        curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n                                        curContext.lineTo(vertArray1[i + 1][0], vertArray1[i + 1][1]);\n                                        curContext.lineTo(vertArray1[i + 3][0], vertArray1[i + 3][1]);\n                                        if (doFill) p.fill(vertArray1[i + 3][5]);\n                                        if (doStroke) p.stroke(vertArray1[i + 3][6]);\n                                    } else {\n                                        curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);\n                                        curContext.lineTo(vertArray1[i + 1][0], vertArray1[i + 1][1]);\n                                    }\n                                    fillStrokeClose();\n                                }\n                            } else {\n                                curContext.beginPath();\n                                curContext.moveTo(vertArray1[0][0], vertArray1[0][1]);\n                                for(i = 1; i < vertArrayLength; i++){\n                                    cachedVertArray = vertArray1[i];\n                                    if (cachedVertArray.isVert) {\n                                        if (cachedVertArray.moveTo) curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);\n                                        else curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n                                    }\n                                }\n                                fillStrokeClose();\n                            }\n                        }\n                        // Reset some settings\n                        isCurve = false;\n                        isBezier = false;\n                        curveVertArray = [];\n                        curveVertCount = 0;\n                        // If the shape is closed, the first element was added as last element.\n                        // We must remove it again to prevent the list of vertices from growing\n                        // over successive calls to endShape(CLOSE)\n                        if (closeShape) vertArray1.pop();\n                    };\n                    Drawing3D.prototype.endShape = function(mode) {\n                        // Duplicated in Drawing3D; too many variables used\n                        if (vertArray1.length === 0) return;\n                        var closeShape = mode === PConstants1.CLOSE;\n                        var lineVertArray = [];\n                        var fillVertArray = [];\n                        var colorVertArray = [];\n                        var strokeVertArray = [];\n                        var texVertArray = [];\n                        var cachedVertArray;\n                        firstVert = true;\n                        var i, j, k;\n                        var vertArrayLength = vertArray1.length;\n                        for(i = 0; i < vertArrayLength; i++){\n                            cachedVertArray = vertArray1[i];\n                            for(j = 0; j < 3; j++)fillVertArray.push(cachedVertArray[j]);\n                        }\n                        // 5,6,7,8\n                        // R,G,B,A - fill colour\n                        for(i = 0; i < vertArrayLength; i++){\n                            cachedVertArray = vertArray1[i];\n                            for(j = 5; j < 9; j++)colorVertArray.push(cachedVertArray[j]);\n                        }\n                        // 9,10,11,12\n                        // R, G, B, A - stroke colour\n                        for(i = 0; i < vertArrayLength; i++){\n                            cachedVertArray = vertArray1[i];\n                            for(j = 9; j < 13; j++)strokeVertArray.push(cachedVertArray[j]);\n                        }\n                        // texture u,v\n                        for(i = 0; i < vertArrayLength; i++){\n                            cachedVertArray = vertArray1[i];\n                            texVertArray.push(cachedVertArray[3]);\n                            texVertArray.push(cachedVertArray[4]);\n                        }\n                        // if shape is closed, push the first point into the last point (including colours)\n                        if (closeShape) {\n                            fillVertArray.push(vertArray1[0][0]);\n                            fillVertArray.push(vertArray1[0][1]);\n                            fillVertArray.push(vertArray1[0][2]);\n                            for(i = 5; i < 9; i++)colorVertArray.push(vertArray1[0][i]);\n                            for(i = 9; i < 13; i++)strokeVertArray.push(vertArray1[0][i]);\n                            texVertArray.push(vertArray1[0][3]);\n                            texVertArray.push(vertArray1[0][4]);\n                        }\n                        // End duplication\n                        // curveVertex\n                        if (isCurve && (curShape === PConstants1.POLYGON || curShape === undef)) {\n                            lineVertArray = fillVertArray;\n                            if (doStroke) line3D(lineVertArray, null, strokeVertArray);\n                            if (doFill) fill3D(fillVertArray, null, colorVertArray);\n                        } else if (isBezier && (curShape === PConstants1.POLYGON || curShape === undef)) {\n                            lineVertArray = fillVertArray;\n                            lineVertArray.splice(lineVertArray.length - 3);\n                            strokeVertArray.splice(strokeVertArray.length - 4);\n                            if (doStroke) line3D(lineVertArray, null, strokeVertArray);\n                            if (doFill) fill3D(fillVertArray, \"TRIANGLES\", colorVertArray);\n                        } else {\n                            if (curShape === PConstants1.POINTS) {\n                                for(i = 0; i < vertArrayLength; i++){\n                                    cachedVertArray = vertArray1[i];\n                                    for(j = 0; j < 3; j++)lineVertArray.push(cachedVertArray[j]);\n                                }\n                                point3D(lineVertArray, strokeVertArray); // render function for points\n                            } else if (curShape === PConstants1.LINES) {\n                                for(i = 0; i < vertArrayLength; i++){\n                                    cachedVertArray = vertArray1[i];\n                                    for(j = 0; j < 3; j++)lineVertArray.push(cachedVertArray[j]);\n                                }\n                                for(i = 0; i < vertArrayLength; i++){\n                                    cachedVertArray = vertArray1[i];\n                                    for(j = 5; j < 9; j++)colorVertArray.push(cachedVertArray[j]);\n                                }\n                                line3D(lineVertArray, \"LINES\", strokeVertArray); // render function for lines\n                            } else if (curShape === PConstants1.TRIANGLES) {\n                                if (vertArrayLength > 2) for(i = 0; i + 2 < vertArrayLength; i += 3){\n                                    fillVertArray = [];\n                                    texVertArray = [];\n                                    lineVertArray = [];\n                                    colorVertArray = [];\n                                    strokeVertArray = [];\n                                    for(j = 0; j < 3; j++)for(k = 0; k < 3; k++){\n                                        lineVertArray.push(vertArray1[i + j][k]); // the line point location information\n                                        fillVertArray.push(vertArray1[i + j][k]); // and fill point location information\n                                    }\n                                    for(j = 0; j < 3; j++)for(k = 3; k < 5; k++)texVertArray.push(vertArray1[i + j][k]);\n                                    for(j = 0; j < 3; j++)for(k = 5; k < 9; k++){\n                                        colorVertArray.push(vertArray1[i + j][k]); // the colour information\n                                        strokeVertArray.push(vertArray1[i + j][k + 4]); // and the stroke information\n                                    }\n                                    if (doStroke) line3D(lineVertArray, \"LINE_LOOP\", strokeVertArray); // line render function\n                                    if (doFill || usingTexture) fill3D(fillVertArray, \"TRIANGLES\", colorVertArray, texVertArray); // fill shape render function\n                                }\n                            } else if (curShape === PConstants1.TRIANGLE_STRIP) {\n                                if (vertArrayLength > 2) for(i = 0; i + 2 < vertArrayLength; i++){\n                                    lineVertArray = [];\n                                    fillVertArray = [];\n                                    strokeVertArray = [];\n                                    colorVertArray = [];\n                                    texVertArray = [];\n                                    for(j = 0; j < 3; j++)for(k = 0; k < 3; k++){\n                                        lineVertArray.push(vertArray1[i + j][k]);\n                                        fillVertArray.push(vertArray1[i + j][k]);\n                                    }\n                                    for(j = 0; j < 3; j++)for(k = 3; k < 5; k++)texVertArray.push(vertArray1[i + j][k]);\n                                    for(j = 0; j < 3; j++)for(k = 5; k < 9; k++){\n                                        strokeVertArray.push(vertArray1[i + j][k + 4]);\n                                        colorVertArray.push(vertArray1[i + j][k]);\n                                    }\n                                    if (doFill || usingTexture) fill3D(fillVertArray, \"TRIANGLE_STRIP\", colorVertArray, texVertArray);\n                                    if (doStroke) line3D(lineVertArray, \"LINE_LOOP\", strokeVertArray);\n                                }\n                            } else if (curShape === PConstants1.TRIANGLE_FAN) {\n                                if (vertArrayLength > 2) {\n                                    for(i = 0; i < 3; i++){\n                                        cachedVertArray = vertArray1[i];\n                                        for(j = 0; j < 3; j++)lineVertArray.push(cachedVertArray[j]);\n                                    }\n                                    for(i = 0; i < 3; i++){\n                                        cachedVertArray = vertArray1[i];\n                                        for(j = 9; j < 13; j++)strokeVertArray.push(cachedVertArray[j]);\n                                    }\n                                    if (doStroke) line3D(lineVertArray, \"LINE_LOOP\", strokeVertArray);\n                                    for(i = 2; i + 1 < vertArrayLength; i++){\n                                        lineVertArray = [];\n                                        strokeVertArray = [];\n                                        lineVertArray.push(vertArray1[0][0]);\n                                        lineVertArray.push(vertArray1[0][1]);\n                                        lineVertArray.push(vertArray1[0][2]);\n                                        strokeVertArray.push(vertArray1[0][9]);\n                                        strokeVertArray.push(vertArray1[0][10]);\n                                        strokeVertArray.push(vertArray1[0][11]);\n                                        strokeVertArray.push(vertArray1[0][12]);\n                                        for(j = 0; j < 2; j++)for(k = 0; k < 3; k++)lineVertArray.push(vertArray1[i + j][k]);\n                                        for(j = 0; j < 2; j++)for(k = 9; k < 13; k++)strokeVertArray.push(vertArray1[i + j][k]);\n                                        if (doStroke) line3D(lineVertArray, \"LINE_STRIP\", strokeVertArray);\n                                    }\n                                    if (doFill || usingTexture) fill3D(fillVertArray, \"TRIANGLE_FAN\", colorVertArray, texVertArray);\n                                }\n                            } else if (curShape === PConstants1.QUADS) for(i = 0; i + 3 < vertArrayLength; i += 4){\n                                lineVertArray = [];\n                                for(j = 0; j < 4; j++){\n                                    cachedVertArray = vertArray1[i + j];\n                                    for(k = 0; k < 3; k++)lineVertArray.push(cachedVertArray[k]);\n                                }\n                                if (doStroke) line3D(lineVertArray, \"LINE_LOOP\", strokeVertArray);\n                                if (doFill) {\n                                    fillVertArray = [];\n                                    colorVertArray = [];\n                                    texVertArray = [];\n                                    for(j = 0; j < 3; j++)fillVertArray.push(vertArray1[i][j]);\n                                    for(j = 5; j < 9; j++)colorVertArray.push(vertArray1[i][j]);\n                                    for(j = 0; j < 3; j++)fillVertArray.push(vertArray1[i + 1][j]);\n                                    for(j = 5; j < 9; j++)colorVertArray.push(vertArray1[i + 1][j]);\n                                    for(j = 0; j < 3; j++)fillVertArray.push(vertArray1[i + 3][j]);\n                                    for(j = 5; j < 9; j++)colorVertArray.push(vertArray1[i + 3][j]);\n                                    for(j = 0; j < 3; j++)fillVertArray.push(vertArray1[i + 2][j]);\n                                    for(j = 5; j < 9; j++)colorVertArray.push(vertArray1[i + 2][j]);\n                                    if (usingTexture) {\n                                        texVertArray.push(vertArray1[i + 0][3]);\n                                        texVertArray.push(vertArray1[i + 0][4]);\n                                        texVertArray.push(vertArray1[i + 1][3]);\n                                        texVertArray.push(vertArray1[i + 1][4]);\n                                        texVertArray.push(vertArray1[i + 3][3]);\n                                        texVertArray.push(vertArray1[i + 3][4]);\n                                        texVertArray.push(vertArray1[i + 2][3]);\n                                        texVertArray.push(vertArray1[i + 2][4]);\n                                    }\n                                    fill3D(fillVertArray, \"TRIANGLE_STRIP\", colorVertArray, texVertArray);\n                                }\n                            }\n                            else if (curShape === PConstants1.QUAD_STRIP) {\n                                var tempArray = [];\n                                if (vertArrayLength > 3) {\n                                    for(i = 0; i < 2; i++){\n                                        cachedVertArray = vertArray1[i];\n                                        for(j = 0; j < 3; j++)lineVertArray.push(cachedVertArray[j]);\n                                    }\n                                    for(i = 0; i < 2; i++){\n                                        cachedVertArray = vertArray1[i];\n                                        for(j = 9; j < 13; j++)strokeVertArray.push(cachedVertArray[j]);\n                                    }\n                                    line3D(lineVertArray, \"LINE_STRIP\", strokeVertArray);\n                                    if (vertArrayLength > 4 && vertArrayLength % 2 > 0) {\n                                        tempArray = fillVertArray.splice(fillVertArray.length - 3);\n                                        vertArray1.pop();\n                                    }\n                                    for(i = 0; i + 3 < vertArrayLength; i += 2){\n                                        lineVertArray = [];\n                                        strokeVertArray = [];\n                                        for(j = 0; j < 3; j++)lineVertArray.push(vertArray1[i + 1][j]);\n                                        for(j = 0; j < 3; j++)lineVertArray.push(vertArray1[i + 3][j]);\n                                        for(j = 0; j < 3; j++)lineVertArray.push(vertArray1[i + 2][j]);\n                                        for(j = 0; j < 3; j++)lineVertArray.push(vertArray1[i + 0][j]);\n                                        for(j = 9; j < 13; j++)strokeVertArray.push(vertArray1[i + 1][j]);\n                                        for(j = 9; j < 13; j++)strokeVertArray.push(vertArray1[i + 3][j]);\n                                        for(j = 9; j < 13; j++)strokeVertArray.push(vertArray1[i + 2][j]);\n                                        for(j = 9; j < 13; j++)strokeVertArray.push(vertArray1[i + 0][j]);\n                                        if (doStroke) line3D(lineVertArray, \"LINE_STRIP\", strokeVertArray);\n                                    }\n                                    if (doFill || usingTexture) fill3D(fillVertArray, \"TRIANGLE_LIST\", colorVertArray, texVertArray);\n                                }\n                            } else // If only one vertex was specified, it must be a point\n                            if (vertArrayLength === 1) {\n                                for(j = 0; j < 3; j++)lineVertArray.push(vertArray1[0][j]);\n                                for(j = 9; j < 13; j++)strokeVertArray.push(vertArray1[0][j]);\n                                point3D(lineVertArray, strokeVertArray);\n                            } else {\n                                for(i = 0; i < vertArrayLength; i++){\n                                    cachedVertArray = vertArray1[i];\n                                    for(j = 0; j < 3; j++)lineVertArray.push(cachedVertArray[j]);\n                                    for(j = 5; j < 9; j++)strokeVertArray.push(cachedVertArray[j]);\n                                }\n                                if (doStroke && closeShape) line3D(lineVertArray, \"LINE_LOOP\", strokeVertArray);\n                                else if (doStroke && !closeShape) line3D(lineVertArray, \"LINE_STRIP\", strokeVertArray);\n                                // fill is ignored if textures are used\n                                if (doFill || usingTexture) fill3D(fillVertArray, \"TRIANGLE_FAN\", colorVertArray, texVertArray);\n                            }\n                            // everytime beginShape is followed by a call to\n                            // texture(), texturing it turned back on. We do this to\n                            // figure out if the shape should be textured or filled\n                            // with a color.\n                            usingTexture = false;\n                            curContext.useProgram(programObject3D);\n                            uniformi(\"usingTexture3d\", programObject3D, \"uUsingTexture\", usingTexture);\n                        }\n                        // Reset some settings\n                        isCurve = false;\n                        isBezier = false;\n                        curveVertArray = [];\n                        curveVertCount = 0;\n                    };\n                    /**\n     * The function splineForward() setup forward-differencing matrix to be used for speedy\n     * curve rendering. It's based on using a specific number\n     * of curve segments and just doing incremental adds for each\n     * vertex of the segment, rather than running the mathematically\n     * expensive cubic equation. This function is used by both curveDetail and bezierDetail.\n     *\n     * @param {int} segments      number of curve segments to use when drawing\n     * @param {PMatrix3D} matrix  target object for the new matrix\n     */ var splineForward = function(segments, matrix) {\n                        var f = 1.0 / segments;\n                        var ff = f * f;\n                        var fff = ff * f;\n                        matrix.set(0, 0, 0, 1, fff, ff, f, 0, 6 * fff, 2 * ff, 0, 0, 6 * fff, 0, 0, 0);\n                    };\n                    /**\n     * The curveInit() function set the number of segments to use when drawing a Catmull-Rom\n     * curve, and setting the s parameter, which defines how tightly\n     * the curve fits to each vertex. Catmull-Rom curves are actually\n     * a subset of this curve type where the s is set to zero.\n     * This in an internal function used by curveDetail() and curveTightness().\n     */ var curveInit = function() {\n                        // allocate only if/when used to save startup time\n                        if (!curveDrawMatrix) {\n                            curveBasisMatrix = new PMatrix3D();\n                            curveDrawMatrix = new PMatrix3D();\n                            curveInited = true;\n                        }\n                        var s = curTightness;\n                        curveBasisMatrix.set((s - 1) / 2, (s + 3) / 2, (-3 - s) / 2, (1 - s) / 2, 1 - s, (-5 - s) / 2, s + 2, (s - 1) / 2, (s - 1) / 2, 0, (1 - s) / 2, 0, 0, 1, 0, 0);\n                        splineForward(curveDet, curveDrawMatrix);\n                        if (!bezierBasisInverse) //bezierBasisInverse = bezierBasisMatrix.get();\n                        //bezierBasisInverse.invert();\n                        curveToBezierMatrix = new PMatrix3D();\n                        // TODO only needed for PGraphicsJava2D? if so, move it there\n                        // actually, it's generally useful for other renderers, so keep it\n                        // or hide the implementation elsewhere.\n                        curveToBezierMatrix.set(curveBasisMatrix);\n                        curveToBezierMatrix.preApply(bezierBasisInverse);\n                        // multiply the basis and forward diff matrices together\n                        // saves much time since this needn't be done for each curve\n                        curveDrawMatrix.apply(curveBasisMatrix);\n                    };\n                    /**\n     * Specifies vertex coordinates for Bezier curves. Each call to <b>bezierVertex()</b> defines the position of two control\n     * points and one anchor point of a Bezier curve, adding a new segment to a line or shape. The first time\n     * <b>bezierVertex()</b> is used within a <b>beginShape()</b> call, it must be prefaced with a call to <b>vertex()</b>\n     * to set the first anchor point. This function must be used between <b>beginShape()</b> and <b>endShape()</b> and only\n     * when there is no MODE parameter specified to <b>beginShape()</b>. Using the 3D version of requires rendering with P3D\n     * or OPENGL (see the Environment reference for more information). <br /> <br /> <b>NOTE: </b> Fill does not work properly yet.\n     *\n     * @param {float | int} cx1 The x-coordinate of 1st control point\n     * @param {float | int} cy1 The y-coordinate of 1st control point\n     * @param {float | int} cz1 The z-coordinate of 1st control point\n     * @param {float | int} cx2 The x-coordinate of 2nd control point\n     * @param {float | int} cy2 The y-coordinate of 2nd control point\n     * @param {float | int} cz2 The z-coordinate of 2nd control point\n     * @param {float | int} x   The x-coordinate of the anchor point\n     * @param {float | int} y   The y-coordinate of the anchor point\n     * @param {float | int} z   The z-coordinate of the anchor point\n     *\n     * @see curveVertex\n     * @see vertex\n     * @see bezier\n     */ Drawing2D.prototype.bezierVertex = function() {\n                        isBezier = true;\n                        var vert = [];\n                        if (firstVert) throw \"vertex() must be used at least once before calling bezierVertex()\";\n                        for(var i = 0; i < arguments.length; i++)vert[i] = arguments[i];\n                        vertArray1.push(vert);\n                        vertArray1[vertArray1.length - 1].isVert = false;\n                    };\n                    Drawing3D.prototype.bezierVertex = function() {\n                        isBezier = true;\n                        var vert = [];\n                        if (firstVert) throw \"vertex() must be used at least once before calling bezierVertex()\";\n                        if (arguments.length === 9) {\n                            if (bezierDrawMatrix === undef) bezierDrawMatrix = new PMatrix3D();\n                            // setup matrix for forward differencing to speed up drawing\n                            var lastPoint = vertArray1.length - 1;\n                            splineForward(bezDetail, bezierDrawMatrix);\n                            bezierDrawMatrix.apply(bezierBasisMatrix);\n                            var draw = bezierDrawMatrix.array();\n                            var x1 = vertArray1[lastPoint][0], y1 = vertArray1[lastPoint][1], z1 = vertArray1[lastPoint][2];\n                            var xplot1 = draw[4] * x1 + draw[5] * arguments[0] + draw[6] * arguments[3] + draw[7] * arguments[6];\n                            var xplot2 = draw[8] * x1 + draw[9] * arguments[0] + draw[10] * arguments[3] + draw[11] * arguments[6];\n                            var xplot3 = draw[12] * x1 + draw[13] * arguments[0] + draw[14] * arguments[3] + draw[15] * arguments[6];\n                            var yplot1 = draw[4] * y1 + draw[5] * arguments[1] + draw[6] * arguments[4] + draw[7] * arguments[7];\n                            var yplot2 = draw[8] * y1 + draw[9] * arguments[1] + draw[10] * arguments[4] + draw[11] * arguments[7];\n                            var yplot3 = draw[12] * y1 + draw[13] * arguments[1] + draw[14] * arguments[4] + draw[15] * arguments[7];\n                            var zplot1 = draw[4] * z1 + draw[5] * arguments[2] + draw[6] * arguments[5] + draw[7] * arguments[8];\n                            var zplot2 = draw[8] * z1 + draw[9] * arguments[2] + draw[10] * arguments[5] + draw[11] * arguments[8];\n                            var zplot3 = draw[12] * z1 + draw[13] * arguments[2] + draw[14] * arguments[5] + draw[15] * arguments[8];\n                            for(var j = 0; j < bezDetail; j++){\n                                x1 += xplot1;\n                                xplot1 += xplot2;\n                                xplot2 += xplot3;\n                                y1 += yplot1;\n                                yplot1 += yplot2;\n                                yplot2 += yplot3;\n                                z1 += zplot1;\n                                zplot1 += zplot2;\n                                zplot2 += zplot3;\n                                p.vertex(x1, y1, z1);\n                            }\n                            p.vertex(arguments[6], arguments[7], arguments[8]);\n                        }\n                    };\n                    /**\n     * Sets a texture to be applied to vertex points. The <b>texture()</b> function\n     * must be called between <b>beginShape()</b> and <b>endShape()</b> and before\n     * any calls to vertex().\n     *\n     * When textures are in use, the fill color is ignored. Instead, use tint() to\n     * specify the color of the texture as it is applied to the shape.\n     *\n     * @param {PImage} pimage the texture to apply\n     *\n     * @returns none\n     *\n     * @see textureMode\n     * @see beginShape\n     * @see endShape\n     * @see vertex\n    */ p.texture = function(pimage) {\n                        var curContext = drawing.$ensureContext();\n                        if (pimage.__texture) curContext.bindTexture(curContext.TEXTURE_2D, pimage.__texture);\n                        else if (pimage.localName === \"canvas\") {\n                            curContext.bindTexture(curContext.TEXTURE_2D, canTex);\n                            curContext.texImage2D(curContext.TEXTURE_2D, 0, curContext.RGBA, curContext.RGBA, curContext.UNSIGNED_BYTE, pimage);\n                            curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MAG_FILTER, curContext.LINEAR);\n                            curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MIN_FILTER, curContext.LINEAR);\n                            curContext.generateMipmap(curContext.TEXTURE_2D);\n                            curTexture.width = pimage.width;\n                            curTexture.height = pimage.height;\n                        } else {\n                            var texture = curContext.createTexture(), cvs = document1.createElement(\"canvas\"), cvsTextureCtx = cvs.getContext(\"2d\"), pot;\n                            // WebGL requires power of two textures\n                            if (pimage.width & pimage.width - 1 === 0) cvs.width = pimage.width;\n                            else {\n                                pot = 1;\n                                while(pot < pimage.width)pot *= 2;\n                                cvs.width = pot;\n                            }\n                            if (pimage.height & pimage.height - 1 === 0) cvs.height = pimage.height;\n                            else {\n                                pot = 1;\n                                while(pot < pimage.height)pot *= 2;\n                                cvs.height = pot;\n                            }\n                            cvsTextureCtx.drawImage(pimage.sourceImg, 0, 0, pimage.width, pimage.height, 0, 0, cvs.width, cvs.height);\n                            curContext.bindTexture(curContext.TEXTURE_2D, texture);\n                            curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MIN_FILTER, curContext.LINEAR_MIPMAP_LINEAR);\n                            curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MAG_FILTER, curContext.LINEAR);\n                            curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_WRAP_T, curContext.CLAMP_TO_EDGE);\n                            curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_WRAP_S, curContext.CLAMP_TO_EDGE);\n                            curContext.texImage2D(curContext.TEXTURE_2D, 0, curContext.RGBA, curContext.RGBA, curContext.UNSIGNED_BYTE, cvs);\n                            curContext.generateMipmap(curContext.TEXTURE_2D);\n                            pimage.__texture = texture;\n                            curTexture.width = pimage.width;\n                            curTexture.height = pimage.height;\n                        }\n                        usingTexture = true;\n                        curContext.useProgram(programObject3D);\n                        uniformi(\"usingTexture3d\", programObject3D, \"uUsingTexture\", usingTexture);\n                    };\n                    /**\n     * Sets the coordinate space for texture mapping. There are two options, IMAGE,\n     * which refers to the actual coordinates of the image, and NORMALIZED, which\n     * refers to a normalized space of values ranging from 0 to 1. The default mode\n     * is IMAGE. In IMAGE, if an image is 100 x 200 pixels, mapping the image onto\n     * the entire size of a quad would require the points (0,0) (0,100) (100,200) (0,200).\n     * The same mapping in NORMAL_SPACE is (0,0) (0,1) (1,1) (0,1).\n     *\n     * @param MODE either IMAGE or NORMALIZED\n     *\n     * @returns none\n     *\n     * @see texture\n    */ p.textureMode = function(mode) {\n                        curTextureMode = mode;\n                    };\n                    /**\n     * The curveVertexSegment() function handle emitting a specific segment of Catmull-Rom curve. Internal helper function used by <b>curveVertex()</b>.\n     */ var curveVertexSegment = function(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {\n                        var x0 = x2;\n                        var y0 = y2;\n                        var z0 = z2;\n                        var draw = curveDrawMatrix.array();\n                        var xplot1 = draw[4] * x1 + draw[5] * x2 + draw[6] * x3 + draw[7] * x4;\n                        var xplot2 = draw[8] * x1 + draw[9] * x2 + draw[10] * x3 + draw[11] * x4;\n                        var xplot3 = draw[12] * x1 + draw[13] * x2 + draw[14] * x3 + draw[15] * x4;\n                        var yplot1 = draw[4] * y1 + draw[5] * y2 + draw[6] * y3 + draw[7] * y4;\n                        var yplot2 = draw[8] * y1 + draw[9] * y2 + draw[10] * y3 + draw[11] * y4;\n                        var yplot3 = draw[12] * y1 + draw[13] * y2 + draw[14] * y3 + draw[15] * y4;\n                        var zplot1 = draw[4] * z1 + draw[5] * z2 + draw[6] * z3 + draw[7] * z4;\n                        var zplot2 = draw[8] * z1 + draw[9] * z2 + draw[10] * z3 + draw[11] * z4;\n                        var zplot3 = draw[12] * z1 + draw[13] * z2 + draw[14] * z3 + draw[15] * z4;\n                        p.vertex(x0, y0, z0);\n                        for(var j = 0; j < curveDet; j++){\n                            x0 += xplot1;\n                            xplot1 += xplot2;\n                            xplot2 += xplot3;\n                            y0 += yplot1;\n                            yplot1 += yplot2;\n                            yplot2 += yplot3;\n                            z0 += zplot1;\n                            zplot1 += zplot2;\n                            zplot2 += zplot3;\n                            p.vertex(x0, y0, z0);\n                        }\n                    };\n                    /**\n     * Specifies vertex coordinates for curves. This function may only be used between <b>beginShape()</b> and\n     * <b>endShape()</b> and only when there is no MODE parameter specified to <b>beginShape()</b>. The first and last points\n     * in a series of <b>curveVertex()</b> lines will be used to guide the beginning and end of a the curve. A minimum of four\n     * points is required to draw a tiny curve between the second and third points. Adding a fifth point with\n     * <b>curveVertex()</b> will draw the curve between the second, third, and fourth points. The <b>curveVertex()</b> function\n     * is an implementation of Catmull-Rom splines. Using the 3D version of requires rendering with P3D or OPENGL (see the\n     * Environment reference for more information). <br /> <br /><b>NOTE: </b> Fill does not work properly yet.\n     *\n     * @param {float | int} x The x-coordinate of the vertex\n     * @param {float | int} y The y-coordinate of the vertex\n     * @param {float | int} z The z-coordinate of the vertex\n     *\n     * @see curve\n     * @see beginShape\n     * @see endShape\n     * @see vertex\n     * @see bezierVertex\n     */ Drawing2D.prototype.curveVertex = function(x, y) {\n                        isCurve = true;\n                        p.vertex(x, y);\n                    };\n                    Drawing3D.prototype.curveVertex = function(x, y, z) {\n                        isCurve = true;\n                        if (!curveInited) curveInit();\n                        var vert = [];\n                        vert[0] = x;\n                        vert[1] = y;\n                        vert[2] = z;\n                        curveVertArray.push(vert);\n                        curveVertCount++;\n                        if (curveVertCount > 3) curveVertexSegment(curveVertArray[curveVertCount - 4][0], curveVertArray[curveVertCount - 4][1], curveVertArray[curveVertCount - 4][2], curveVertArray[curveVertCount - 3][0], curveVertArray[curveVertCount - 3][1], curveVertArray[curveVertCount - 3][2], curveVertArray[curveVertCount - 2][0], curveVertArray[curveVertCount - 2][1], curveVertArray[curveVertCount - 2][2], curveVertArray[curveVertCount - 1][0], curveVertArray[curveVertCount - 1][1], curveVertArray[curveVertCount - 1][2]);\n                    };\n                    /**\n     * The curve() function draws a curved line on the screen. The first and second parameters\n     * specify the beginning control point and the last two parameters specify\n     * the ending control point. The middle parameters specify the start and\n     * stop of the curve. Longer curves can be created by putting a series of\n     * <b>curve()</b> functions together or using <b>curveVertex()</b>.\n     * An additional function called <b>curveTightness()</b> provides control\n     * for the visual quality of the curve. The <b>curve()</b> function is an\n     * implementation of Catmull-Rom splines. Using the 3D version of requires\n     * rendering with P3D or OPENGL (see the Environment reference for more\n     * information).\n     *\n     * @param {int|float} x1 coordinates for the beginning control point\n     * @param {int|float} y1 coordinates for the beginning control point\n     * @param {int|float} z1 coordinates for the beginning control point\n     * @param {int|float} x2 coordinates for the first point\n     * @param {int|float} y2 coordinates for the first point\n     * @param {int|float} z2 coordinates for the first point\n     * @param {int|float} x3 coordinates for the second point\n     * @param {int|float} y3 coordinates for the second point\n     * @param {int|float} z3 coordinates for the second point\n     * @param {int|float} x4 coordinates for the ending control point\n     * @param {int|float} y4 coordinates for the ending control point\n     * @param {int|float} z4 coordinates for the ending control point\n     *\n     * @see #curveVertex()\n     * @see #curveTightness()\n     * @see #bezier()\n     */ Drawing2D.prototype.curve = function(x1, y1, x2, y2, x3, y3, x4, y4) {\n                        p.beginShape();\n                        p.curveVertex(x1, y1);\n                        p.curveVertex(x2, y2);\n                        p.curveVertex(x3, y3);\n                        p.curveVertex(x4, y4);\n                        p.endShape();\n                    };\n                    Drawing3D.prototype.curve = function(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {\n                        if (z4 !== undef) {\n                            p.beginShape();\n                            p.curveVertex(x1, y1, z1);\n                            p.curveVertex(x2, y2, z2);\n                            p.curveVertex(x3, y3, z3);\n                            p.curveVertex(x4, y4, z4);\n                            p.endShape();\n                            return;\n                        }\n                        p.beginShape();\n                        p.curveVertex(x1, y1);\n                        p.curveVertex(z1, x2);\n                        p.curveVertex(y2, z2);\n                        p.curveVertex(x3, y3);\n                        p.endShape();\n                    };\n                    /**\n     * The curveTightness() function modifies the quality of forms created with <b>curve()</b> and\n     * <b>curveVertex()</b>. The parameter <b>squishy</b> determines how the\n     * curve fits to the vertex points. The value 0.0 is the default value for\n     * <b>squishy</b> (this value defines the curves to be Catmull-Rom splines)\n     * and the value 1.0 connects all the points with straight lines.\n     * Values within the range -5.0 and 5.0 will deform the curves but\n     * will leave them recognizable and as values increase in magnitude,\n     * they will continue to deform.\n     *\n     * @param {float} tightness amount of deformation from the original vertices\n     *\n     * @see #curve()\n     * @see #curveVertex()\n     *\n     */ p.curveTightness = function(tightness) {\n                        curTightness = tightness;\n                    };\n                    /**\n     * The curveDetail() function sets the resolution at which curves display. The default value is 20.\n     * This function is only useful when using the P3D or OPENGL renderer.\n     *\n     * @param {int} detail resolution of the curves\n     *\n     * @see curve()\n     * @see curveVertex()\n     * @see curveTightness()\n     */ p.curveDetail = function(detail) {\n                        curveDet = detail;\n                        curveInit();\n                    };\n                    /**\n    * Modifies the location from which rectangles draw. The default mode is rectMode(CORNER), which\n    * specifies the location to be the upper left corner of the shape and uses the third and fourth\n    * parameters of rect() to specify the width and height. The syntax rectMode(CORNERS) uses the\n    * first and second parameters of rect() to set the location of one corner and uses the third and\n    * fourth parameters to set the opposite corner. The syntax rectMode(CENTER) draws the image from\n    * its center point and uses the third and forth parameters of rect() to specify the image's width\n    * and height. The syntax rectMode(RADIUS) draws the image from its center point and uses the third\n    * and forth parameters of rect()  to specify half of the image's width and height. The parameter must\n    * be written in ALL CAPS because Processing is a case sensitive language. Note: In version 125, the\n    * mode named CENTER_RADIUS was shortened to RADIUS.\n    *\n    * @param {MODE} MODE      Either CORNER, CORNERS, CENTER, or RADIUS\n    *\n    * @see rect\n    */ p.rectMode = function(aRectMode) {\n                        curRectMode = aRectMode;\n                    };\n                    /**\n    * Modifies the location from which images draw. The default mode is imageMode(CORNER), which specifies\n    * the location to be the upper left corner and uses the fourth and fifth parameters of image() to set\n    * the image's width and height. The syntax imageMode(CORNERS) uses the second and third parameters of\n    * image() to set the location of one corner of the image and uses the fourth and fifth parameters to\n    * set the opposite corner. Use imageMode(CENTER) to draw images centered at the given x and y position.\n    * The parameter to imageMode() must be written in ALL CAPS because Processing is a case sensitive language.\n    *\n    * @param {MODE} MODE      Either CORNER, CORNERS, or CENTER\n    *\n    * @see loadImage\n    * @see PImage\n    * @see image\n    * @see background\n    */ p.imageMode = function(mode) {\n                        switch(mode){\n                            case PConstants1.CORNER:\n                                imageModeConvert1 = imageModeCorner;\n                                break;\n                            case PConstants1.CORNERS:\n                                imageModeConvert1 = imageModeCorners;\n                                break;\n                            case PConstants1.CENTER:\n                                imageModeConvert1 = imageModeCenter;\n                                break;\n                            default:\n                                throw \"Invalid imageMode\";\n                        }\n                    };\n                    /**\n    * The origin of the ellipse is modified by the ellipseMode() function. The default configuration is\n    * ellipseMode(CENTER), which specifies the location of the ellipse as the center of the shape. The RADIUS\n    * mode is the same, but the width and height parameters to ellipse()  specify the radius of the ellipse,\n    * rather than the diameter. The CORNER mode draws the shape from the upper-left corner of its bounding box.\n    * The CORNERS mode uses the four parameters to ellipse() to set two opposing corners of the ellipse's bounding\n    * box. The parameter must be written in \"ALL CAPS\" because Processing is a case sensitive language.\n    *\n    * @param {MODE} MODE      Either CENTER, RADIUS, CORNER, or CORNERS.\n    *\n    * @see ellipse\n    */ p.ellipseMode = function(aEllipseMode) {\n                        curEllipseMode1 = aEllipseMode;\n                    };\n                    /**\n     * The arc() function draws an arc in the display window.\n     * Arcs are drawn along the outer edge of an ellipse defined by the\n     * <b>x</b>, <b>y</b>, <b>width</b> and <b>height</b> parameters.\n     * The origin or the arc's ellipse may be changed with the\n     * <b>ellipseMode()</b> function.\n     * The <b>start</b> and <b>stop</b> parameters specify the angles\n     * at which to draw the arc.\n     *\n     * @param {float} a       x-coordinate of the arc's ellipse\n     * @param {float} b       y-coordinate of the arc's ellipse\n     * @param {float} c       width of the arc's ellipse\n     * @param {float} d       height of the arc's ellipse\n     * @param {float} start   angle to start the arc, specified in radians\n     * @param {float} stop    angle to stop the arc, specified in radians\n     * @param {enum}  mode    drawing mode (OPEN, CHORD, PIE)\n     *\n     * @see #ellipseMode()\n     * @see #ellipse()\n     */ p.arc = function(x, y, width, height, start, stop, mode) {\n                        if (width <= 0 || stop < start) return;\n                        if (curEllipseMode1 === PConstants1.CORNERS) {\n                            width = width - x;\n                            height = height - y;\n                        } else if (curEllipseMode1 === PConstants1.RADIUS) {\n                            x = x - width;\n                            y = y - height;\n                            width = width * 2;\n                            height = height * 2;\n                        } else if (curEllipseMode1 === PConstants1.CENTER) {\n                            x = x - width / 2;\n                            y = y - height / 2;\n                        }\n                        // make sure that we're starting at a useful point\n                        while(start < 0){\n                            start += PConstants1.TWO_PI;\n                            stop += PConstants1.TWO_PI;\n                        }\n                        if (stop - start > PConstants1.TWO_PI) // don't change start, it is visible in PIE mode\n                        stop = start + PConstants1.TWO_PI;\n                        var hr = width / 2, vr = height / 2, centerX = x + hr, centerY = y + vr, step = 1 / (hr + vr);\n                        var drawSlice = function(x, y, start, step, stop) {\n                            return function(p, closed, i, a, e) {\n                                i = 0;\n                                a = start;\n                                e = stop + step;\n                                p.beginShape();\n                                if (closed) p.vertex(x - 0.5, y - 0.5);\n                                for(; a < e; i++, a = i * step + start)p.vertex(x + Math.cos(a) * hr | 0, y + Math.sin(a) * vr | 0);\n                                if (mode === PConstants1.OPEN && doFill) p.vertex(centerX + Math.cos(start) * hr, centerY + Math.sin(start) * vr);\n                                else if (mode === PConstants1.CHORD) p.vertex(centerX + Math.cos(start) * hr, centerY + Math.sin(start) * vr);\n                                else if (mode === PConstants1.PIE) {\n                                    p.line(centerX + Math.cos(start) * hr, centerY + Math.sin(start) * vr, centerX, centerY);\n                                    p.line(centerX, centerY, centerX + Math.cos(stop) * hr, centerY + Math.sin(stop) * vr);\n                                }\n                                p.endShape(closed ? PConstants1.CLOSE : undefined);\n                            };\n                        }(centerX + 0.5, centerY + 0.5, start, step, stop);\n                        if (doFill) {\n                            var savedStroke = doStroke;\n                            doStroke = false;\n                            drawSlice(p, true);\n                            doStroke = savedStroke;\n                        }\n                        if (doStroke) {\n                            var savedFill = doFill;\n                            doFill = false;\n                            drawSlice(p);\n                            doFill = savedFill;\n                        }\n                    };\n                    /**\n    * Draws a line (a direct path between two points) to the screen. The version of line() with four parameters\n    * draws the line in 2D. To color a line, use the stroke() function. A line cannot be filled, therefore the\n    * fill()  method will not affect the color of a line. 2D lines are drawn with a width of one pixel by default,\n    * but this can be changed with the strokeWeight()  function. The version with six parameters allows the line\n    * to be placed anywhere within XYZ space. Drawing this shape in 3D using the z parameter requires the P3D or\n    * OPENGL parameter in combination with size.\n    *\n    * @param {int|float} x1       x-coordinate of the first point\n    * @param {int|float} y1       y-coordinate of the first point\n    * @param {int|float} z1       z-coordinate of the first point\n    * @param {int|float} x2       x-coordinate of the second point\n    * @param {int|float} y2       y-coordinate of the second point\n    * @param {int|float} z2       z-coordinate of the second point\n    *\n    * @see strokeWeight\n    * @see strokeJoin\n    * @see strokeCap\n    * @see beginShape\n    */ Drawing2D.prototype.line = function(x1, y1, x2, y2) {\n                        if (!doStroke) return;\n                        if (!renderSmooth) {\n                            x1 = Math.round(x1);\n                            x2 = Math.round(x2);\n                            y1 = Math.round(y1);\n                            y2 = Math.round(y2);\n                        }\n                        // A line is only defined if it has different start and end coordinates.\n                        // If they are the same, we call point instead.\n                        if (x1 === x2 && y1 === y2) {\n                            p.point(x1, y1);\n                            return;\n                        }\n                        var swap = undef, lineCap = undef, drawCrisp = true, currentModelView = modelView.array(), identityMatrix = [\n                            1,\n                            0,\n                            0,\n                            0,\n                            1,\n                            0\n                        ];\n                        // Test if any transformations have been applied to the sketch\n                        for(var i = 0; i < 6 && drawCrisp; i++)drawCrisp = currentModelView[i] === identityMatrix[i];\n                        /* Draw crisp lines if the line is vertical or horizontal with the following method\n       * If any transformations have been applied to the sketch, don't make the line crisp\n       * If the line is directed up or to the left, reverse it by swapping x1/x2 or y1/y2\n       * Make the line 1 pixel longer to work around cross-platform canvas implementations\n       * If the lineWidth is odd, translate the line by 0.5 in the perpendicular direction\n       * Even lineWidths do not need to be translated because the canvas will draw them on pixel boundaries\n       * Change the cap to butt-end to work around cross-platform canvas implementations\n       * Reverse the translate and lineCap canvas state changes after drawing the line\n       */ if (drawCrisp) {\n                            if (x1 === x2) {\n                                if (y1 > y2) {\n                                    swap = y1;\n                                    y1 = y2;\n                                    y2 = swap;\n                                }\n                                y2++;\n                                if (lineWidth % 2 === 1) curContext.translate(0.5, 0.0);\n                            } else if (y1 === y2) {\n                                if (x1 > x2) {\n                                    swap = x1;\n                                    x1 = x2;\n                                    x2 = swap;\n                                }\n                                x2++;\n                                if (lineWidth % 2 === 1) curContext.translate(0.0, 0.5);\n                            }\n                            if (lineWidth === 1) {\n                                lineCap = curContext.lineCap;\n                                curContext.lineCap = \"butt\";\n                            }\n                        }\n                        curContext.beginPath();\n                        curContext.moveTo(x1 || 0, y1 || 0);\n                        curContext.lineTo(x2 || 0, y2 || 0);\n                        executeContextStroke();\n                        if (drawCrisp) {\n                            if (x1 === x2 && lineWidth % 2 === 1) curContext.translate(-0.5, 0.0);\n                            else if (y1 === y2 && lineWidth % 2 === 1) curContext.translate(0.0, -0.5);\n                            if (lineWidth === 1) curContext.lineCap = lineCap;\n                        }\n                    };\n                    Drawing3D.prototype.line = function(x1, y1, z1, x2, y2, z2) {\n                        if (y2 === undef || z2 === undef) {\n                            z2 = 0;\n                            y2 = x2;\n                            x2 = z1;\n                            z1 = 0;\n                        }\n                        // a line is only defined if it has different start and end coordinates.\n                        // If they are the same, we call point instead.\n                        if (x1 === x2 && y1 === y2 && z1 === z2) {\n                            p.point(x1, y1, z1);\n                            return;\n                        }\n                        var lineVerts = [\n                            x1,\n                            y1,\n                            z1,\n                            x2,\n                            y2,\n                            z2\n                        ];\n                        var view = new PMatrix3D();\n                        view.scale(1, -1, 1);\n                        view.apply(modelView.array());\n                        view.transpose();\n                        if (lineWidth > 0 && doStroke) {\n                            curContext.useProgram(programObject2D);\n                            uniformMatrix(\"uModel2d\", programObject2D, \"uModel\", false, [\n                                1,\n                                0,\n                                0,\n                                0,\n                                0,\n                                1,\n                                0,\n                                0,\n                                0,\n                                0,\n                                1,\n                                0,\n                                0,\n                                0,\n                                0,\n                                1\n                            ]);\n                            uniformMatrix(\"uView2d\", programObject2D, \"uView\", false, view.array());\n                            uniformf(\"uColor2d\", programObject2D, \"uColor\", strokeStyle);\n                            uniformi(\"uIsDrawingText\", programObject2D, \"uIsDrawingText\", false);\n                            vertexAttribPointer(\"aVertex2d\", programObject2D, \"aVertex\", 3, lineBuffer);\n                            disableVertexAttribPointer(\"aTextureCoord2d\", programObject2D, \"aTextureCoord\");\n                            curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(lineVerts), curContext.STREAM_DRAW);\n                            curContext.drawArrays(curContext.LINES, 0, 2);\n                        }\n                    };\n                    /**\n     * Draws a Bezier curve on the screen. These curves are defined by a series of anchor and control points. The first\n     * two parameters specify the first anchor point and the last two parameters specify the other anchor point. The\n     * middle parameters specify the control points which define the shape of the curve. Bezier curves were developed\n     * by French engineer Pierre Bezier. Using the 3D version of requires rendering with P3D or OPENGL (see the\n     * Environment reference for more information).\n     *\n     * @param {int | float} x1,y1,z1    coordinates for the first anchor point\n     * @param {int | float} cx1,cy1,cz1 coordinates for the first control point\n     * @param {int | float} cx2,cy2,cz2 coordinates for the second control point\n     * @param {int | float} x2,y2,z2    coordinates for the second anchor point\n     *\n     * @see bezierVertex\n     * @see curve\n     */ Drawing2D.prototype.bezier = function() {\n                        if (arguments.length !== 8) throw \"You must use 8 parameters for bezier() in 2D mode\";\n                        p.beginShape();\n                        p.vertex(arguments[0], arguments[1]);\n                        p.bezierVertex(arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7]);\n                        p.endShape();\n                    };\n                    Drawing3D.prototype.bezier = function() {\n                        if (arguments.length !== 12) throw \"You must use 12 parameters for bezier() in 3D mode\";\n                        p.beginShape();\n                        p.vertex(arguments[0], arguments[1], arguments[2]);\n                        p.bezierVertex(arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8], arguments[9], arguments[10], arguments[11]);\n                        p.endShape();\n                    };\n                    /**\n     * Sets the resolution at which Beziers display. The default value is 20. This function is only useful when using the P3D\n     * or OPENGL renderer as the default (JAVA2D) renderer does not use this information.\n     *\n     * @param {int} detail resolution of the curves\n     *\n     * @see curve\n     * @see curveVertex\n     * @see curveTightness\n     */ p.bezierDetail = function(detail) {\n                        bezDetail = detail;\n                    };\n                    /**\n     * The bezierPoint() function evalutes quadratic bezier at point t for points a, b, c, d.\n     * The parameter t varies between 0 and 1. The a and d parameters are the\n     * on-curve points, b and c are the control points. To make a two-dimensional\n     * curve, call this function once with the x coordinates and a second time\n     * with the y coordinates to get the location of a bezier curve at t.\n     *\n     * @param {float} a   coordinate of first point on the curve\n     * @param {float} b   coordinate of first control point\n     * @param {float} c   coordinate of second control point\n     * @param {float} d   coordinate of second point on the curve\n     * @param {float} t   value between 0 and 1\n     *\n     * @see #bezier()\n     * @see #bezierVertex()\n     * @see #curvePoint()\n     */ p.bezierPoint = function(a, b, c, d, t1) {\n                        return (1 - t1) * (1 - t1) * (1 - t1) * a + 3 * (1 - t1) * (1 - t1) * t1 * b + 3 * (1 - t1) * t1 * t1 * c + t1 * t1 * t1 * d;\n                    };\n                    /**\n     * The bezierTangent() function calculates the tangent of a point on a Bezier curve. There is a good\n     * definition of \"tangent\" at Wikipedia: <a href=\"http://en.wikipedia.org/wiki/Tangent\" target=\"new\">http://en.wikipedia.org/wiki/Tangent</a>\n     *\n     * @param {float} a   coordinate of first point on the curve\n     * @param {float} b   coordinate of first control point\n     * @param {float} c   coordinate of second control point\n     * @param {float} d   coordinate of second point on the curve\n     * @param {float} t   value between 0 and 1\n     *\n     * @see #bezier()\n     * @see #bezierVertex()\n     * @see #curvePoint()\n     */ p.bezierTangent = function(a, b, c, d, t1) {\n                        return 3 * t1 * t1 * (-a + 3 * b - 3 * c + d) + 6 * t1 * (a - 2 * b + c) + 3 * (-a + b);\n                    };\n                    /**\n     * The curvePoint() function evalutes the Catmull-Rom curve at point t for points a, b, c, d. The\n     * parameter t varies between 0 and 1, a and d are points on the curve,\n     * and b and c are the control points. This can be done once with the x\n     * coordinates and a second time with the y coordinates to get the\n     * location of a curve at t.\n     *\n     * @param {int|float} a   coordinate of first point on the curve\n     * @param {int|float} b   coordinate of second point on the curve\n     * @param {int|float} c   coordinate of third point on the curve\n     * @param {int|float} d   coordinate of fourth point on the curve\n     * @param {float} t       value between 0 and 1\n     *\n     * @see #curve()\n     * @see #curveVertex()\n     * @see #bezierPoint()\n     */ p.curvePoint = function(a, b, c, d, t1) {\n                        return 0.5 * (2 * b + (-a + c) * t1 + (2 * a - 5 * b + 4 * c - d) * t1 * t1 + (-a + 3 * b - 3 * c + d) * t1 * t1 * t1);\n                    };\n                    /**\n     * The curveTangent() function calculates the tangent of a point on a Catmull-Rom curve.\n     * There is a good definition of \"tangent\" at Wikipedia: <a href=\"http://en.wikipedia.org/wiki/Tangent\" target=\"new\">http://en.wikipedia.org/wiki/Tangent</a>.\n     *\n     * @param {int|float} a   coordinate of first point on the curve\n     * @param {int|float} b   coordinate of first control point\n     * @param {int|float} c   coordinate of second control point\n     * @param {int|float} d   coordinate of second point on the curve\n     * @param {float} t       value between 0 and 1\n     *\n     * @see #curve()\n     * @see #curveVertex()\n     * @see #curvePoint()\n     * @see #bezierTangent()\n     */ p.curveTangent = function(a, b, c, d, t1) {\n                        return 0.5 * (-a + c + 2 * (2 * a - 5 * b + 4 * c - d) * t1 + 3 * (-a + 3 * b - 3 * c + d) * t1 * t1);\n                    };\n                    /**\n     * A triangle is a plane created by connecting three points. The first two arguments specify the first point,\n     * the middle two arguments specify the second point, and the last two arguments specify the third point.\n     *\n     * @param {int | float} x1 x-coordinate of the first point\n     * @param {int | float} y1 y-coordinate of the first point\n     * @param {int | float} x2 x-coordinate of the second point\n     * @param {int | float} y2 y-coordinate of the second point\n     * @param {int | float} x3 x-coordinate of the third point\n     * @param {int | float} y3 y-coordinate of the third point\n     */ p.triangle = function(x1, y1, x2, y2, x3, y3) {\n                        p.beginShape(PConstants1.TRIANGLES);\n                        p.vertex(x1, y1, 0);\n                        p.vertex(x2, y2, 0);\n                        p.vertex(x3, y3, 0);\n                        p.endShape();\n                    };\n                    /**\n     * A quad is a quadrilateral, a four sided polygon. It is similar to a rectangle, but the angles between its\n     * edges are not constrained to ninety degrees. The first pair of parameters (x1,y1) sets the first vertex\n     * and the subsequent pairs should proceed clockwise or counter-clockwise around the defined shape.\n     *\n     * @param {float | int} x1 x-coordinate of the first corner\n     * @param {float | int} y1 y-coordinate of the first corner\n     * @param {float | int} x2 x-coordinate of the second corner\n     * @param {float | int} y2 y-coordinate of the second corner\n     * @param {float | int} x3 x-coordinate of the third corner\n     * @param {float | int} y3 y-coordinate of the third corner\n     * @param {float | int} x4 x-coordinate of the fourth corner\n     * @param {float | int} y4 y-coordinate of the fourth corner\n     */ p.quad = function(x1, y1, x2, y2, x3, y3, x4, y4) {\n                        p.beginShape(PConstants1.QUADS);\n                        p.vertex(x1, y1, 0);\n                        p.vertex(x2, y2, 0);\n                        p.vertex(x3, y3, 0);\n                        p.vertex(x4, y4, 0);\n                        p.endShape();\n                    };\n                    var roundedRect$2d = function(x, y, width, height, tl, tr, br, bl) {\n                        if (bl === undef) {\n                            tr = tl;\n                            br = tl;\n                            bl = tl;\n                        }\n                        var halfWidth = width / 2, halfHeight = height / 2;\n                        if (tl > halfWidth || tl > halfHeight) tl = Math.min(halfWidth, halfHeight);\n                        if (tr > halfWidth || tr > halfHeight) tr = Math.min(halfWidth, halfHeight);\n                        if (br > halfWidth || br > halfHeight) br = Math.min(halfWidth, halfHeight);\n                        if (bl > halfWidth || bl > halfHeight) bl = Math.min(halfWidth, halfHeight);\n                        // Translate the stroke by (0.5, 0.5) to draw a crisp border\n                        if (!doFill || doStroke) curContext.translate(0.5, 0.5);\n                        curContext.beginPath();\n                        curContext.moveTo(x + tl, y);\n                        curContext.lineTo(x + width - tr, y);\n                        curContext.quadraticCurveTo(x + width, y, x + width, y + tr);\n                        curContext.lineTo(x + width, y + height - br);\n                        curContext.quadraticCurveTo(x + width, y + height, x + width - br, y + height);\n                        curContext.lineTo(x + bl, y + height);\n                        curContext.quadraticCurveTo(x, y + height, x, y + height - bl);\n                        curContext.lineTo(x, y + tl);\n                        curContext.quadraticCurveTo(x, y, x + tl, y);\n                        if (!doFill || doStroke) curContext.translate(-0.5, -0.5);\n                        executeContextFill();\n                        executeContextStroke();\n                    };\n                    /**\n    * Draws a rectangle to the screen. A rectangle is a four-sided shape with every angle at ninety\n    * degrees. The first two parameters set the location, the third sets the width, and the fourth\n    * sets the height. The origin is changed with the rectMode() function.\n    *\n    * @param {int|float} x        x-coordinate of the rectangle\n    * @param {int|float} y        y-coordinate of the rectangle\n    * @param {int|float} width    width of the rectangle\n    * @param {int|float} height   height of the rectangle\n    *\n    * @see rectMode\n    * @see quad\n    */ Drawing2D.prototype.rect = function(x, y, width, height, tl, tr, br, bl) {\n                        // width and height need to be defined, numerical values\n                        if (width != \"\" + width && height != \"\" + height) return;\n                        if (curRectMode === PConstants1.CORNERS) {\n                            width -= x;\n                            height -= y;\n                        } else if (curRectMode === PConstants1.RADIUS) {\n                            width *= 2;\n                            height *= 2;\n                            x -= width / 2;\n                            y -= height / 2;\n                        } else if (curRectMode === PConstants1.CENTER) {\n                            x -= width / 2;\n                            y -= height / 2;\n                        }\n                        if (!renderSmooth) {\n                            x = Math.round(x);\n                            y = Math.round(y);\n                            width = Math.round(width);\n                            height = Math.round(height);\n                        }\n                        if (tl !== undef) {\n                            roundedRect$2d(x, y, width, height, tl, tr, br, bl);\n                            return;\n                        }\n                        // Translate the line by (0.5, 0.5) to draw a crisp rectangle border\n                        if (doStroke && lineWidth % 2 === 1) curContext.translate(0.5, 0.5);\n                        curContext.beginPath();\n                        curContext.rect(x, y, width, height);\n                        executeContextFill();\n                        executeContextStroke();\n                        if (doStroke && lineWidth % 2 === 1) curContext.translate(-0.5, -0.5);\n                    };\n                    Drawing3D.prototype.rect = function(x, y, width, height, tl, tr, br, bl) {\n                        if (tl !== undef) throw \"rect() with rounded corners is not supported in 3D mode\";\n                        if (curRectMode === PConstants1.CORNERS) {\n                            width -= x;\n                            height -= y;\n                        } else if (curRectMode === PConstants1.RADIUS) {\n                            width *= 2;\n                            height *= 2;\n                            x -= width / 2;\n                            y -= height / 2;\n                        } else if (curRectMode === PConstants1.CENTER) {\n                            x -= width / 2;\n                            y -= height / 2;\n                        }\n                        // Modeling transformation\n                        var model = new PMatrix3D();\n                        model.translate(x, y, 0);\n                        model.scale(width, height, 1);\n                        model.transpose();\n                        // viewing transformation needs to have Y flipped\n                        // becuase that's what Processing does.\n                        var view = new PMatrix3D();\n                        view.scale(1, -1, 1);\n                        view.apply(modelView.array());\n                        view.transpose();\n                        if (lineWidth > 0 && doStroke) {\n                            curContext.useProgram(programObject2D);\n                            uniformMatrix(\"uModel2d\", programObject2D, \"uModel\", false, model.array());\n                            uniformMatrix(\"uView2d\", programObject2D, \"uView\", false, view.array());\n                            uniformf(\"uColor2d\", programObject2D, \"uColor\", strokeStyle);\n                            uniformi(\"uIsDrawingText2d\", programObject2D, \"uIsDrawingText\", false);\n                            vertexAttribPointer(\"aVertex2d\", programObject2D, \"aVertex\", 3, rectBuffer);\n                            disableVertexAttribPointer(\"aTextureCoord2d\", programObject2D, \"aTextureCoord\");\n                            curContext.drawArrays(curContext.LINE_LOOP, 0, rectVerts.length / 3);\n                        }\n                        if (doFill) {\n                            curContext.useProgram(programObject3D);\n                            uniformMatrix(\"uModel3d\", programObject3D, \"uModel\", false, model.array());\n                            uniformMatrix(\"uView3d\", programObject3D, \"uView\", false, view.array());\n                            // fix stitching problems. (lines get occluded by triangles\n                            // since they share the same depth values). This is not entirely\n                            // working, but it's a start for drawing the outline. So\n                            // developers can start playing around with styles.\n                            curContext.enable(curContext.POLYGON_OFFSET_FILL);\n                            curContext.polygonOffset(1, 1);\n                            uniformf(\"color3d\", programObject3D, \"uColor\", fillStyle);\n                            if (lightCount > 0) {\n                                var v = new PMatrix3D();\n                                v.set(view);\n                                var m = new PMatrix3D();\n                                m.set(model);\n                                v.mult(m);\n                                var normalMatrix = new PMatrix3D();\n                                normalMatrix.set(v);\n                                normalMatrix.invert();\n                                normalMatrix.transpose();\n                                uniformMatrix(\"uNormalTransform3d\", programObject3D, \"uNormalTransform\", false, normalMatrix.array());\n                                vertexAttribPointer(\"aNormal3d\", programObject3D, \"aNormal\", 3, rectNormBuffer);\n                            } else disableVertexAttribPointer(\"normal3d\", programObject3D, \"aNormal\");\n                            vertexAttribPointer(\"vertex3d\", programObject3D, \"aVertex\", 3, rectBuffer);\n                            curContext.drawArrays(curContext.TRIANGLE_FAN, 0, rectVerts.length / 3);\n                            curContext.disable(curContext.POLYGON_OFFSET_FILL);\n                        }\n                    };\n                    /**\n     * Draws an ellipse (oval) in the display window. An ellipse with an equal <b>width</b> and <b>height</b> is a circle.\n     * The first two parameters set the location, the third sets the width, and the fourth sets the height. The origin may be\n     * changed with the <b>ellipseMode()</b> function.\n     *\n     * @param {float|int} x      x-coordinate of the ellipse\n     * @param {float|int} y      y-coordinate of the ellipse\n     * @param {float|int} width  width of the ellipse\n     * @param {float|int} height height of the ellipse\n     *\n     * @see ellipseMode\n     */ Drawing2D.prototype.ellipse = function(x, y, width, height) {\n                        x = x || 0;\n                        y = y || 0;\n                        if (width <= 0 && height <= 0) return;\n                        if (curEllipseMode1 === PConstants1.RADIUS) {\n                            width *= 2;\n                            height *= 2;\n                        } else if (curEllipseMode1 === PConstants1.CORNERS) {\n                            width = width - x;\n                            height = height - y;\n                            x += width / 2;\n                            y += height / 2;\n                        } else if (curEllipseMode1 === PConstants1.CORNER) {\n                            x += width / 2;\n                            y += height / 2;\n                        }\n                        // Shortcut for drawing a 2D circle\n                        if (width === height) {\n                            curContext.beginPath();\n                            curContext.arc(x, y, width / 2, 0, PConstants1.TWO_PI, false);\n                            executeContextFill();\n                            executeContextStroke();\n                        } else {\n                            var w = width / 2, h = height / 2, C = 0.5522847498307933, c_x = C * w, c_y = C * h;\n                            p.beginShape();\n                            p.vertex(x + w, y);\n                            p.bezierVertex(x + w, y - c_y, x + c_x, y - h, x, y - h);\n                            p.bezierVertex(x - c_x, y - h, x - w, y - c_y, x - w, y);\n                            p.bezierVertex(x - w, y + c_y, x - c_x, y + h, x, y + h);\n                            p.bezierVertex(x + c_x, y + h, x + w, y + c_y, x + w, y);\n                            p.endShape();\n                        }\n                    };\n                    Drawing3D.prototype.ellipse = function(x, y, width, height) {\n                        x = x || 0;\n                        y = y || 0;\n                        if (width <= 0 && height <= 0) return;\n                        if (curEllipseMode1 === PConstants1.RADIUS) {\n                            width *= 2;\n                            height *= 2;\n                        } else if (curEllipseMode1 === PConstants1.CORNERS) {\n                            width = width - x;\n                            height = height - y;\n                            x += width / 2;\n                            y += height / 2;\n                        } else if (curEllipseMode1 === PConstants1.CORNER) {\n                            x += width / 2;\n                            y += height / 2;\n                        }\n                        var w = width / 2, h = height / 2, C = 0.5522847498307933, c_x = C * w, c_y = C * h;\n                        p.beginShape();\n                        p.vertex(x + w, y);\n                        p.bezierVertex(x + w, y - c_y, 0, x + c_x, y - h, 0, x, y - h, 0);\n                        p.bezierVertex(x - c_x, y - h, 0, x - w, y - c_y, 0, x - w, y, 0);\n                        p.bezierVertex(x - w, y + c_y, 0, x - c_x, y + h, 0, x, y + h, 0);\n                        p.bezierVertex(x + c_x, y + h, 0, x + w, y + c_y, 0, x + w, y, 0);\n                        p.endShape();\n                        if (doFill) {\n                            //temporary workaround to not working fills for bezier -- will fix later\n                            var xAv = 0, yAv = 0, i, j;\n                            for(i = 0; i < vertArray1.length; i++){\n                                xAv += vertArray1[i][0];\n                                yAv += vertArray1[i][1];\n                            }\n                            xAv /= vertArray1.length;\n                            yAv /= vertArray1.length;\n                            var vert = [], fillVertArray = [], colorVertArray = [];\n                            vert[0] = xAv;\n                            vert[1] = yAv;\n                            vert[2] = 0;\n                            vert[3] = 0;\n                            vert[4] = 0;\n                            vert[5] = fillStyle[0];\n                            vert[6] = fillStyle[1];\n                            vert[7] = fillStyle[2];\n                            vert[8] = fillStyle[3];\n                            vert[9] = strokeStyle[0];\n                            vert[10] = strokeStyle[1];\n                            vert[11] = strokeStyle[2];\n                            vert[12] = strokeStyle[3];\n                            vert[13] = normalX;\n                            vert[14] = normalY;\n                            vert[15] = normalZ;\n                            vertArray1.unshift(vert);\n                            for(i = 0; i < vertArray1.length; i++){\n                                for(j = 0; j < 3; j++)fillVertArray.push(vertArray1[i][j]);\n                                for(j = 5; j < 9; j++)colorVertArray.push(vertArray1[i][j]);\n                            }\n                            fill3D(fillVertArray, \"TRIANGLE_FAN\", colorVertArray);\n                        }\n                    };\n                    /**\n    * Sets the current normal vector. This is for drawing three dimensional shapes and surfaces and\n    * specifies a vector perpendicular to the surface of the shape which determines how lighting affects\n    * it. Processing attempts to automatically assign normals to shapes, but since that's imperfect,\n    * this is a better option when you want more control. This function is identical to glNormal3f() in OpenGL.\n    *\n    * @param {float} nx       x direction\n    * @param {float} ny       y direction\n    * @param {float} nz       z direction\n    *\n    * @see beginShape\n    * @see endShape\n    * @see lights\n    */ p.normal = function(nx, ny, nz) {\n                        if (arguments.length !== 3 || !(typeof nx === \"number\" && typeof ny === \"number\" && typeof nz === \"number\")) throw \"normal() requires three numeric arguments.\";\n                        normalX = nx;\n                        normalY = ny;\n                        normalZ = nz;\n                        if (curShape !== 0) {\n                            if (normalMode === PConstants1.NORMAL_MODE_AUTO) normalMode = PConstants1.NORMAL_MODE_SHAPE;\n                            else if (normalMode === PConstants1.NORMAL_MODE_SHAPE) normalMode = PConstants1.NORMAL_MODE_VERTEX;\n                        }\n                    };\n                    ////////////////////////////////////////////////////////////////////////////\n                    // Raster drawing functions\n                    ////////////////////////////////////////////////////////////////////////////\n                    /**\n    * Saves an image from the display window. Images are saved in TIFF, TARGA, JPEG, and PNG format\n    * depending on the extension within the filename  parameter. For example, \"image.tif\" will have\n    * a TIFF image and \"image.png\" will save a PNG image. If no extension is included in the filename,\n    * the image will save in TIFF format and .tif will be added to the name. These files are saved to\n    * the sketch's folder, which may be opened by selecting \"Show sketch folder\" from the \"Sketch\" menu.\n    * It is not possible to use save() while running the program in a web browser.  All images saved\n    * from the main drawing window will be opaque. To save images without a background, use createGraphics().\n    *\n    * @param {String} filename      any sequence of letters and numbers\n    *\n    * @see saveFrame\n    * @see createGraphics\n    */ p.save = function(file, img) {\n                        // file is unused at the moment\n                        // may implement this differently in later release\n                        if (img !== undef) return window1.open(img.toDataURL(), \"_blank\");\n                        return window1.open(p.externals.canvas.toDataURL(), \"_blank\");\n                    };\n                    var saveNumber = 0;\n                    p.saveFrame = function(file) {\n                        if (file === undef) // use default name template if parameter is not specified\n                        file = \"screen-####.png\";\n                        // Increment changeable part: screen-0000.png, screen-0001.png, ...\n                        var frameFilename = file.replace(/#+/, function(all) {\n                            var s = \"\" + saveNumber++;\n                            while(s.length < all.length)s = \"0\" + s;\n                            return s;\n                        });\n                        p.save(frameFilename);\n                    };\n                    var utilityContext2d = document1.createElement(\"canvas\").getContext(\"2d\");\n                    var canvasDataCache = [\n                        undef,\n                        undef,\n                        undef\n                    ]; // we need three for now\n                    function getCanvasData(obj, w, h) {\n                        var canvasData = canvasDataCache.shift();\n                        if (canvasData === undef) {\n                            canvasData = {};\n                            canvasData.canvas = document1.createElement(\"canvas\");\n                            canvasData.context = canvasData.canvas.getContext(\"2d\");\n                        }\n                        canvasDataCache.push(canvasData);\n                        var canvas = canvasData.canvas, context = canvasData.context, width = w || obj.width, height = h || obj.height;\n                        canvas.width = width;\n                        canvas.height = height;\n                        if (!obj) context.clearRect(0, 0, width, height);\n                        else if (\"data\" in obj) context.putImageData(obj, 0, 0);\n                        else {\n                            context.clearRect(0, 0, width, height);\n                            context.drawImage(obj, 0, 0, width, height);\n                        }\n                        return canvasData;\n                    }\n                    /**\n     * Handle the sketch code for pixels[] and pixels.length\n     * parser code converts pixels[] to getPixels()\n     * or setPixels(), .length becomes getLength()\n     */ function buildPixelsObject(pImage) {\n                        return {\n                            getLength: function(aImg) {\n                                return function() {\n                                    if (aImg.isRemote) throw \"Image is loaded remotely. Cannot get length.\";\n                                    else return aImg.imageData.data.length ? aImg.imageData.data.length / 4 : 0;\n                                };\n                            }(pImage),\n                            getPixel: function(aImg) {\n                                return function(i) {\n                                    var offset = i * 4, data = aImg.imageData.data;\n                                    if (aImg.isRemote) throw \"Image is loaded remotely. Cannot get pixels.\";\n                                    return data[offset + 3] << 24 & PConstants1.ALPHA_MASK | data[offset] << 16 & PConstants1.RED_MASK | data[offset + 1] << 8 & PConstants1.GREEN_MASK | data[offset + 2] & PConstants1.BLUE_MASK;\n                                };\n                            }(pImage),\n                            setPixel: function(aImg) {\n                                return function(i, c) {\n                                    var offset = i * 4, data = aImg.imageData.data;\n                                    if (aImg.isRemote) throw \"Image is loaded remotely. Cannot set pixel.\";\n                                    data[offset + 0] = (c & PConstants1.RED_MASK) >>> 16;\n                                    data[offset + 1] = (c & PConstants1.GREEN_MASK) >>> 8;\n                                    data[offset + 2] = c & PConstants1.BLUE_MASK;\n                                    data[offset + 3] = (c & PConstants1.ALPHA_MASK) >>> 24;\n                                    aImg.__isDirty = true;\n                                };\n                            }(pImage),\n                            toArray: function(aImg) {\n                                return function() {\n                                    var arr = [], data = aImg.imageData.data, length = aImg.width * aImg.height;\n                                    if (aImg.isRemote) throw \"Image is loaded remotely. Cannot get pixels.\";\n                                    for(var i = 0, offset = 0; i < length; i++, offset += 4)arr.push(data[offset + 3] << 24 & PConstants1.ALPHA_MASK | data[offset] << 16 & PConstants1.RED_MASK | data[offset + 1] << 8 & PConstants1.GREEN_MASK | data[offset + 2] & PConstants1.BLUE_MASK);\n                                    return arr;\n                                };\n                            }(pImage),\n                            set: function(aImg) {\n                                return function(arr) {\n                                    var offset, data, c;\n                                    if (this.isRemote) throw \"Image is loaded remotely. Cannot set pixels.\";\n                                    data = aImg.imageData.data;\n                                    for(var i = 0, aL = arr.length; i < aL; i++){\n                                        c = arr[i];\n                                        offset = i * 4;\n                                        data[offset + 0] = (c & PConstants1.RED_MASK) >>> 16;\n                                        data[offset + 1] = (c & PConstants1.GREEN_MASK) >>> 8;\n                                        data[offset + 2] = c & PConstants1.BLUE_MASK;\n                                        data[offset + 3] = (c & PConstants1.ALPHA_MASK) >>> 24;\n                                    }\n                                    aImg.__isDirty = true;\n                                };\n                            }(pImage)\n                        };\n                    }\n                    /**\n    * Datatype for storing images. Processing can display .gif, .jpg, .tga, and .png images. Images may be\n    * displayed in 2D and 3D space. Before an image is used, it must be loaded with the loadImage() function.\n    * The PImage object contains fields for the width and height of the image, as well as an array called\n    * pixels[]  which contains the values for every pixel in the image. A group of methods, described below,\n    * allow easy access to the image's pixels and alpha channel and simplify the process of compositing.\n    * Before using the pixels[] array, be sure to use the loadPixels() method on the image to make sure that the\n    * pixel data is properly loaded. To create a new image, use the createImage() function (do not use new PImage()).\n    *\n    * @param {int} width                image width\n    * @param {int} height               image height\n    * @param {MODE} format              Either RGB, ARGB, ALPHA (grayscale alpha channel)\n    *\n    * @returns {PImage}\n    *\n    * @see loadImage\n    * @see imageMode\n    * @see createImage\n    */ var PImage = function(aWidth, aHeight, aFormat) {\n                        // Keep track of whether or not the cached imageData has been touched.\n                        this.__isDirty = false;\n                        if (aWidth instanceof HTMLImageElement) // convert an <img> to a PImage\n                        this.fromHTMLImageData(aWidth);\n                        else if (aHeight || aFormat) {\n                            this.width = aWidth || 1;\n                            this.height = aHeight || 1;\n                            // Stuff a canvas into sourceImg so image() calls can use drawImage like an <img>\n                            var canvas = this.sourceImg = document1.createElement(\"canvas\");\n                            canvas.width = this.width;\n                            canvas.height = this.height;\n                            var imageData = this.imageData = canvas.getContext(\"2d\").createImageData(this.width, this.height);\n                            this.format = aFormat === PConstants1.ARGB || aFormat === PConstants1.ALPHA ? aFormat : PConstants1.RGB;\n                            if (this.format === PConstants1.RGB) // Set the alpha channel of an RGB image to opaque.\n                            for(var i = 3, data = this.imageData.data, len = data.length; i < len; i += 4)data[i] = 255;\n                            this.__isDirty = true;\n                            this.updatePixels();\n                        } else {\n                            this.width = 0;\n                            this.height = 0;\n                            this.imageData = utilityContext2d.createImageData(1, 1);\n                            this.format = PConstants1.ARGB;\n                        }\n                        this.pixels = buildPixelsObject(this);\n                    };\n                    PImage.prototype = {\n                        /**\n       * Temporary hack to deal with cross-Processing-instance created PImage.  See\n       * tickets #1623 and #1644.\n       */ __isPImage: true,\n                        /**\n      * @member PImage\n      * Updates the image with the data in its pixels[] array. Use in conjunction with loadPixels(). If\n      * you're only reading pixels from the array, there's no need to call updatePixels().\n      * Certain renderers may or may not seem to require loadPixels() or updatePixels(). However, the rule\n      * is that any time you want to manipulate the pixels[] array, you must first call loadPixels(), and\n      * after changes have been made, call updatePixels(). Even if the renderer may not seem to use this\n      * function in the current Processing release, this will always be subject to change.\n      * Currently, none of the renderers use the additional parameters to updatePixels().\n      */ updatePixels: function() {\n                            var canvas = this.sourceImg;\n                            if (canvas && canvas instanceof HTMLCanvasElement && this.__isDirty) canvas.getContext(\"2d\").putImageData(this.imageData, 0, 0);\n                            this.__isDirty = false;\n                        },\n                        fromHTMLImageData: function(htmlImg) {\n                            // convert an <img> to a PImage\n                            var canvasData = getCanvasData(htmlImg);\n                            try {\n                                var imageData = canvasData.context.getImageData(0, 0, htmlImg.width, htmlImg.height);\n                                this.fromImageData(imageData);\n                            } catch (e) {\n                                if (htmlImg.width && htmlImg.height) {\n                                    this.isRemote = true;\n                                    this.width = htmlImg.width;\n                                    this.height = htmlImg.height;\n                                }\n                            }\n                            this.sourceImg = htmlImg;\n                        },\n                        \"get\": function(x, y, w, h) {\n                            if (!arguments.length) return p.get(this);\n                            if (arguments.length === 2) return p.get(x, y, this);\n                            if (arguments.length === 4) return p.get(x, y, w, h, this);\n                        },\n                        /**\n      * @member PImage\n      * Changes the color of any pixel or writes an image directly into the image. The x and y parameter\n      * specify the pixel or the upper-left corner of the image. The color parameter specifies the color value.\n      * Setting the color of a single pixel with set(x, y) is easy, but not as fast as putting the data\n      * directly into pixels[]. The equivalent statement to \"set(x, y, #000000)\" using pixels[] is\n      * \"pixels[y*width+x] = #000000\". Processing requires calling loadPixels() to load the display window\n      * data into the pixels[] array before getting the values and calling updatePixels() to update the window.\n      *\n      * @param {int} x        x-coordinate of the pixel or upper-left corner of the image\n      * @param {int} y        y-coordinate of the pixel or upper-left corner of the image\n      * @param {color} color  any value of the color datatype\n      *\n      * @see get\n      * @see pixels[]\n      * @see copy\n      */ \"set\": function(x, y, c) {\n                            p.set(x, y, c, this);\n                            this.__isDirty = true;\n                        },\n                        /**\n      * @member PImage\n      * Blends a region of pixels into the image specified by the img parameter. These copies utilize full\n      * alpha channel support and a choice of the following modes to blend the colors of source pixels (A)\n      * with the ones of pixels in the destination image (B):\n      * BLEND - linear interpolation of colours: C = A*factor + B\n      * ADD - additive blending with white clip: C = min(A*factor + B, 255)\n      * SUBTRACT - subtractive blending with black clip: C = max(B - A*factor, 0)\n      * DARKEST - only the darkest colour succeeds: C = min(A*factor, B)\n      * LIGHTEST - only the lightest colour succeeds: C = max(A*factor, B)\n      * DIFFERENCE - subtract colors from underlying image.\n      * EXCLUSION - similar to DIFFERENCE, but less extreme.\n      * MULTIPLY - Multiply the colors, result will always be darker.\n      * SCREEN - Opposite multiply, uses inverse values of the colors.\n      * OVERLAY - A mix of MULTIPLY and SCREEN. Multiplies dark values, and screens light values.\n      * HARD_LIGHT - SCREEN when greater than 50% gray, MULTIPLY when lower.\n      * SOFT_LIGHT - Mix of DARKEST and LIGHTEST. Works like OVERLAY, but not as harsh.\n      * DODGE - Lightens light tones and increases contrast, ignores darks. Called \"Color Dodge\" in Illustrator and Photoshop.\n      * BURN - Darker areas are applied, increasing contrast, ignores lights. Called \"Color Burn\" in Illustrator and Photoshop.\n      * All modes use the alpha information (highest byte) of source image pixels as the blending factor.\n      * If the source and destination regions are different sizes, the image will be automatically resized to\n      * match the destination size. If the srcImg parameter is not used, the display window is used as the source image.\n      * This function ignores imageMode().\n      *\n      * @param {int} x              X coordinate of the source's upper left corner\n      * @param {int} y              Y coordinate of the source's upper left corner\n      * @param {int} width          source image width\n      * @param {int} height         source image height\n      * @param {int} dx             X coordinate of the destinations's upper left corner\n      * @param {int} dy             Y coordinate of the destinations's upper left corner\n      * @param {int} dwidth         destination image width\n      * @param {int} dheight        destination image height\n      * @param {PImage} srcImg      an image variable referring to the source image\n      * @param {MODE} MODE          Either BLEND, ADD, SUBTRACT, LIGHTEST, DARKEST, DIFFERENCE, EXCLUSION,\n      * MULTIPLY, SCREEN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, BURN\n      *\n      * @see alpha\n      * @see copy\n      */ blend: function(srcImg, x, y, width, height, dx, dy, dwidth, dheight, MODE) {\n                            if (arguments.length === 9) p.blend(this, srcImg, x, y, width, height, dx, dy, dwidth, dheight, this);\n                            else if (arguments.length === 10) p.blend(srcImg, x, y, width, height, dx, dy, dwidth, dheight, MODE, this);\n                            delete this.sourceImg;\n                        },\n                        /**\n      * @member PImage\n      * Copies a region of pixels from one image into another. If the source and destination regions\n      * aren't the same size, it will automatically resize source pixels to fit the specified target region.\n      * No alpha information is used in the process, however if the source image has an alpha channel set,\n      * it will be copied as well. This function ignores imageMode().\n      *\n      * @param {int} sx             X coordinate of the source's upper left corner\n      * @param {int} sy             Y coordinate of the source's upper left corner\n      * @param {int} swidth         source image width\n      * @param {int} sheight        source image height\n      * @param {int} dx             X coordinate of the destinations's upper left corner\n      * @param {int} dy             Y coordinate of the destinations's upper left corner\n      * @param {int} dwidth         destination image width\n      * @param {int} dheight        destination image height\n      * @param {PImage} srcImg      an image variable referring to the source image\n      *\n      * @see alpha\n      * @see blend\n      */ copy: function(srcImg, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {\n                            if (arguments.length === 8) p.blend(this, srcImg, sx, sy, swidth, sheight, dx, dy, dwidth, PConstants1.REPLACE, this);\n                            else if (arguments.length === 9) p.blend(srcImg, sx, sy, swidth, sheight, dx, dy, dwidth, dheight, PConstants1.REPLACE, this);\n                            delete this.sourceImg;\n                        },\n                        /**\n      * @member PImage\n      * Filters an image as defined by one of the following modes:\n      * THRESHOLD - converts the image to black and white pixels depending if they are above or below\n      * the threshold defined by the level parameter. The level must be between 0.0 (black) and 1.0(white).\n      * If no level is specified, 0.5 is used.\n      * GRAY - converts any colors in the image to grayscale equivalents\n      * INVERT - sets each pixel to its inverse value\n      * POSTERIZE - limits each channel of the image to the number of colors specified as the level parameter\n      * BLUR - executes a Guassian blur with the level parameter specifying the extent of the blurring.\n      * If no level parameter is used, the blur is equivalent to Guassian blur of radius 1.\n      * OPAQUE - sets the alpha channel to entirely opaque.\n      * ERODE - reduces the light areas with the amount defined by the level parameter.\n      * DILATE - increases the light areas with the amount defined by the level parameter\n      *\n      * @param {MODE} MODE        Either THRESHOLD, GRAY, INVERT, POSTERIZE, BLUR, OPAQUE, ERODE, or DILATE\n      * @param {int|float} param  in the range from 0 to 1\n      */ filter: function(mode, param) {\n                            if (arguments.length === 2) p.filter(mode, param, this);\n                            else if (arguments.length === 1) // no param specified, send null to show its invalid\n                            p.filter(mode, null, this);\n                            delete this.sourceImg;\n                        },\n                        /**\n      * @member PImage\n      * Saves the image into a file. Images are saved in TIFF, TARGA, JPEG, and PNG format depending on\n      * the extension within the filename  parameter. For example, \"image.tif\" will have a TIFF image and\n      * \"image.png\" will save a PNG image. If no extension is included in the filename, the image will save\n      * in TIFF format and .tif will be added to the name. These files are saved to the sketch's folder,\n      * which may be opened by selecting \"Show sketch folder\" from the \"Sketch\" menu. It is not possible to\n      * use save() while running the program in a web browser.\n      * To save an image created within the code, rather than through loading, it's necessary to make the\n      * image with the createImage() function so it is aware of the location of the program and can therefore\n      * save the file to the right place. See the createImage() reference for more information.\n      *\n      * @param {String} filename        a sequence of letters and numbers\n      */ save: function(file) {\n                            p.save(file, this);\n                        },\n                        /**\n      * @member PImage\n      * Resize the image to a new width and height. To make the image scale proportionally, use 0 as the\n      * value for the wide or high parameter.\n      *\n      * @param {int} wide         the resized image width\n      * @param {int} high         the resized image height\n      *\n      * @see get\n      */ resize: function(w, h) {\n                            if (this.isRemote) throw \"Image is loaded remotely. Cannot resize.\";\n                            if (this.width !== 0 || this.height !== 0) {\n                                // make aspect ratio if w or h is 0\n                                if (w === 0 && h !== 0) w = Math.floor(this.width / this.height * h);\n                                else if (h === 0 && w !== 0) h = Math.floor(this.height / this.width * w);\n                                // put 'this.imageData' into a new canvas\n                                var canvas = getCanvasData(this.imageData).canvas;\n                                // pull imageData object out of canvas into ImageData object\n                                var imageData = getCanvasData(canvas, w, h).context.getImageData(0, 0, w, h);\n                                // set this as new pimage\n                                this.fromImageData(imageData);\n                            }\n                        },\n                        /**\n      * @member PImage\n      * Masks part of an image from displaying by loading another image and using it as an alpha channel.\n      * This mask image should only contain grayscale data, but only the blue color channel is used. The\n      * mask image needs to be the same size as the image to which it is applied.\n      * In addition to using a mask image, an integer array containing the alpha channel data can be\n      * specified directly. This method is useful for creating dynamically generated alpha masks. This\n      * array must be of the same length as the target image's pixels array and should contain only grayscale\n      * data of values between 0-255.\n      *\n      * @param {PImage} maskImg         any PImage object used as the alpha channel for \"img\", needs to be same\n      *                                 size as \"img\"\n      * @param {int[]} maskArray        any array of Integer numbers used as the alpha channel, needs to be same\n      *                                 length as the image's pixel array\n      */ mask: function(mask) {\n                            var obj = this.toImageData(), i, size;\n                            if (mask instanceof PImage || mask.__isPImage) {\n                                if (mask.width === this.width && mask.height === this.height) {\n                                    mask = mask.toImageData();\n                                    for(i = 2, size = this.width * this.height * 4; i < size; i += 4)// using it as an alpha channel\n                                    obj.data[i + 1] = mask.data[i];\n                                } else throw \"mask must have the same dimensions as PImage.\";\n                            } else if (mask instanceof Array) {\n                                if (this.width * this.height === mask.length) for(i = 0, size = mask.length; i < size; ++i)obj.data[i * 4 + 3] = mask[i];\n                                else throw \"mask array must be the same length as PImage pixels array.\";\n                            }\n                            this.fromImageData(obj);\n                        },\n                        // These are intentionally left blank for PImages, we work live with pixels and draw as necessary\n                        /**\n      * @member PImage\n      * Loads the pixel data for the image into its pixels[] array. This function must always be called\n      * before reading from or writing to pixels[].\n      * Certain renderers may or may not seem to require loadPixels() or updatePixels(). However, the\n      * rule is that any time you want to manipulate the pixels[] array, you must first call loadPixels(),\n      * and after changes have been made, call updatePixels(). Even if the renderer may not seem to use\n      * this function in the current Processing release, this will always be subject to change.\n      */ loadPixels: noop,\n                        toImageData: function() {\n                            if (this.isRemote) return this.sourceImg;\n                            if (!this.__isDirty) return this.imageData;\n                            var canvasData = getCanvasData(this.sourceImg);\n                            return canvasData.context.getImageData(0, 0, this.width, this.height);\n                        },\n                        toDataURL: function() {\n                            if (this.isRemote) throw \"Image is loaded remotely. Cannot create dataURI.\";\n                            var canvasData = getCanvasData(this.imageData);\n                            return canvasData.canvas.toDataURL();\n                        },\n                        fromImageData: function(canvasImg) {\n                            var w = canvasImg.width, h = canvasImg.height, canvas = document1.createElement(\"canvas\"), ctx = canvas.getContext(\"2d\");\n                            this.width = canvas.width = w;\n                            this.height = canvas.height = h;\n                            ctx.putImageData(canvasImg, 0, 0);\n                            // changed for 0.9\n                            this.format = PConstants1.ARGB;\n                            this.imageData = canvasImg;\n                            this.sourceImg = canvas;\n                        }\n                    };\n                    p.PImage = PImage;\n                    /**\n    * Creates a new PImage (the datatype for storing images). This provides a fresh buffer of pixels to play\n    * with. Set the size of the buffer with the width and height parameters. The format parameter defines how\n    * the pixels are stored. See the PImage reference for more information.\n    * Be sure to include all three parameters, specifying only the width and height (but no format) will\n    * produce a strange error.\n    * Advanced users please note that createImage() should be used instead of the syntax new PImage().\n    *\n    * @param {int} width                image width\n    * @param {int} height               image height\n    * @param {MODE} format              Either RGB, ARGB, ALPHA (grayscale alpha channel)\n    *\n    * @returns {PImage}\n    *\n    * @see PImage\n    * @see PGraphics\n    */ p.createImage = function(w, h, mode) {\n                        return new PImage(w, h, mode);\n                    };\n                    // Loads an image for display. Type is an extension. Callback is fired on load.\n                    /**\n    * Loads an image into a variable of type PImage. Four types of images ( .gif, .jpg, .tga, .png) images may\n    * be loaded. To load correctly, images must be located in the data directory of the current sketch. In most\n    * cases, load all images in setup() to preload them at the start of the program. Loading images inside draw()\n    * will reduce the speed of a program.\n    * The filename parameter can also be a URL to a file found online. For security reasons, a Processing sketch\n    * found online can only download files from the same server from which it came. Getting around this restriction\n    * requires a signed applet.\n    * The extension parameter is used to determine the image type in cases where the image filename does not end\n    * with a proper extension. Specify the extension as the second parameter to loadImage(), as shown in the\n    * third example on this page.\n    * If an image is not loaded successfully, the null value is returned and an error message will be printed to\n    * the console. The error message does not halt the program, however the null value may cause a NullPointerException\n    * if your code does not check whether the value returned from loadImage() is null.\n    * Depending on the type of error, a PImage object may still be returned, but the width and height of the image\n    * will be set to -1. This happens if bad image data is returned or cannot be decoded properly. Sometimes this happens\n    * with image URLs that produce a 403 error or that redirect to a password prompt, because loadImage() will attempt\n    * to interpret the HTML as image data.\n    *\n    * @param {String} filename        name of file to load, can be .gif, .jpg, .tga, or a handful of other image\n    *                                 types depending on your platform.\n    * @param {String} extension       the type of image to load, for example \"png\", \"gif\", \"jpg\"\n    *\n    * @returns {PImage}\n    *\n    * @see PImage\n    * @see image\n    * @see imageMode\n    * @see background\n    */ p.loadImage = function(file, type, callback) {\n                        // if type is specified, we just ignore it\n                        var pimg;\n                        // if image is in the preloader cache return a new PImage\n                        if (curSketch.imageCache.images[file]) {\n                            pimg = new PImage(curSketch.imageCache.images[file]);\n                            pimg.loaded = true;\n                            return pimg;\n                        }\n                        // else async load it\n                        pimg = new PImage();\n                        var img = document1.createElement(\"img\");\n                        pimg.sourceImg = img;\n                        img.onload = function(aImage, aPImage, aCallback) {\n                            var image = aImage;\n                            var pimg = aPImage;\n                            var callback = aCallback;\n                            return function() {\n                                // change the <img> object into a PImage now that its loaded\n                                pimg.fromHTMLImageData(image);\n                                pimg.loaded = true;\n                                if (callback) callback();\n                            };\n                        }(img, pimg, callback);\n                        img.src = file; // needs to be called after the img.onload function is declared or it wont work in opera\n                        return pimg;\n                    };\n                    // async loading of large images, same functionality as loadImage above\n                    /**\n    * This function load images on a separate thread so that your sketch does not freeze while images load during\n    * setup(). While the image is loading, its width and height will be 0. If an error occurs while loading the image,\n    * its width and height will be set to -1. You'll know when the image has loaded properly because its width and\n    * height will be greater than 0. Asynchronous image loading (particularly when downloading from a server) can\n    * dramatically improve performance.\n    * The extension parameter is used to determine the image type in cases where the image filename does not end\n    * with a proper extension. Specify the extension as the second parameter to requestImage().\n    *\n    * @param {String} filename        name of file to load, can be .gif, .jpg, .tga, or a handful of other image\n    *                                 types depending on your platform.\n    * @param {String} extension       the type of image to load, for example \"png\", \"gif\", \"jpg\"\n    *\n    * @returns {PImage}\n    *\n    * @see PImage\n    * @see loadImage\n    */ p.requestImage = p.loadImage;\n                    function get$2(x, y) {\n                        var data;\n                        // return the color at x,y (int) of curContext\n                        if (x >= p.width || x < 0 || y < 0 || y >= p.height) // x,y is outside image return transparent black\n                        return 0;\n                        // loadPixels() has been called\n                        if (isContextReplaced) {\n                            var offset = ((0 | x) + p.width * (0 | y)) * 4;\n                            data = p.imageData.data;\n                            return data[offset + 3] << 24 & PConstants1.ALPHA_MASK | data[offset] << 16 & PConstants1.RED_MASK | data[offset + 1] << 8 & PConstants1.GREEN_MASK | data[offset + 2] & PConstants1.BLUE_MASK;\n                        }\n                        // x,y is inside canvas space\n                        data = p.toImageData(0 | x, 0 | y, 1, 1).data;\n                        return data[3] << 24 & PConstants1.ALPHA_MASK | data[0] << 16 & PConstants1.RED_MASK | data[1] << 8 & PConstants1.GREEN_MASK | data[2] & PConstants1.BLUE_MASK;\n                    }\n                    function get$3(x, y, img) {\n                        if (img.isRemote) throw \"Image is loaded remotely. Cannot get x,y.\";\n                        // PImage.get(x,y) was called, return the color (int) at x,y of img\n                        var offset = y * img.width * 4 + x * 4, data = img.imageData.data;\n                        return data[offset + 3] << 24 & PConstants1.ALPHA_MASK | data[offset] << 16 & PConstants1.RED_MASK | data[offset + 1] << 8 & PConstants1.GREEN_MASK | data[offset + 2] & PConstants1.BLUE_MASK;\n                    }\n                    function get$4(x, y, w, h) {\n                        // return a PImage of w and h from cood x,y of curContext\n                        var c = new PImage(w, h, PConstants1.ARGB);\n                        c.fromImageData(p.toImageData(x, y, w, h));\n                        return c;\n                    }\n                    function get$5(x, y, w, h, img) {\n                        if (img.isRemote) throw \"Image is loaded remotely. Cannot get x,y,w,h.\";\n                        // PImage.get(x,y,w,h) was called, return x,y,w,h PImage of img\n                        // offset start point needs to be *4\n                        var c = new PImage(w, h, PConstants1.ARGB), cData = c.imageData.data, imgWidth = img.width, imgHeight = img.height, imgData = img.imageData.data;\n                        // Don't need to copy pixels from the image outside ranges.\n                        var startRow = Math.max(0, -y), startColumn = Math.max(0, -x), stopRow = Math.min(h, imgHeight - y), stopColumn = Math.min(w, imgWidth - x);\n                        for(var i = startRow; i < stopRow; ++i){\n                            var sourceOffset = ((y + i) * imgWidth + (x + startColumn)) * 4;\n                            var targetOffset = (i * w + startColumn) * 4;\n                            for(var j = startColumn; j < stopColumn; ++j){\n                                cData[targetOffset++] = imgData[sourceOffset++];\n                                cData[targetOffset++] = imgData[sourceOffset++];\n                                cData[targetOffset++] = imgData[sourceOffset++];\n                                cData[targetOffset++] = imgData[sourceOffset++];\n                            }\n                        }\n                        c.__isDirty = true;\n                        return c;\n                    }\n                    // Gets a single pixel or block of pixels from the current Canvas Context or a PImage\n                    /**\n    * Reads the color of any pixel or grabs a section of an image. If no parameters are specified, the entire\n    * image is returned. Get the value of one pixel by specifying an x,y coordinate. Get a section of the display\n    * window by specifying an additional width and height parameter. If the pixel requested is outside of the image\n    * window, black is returned. The numbers returned are scaled according to the current color ranges, but only RGB\n    * values are returned by this function. For example, even though you may have drawn a shape with colorMode(HSB),\n    * the numbers returned will be in RGB.\n    * Getting the color of a single pixel with get(x, y) is easy, but not as fast as grabbing the data directly\n    * from pixels[]. The equivalent statement to \"get(x, y)\" using pixels[] is \"pixels[y*width+x]\". Processing\n    * requires calling loadPixels() to load the display window data into the pixels[] array before getting the values.\n    * This function ignores imageMode().\n    *\n    * @param {int} x            x-coordinate of the pixel\n    * @param {int} y            y-coordinate of the pixel\n    * @param {int} width        width of pixel rectangle to get\n    * @param {int} height       height of pixel rectangle to get\n    *\n    * @returns {Color|PImage}\n    *\n    * @see set\n    * @see pixels[]\n    * @see imageMode\n    */ p.get = function(x, y, w, h, img) {\n                        // for 0 2 and 4 arguments use curContext, otherwise PImage.get was called\n                        if (img !== undefined) return get$5(x, y, w, h, img);\n                        if (h !== undefined) return get$4(x, y, w, h);\n                        if (w !== undefined) return get$3(x, y, w);\n                        if (y !== undefined) return get$2(x, y);\n                        if (x !== undefined) // PImage.get() was called, return a new PImage\n                        return get$5(0, 0, x.width, x.height, x);\n                        return get$4(0, 0, p.width, p.height);\n                    };\n                    /**\n     * Creates and returns a new <b>PGraphics</b> object of the types P2D, P3D, and JAVA2D. Use this class if you need to draw\n     * into an off-screen graphics buffer. It's not possible to use <b>createGraphics()</b> with OPENGL, because it doesn't\n     * allow offscreen use. The DXF and PDF renderers require the filename parameter. <br /><br /> It's important to call\n     * any drawing commands between beginDraw() and endDraw() statements. This is also true for any commands that affect\n     * drawing, such as smooth() or colorMode().<br /><br /> Unlike the main drawing surface which is completely opaque,\n     * surfaces created with createGraphics() can have transparency. This makes it possible to draw into a graphics and\n     * maintain the alpha channel.\n     *\n     * @param {int} width       width in pixels\n     * @param {int} height      height in pixels\n     * @param {int} renderer    Either P2D, P3D, JAVA2D, PDF, DXF\n     * @param {String} filename the name of the file (not supported yet)\n     */ p.createGraphics = function(w, h, render) {\n                        var pg = new Processing1();\n                        pg.size(w, h, render);\n                        pg.background(0, 0);\n                        return pg;\n                    };\n                    // pixels caching\n                    function resetContext() {\n                        if (isContextReplaced) {\n                            curContext = originalContext;\n                            isContextReplaced = false;\n                            p.updatePixels();\n                        }\n                    }\n                    function SetPixelContextWrapper() {\n                        function wrapFunction(newContext, name) {\n                            function wrapper() {\n                                resetContext();\n                                curContext[name].apply(curContext, arguments);\n                            }\n                            newContext[name] = wrapper;\n                        }\n                        function wrapProperty(newContext, name) {\n                            function getter() {\n                                resetContext();\n                                return curContext[name];\n                            }\n                            function setter(value) {\n                                resetContext();\n                                curContext[name] = value;\n                            }\n                            p.defineProperty(newContext, name, {\n                                get: getter,\n                                set: setter\n                            });\n                        }\n                        for(var n in curContext)if (typeof curContext[n] === \"function\") wrapFunction(this, n);\n                        else wrapProperty(this, n);\n                    }\n                    function replaceContext() {\n                        if (isContextReplaced) return;\n                        p.loadPixels();\n                        if (proxyContext === null) {\n                            originalContext = curContext;\n                            proxyContext = new SetPixelContextWrapper();\n                        }\n                        isContextReplaced = true;\n                        curContext = proxyContext;\n                        setPixelsCached = 0;\n                    }\n                    function set$3(x, y, c) {\n                        if (x < p.width && x >= 0 && y >= 0 && y < p.height) {\n                            replaceContext();\n                            p.pixels.setPixel((0 | x) + p.width * (0 | y), c);\n                            if (++setPixelsCached > maxPixelsCached) resetContext();\n                        }\n                    }\n                    function set$4(x, y, obj, img) {\n                        if (img.isRemote) throw \"Image is loaded remotely. Cannot set x,y.\";\n                        var c = p.color.toArray(obj);\n                        var offset = y * img.width * 4 + x * 4;\n                        var data = img.imageData.data;\n                        data[offset] = c[0];\n                        data[offset + 1] = c[1];\n                        data[offset + 2] = c[2];\n                        data[offset + 3] = c[3];\n                    }\n                    // Paints a pixel array into the canvas\n                    /**\n    * Changes the color of any pixel or writes an image directly into the display window. The x and y parameters\n    * specify the pixel to change and the color  parameter specifies the color value. The color parameter is affected\n    * by the current color mode (the default is RGB values from 0 to 255). When setting an image, the x and y\n    * parameters define the coordinates for the upper-left corner of the image.\n    * Setting the color of a single pixel with set(x, y) is easy, but not as fast as putting the data directly\n    * into pixels[]. The equivalent statement to \"set(x, y, #000000)\" using pixels[] is \"pixels[y*width+x] = #000000\".\n    * You must call loadPixels() to load the display window data into the pixels[] array before setting the values\n    * and calling updatePixels() to update the window with any changes. This function ignores imageMode().\n    *\n    * @param {int} x            x-coordinate of the pixel\n    * @param {int} y            y-coordinate of the pixel\n    * @param {Color} obj        any value of the color datatype\n    * @param {PImage} img       any valid variable of type PImage\n    *\n    * @see get\n    * @see pixels[]\n    * @see imageMode\n    */ p.set = function(x, y, obj, img) {\n                        var color, oldFill;\n                        if (arguments.length === 3) {\n                            // called p.set(), was it with a color or a img ?\n                            if (typeof obj === \"number\") set$3(x, y, obj);\n                            else if (obj instanceof PImage || obj.__isPImage) p.image(obj, x, y);\n                        } else if (arguments.length === 4) // PImage.set(x,y,c) was called, set coordinate x,y color to c of img\n                        set$4(x, y, obj, img);\n                    };\n                    p.imageData = {};\n                    // handle the sketch code for pixels[]\n                    // parser code converts pixels[] to getPixels() or setPixels(),\n                    // .length becomes getLength()\n                    /**\n    * Array containing the values for all the pixels in the display window. These values are of the color datatype.\n    * This array is the size of the display window. For example, if the image is 100x100 pixels, there will be 10000\n    * values and if the window is 200x300 pixels, there will be 60000 values. The index value defines the position\n    * of a value within the array. For example, the statment color b = pixels[230] will set the variable b to be\n    * equal to the value at that location in the array.\n    * Before accessing this array, the data must loaded with the loadPixels() function. After the array data has\n    * been modified, the updatePixels() function must be run to update the changes.\n    *\n    * @param {int} index      must not exceed the size of the array\n    *\n    * @see loadPixels\n    * @see updatePixels\n    * @see get\n    * @see set\n    * @see PImage\n    */ p.pixels = {\n                        getLength: function() {\n                            return p.imageData.data.length ? p.imageData.data.length / 4 : 0;\n                        },\n                        getPixel: function(i) {\n                            var offset = i * 4, data = p.imageData.data;\n                            return data[offset + 3] << 24 & 0xff000000 | data[offset + 0] << 16 & 0x00ff0000 | data[offset + 1] << 8 & 0x0000ff00 | data[offset + 2] & 0x000000ff;\n                        },\n                        setPixel: function(i, c) {\n                            var offset = i * 4, data = p.imageData.data;\n                            data[offset + 0] = (c & 0x00ff0000) >>> 16; // RED_MASK\n                            data[offset + 1] = (c & 0x0000ff00) >>> 8; // GREEN_MASK\n                            data[offset + 2] = c & 0x000000ff; // BLUE_MASK\n                            data[offset + 3] = (c & 0xff000000) >>> 24; // ALPHA_MASK\n                        },\n                        toArray: function() {\n                            var arr = [], length = p.imageData.width * p.imageData.height, data = p.imageData.data;\n                            for(var i = 0, offset = 0; i < length; i++, offset += 4)arr.push(data[offset + 3] << 24 & 0xff000000 | data[offset + 0] << 16 & 0x00ff0000 | data[offset + 1] << 8 & 0x0000ff00 | data[offset + 2] & 0x000000ff);\n                            return arr;\n                        },\n                        set: function(arr) {\n                            for(var i = 0, aL = arr.length; i < aL; i++)this.setPixel(i, arr[i]);\n                        }\n                    };\n                    // Gets a 1-Dimensional pixel array from Canvas\n                    /**\n    * Loads the pixel data for the display window into the pixels[] array. This function must always be called\n    * before reading from or writing to pixels[].\n    * Certain renderers may or may not seem to require loadPixels() or updatePixels(). However, the rule is that\n    * any time you want to manipulate the pixels[] array, you must first call loadPixels(), and after changes\n    * have been made, call updatePixels(). Even if the renderer may not seem to use this function in the current\n    * Processing release, this will always be subject to change.\n    *\n    * @see pixels[]\n    * @see updatePixels\n    */ p.loadPixels = function() {\n                        p.imageData = drawing.$ensureContext().getImageData(0, 0, p.width, p.height);\n                    };\n                    // Draws a 1-Dimensional pixel array to Canvas\n                    /**\n    * Updates the display window with the data in the pixels[] array. Use in conjunction with loadPixels(). If\n    * you're only reading pixels from the array, there's no need to call updatePixels() unless there are changes.\n    * Certain renderers may or may not seem to require loadPixels() or updatePixels(). However, the rule is that\n    * any time you want to manipulate the pixels[] array, you must first call loadPixels(), and after changes\n    * have been made, call updatePixels(). Even if the renderer may not seem to use this function in the current\n    * Processing release, this will always be subject to change.\n    * Currently, none of the renderers use the additional parameters to updatePixels(), however this may be\n    * implemented in the future.\n    *\n    * @see loadPixels\n    * @see pixels[]\n    */ p.updatePixels = function() {\n                        if (p.imageData) drawing.$ensureContext().putImageData(p.imageData, 0, 0);\n                    };\n                    /**\n    * Set various hints and hacks for the renderer. This is used to handle obscure rendering features that cannot be\n    * implemented in a consistent manner across renderers. Many options will often graduate to standard features\n    * instead of hints over time.\n    * hint(ENABLE_OPENGL_4X_SMOOTH) - Enable 4x anti-aliasing for OpenGL. This can help force anti-aliasing if\n    * it has not been enabled by the user. On some graphics cards, this can also be set by the graphics driver's\n    * control panel, however not all cards make this available. This hint must be called immediately after the\n    * size() command because it resets the renderer, obliterating any settings and anything drawn (and like size(),\n    * re-running the code that came before it again).\n    * hint(DISABLE_OPENGL_2X_SMOOTH) - In Processing 1.0, Processing always enables 2x smoothing when the OpenGL\n    * renderer is used. This hint disables the default 2x smoothing and returns the smoothing behavior found in\n    * earlier releases, where smooth() and noSmooth() could be used to enable and disable smoothing, though the\n    * quality was inferior.\n    * hint(ENABLE_NATIVE_FONTS) - Use the native version fonts when they are installed, rather than the bitmapped\n    * version from a .vlw file. This is useful with the JAVA2D renderer setting, as it will improve font rendering\n    * speed. This is not enabled by default, because it can be misleading while testing because the type will look\n    * great on your machine (because you have the font installed) but lousy on others' machines if the identical\n    * font is unavailable. This option can only be set per-sketch, and must be called before any use of textFont().\n    * hint(DISABLE_DEPTH_TEST) - Disable the zbuffer, allowing you to draw on top of everything at will. When depth\n    * testing is disabled, items will be drawn to the screen sequentially, like a painting. This hint is most often\n    * used to draw in 3D, then draw in 2D on top of it (for instance, to draw GUI controls in 2D on top of a 3D\n    * interface). Starting in release 0149, this will also clear the depth buffer. Restore the default with\n    * hint(ENABLE_DEPTH_TEST), but note that with the depth buffer cleared, any 3D drawing that happens later in\n    * draw() will ignore existing shapes on the screen.\n    * hint(ENABLE_DEPTH_SORT) - Enable primitive z-sorting of triangles and lines in P3D and OPENGL. This can slow\n    * performance considerably, and the algorithm is not yet perfect. Restore the default with hint(DISABLE_DEPTH_SORT).\n    * hint(DISABLE_OPENGL_ERROR_REPORT) - Speeds up the OPENGL renderer setting by not checking for errors while\n    * running. Undo with hint(ENABLE_OPENGL_ERROR_REPORT).\n    * As of release 0149, unhint() has been removed in favor of adding additional ENABLE/DISABLE constants to reset\n    * the default behavior. This prevents the double negatives, and also reinforces which hints can be enabled or disabled.\n    *\n    * @param {MODE} item          constant: name of the hint to be enabled or disabled\n    *\n    * @see PGraphics\n    * @see createGraphics\n    * @see size\n    */ p.hint = function(which) {\n                        var curContext = drawing.$ensureContext();\n                        if (which === PConstants1.DISABLE_DEPTH_TEST) {\n                            curContext.disable(curContext.DEPTH_TEST);\n                            curContext.depthMask(false);\n                            curContext.clear(curContext.DEPTH_BUFFER_BIT);\n                        } else if (which === PConstants1.ENABLE_DEPTH_TEST) {\n                            curContext.enable(curContext.DEPTH_TEST);\n                            curContext.depthMask(true);\n                        } else if (which === PConstants1.ENABLE_OPENGL_2X_SMOOTH || which === PConstants1.ENABLE_OPENGL_4X_SMOOTH) renderSmooth = true;\n                        else if (which === PConstants1.DISABLE_OPENGL_2X_SMOOTH) renderSmooth = false;\n                    };\n                    /**\n     * The background() function sets the color used for the background of the Processing window.\n     * The default background is light gray. In the <b>draw()</b> function, the background color is used to clear the display window at the beginning of each frame.\n     * An image can also be used as the background for a sketch, however its width and height must be the same size as the sketch window.\n     * To resize an image 'b' to the size of the sketch window, use b.resize(width, height).\n     * Images used as background will ignore the current <b>tint()</b> setting.\n     * For the main drawing surface, the alpha value will be ignored. However,\n     * alpha can be used on PGraphics objects from <b>createGraphics()</b>. This is\n     * the only way to set all the pixels partially transparent, for instance.\n     * If the 'gray' parameter is passed in the function sets the background to a grayscale value, based on the\n     * current colorMode.\n     * <p>\n     * Note that background() should be called before any transformations occur,\n     * because some implementations may require the current transformation matrix\n     * to be identity before drawing.\n     *\n     * @param {int|float} gray    specifies a value between white and black\n     * @param {int|float} value1  red or hue value (depending on the current color mode)\n     * @param {int|float} value2  green or saturation value (depending on the current color mode)\n     * @param {int|float} value3  blue or brightness value (depending on the current color mode)\n     * @param {int|float} alpha   opacity of the background\n     * @param {Color} color       any value of the color datatype\n     * @param {int} hex           color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)\n     * @param {PImage} image      an instance of a PImage to use as a background\n     *\n     * @see #stroke()\n     * @see #fill()\n     * @see #tint()\n     * @see #colorMode()\n     */ var backgroundHelper = function(arg1, arg2, arg3, arg4) {\n                        var obj;\n                        if (arg1 instanceof PImage || arg1.__isPImage) {\n                            obj = arg1;\n                            if (!obj.loaded) throw \"Error using image in background(): PImage not loaded.\";\n                            if (obj.width !== p.width || obj.height !== p.height) throw \"Background image must be the same dimensions as the canvas.\";\n                        } else obj = p.color(arg1, arg2, arg3, arg4);\n                        backgroundObj = obj;\n                    };\n                    Drawing2D.prototype.background = function(arg1, arg2, arg3, arg4) {\n                        if (arg1 !== undef) backgroundHelper(arg1, arg2, arg3, arg4);\n                        if (backgroundObj instanceof PImage || backgroundObj.__isPImage) {\n                            saveContext();\n                            curContext.setTransform(1, 0, 0, 1, 0, 0);\n                            p.image(backgroundObj, 0, 0);\n                            restoreContext();\n                        } else {\n                            saveContext();\n                            curContext.setTransform(1, 0, 0, 1, 0, 0);\n                            // If the background is transparent\n                            if (p.alpha(backgroundObj) !== colorModeA) curContext.clearRect(0, 0, p.width, p.height);\n                            curContext.fillStyle = p.color.toString(backgroundObj);\n                            curContext.fillRect(0, 0, p.width, p.height);\n                            isFillDirty = true;\n                            restoreContext();\n                        }\n                    };\n                    Drawing3D.prototype.background = function(arg1, arg2, arg3, arg4) {\n                        if (arguments.length > 0) backgroundHelper(arg1, arg2, arg3, arg4);\n                        var c = p.color.toGLArray(backgroundObj);\n                        curContext.clearColor(c[0], c[1], c[2], c[3]);\n                        curContext.clear(curContext.COLOR_BUFFER_BIT | curContext.DEPTH_BUFFER_BIT);\n                    // An image as a background in 3D is not implemented yet\n                    };\n                    // Draws an image to the Canvas\n                    /**\n    * Displays images to the screen. The images must be in the sketch's \"data\" directory to load correctly. Select \"Add\n    * file...\" from the \"Sketch\" menu to add the image. Processing currently works with GIF, JPEG, and Targa images. The\n    * color of an image may be modified with the tint() function and if a GIF has transparency, it will maintain its\n    * transparency. The img parameter specifies the image to display and the x and y parameters define the location of\n    * the image from its upper-left corner. The image is displayed at its original size unless the width and height\n    * parameters specify a different size. The imageMode() function changes the way the parameters work. A call to\n    * imageMode(CORNERS) will change the width and height parameters to define the x and y values of the opposite\n    * corner of the image.\n    *\n    * @param {PImage} img            the image to display\n    * @param {int|float} x           x-coordinate of the image\n    * @param {int|float} y           y-coordinate of the image\n    * @param {int|float} width       width to display the image\n    * @param {int|float} height      height to display the image\n    *\n    * @see loadImage\n    * @see PImage\n    * @see imageMode\n    * @see tint\n    * @see background\n    * @see alpha\n    */ Drawing2D.prototype.image = function(img, x, y, w, h) {\n                        // Fix fractional positions\n                        x = Math.round(x);\n                        y = Math.round(y);\n                        if (img.width > 0) {\n                            var wid = w || img.width;\n                            var hgt = h || img.height;\n                            var bounds = imageModeConvert1(x || 0, y || 0, w || img.width, h || img.height, arguments.length < 4);\n                            var fastImage = !!img.sourceImg && curTint === null;\n                            if (fastImage) {\n                                var htmlElement = img.sourceImg;\n                                if (img.__isDirty) img.updatePixels();\n                                // Using HTML element's width and height in case if the image was resized.\n                                curContext.drawImage(htmlElement, 0, 0, htmlElement.width, htmlElement.height, bounds.x, bounds.y, bounds.w, bounds.h);\n                            } else {\n                                var obj = img.toImageData();\n                                // Tint the image\n                                if (curTint !== null) {\n                                    curTint(obj);\n                                    img.__isDirty = true;\n                                }\n                                curContext.drawImage(getCanvasData(obj).canvas, 0, 0, img.width, img.height, bounds.x, bounds.y, bounds.w, bounds.h);\n                            }\n                        }\n                    };\n                    Drawing3D.prototype.image = function(img, x, y, w, h) {\n                        if (img.width > 0) {\n                            // Fix fractional positions\n                            x = Math.round(x);\n                            y = Math.round(y);\n                            w = w || img.width;\n                            h = h || img.height;\n                            p.beginShape(p.QUADS);\n                            p.texture(img);\n                            p.vertex(x, y, 0, 0, 0);\n                            p.vertex(x, y + h, 0, 0, h);\n                            p.vertex(x + w, y + h, 0, w, h);\n                            p.vertex(x + w, y, 0, w, 0);\n                            p.endShape();\n                        }\n                    };\n                    /**\n     * The tint() function sets the fill value for displaying images. Images can be tinted to\n     * specified colors or made transparent by setting the alpha.\n     * <br><br>To make an image transparent, but not change it's color,\n     * use white as the tint color and specify an alpha value. For instance,\n     * tint(255, 128) will make an image 50% transparent (unless\n     * <b>colorMode()</b> has been used).\n     *\n     * <br><br>When using hexadecimal notation to specify a color, use \"#\" or\n     * \"0x\" before the values (e.g. #CCFFAA, 0xFFCCFFAA). The # syntax uses six\n     * digits to specify a color (the way colors are specified in HTML and CSS).\n     * When using the hexadecimal notation starting with \"0x\", the hexadecimal\n     * value must be specified with eight characters; the first two characters\n     * define the alpha component and the remainder the red, green, and blue\n     * components.\n     * <br><br>The value for the parameter \"gray\" must be less than or equal\n     * to the current maximum value as specified by <b>colorMode()</b>.\n     * The default maximum value is 255.\n     * <br><br>The tint() method is also used to control the coloring of\n     * textures in 3D.\n     *\n     * @param {int|float} gray    any valid number\n     * @param {int|float} alpha    opacity of the image\n     * @param {int|float} value1  red or hue value\n     * @param {int|float} value2  green or saturation value\n     * @param {int|float} value3  blue or brightness value\n     * @param {int|float} color    any value of the color datatype\n     * @param {int} hex            color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)\n     *\n     * @see #noTint()\n     * @see #image()\n     */ p.tint = function(a1, a2, a3, a4) {\n                        var tintColor = p.color(a1, a2, a3, a4);\n                        var r = p.red(tintColor) / colorModeX;\n                        var g = p.green(tintColor) / colorModeY;\n                        var b = p.blue(tintColor) / colorModeZ;\n                        var a = p.alpha(tintColor) / colorModeA;\n                        curTint = function(obj) {\n                            var data = obj.data, length = 4 * obj.width * obj.height;\n                            for(var i = 0; i < length;){\n                                data[i++] *= r;\n                                data[i++] *= g;\n                                data[i++] *= b;\n                                data[i++] *= a;\n                            }\n                        };\n                        // for overriding the color buffer when 3d rendering\n                        curTint3d = function(data) {\n                            for(var i = 0; i < data.length;){\n                                data[i++] = r;\n                                data[i++] = g;\n                                data[i++] = b;\n                                data[i++] = a;\n                            }\n                        };\n                    };\n                    /**\n     * The noTint() function removes the current fill value for displaying images and reverts to displaying images with their original hues.\n     *\n     * @see #tint()\n     * @see #image()\n     */ p.noTint = function() {\n                        curTint = null;\n                        curTint3d = null;\n                    };\n                    /**\n    * Copies a region of pixels from the display window to another area of the display window and copies a region of pixels from an\n    * image used as the srcImg  parameter into the display window. If the source and destination regions aren't the same size, it will\n    * automatically resize the source pixels to fit the specified target region. No alpha information is used in the process, however\n    * if the source image has an alpha channel set, it will be copied as well. This function ignores imageMode().\n    *\n    * @param {int} x            X coordinate of the source's upper left corner\n    * @param {int} y            Y coordinate of the source's upper left corner\n    * @param {int} width        source image width\n    * @param {int} height       source image height\n    * @param {int} dx           X coordinate of the destination's upper left corner\n    * @param {int} dy           Y coordinate of the destination's upper left corner\n    * @param {int} dwidth       destination image width\n    * @param {int} dheight      destination image height\n    * @param {PImage} srcImg    image variable referring to the source image\n    *\n    * @see blend\n    * @see get\n    */ p.copy = function(src, sx, sy, sw, sh, dx, dy, dw, dh) {\n                        if (dh === undef) {\n                            // shift everything, and introduce p\n                            dh = dw;\n                            dw = dy;\n                            dy = dx;\n                            dx = sh;\n                            sh = sw;\n                            sw = sy;\n                            sy = sx;\n                            sx = src;\n                            src = p;\n                        }\n                        p.blend(src, sx, sy, sw, sh, dx, dy, dw, dh, PConstants1.REPLACE);\n                    };\n                    /**\n    * Blends a region of pixels from one image into another (or in itself again) with full alpha channel support. There\n    * is a choice of the following modes to blend the source pixels (A) with the ones of pixels in the destination image (B):\n    * BLEND - linear interpolation of colours: C = A*factor + B\n    * ADD - additive blending with white clip: C = min(A*factor + B, 255)\n    * SUBTRACT - subtractive blending with black clip: C = max(B - A*factor, 0)\n    * DARKEST - only the darkest colour succeeds: C = min(A*factor, B)\n    * LIGHTEST - only the lightest colour succeeds: C = max(A*factor, B)\n    * DIFFERENCE - subtract colors from underlying image.\n    * EXCLUSION - similar to DIFFERENCE, but less extreme.\n    * MULTIPLY - Multiply the colors, result will always be darker.\n    * SCREEN - Opposite multiply, uses inverse values of the colors.\n    * OVERLAY - A mix of MULTIPLY and SCREEN. Multiplies dark values, and screens light values.\n    * HARD_LIGHT - SCREEN when greater than 50% gray, MULTIPLY when lower.\n    * SOFT_LIGHT - Mix of DARKEST and LIGHTEST. Works like OVERLAY, but not as harsh.\n    * DODGE - Lightens light tones and increases contrast, ignores darks. Called \"Color Dodge\" in Illustrator and Photoshop.\n    * BURN - Darker areas are applied, increasing contrast, ignores lights. Called \"Color Burn\" in Illustrator and Photoshop.\n    * All modes use the alpha information (highest byte) of source image pixels as the blending factor. If the source and\n    * destination regions are different sizes, the image will be automatically resized to match the destination size. If the\n    * srcImg parameter is not used, the display window is used as the source image.  This function ignores imageMode().\n    *\n    * @param {int} x            X coordinate of the source's upper left corner\n    * @param {int} y            Y coordinate of the source's upper left corner\n    * @param {int} width        source image width\n    * @param {int} height       source image height\n    * @param {int} dx           X coordinate of the destination's upper left corner\n    * @param {int} dy           Y coordinate of the destination's upper left corner\n    * @param {int} dwidth       destination image width\n    * @param {int} dheight      destination image height\n    * @param {PImage} srcImg    image variable referring to the source image\n    * @param {PImage} MODE      Either BLEND, ADD, SUBTRACT, LIGHTEST, DARKEST, DIFFERENCE, EXCLUSION, MULTIPLY, SCREEN,\n    *                           OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, BURN\n    * @see filter\n    */ p.blend = function(src, sx, sy, sw, sh, dx, dy, dw, dh, mode, pimgdest) {\n                        if (src.isRemote) throw \"Image is loaded remotely. Cannot blend image.\";\n                        if (mode === undef) {\n                            // shift everything, and introduce p\n                            mode = dh;\n                            dh = dw;\n                            dw = dy;\n                            dy = dx;\n                            dx = sh;\n                            sh = sw;\n                            sw = sy;\n                            sy = sx;\n                            sx = src;\n                            src = p;\n                        }\n                        var sx2 = sx + sw, sy2 = sy + sh, dx2 = dx + dw, dy2 = dy + dh, dest = pimgdest || p;\n                        // check if pimgdest is there and pixels, if so this was a call from pimg.blend\n                        if (pimgdest === undef || mode === undef) p.loadPixels();\n                        src.loadPixels();\n                        if (src === p && p.intersect(sx, sy, sx2, sy2, dx, dy, dx2, dy2)) p.blit_resize(p.get(sx, sy, sx2 - sx, sy2 - sy), 0, 0, sx2 - sx - 1, sy2 - sy - 1, dest.imageData.data, dest.width, dest.height, dx, dy, dx2, dy2, mode);\n                        else p.blit_resize(src, sx, sy, sx2, sy2, dest.imageData.data, dest.width, dest.height, dx, dy, dx2, dy2, mode);\n                        if (pimgdest === undef) p.updatePixels();\n                    };\n                    // helper function for filter()\n                    var buildBlurKernel = function(r) {\n                        var radius = p.floor(r * 3.5), i;\n                        radius = radius < 1 ? 1 : radius < 248 ? radius : 248;\n                        if (p.shared.blurRadius !== radius) {\n                            p.shared.blurRadius = radius;\n                            p.shared.blurKernelSize = 1 + (p.shared.blurRadius << 1);\n                            p.shared.blurKernel = new Float32Array(p.shared.blurKernelSize);\n                            var sharedBlurKernal = p.shared.blurKernel;\n                            var sharedBlurKernelSize = p.shared.blurKernelSize;\n                            var sharedBlurRadius = p.shared.blurRadius;\n                            // init blurKernel\n                            for(i = 0; i < sharedBlurKernelSize; i++)sharedBlurKernal[i] = 0;\n                            var radiusiSquared = (radius - 1) * (radius - 1);\n                            for(i = 1; i < radius; i++)sharedBlurKernal[radius + i] = sharedBlurKernal[radius - i] = radiusiSquared;\n                            sharedBlurKernal[radius] = radius * radius;\n                        }\n                    };\n                    var blurARGB = function(r, aImg) {\n                        var sum, cr, cg, cb, ca, c, m;\n                        var read, ri, ym, ymi, bk0;\n                        var wh = aImg.pixels.getLength();\n                        var r2 = new Float32Array(wh);\n                        var g2 = new Float32Array(wh);\n                        var b2 = new Float32Array(wh);\n                        var a2 = new Float32Array(wh);\n                        var yi = 0;\n                        var x, y, i, offset;\n                        buildBlurKernel(r);\n                        var aImgHeight = aImg.height;\n                        var aImgWidth = aImg.width;\n                        var sharedBlurKernelSize = p.shared.blurKernelSize;\n                        var sharedBlurRadius = p.shared.blurRadius;\n                        var sharedBlurKernal = p.shared.blurKernel;\n                        var pix = aImg.imageData.data;\n                        for(y = 0; y < aImgHeight; y++){\n                            for(x = 0; x < aImgWidth; x++){\n                                cb = cg = cr = ca = sum = 0;\n                                read = x - sharedBlurRadius;\n                                if (read < 0) {\n                                    bk0 = -read;\n                                    read = 0;\n                                } else {\n                                    if (read >= aImgWidth) break;\n                                    bk0 = 0;\n                                }\n                                for(i = bk0; i < sharedBlurKernelSize; i++){\n                                    if (read >= aImgWidth) break;\n                                    offset = (read + yi) * 4;\n                                    m = sharedBlurKernal[i];\n                                    ca += m * pix[offset + 3];\n                                    cr += m * pix[offset];\n                                    cg += m * pix[offset + 1];\n                                    cb += m * pix[offset + 2];\n                                    sum += m;\n                                    read++;\n                                }\n                                ri = yi + x;\n                                a2[ri] = ca / sum;\n                                r2[ri] = cr / sum;\n                                g2[ri] = cg / sum;\n                                b2[ri] = cb / sum;\n                            }\n                            yi += aImgWidth;\n                        }\n                        yi = 0;\n                        ym = -sharedBlurRadius;\n                        ymi = ym * aImgWidth;\n                        for(y = 0; y < aImgHeight; y++){\n                            for(x = 0; x < aImgWidth; x++){\n                                cb = cg = cr = ca = sum = 0;\n                                if (ym < 0) {\n                                    bk0 = ri = -ym;\n                                    read = x;\n                                } else {\n                                    if (ym >= aImgHeight) break;\n                                    bk0 = 0;\n                                    ri = ym;\n                                    read = x + ymi;\n                                }\n                                for(i = bk0; i < sharedBlurKernelSize; i++){\n                                    if (ri >= aImgHeight) break;\n                                    m = sharedBlurKernal[i];\n                                    ca += m * a2[read];\n                                    cr += m * r2[read];\n                                    cg += m * g2[read];\n                                    cb += m * b2[read];\n                                    sum += m;\n                                    ri++;\n                                    read += aImgWidth;\n                                }\n                                offset = (x + yi) * 4;\n                                pix[offset] = cr / sum;\n                                pix[offset + 1] = cg / sum;\n                                pix[offset + 2] = cb / sum;\n                                pix[offset + 3] = ca / sum;\n                            }\n                            yi += aImgWidth;\n                            ymi += aImgWidth;\n                            ym++;\n                        }\n                    };\n                    // helper funtion for ERODE and DILATE modes of filter()\n                    var dilate = function(isInverted, aImg) {\n                        var currIdx = 0;\n                        var maxIdx = aImg.pixels.getLength();\n                        var out = new Int32Array(maxIdx);\n                        var currRowIdx, maxRowIdx, colOrig, colOut, currLum;\n                        var idxRight, idxLeft, idxUp, idxDown, colRight, colLeft, colUp, colDown, lumRight, lumLeft, lumUp, lumDown;\n                        if (!isInverted) // erosion (grow light areas)\n                        while(currIdx < maxIdx){\n                            currRowIdx = currIdx;\n                            maxRowIdx = currIdx + aImg.width;\n                            while(currIdx < maxRowIdx){\n                                colOrig = colOut = aImg.pixels.getPixel(currIdx);\n                                idxLeft = currIdx - 1;\n                                idxRight = currIdx + 1;\n                                idxUp = currIdx - aImg.width;\n                                idxDown = currIdx + aImg.width;\n                                if (idxLeft < currRowIdx) idxLeft = currIdx;\n                                if (idxRight >= maxRowIdx) idxRight = currIdx;\n                                if (idxUp < 0) idxUp = 0;\n                                if (idxDown >= maxIdx) idxDown = currIdx;\n                                colUp = aImg.pixels.getPixel(idxUp);\n                                colLeft = aImg.pixels.getPixel(idxLeft);\n                                colDown = aImg.pixels.getPixel(idxDown);\n                                colRight = aImg.pixels.getPixel(idxRight);\n                                // compute luminance\n                                currLum = 77 * (colOrig >> 16 & 0xff) + 151 * (colOrig >> 8 & 0xff) + 28 * (colOrig & 0xff);\n                                lumLeft = 77 * (colLeft >> 16 & 0xff) + 151 * (colLeft >> 8 & 0xff) + 28 * (colLeft & 0xff);\n                                lumRight = 77 * (colRight >> 16 & 0xff) + 151 * (colRight >> 8 & 0xff) + 28 * (colRight & 0xff);\n                                lumUp = 77 * (colUp >> 16 & 0xff) + 151 * (colUp >> 8 & 0xff) + 28 * (colUp & 0xff);\n                                lumDown = 77 * (colDown >> 16 & 0xff) + 151 * (colDown >> 8 & 0xff) + 28 * (colDown & 0xff);\n                                if (lumLeft > currLum) {\n                                    colOut = colLeft;\n                                    currLum = lumLeft;\n                                }\n                                if (lumRight > currLum) {\n                                    colOut = colRight;\n                                    currLum = lumRight;\n                                }\n                                if (lumUp > currLum) {\n                                    colOut = colUp;\n                                    currLum = lumUp;\n                                }\n                                if (lumDown > currLum) {\n                                    colOut = colDown;\n                                    currLum = lumDown;\n                                }\n                                out[currIdx++] = colOut;\n                            }\n                        }\n                        else // dilate (grow dark areas)\n                        while(currIdx < maxIdx){\n                            currRowIdx = currIdx;\n                            maxRowIdx = currIdx + aImg.width;\n                            while(currIdx < maxRowIdx){\n                                colOrig = colOut = aImg.pixels.getPixel(currIdx);\n                                idxLeft = currIdx - 1;\n                                idxRight = currIdx + 1;\n                                idxUp = currIdx - aImg.width;\n                                idxDown = currIdx + aImg.width;\n                                if (idxLeft < currRowIdx) idxLeft = currIdx;\n                                if (idxRight >= maxRowIdx) idxRight = currIdx;\n                                if (idxUp < 0) idxUp = 0;\n                                if (idxDown >= maxIdx) idxDown = currIdx;\n                                colUp = aImg.pixels.getPixel(idxUp);\n                                colLeft = aImg.pixels.getPixel(idxLeft);\n                                colDown = aImg.pixels.getPixel(idxDown);\n                                colRight = aImg.pixels.getPixel(idxRight);\n                                // compute luminance\n                                currLum = 77 * (colOrig >> 16 & 0xff) + 151 * (colOrig >> 8 & 0xff) + 28 * (colOrig & 0xff);\n                                lumLeft = 77 * (colLeft >> 16 & 0xff) + 151 * (colLeft >> 8 & 0xff) + 28 * (colLeft & 0xff);\n                                lumRight = 77 * (colRight >> 16 & 0xff) + 151 * (colRight >> 8 & 0xff) + 28 * (colRight & 0xff);\n                                lumUp = 77 * (colUp >> 16 & 0xff) + 151 * (colUp >> 8 & 0xff) + 28 * (colUp & 0xff);\n                                lumDown = 77 * (colDown >> 16 & 0xff) + 151 * (colDown >> 8 & 0xff) + 28 * (colDown & 0xff);\n                                if (lumLeft < currLum) {\n                                    colOut = colLeft;\n                                    currLum = lumLeft;\n                                }\n                                if (lumRight < currLum) {\n                                    colOut = colRight;\n                                    currLum = lumRight;\n                                }\n                                if (lumUp < currLum) {\n                                    colOut = colUp;\n                                    currLum = lumUp;\n                                }\n                                if (lumDown < currLum) {\n                                    colOut = colDown;\n                                    currLum = lumDown;\n                                }\n                                out[currIdx++] = colOut;\n                            }\n                        }\n                        aImg.pixels.set(out);\n                    //p.arraycopy(out,0,pixels,0,maxIdx);\n                    };\n                    /**\n    * Filters the display window as defined by one of the following modes:\n    * THRESHOLD - converts the image to black and white pixels depending if they are above or below the threshold\n    * defined by the level parameter. The level must be between 0.0 (black) and 1.0(white). If no level is specified, 0.5 is used.\n    * GRAY - converts any colors in the image to grayscale equivalents\n    * INVERT - sets each pixel to its inverse value\n    * POSTERIZE - limits each channel of the image to the number of colors specified as the level parameter\n    * BLUR - executes a Guassian blur with the level parameter specifying the extent of the blurring. If no level parameter is\n    * used, the blur is equivalent to Guassian blur of radius 1.\n    * OPAQUE - sets the alpha channel to entirely opaque.\n    * ERODE - reduces the light areas with the amount defined by the level parameter.\n    * DILATE - increases the light areas with the amount defined by the level parameter.\n    *\n    * @param {MODE} MODE          Either THRESHOLD, GRAY, INVERT, POSTERIZE, BLUR, OPAQUE, ERODE, or DILATE\n    * @param {int|float} level    defines the quality of the filter\n    *\n    * @see blend\n    */ p.filter = function(kind, param, aImg) {\n                        var img, col, lum, i;\n                        if (arguments.length === 3) {\n                            aImg.loadPixels();\n                            img = aImg;\n                        } else {\n                            p.loadPixels();\n                            img = p;\n                        }\n                        if (param === undef) param = null;\n                        if (img.isRemote) throw \"Image is loaded remotely. Cannot filter image.\";\n                        // begin filter process\n                        var imglen = img.pixels.getLength();\n                        switch(kind){\n                            case PConstants1.BLUR:\n                                var radius = param || 1; // if no param specified, use 1 (default for p5)\n                                blurARGB(radius, img);\n                                break;\n                            case PConstants1.GRAY:\n                                if (img.format === PConstants1.ALPHA) {\n                                    // for an alpha image, convert it to an opaque grayscale\n                                    for(i = 0; i < imglen; i++){\n                                        col = 255 - img.pixels.getPixel(i);\n                                        img.pixels.setPixel(i, 0xff000000 | col << 16 | col << 8 | col);\n                                    }\n                                    img.format = PConstants1.RGB; //trouble\n                                } else for(i = 0; i < imglen; i++){\n                                    col = img.pixels.getPixel(i);\n                                    lum = 77 * (col >> 16 & 0xff) + 151 * (col >> 8 & 0xff) + 28 * (col & 0xff) >> 8;\n                                    img.pixels.setPixel(i, col & PConstants1.ALPHA_MASK | lum << 16 | lum << 8 | lum);\n                                }\n                                break;\n                            case PConstants1.INVERT:\n                                for(i = 0; i < imglen; i++)img.pixels.setPixel(i, img.pixels.getPixel(i) ^ 0xffffff);\n                                break;\n                            case PConstants1.POSTERIZE:\n                                if (param === null) throw \"Use filter(POSTERIZE, int levels) instead of filter(POSTERIZE)\";\n                                var levels = p.floor(param);\n                                if (levels < 2 || levels > 255) throw \"Levels must be between 2 and 255 for filter(POSTERIZE, levels)\";\n                                var levels1 = levels - 1;\n                                for(i = 0; i < imglen; i++){\n                                    var rlevel = img.pixels.getPixel(i) >> 16 & 0xff;\n                                    var glevel = img.pixels.getPixel(i) >> 8 & 0xff;\n                                    var blevel = img.pixels.getPixel(i) & 0xff;\n                                    rlevel = (rlevel * levels >> 8) * 255 / levels1;\n                                    glevel = (glevel * levels >> 8) * 255 / levels1;\n                                    blevel = (blevel * levels >> 8) * 255 / levels1;\n                                    img.pixels.setPixel(i, 0xff000000 & img.pixels.getPixel(i) | rlevel << 16 | glevel << 8 | blevel);\n                                }\n                                break;\n                            case PConstants1.OPAQUE:\n                                for(i = 0; i < imglen; i++)img.pixels.setPixel(i, img.pixels.getPixel(i) | 0xff000000);\n                                img.format = PConstants1.RGB; //trouble\n                                break;\n                            case PConstants1.THRESHOLD:\n                                if (param === null) param = 0.5;\n                                if (param < 0 || param > 1) throw \"Level must be between 0 and 1 for filter(THRESHOLD, level)\";\n                                var thresh = p.floor(param * 255);\n                                for(i = 0; i < imglen; i++){\n                                    var max = p.max((img.pixels.getPixel(i) & PConstants1.RED_MASK) >> 16, p.max((img.pixels.getPixel(i) & PConstants1.GREEN_MASK) >> 8, img.pixels.getPixel(i) & PConstants1.BLUE_MASK));\n                                    img.pixels.setPixel(i, img.pixels.getPixel(i) & PConstants1.ALPHA_MASK | (max < thresh ? 0x000000 : 0xffffff));\n                                }\n                                break;\n                            case PConstants1.ERODE:\n                                dilate(true, img);\n                                break;\n                            case PConstants1.DILATE:\n                                dilate(false, img);\n                                break;\n                        }\n                        img.updatePixels();\n                    };\n                    // shared variables for blit_resize(), filter_new_scanline(), filter_bilinear(), filter()\n                    // change this in the future to not be exposed to p\n                    p.shared = {\n                        fracU: 0,\n                        ifU: 0,\n                        fracV: 0,\n                        ifV: 0,\n                        u1: 0,\n                        u2: 0,\n                        v1: 0,\n                        v2: 0,\n                        sX: 0,\n                        sY: 0,\n                        iw: 0,\n                        iw1: 0,\n                        ih1: 0,\n                        ul: 0,\n                        ll: 0,\n                        ur: 0,\n                        lr: 0,\n                        cUL: 0,\n                        cLL: 0,\n                        cUR: 0,\n                        cLR: 0,\n                        srcXOffset: 0,\n                        srcYOffset: 0,\n                        r: 0,\n                        g: 0,\n                        b: 0,\n                        a: 0,\n                        srcBuffer: null,\n                        blurRadius: 0,\n                        blurKernelSize: 0,\n                        blurKernel: null\n                    };\n                    p.intersect = function(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2) {\n                        var sw = sx2 - sx1 + 1;\n                        var sh = sy2 - sy1 + 1;\n                        var dw = dx2 - dx1 + 1;\n                        var dh = dy2 - dy1 + 1;\n                        if (dx1 < sx1) {\n                            dw += dx1 - sx1;\n                            if (dw > sw) dw = sw;\n                        } else {\n                            var w = sw + sx1 - dx1;\n                            if (dw > w) dw = w;\n                        }\n                        if (dy1 < sy1) {\n                            dh += dy1 - sy1;\n                            if (dh > sh) dh = sh;\n                        } else {\n                            var h = sh + sy1 - dy1;\n                            if (dh > h) dh = h;\n                        }\n                        return !(dw <= 0 || dh <= 0);\n                    };\n                    var blendFuncs = {};\n                    blendFuncs[PConstants1.BLEND] = p.modes.blend;\n                    blendFuncs[PConstants1.ADD] = p.modes.add;\n                    blendFuncs[PConstants1.SUBTRACT] = p.modes.subtract;\n                    blendFuncs[PConstants1.LIGHTEST] = p.modes.lightest;\n                    blendFuncs[PConstants1.DARKEST] = p.modes.darkest;\n                    blendFuncs[PConstants1.REPLACE] = p.modes.replace;\n                    blendFuncs[PConstants1.DIFFERENCE] = p.modes.difference;\n                    blendFuncs[PConstants1.EXCLUSION] = p.modes.exclusion;\n                    blendFuncs[PConstants1.MULTIPLY] = p.modes.multiply;\n                    blendFuncs[PConstants1.SCREEN] = p.modes.screen;\n                    blendFuncs[PConstants1.OVERLAY] = p.modes.overlay;\n                    blendFuncs[PConstants1.HARD_LIGHT] = p.modes.hard_light;\n                    blendFuncs[PConstants1.SOFT_LIGHT] = p.modes.soft_light;\n                    blendFuncs[PConstants1.DODGE] = p.modes.dodge;\n                    blendFuncs[PConstants1.BURN] = p.modes.burn;\n                    p.blit_resize = function(img, srcX1, srcY1, srcX2, srcY2, destPixels, screenW, screenH, destX1, destY1, destX2, destY2, mode) {\n                        var x, y;\n                        if (srcX1 < 0) srcX1 = 0;\n                        if (srcY1 < 0) srcY1 = 0;\n                        if (srcX2 >= img.width) srcX2 = img.width - 1;\n                        if (srcY2 >= img.height) srcY2 = img.height - 1;\n                        var srcW = srcX2 - srcX1;\n                        var srcH = srcY2 - srcY1;\n                        var destW = destX2 - destX1;\n                        var destH = destY2 - destY1;\n                        if (destW <= 0 || destH <= 0 || srcW <= 0 || srcH <= 0 || destX1 >= screenW || destY1 >= screenH || srcX1 >= img.width || srcY1 >= img.height) return;\n                        var dx = Math.floor(srcW / destW * PConstants1.PRECISIONF);\n                        var dy = Math.floor(srcH / destH * PConstants1.PRECISIONF);\n                        var pshared = p.shared;\n                        pshared.srcXOffset = Math.floor(destX1 < 0 ? -destX1 * dx : srcX1 * PConstants1.PRECISIONF);\n                        pshared.srcYOffset = Math.floor(destY1 < 0 ? -destY1 * dy : srcY1 * PConstants1.PRECISIONF);\n                        if (destX1 < 0) {\n                            destW += destX1;\n                            destX1 = 0;\n                        }\n                        if (destY1 < 0) {\n                            destH += destY1;\n                            destY1 = 0;\n                        }\n                        destW = Math.min(destW, screenW - destX1);\n                        destH = Math.min(destH, screenH - destY1);\n                        var destOffset = destY1 * screenW + destX1;\n                        var destColor;\n                        pshared.srcBuffer = img.imageData.data;\n                        pshared.iw = img.width;\n                        pshared.iw1 = img.width - 1;\n                        pshared.ih1 = img.height - 1;\n                        // cache for speed\n                        var filterBilinear = p.filter_bilinear, filterNewScanline = p.filter_new_scanline, blendFunc = blendFuncs[mode], blendedColor, idx, cULoffset, cURoffset, cLLoffset, cLRoffset, ALPHA_MASK = PConstants1.ALPHA_MASK, RED_MASK = PConstants1.RED_MASK, GREEN_MASK = PConstants1.GREEN_MASK, BLUE_MASK = PConstants1.BLUE_MASK, PREC_MAXVAL = PConstants1.PREC_MAXVAL, PRECISIONB = PConstants1.PRECISIONB, PREC_RED_SHIFT = PConstants1.PREC_RED_SHIFT, PREC_ALPHA_SHIFT = PConstants1.PREC_ALPHA_SHIFT, srcBuffer = pshared.srcBuffer, min = Math.min;\n                        for(y = 0; y < destH; y++){\n                            pshared.sX = pshared.srcXOffset;\n                            pshared.fracV = pshared.srcYOffset & PREC_MAXVAL;\n                            pshared.ifV = PREC_MAXVAL - pshared.fracV;\n                            pshared.v1 = (pshared.srcYOffset >> PRECISIONB) * pshared.iw;\n                            pshared.v2 = min((pshared.srcYOffset >> PRECISIONB) + 1, pshared.ih1) * pshared.iw;\n                            for(x = 0; x < destW; x++){\n                                idx = (destOffset + x) * 4;\n                                destColor = destPixels[idx + 3] << 24 & ALPHA_MASK | destPixels[idx] << 16 & RED_MASK | destPixels[idx + 1] << 8 & GREEN_MASK | destPixels[idx + 2] & BLUE_MASK;\n                                pshared.fracU = pshared.sX & PREC_MAXVAL;\n                                pshared.ifU = PREC_MAXVAL - pshared.fracU;\n                                pshared.ul = pshared.ifU * pshared.ifV >> PRECISIONB;\n                                pshared.ll = pshared.ifU * pshared.fracV >> PRECISIONB;\n                                pshared.ur = pshared.fracU * pshared.ifV >> PRECISIONB;\n                                pshared.lr = pshared.fracU * pshared.fracV >> PRECISIONB;\n                                pshared.u1 = pshared.sX >> PRECISIONB;\n                                pshared.u2 = min(pshared.u1 + 1, pshared.iw1);\n                                cULoffset = (pshared.v1 + pshared.u1) * 4;\n                                cURoffset = (pshared.v1 + pshared.u2) * 4;\n                                cLLoffset = (pshared.v2 + pshared.u1) * 4;\n                                cLRoffset = (pshared.v2 + pshared.u2) * 4;\n                                pshared.cUL = srcBuffer[cULoffset + 3] << 24 & ALPHA_MASK | srcBuffer[cULoffset] << 16 & RED_MASK | srcBuffer[cULoffset + 1] << 8 & GREEN_MASK | srcBuffer[cULoffset + 2] & BLUE_MASK;\n                                pshared.cUR = srcBuffer[cURoffset + 3] << 24 & ALPHA_MASK | srcBuffer[cURoffset] << 16 & RED_MASK | srcBuffer[cURoffset + 1] << 8 & GREEN_MASK | srcBuffer[cURoffset + 2] & BLUE_MASK;\n                                pshared.cLL = srcBuffer[cLLoffset + 3] << 24 & ALPHA_MASK | srcBuffer[cLLoffset] << 16 & RED_MASK | srcBuffer[cLLoffset + 1] << 8 & GREEN_MASK | srcBuffer[cLLoffset + 2] & BLUE_MASK;\n                                pshared.cLR = srcBuffer[cLRoffset + 3] << 24 & ALPHA_MASK | srcBuffer[cLRoffset] << 16 & RED_MASK | srcBuffer[cLRoffset + 1] << 8 & GREEN_MASK | srcBuffer[cLRoffset + 2] & BLUE_MASK;\n                                pshared.r = pshared.ul * ((pshared.cUL & RED_MASK) >> 16) + pshared.ll * ((pshared.cLL & RED_MASK) >> 16) + pshared.ur * ((pshared.cUR & RED_MASK) >> 16) + pshared.lr * ((pshared.cLR & RED_MASK) >> 16) << PREC_RED_SHIFT & RED_MASK;\n                                pshared.g = pshared.ul * (pshared.cUL & GREEN_MASK) + pshared.ll * (pshared.cLL & GREEN_MASK) + pshared.ur * (pshared.cUR & GREEN_MASK) + pshared.lr * (pshared.cLR & GREEN_MASK) >>> PRECISIONB & GREEN_MASK;\n                                pshared.b = pshared.ul * (pshared.cUL & BLUE_MASK) + pshared.ll * (pshared.cLL & BLUE_MASK) + pshared.ur * (pshared.cUR & BLUE_MASK) + pshared.lr * (pshared.cLR & BLUE_MASK) >>> PRECISIONB;\n                                pshared.a = pshared.ul * ((pshared.cUL & ALPHA_MASK) >>> 24) + pshared.ll * ((pshared.cLL & ALPHA_MASK) >>> 24) + pshared.ur * ((pshared.cUR & ALPHA_MASK) >>> 24) + pshared.lr * ((pshared.cLR & ALPHA_MASK) >>> 24) << PREC_ALPHA_SHIFT & ALPHA_MASK;\n                                blendedColor = blendFunc(destColor, pshared.a | pshared.r | pshared.g | pshared.b);\n                                destPixels[idx] = (blendedColor & RED_MASK) >>> 16;\n                                destPixels[idx + 1] = (blendedColor & GREEN_MASK) >>> 8;\n                                destPixels[idx + 2] = blendedColor & BLUE_MASK;\n                                destPixels[idx + 3] = (blendedColor & ALPHA_MASK) >>> 24;\n                                pshared.sX += dx;\n                            }\n                            destOffset += screenW;\n                            pshared.srcYOffset += dy;\n                        }\n                    };\n                    ////////////////////////////////////////////////////////////////////////////\n                    // Font handling\n                    ////////////////////////////////////////////////////////////////////////////\n                    /**\n     * loadFont() Loads a font into a variable of type PFont.\n     *\n     * @param {String} name filename of the font to load\n     * @param {int|float} size option font size (used internally)\n     *\n     * @returns {PFont} new PFont object\n     *\n     * @see #PFont\n     * @see #textFont\n     * @see #text\n     * @see #createFont\n     */ p.loadFont = function(name, size) {\n                        if (name === undef) throw \"font name required in loadFont.\";\n                        if (name.indexOf(\".svg\") === -1) {\n                            if (size === undef) size = curTextFont.size;\n                            return PFont.get(name, size);\n                        }\n                        // If the font is a glyph, calculate by SVG table\n                        var font = p.loadGlyphs(name);\n                        return {\n                            name: name,\n                            css: \"12px sans-serif\",\n                            glyph: true,\n                            units_per_em: font.units_per_em,\n                            horiz_adv_x: 1 / font.units_per_em * font.horiz_adv_x,\n                            ascent: font.ascent,\n                            descent: font.descent,\n                            width: function(str) {\n                                var width = 0;\n                                var len = str.length;\n                                for(var i = 0; i < len; i++)try {\n                                    width += parseFloat(p.glyphLook(p.glyphTable[name], str[i]).horiz_adv_x);\n                                } catch (e) {\n                                    Processing1.debug(e);\n                                }\n                                return width / p.glyphTable[name].units_per_em;\n                            }\n                        };\n                    };\n                    /**\n     * createFont() Loads a font into a variable of type PFont.\n     * Smooth and charset are ignored in Processing.js.\n     *\n     * @param {String}    name    filename of the font to load\n     * @param {int|float} size    font size in pixels\n     * @param {boolean}   smooth  not used in Processing.js\n     * @param {char[]}    charset not used in Processing.js\n     *\n     * @returns {PFont} new PFont object\n     *\n     * @see #PFont\n     * @see #textFont\n     * @see #text\n     * @see #loadFont\n     */ p.createFont = function(name, size) {\n                        // because Processing.js only deals with real fonts,\n                        // createFont is simply a wrapper for loadFont/2\n                        return p.loadFont(name, size);\n                    };\n                    /**\n     * textFont() Sets the current font.\n     *\n     * @param {PFont}     pfont the PFont to load as current text font\n     * @param {int|float} size optional font size in pixels\n     *\n     * @see #createFont\n     * @see #loadFont\n     * @see #PFont\n     * @see #text\n     */ p.textFont = function(pfont, size) {\n                        if (size !== undef) {\n                            // If we're using an SVG glyph font, don't load from cache\n                            if (!pfont.glyph) pfont = PFont.get(pfont.name, size);\n                            curTextSize = size;\n                        }\n                        curTextFont = pfont;\n                        curFontName = curTextFont.name;\n                        curTextAscent = curTextFont.ascent;\n                        curTextDescent = curTextFont.descent;\n                        curTextLeading = curTextFont.leading;\n                        var curContext = drawing.$ensureContext();\n                        curContext.font = curTextFont.css;\n                    };\n                    /**\n     * textSize() Sets the current font size in pixels.\n     *\n     * @param {int|float} size font size in pixels\n     *\n     * @see #textFont\n     * @see #loadFont\n     * @see #PFont\n     * @see #text\n     */ p.textSize = function(size) {\n                        curTextFont = PFont.get(curFontName, size);\n                        curTextSize = size;\n                        // recache metrics\n                        curTextAscent = curTextFont.ascent;\n                        curTextDescent = curTextFont.descent;\n                        curTextLeading = curTextFont.leading;\n                        var curContext = drawing.$ensureContext();\n                        curContext.font = curTextFont.css;\n                    };\n                    /**\n     * textAscent() returns the maximum height a character extends above the baseline of the\n     * current font at its current size, in pixels.\n     *\n     * @returns {float} height of the current font above the baseline, at its current size, in pixels\n     *\n     * @see #textDescent\n     */ p.textAscent = function() {\n                        return curTextAscent;\n                    };\n                    /**\n     * textDescent() returns the maximum depth a character will protrude below the baseline of\n     * the current font at its current size, in pixels.\n     *\n     * @returns {float} depth of the current font below the baseline, at its current size, in pixels\n     *\n     * @see #textAscent\n     */ p.textDescent = function() {\n                        return curTextDescent;\n                    };\n                    /**\n     * textLeading() Sets the current font's leading, which is the distance\n     * from baseline to baseline over consecutive lines, with additional vertical\n     * spacing taking into account. Usually this value is 1.2 or 1.25 times the\n     * textsize, but this value can be changed to effect vertically compressed\n     * or stretched text.\n     *\n     * @param {int|float} the desired baseline-to-baseline size in pixels\n     */ p.textLeading = function(leading) {\n                        curTextLeading = leading;\n                    };\n                    /**\n     * textAlign() Sets the current alignment for drawing text.\n     *\n     * @param {int} ALIGN  Horizontal alignment, either LEFT, CENTER, or RIGHT\n     * @param {int} YALIGN optional vertical alignment, either TOP, BOTTOM, CENTER, or BASELINE\n     *\n     * @see #loadFont\n     * @see #PFont\n     * @see #text\n     */ p.textAlign = function(xalign, yalign) {\n                        horizontalTextAlignment = xalign;\n                        verticalTextAlignment = yalign || PConstants1.BASELINE;\n                    };\n                    /**\n     * toP5String converts things with arbitrary data type into\n     * string values, for text rendering.\n     *\n     * @param {any} any object that can be converted into a string\n     *\n     * @return {String} the string representation of the input\n     */ function toP5String(obj) {\n                        if (obj instanceof String) return obj;\n                        if (typeof obj === \"number\") {\n                            // check if an int\n                            if (obj === (0 | obj)) return obj.toString();\n                            return p.nf(obj, 0, 3);\n                        }\n                        if (obj === null || obj === undef) return \"\";\n                        return obj.toString();\n                    }\n                    /**\n     * textWidth() Calculates and returns the width of any character or text string in pixels.\n     *\n     * @param {char|String} str char or String to be measured\n     *\n     * @return {float} width of char or String in pixels\n     *\n     * @see #loadFont\n     * @see #PFont\n     * @see #text\n     * @see #textFont\n     */ Drawing2D.prototype.textWidth = function(str) {\n                        var lines = toP5String(str).split(/\\r?\\n/g), width = 0;\n                        var i, linesCount = lines.length;\n                        curContext.font = curTextFont.css;\n                        for(i = 0; i < linesCount; ++i)width = Math.max(width, curTextFont.measureTextWidth(lines[i]));\n                        return width | 0;\n                    };\n                    Drawing3D.prototype.textWidth = function(str) {\n                        var lines = toP5String(str).split(/\\r?\\n/g), width = 0;\n                        var i, linesCount = lines.length;\n                        if (textcanvas === undef) textcanvas = document1.createElement(\"canvas\");\n                        var textContext = textcanvas.getContext(\"2d\");\n                        textContext.font = curTextFont.css;\n                        for(i = 0; i < linesCount; ++i)width = Math.max(width, textContext.measureText(lines[i]).width);\n                        return width | 0;\n                    };\n                    // A lookup table for characters that can not be referenced by Object\n                    p.glyphLook = function(font, chr) {\n                        try {\n                            switch(chr){\n                                case \"1\":\n                                    return font.one;\n                                case \"2\":\n                                    return font.two;\n                                case \"3\":\n                                    return font.three;\n                                case \"4\":\n                                    return font.four;\n                                case \"5\":\n                                    return font.five;\n                                case \"6\":\n                                    return font.six;\n                                case \"7\":\n                                    return font.seven;\n                                case \"8\":\n                                    return font.eight;\n                                case \"9\":\n                                    return font.nine;\n                                case \"0\":\n                                    return font.zero;\n                                case \" \":\n                                    return font.space;\n                                case \"$\":\n                                    return font.dollar;\n                                case \"!\":\n                                    return font.exclam;\n                                case '\"':\n                                    return font.quotedbl;\n                                case \"#\":\n                                    return font.numbersign;\n                                case \"%\":\n                                    return font.percent;\n                                case \"&\":\n                                    return font.ampersand;\n                                case \"'\":\n                                    return font.quotesingle;\n                                case \"(\":\n                                    return font.parenleft;\n                                case \")\":\n                                    return font.parenright;\n                                case \"*\":\n                                    return font.asterisk;\n                                case \"+\":\n                                    return font.plus;\n                                case \",\":\n                                    return font.comma;\n                                case \"-\":\n                                    return font.hyphen;\n                                case \".\":\n                                    return font.period;\n                                case \"/\":\n                                    return font.slash;\n                                case \"_\":\n                                    return font.underscore;\n                                case \":\":\n                                    return font.colon;\n                                case \";\":\n                                    return font.semicolon;\n                                case \"<\":\n                                    return font.less;\n                                case \"=\":\n                                    return font.equal;\n                                case \">\":\n                                    return font.greater;\n                                case \"?\":\n                                    return font.question;\n                                case \"@\":\n                                    return font.at;\n                                case \"[\":\n                                    return font.bracketleft;\n                                case \"\\\\\":\n                                    return font.backslash;\n                                case \"]\":\n                                    return font.bracketright;\n                                case \"^\":\n                                    return font.asciicircum;\n                                case \"`\":\n                                    return font.grave;\n                                case \"{\":\n                                    return font.braceleft;\n                                case \"|\":\n                                    return font.bar;\n                                case \"}\":\n                                    return font.braceright;\n                                case \"~\":\n                                    return font.asciitilde;\n                                // If the character is not 'special', access it by object reference\n                                default:\n                                    return font[chr];\n                            }\n                        } catch (e) {\n                            Processing1.debug(e);\n                        }\n                    };\n                    // Print some text to the Canvas\n                    Drawing2D.prototype.text$line = function(str, x, y, z, align) {\n                        var textWidth = 0, xOffset = 0;\n                        // If the font is a standard Canvas font...\n                        if (!curTextFont.glyph) {\n                            if (str && \"fillText\" in curContext) {\n                                if (isFillDirty) {\n                                    curContext.fillStyle = p.color.toString(currentFillColor);\n                                    isFillDirty = false;\n                                }\n                                // horizontal offset/alignment\n                                if (align === PConstants1.RIGHT || align === PConstants1.CENTER) {\n                                    textWidth = curTextFont.measureTextWidth(str);\n                                    if (align === PConstants1.RIGHT) xOffset = -textWidth;\n                                    else xOffset = -textWidth / 2;\n                                }\n                                curContext.fillText(str, x + xOffset, y);\n                            }\n                        } else {\n                            // If the font is a Batik SVG font...\n                            var font = p.glyphTable[curFontName];\n                            saveContext();\n                            curContext.translate(x, y + curTextSize);\n                            // horizontal offset/alignment\n                            if (align === PConstants1.RIGHT || align === PConstants1.CENTER) {\n                                textWidth = font.width(str);\n                                if (align === PConstants1.RIGHT) xOffset = -textWidth;\n                                else xOffset = -textWidth / 2;\n                            }\n                            var upem = font.units_per_em, newScale = 1 / upem * curTextSize;\n                            curContext.scale(newScale, newScale);\n                            for(var i = 0, len = str.length; i < len; i++)// Test character against glyph table\n                            try {\n                                p.glyphLook(font, str[i]).draw();\n                            } catch (e) {\n                                Processing1.debug(e);\n                            }\n                            restoreContext();\n                        }\n                    };\n                    Drawing3D.prototype.text$line = function(str, x, y, z, align) {\n                        // handle case for 3d text\n                        if (textcanvas === undef) textcanvas = document1.createElement(\"canvas\");\n                        var oldContext = curContext;\n                        curContext = textcanvas.getContext(\"2d\");\n                        curContext.font = curTextFont.css;\n                        var textWidth = curTextFont.measureTextWidth(str);\n                        textcanvas.width = textWidth;\n                        textcanvas.height = curTextSize;\n                        curContext = textcanvas.getContext(\"2d\"); // refreshes curContext\n                        curContext.font = curTextFont.css;\n                        curContext.textBaseline = \"top\";\n                        // paint on 2D canvas\n                        Drawing2D.prototype.text$line(str, 0, 0, 0, PConstants1.LEFT);\n                        // use it as a texture\n                        var aspect = textcanvas.width / textcanvas.height;\n                        curContext = oldContext;\n                        curContext.bindTexture(curContext.TEXTURE_2D, textTex);\n                        curContext.texImage2D(curContext.TEXTURE_2D, 0, curContext.RGBA, curContext.RGBA, curContext.UNSIGNED_BYTE, textcanvas);\n                        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MAG_FILTER, curContext.LINEAR);\n                        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MIN_FILTER, curContext.LINEAR);\n                        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_WRAP_T, curContext.CLAMP_TO_EDGE);\n                        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_WRAP_S, curContext.CLAMP_TO_EDGE);\n                        // If we don't have a power of two texture, we can't mipmap it.\n                        // curContext.generateMipmap(curContext.TEXTURE_2D);\n                        // horizontal offset/alignment\n                        var xOffset = 0;\n                        if (align === PConstants1.RIGHT) xOffset = -textWidth;\n                        else if (align === PConstants1.CENTER) xOffset = -textWidth / 2;\n                        var model = new PMatrix3D();\n                        var scalefactor = curTextSize * 0.5;\n                        model.translate(x + xOffset - scalefactor / 2, y - scalefactor, z);\n                        model.scale(-aspect * scalefactor, -scalefactor, scalefactor);\n                        model.translate(-1, -1, -1);\n                        model.transpose();\n                        var view = new PMatrix3D();\n                        view.scale(1, -1, 1);\n                        view.apply(modelView.array());\n                        view.transpose();\n                        curContext.useProgram(programObject2D);\n                        vertexAttribPointer(\"aVertex2d\", programObject2D, \"aVertex\", 3, textBuffer);\n                        vertexAttribPointer(\"aTextureCoord2d\", programObject2D, \"aTextureCoord\", 2, textureBuffer);\n                        uniformi(\"uSampler2d\", programObject2D, \"uSampler\", [\n                            0\n                        ]);\n                        uniformi(\"uIsDrawingText2d\", programObject2D, \"uIsDrawingText\", true);\n                        uniformMatrix(\"uModel2d\", programObject2D, \"uModel\", false, model.array());\n                        uniformMatrix(\"uView2d\", programObject2D, \"uView\", false, view.array());\n                        uniformf(\"uColor2d\", programObject2D, \"uColor\", fillStyle);\n                        curContext.bindBuffer(curContext.ELEMENT_ARRAY_BUFFER, indexBuffer);\n                        curContext.drawElements(curContext.TRIANGLES, 6, curContext.UNSIGNED_SHORT, 0);\n                    };\n                    /**\n    * unbounded text function (z is an optional argument)\n    */ function text$4(str, x, y, z) {\n                        var lines, linesCount;\n                        if (str.indexOf(\"\\n\") < 0) {\n                            lines = [\n                                str\n                            ];\n                            linesCount = 1;\n                        } else {\n                            lines = str.split(/\\r?\\n/g);\n                            linesCount = lines.length;\n                        }\n                        // handle text line-by-line\n                        var yOffset = 0;\n                        if (verticalTextAlignment === PConstants1.TOP) yOffset = curTextAscent + curTextDescent;\n                        else if (verticalTextAlignment === PConstants1.CENTER) yOffset = curTextAscent / 2 - (linesCount - 1) * curTextLeading / 2;\n                        else if (verticalTextAlignment === PConstants1.BOTTOM) yOffset = -(curTextDescent + (linesCount - 1) * curTextLeading);\n                        for(var i = 0; i < linesCount; ++i){\n                            var line = lines[i];\n                            drawing.text$line(line, x, y + yOffset, z, horizontalTextAlignment);\n                            yOffset += curTextLeading;\n                        }\n                    }\n                    /**\n    * box-bounded text function (z is an optional argument)\n    */ function text$6(str, x, y, width, height, z) {\n                        // 'fail' on 0-valued dimensions\n                        if (str.length === 0 || width === 0 || height === 0) return;\n                        // also 'fail' if the text height is larger than the bounding height\n                        if (curTextSize > height) return;\n                        var spaceMark = -1;\n                        var start = 0;\n                        var lineWidth = 0;\n                        var drawCommands = [];\n                        // run through text, character-by-character\n                        for(var charPos = 0, len = str.length; charPos < len; charPos++){\n                            var currentChar = str[charPos];\n                            var spaceChar = currentChar === \" \";\n                            var letterWidth = curTextFont.measureTextWidth(currentChar);\n                            // if we aren't looking at a newline, and the text still fits, keep processing\n                            if (currentChar !== \"\\n\" && lineWidth + letterWidth <= width) {\n                                if (spaceChar) spaceMark = charPos;\n                                lineWidth += letterWidth;\n                            } else {\n                                if (spaceMark + 1 === start) {\n                                    if (charPos > 0) // Whole line without spaces so far.\n                                    spaceMark = charPos;\n                                    else // 'fail', because the line can't even fit the first character\n                                    return;\n                                }\n                                if (currentChar === \"\\n\") {\n                                    drawCommands.push({\n                                        text: str.substring(start, charPos),\n                                        width: lineWidth\n                                    });\n                                    start = charPos + 1;\n                                } else {\n                                    // current is not a newline, which means the line doesn't fit in box. push text.\n                                    // In Processing 1.5.1, the space is also pushed, so we push up to spaceMark+1,\n                                    // rather than up to spaceMark, as was the case for Processing 1.5 and earlier.\n                                    drawCommands.push({\n                                        text: str.substring(start, spaceMark + 1),\n                                        width: lineWidth\n                                    });\n                                    start = spaceMark + 1;\n                                }\n                                // newline + return\n                                lineWidth = 0;\n                                charPos = start - 1;\n                            }\n                        }\n                        // push the remaining text\n                        if (start < len) drawCommands.push({\n                            text: str.substring(start),\n                            width: lineWidth\n                        });\n                        // resolve horizontal alignment\n                        var xOffset = 1, yOffset = curTextAscent;\n                        if (horizontalTextAlignment === PConstants1.CENTER) xOffset = width / 2;\n                        else if (horizontalTextAlignment === PConstants1.RIGHT) xOffset = width;\n                        // resolve vertical alignment\n                        var linesCount = drawCommands.length, visibleLines = Math.min(linesCount, Math.floor(height / curTextLeading));\n                        if (verticalTextAlignment === PConstants1.TOP) yOffset = curTextAscent + curTextDescent;\n                        else if (verticalTextAlignment === PConstants1.CENTER) yOffset = height / 2 - curTextLeading * (visibleLines / 2 - 1);\n                        else if (verticalTextAlignment === PConstants1.BOTTOM) yOffset = curTextDescent + curTextLeading;\n                        var command, drawCommand, leading;\n                        for(command = 0; command < linesCount; command++){\n                            leading = command * curTextLeading;\n                            // stop if not enough space for one more line draw\n                            if (yOffset + leading > height - curTextDescent) break;\n                            drawCommand = drawCommands[command];\n                            drawing.text$line(drawCommand.text, x + xOffset, y + yOffset + leading, z, horizontalTextAlignment);\n                        }\n                    }\n                    /**\n     * text() Draws text to the screen.\n     *\n     * @param {String|char|int|float} data       the alphanumeric symbols to be displayed\n     * @param {int|float}             x          x-coordinate of text\n     * @param {int|float}             y          y-coordinate of text\n     * @param {int|float}             z          optional z-coordinate of text\n     * @param {String}                stringdata optional letters to be displayed\n     * @param {int|float}             width      optional width of text box\n     * @param {int|float}             height     optional height of text box\n     *\n     * @see #textAlign\n     * @see #textMode\n     * @see #loadFont\n     * @see #PFont\n     * @see #textFont\n     */ p.text = function() {\n                        if (textMode === PConstants1.SHAPE) // TODO: requires beginRaw function\n                        return;\n                        if (arguments.length === 3) text$4(toP5String(arguments[0]), arguments[1], arguments[2], 0);\n                        else if (arguments.length === 4) text$4(toP5String(arguments[0]), arguments[1], arguments[2], arguments[3]);\n                        else if (arguments.length === 5) text$6(toP5String(arguments[0]), arguments[1], arguments[2], arguments[3], arguments[4], 0);\n                        else if (arguments.length === 6) text$6(toP5String(arguments[0]), arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);\n                    };\n                    /**\n     * Sets the way text draws to the screen. In the default configuration (the MODEL mode), it's possible to rotate,\n     * scale, and place letters in two and three dimensional space. <br /><br /> Changing to SCREEN mode draws letters\n     * directly to the front of the window and greatly increases rendering quality and speed when used with the P2D and\n     * P3D renderers. textMode(SCREEN) with OPENGL and JAVA2D (the default) renderers will generally be slower, though\n     * pixel accurate with P2D and P3D. With textMode(SCREEN), the letters draw at the actual size of the font (in pixels)\n     * and therefore calls to <b>textSize()</b> will not affect the size of the letters. To create a font at the size you\n     * desire, use the \"Create font...\" option in the Tools menu, or use the createFont() function. When using textMode(SCREEN),\n     * any z-coordinate passed to a text() command will be ignored, because your computer screen is...flat!\n     *\n     * @param {int} MODE Either MODEL, SCREEN or SHAPE (not yet supported)\n     *\n     * @see loadFont\n     * @see PFont\n     * @see text\n     * @see textFont\n     * @see createFont\n     */ p.textMode = function(mode) {\n                        textMode = mode;\n                    };\n                    // Load Batik SVG Fonts and parse to pre-def objects for quick rendering\n                    p.loadGlyphs = function(url) {\n                        var x, y, cx, cy, nx, ny, d, a, lastCom, lenC, horiz_adv_x, getXY = \"[0-9\\\\-]+\", path;\n                        // Return arrays of SVG commands and coords\n                        // get this to use p.matchAll() - will need to work around the lack of null return\n                        var regex = function(needle, hay) {\n                            var i = 0, results = [], latest, regexp = new RegExp(needle, \"g\");\n                            latest = results[i] = regexp.exec(hay);\n                            while(latest){\n                                i++;\n                                latest = results[i] = regexp.exec(hay);\n                            }\n                            return results;\n                        };\n                        var buildPath = function(d) {\n                            var c = regex(\"[A-Za-z][0-9\\\\- ]+|Z\", d);\n                            var beforePathDraw = function() {\n                                saveContext();\n                                return drawing.$ensureContext();\n                            };\n                            var afterPathDraw = function() {\n                                executeContextFill();\n                                executeContextStroke();\n                                restoreContext();\n                            };\n                            // Begin storing path object\n                            path = \"return {draw:function(){var curContext=beforePathDraw();curContext.beginPath();\";\n                            x = 0;\n                            y = 0;\n                            cx = 0;\n                            cy = 0;\n                            nx = 0;\n                            ny = 0;\n                            d = 0;\n                            a = 0;\n                            lastCom = \"\";\n                            lenC = c.length - 1;\n                            // Loop through SVG commands translating to canvas eqivs functions in path object\n                            for(var j = 0; j < lenC; j++){\n                                var com = c[j][0], xy = regex(getXY, com);\n                                switch(com[0]){\n                                    case \"M\":\n                                        //curContext.moveTo(x,-y);\n                                        x = parseFloat(xy[0][0]);\n                                        y = parseFloat(xy[1][0]);\n                                        path += \"curContext.moveTo(\" + x + \",\" + -y + \");\";\n                                        break;\n                                    case \"L\":\n                                        //curContext.lineTo(x,-y);\n                                        x = parseFloat(xy[0][0]);\n                                        y = parseFloat(xy[1][0]);\n                                        path += \"curContext.lineTo(\" + x + \",\" + -y + \");\";\n                                        break;\n                                    case \"H\":\n                                        //curContext.lineTo(x,-y)\n                                        x = parseFloat(xy[0][0]);\n                                        path += \"curContext.lineTo(\" + x + \",\" + -y + \");\";\n                                        break;\n                                    case \"V\":\n                                        //curContext.lineTo(x,-y);\n                                        y = parseFloat(xy[0][0]);\n                                        path += \"curContext.lineTo(\" + x + \",\" + -y + \");\";\n                                        break;\n                                    case \"T\":\n                                        //curContext.quadraticCurveTo(cx,-cy,nx,-ny);\n                                        nx = parseFloat(xy[0][0]);\n                                        ny = parseFloat(xy[1][0]);\n                                        if (lastCom === \"Q\" || lastCom === \"T\") {\n                                            d = Math.sqrt(Math.pow(x - cx, 2) + Math.pow(cy - y, 2));\n                                            a = Math.PI + Math.atan2(cx - x, cy - y);\n                                            cx = x + Math.sin(a) * d;\n                                            cy = y + Math.cos(a) * d;\n                                        } else {\n                                            cx = x;\n                                            cy = y;\n                                        }\n                                        path += \"curContext.quadraticCurveTo(\" + cx + \",\" + -cy + \",\" + nx + \",\" + -ny + \");\";\n                                        x = nx;\n                                        y = ny;\n                                        break;\n                                    case \"Q\":\n                                        //curContext.quadraticCurveTo(cx,-cy,nx,-ny);\n                                        cx = parseFloat(xy[0][0]);\n                                        cy = parseFloat(xy[1][0]);\n                                        nx = parseFloat(xy[2][0]);\n                                        ny = parseFloat(xy[3][0]);\n                                        path += \"curContext.quadraticCurveTo(\" + cx + \",\" + -cy + \",\" + nx + \",\" + -ny + \");\";\n                                        x = nx;\n                                        y = ny;\n                                        break;\n                                    case \"Z\":\n                                        //curContext.closePath();\n                                        path += \"curContext.closePath();\";\n                                        break;\n                                }\n                                lastCom = com[0];\n                            }\n                            path += \"afterPathDraw();\";\n                            path += \"curContext.translate(\" + horiz_adv_x + \",0);\";\n                            path += \"}}\";\n                            return new Function(\"beforePathDraw\", \"afterPathDraw\", path)(beforePathDraw, afterPathDraw);\n                        };\n                        // Parse SVG font-file into block of Canvas commands\n                        var parseSVGFont = function(svg) {\n                            // Store font attributes\n                            var font = svg.getElementsByTagName(\"font\");\n                            p.glyphTable[url].horiz_adv_x = font[0].getAttribute(\"horiz-adv-x\");\n                            var font_face = svg.getElementsByTagName(\"font-face\")[0];\n                            p.glyphTable[url].units_per_em = parseFloat(font_face.getAttribute(\"units-per-em\"));\n                            p.glyphTable[url].ascent = parseFloat(font_face.getAttribute(\"ascent\"));\n                            p.glyphTable[url].descent = parseFloat(font_face.getAttribute(\"descent\"));\n                            var glyph = svg.getElementsByTagName(\"glyph\"), len = glyph.length;\n                            // Loop through each glyph in the SVG\n                            for(var i = 0; i < len; i++){\n                                // Store attributes for this glyph\n                                var unicode = glyph[i].getAttribute(\"unicode\");\n                                var name = glyph[i].getAttribute(\"glyph-name\");\n                                horiz_adv_x = glyph[i].getAttribute(\"horiz-adv-x\");\n                                if (horiz_adv_x === null) horiz_adv_x = p.glyphTable[url].horiz_adv_x;\n                                d = glyph[i].getAttribute(\"d\");\n                                // Split path commands in glpyh\n                                if (d !== undef) {\n                                    path = buildPath(d);\n                                    // Store glyph data to table object\n                                    p.glyphTable[url][name] = {\n                                        name: name,\n                                        unicode: unicode,\n                                        horiz_adv_x: horiz_adv_x,\n                                        draw: path.draw\n                                    };\n                                }\n                            } // finished adding glyphs to table\n                        };\n                        // Load and parse Batik SVG font as XML into a Processing Glyph object\n                        var loadXML = function() {\n                            var xmlDoc;\n                            try {\n                                xmlDoc = document1.implementation.createDocument(\"\", \"\", null);\n                            } catch (e_fx_op) {\n                                Processing1.debug(e_fx_op.message);\n                                return;\n                            }\n                            try {\n                                xmlDoc.async = false;\n                                xmlDoc.load(url);\n                                parseSVGFont(xmlDoc.getElementsByTagName(\"svg\")[0]);\n                            } catch (e_sf_ch) {\n                                // Google Chrome, Safari etc.\n                                Processing1.debug(e_sf_ch);\n                                try {\n                                    var xmlhttp = new window1.XMLHttpRequest();\n                                    xmlhttp.open(\"GET\", url, false);\n                                    xmlhttp.send(null);\n                                    parseSVGFont(xmlhttp.responseXML.documentElement);\n                                } catch (e) {\n                                    Processing1.debug(e_sf_ch);\n                                }\n                            }\n                        };\n                        // Create a new object in glyphTable to store this font\n                        p.glyphTable[url] = {};\n                        // Begin loading the Batik SVG font...\n                        loadXML(url);\n                        // Return the loaded font for attribute grabbing\n                        return p.glyphTable[url];\n                    };\n                    /**\n     * Gets the sketch parameter value. The parameter can be defined as the canvas attribute with\n     * the \"data-processing-\" prefix or provided in the pjs directive (e.g. param-test=\"52\").\n     * The function tries the canvas attributes, then the pjs directive content.\n     *\n     * @param   {String}    name          The name of the param to read.\n     *\n     * @returns {String}    The parameter value, or null if parameter is not defined.\n     */ p.param = function(name) {\n                        // trying attribute that was specified in CANVAS\n                        var attributeName = \"data-processing-\" + name;\n                        if (curElement.hasAttribute(attributeName)) return curElement.getAttribute(attributeName);\n                        // trying child PARAM elements of the CANVAS\n                        for(var i = 0, len = curElement.childNodes.length; i < len; ++i){\n                            var item = curElement.childNodes.item(i);\n                            if (item.nodeType !== 1 || item.tagName.toLowerCase() !== \"param\") continue;\n                            if (item.getAttribute(\"name\") === name) return item.getAttribute(\"value\");\n                        }\n                        // fallback to default params\n                        if (curSketch.params.hasOwnProperty(name)) return curSketch.params[name];\n                        return null;\n                    };\n                    ////////////////////////////////////////////////////////////////////////////\n                    // 2D/3D methods wiring utils\n                    ////////////////////////////////////////////////////////////////////////////\n                    function wireDimensionalFunctions(mode) {\n                        // Drawing2D/Drawing3D\n                        if (mode === \"3D\") drawing = new Drawing3D();\n                        else if (mode === \"2D\") drawing = new Drawing2D();\n                        else drawing = new DrawingPre();\n                        // Wire up functions (Use DrawingPre properties names)\n                        for(var i in DrawingPre.prototype)if (DrawingPre.prototype.hasOwnProperty(i) && i.indexOf(\"$\") < 0) p[i] = drawing[i];\n                        // Run initialization\n                        drawing.$init();\n                    }\n                    function createDrawingPreFunction(name) {\n                        return function() {\n                            wireDimensionalFunctions(\"2D\");\n                            return drawing[name].apply(this, arguments);\n                        };\n                    }\n                    DrawingPre.prototype.translate = createDrawingPreFunction(\"translate\");\n                    DrawingPre.prototype.transform = createDrawingPreFunction(\"transform\");\n                    DrawingPre.prototype.scale = createDrawingPreFunction(\"scale\");\n                    DrawingPre.prototype.pushMatrix = createDrawingPreFunction(\"pushMatrix\");\n                    DrawingPre.prototype.popMatrix = createDrawingPreFunction(\"popMatrix\");\n                    DrawingPre.prototype.resetMatrix = createDrawingPreFunction(\"resetMatrix\");\n                    DrawingPre.prototype.applyMatrix = createDrawingPreFunction(\"applyMatrix\");\n                    DrawingPre.prototype.rotate = createDrawingPreFunction(\"rotate\");\n                    DrawingPre.prototype.rotateZ = createDrawingPreFunction(\"rotateZ\");\n                    DrawingPre.prototype.shearX = createDrawingPreFunction(\"shearX\");\n                    DrawingPre.prototype.shearY = createDrawingPreFunction(\"shearY\");\n                    DrawingPre.prototype.redraw = createDrawingPreFunction(\"redraw\");\n                    DrawingPre.prototype.toImageData = createDrawingPreFunction(\"toImageData\");\n                    DrawingPre.prototype.ambientLight = createDrawingPreFunction(\"ambientLight\");\n                    DrawingPre.prototype.directionalLight = createDrawingPreFunction(\"directionalLight\");\n                    DrawingPre.prototype.lightFalloff = createDrawingPreFunction(\"lightFalloff\");\n                    DrawingPre.prototype.lightSpecular = createDrawingPreFunction(\"lightSpecular\");\n                    DrawingPre.prototype.pointLight = createDrawingPreFunction(\"pointLight\");\n                    DrawingPre.prototype.noLights = createDrawingPreFunction(\"noLights\");\n                    DrawingPre.prototype.spotLight = createDrawingPreFunction(\"spotLight\");\n                    DrawingPre.prototype.beginCamera = createDrawingPreFunction(\"beginCamera\");\n                    DrawingPre.prototype.endCamera = createDrawingPreFunction(\"endCamera\");\n                    DrawingPre.prototype.frustum = createDrawingPreFunction(\"frustum\");\n                    DrawingPre.prototype.box = createDrawingPreFunction(\"box\");\n                    DrawingPre.prototype.sphere = createDrawingPreFunction(\"sphere\");\n                    DrawingPre.prototype.ambient = createDrawingPreFunction(\"ambient\");\n                    DrawingPre.prototype.emissive = createDrawingPreFunction(\"emissive\");\n                    DrawingPre.prototype.shininess = createDrawingPreFunction(\"shininess\");\n                    DrawingPre.prototype.specular = createDrawingPreFunction(\"specular\");\n                    DrawingPre.prototype.fill = createDrawingPreFunction(\"fill\");\n                    DrawingPre.prototype.stroke = createDrawingPreFunction(\"stroke\");\n                    DrawingPre.prototype.strokeWeight = createDrawingPreFunction(\"strokeWeight\");\n                    DrawingPre.prototype.smooth = createDrawingPreFunction(\"smooth\");\n                    DrawingPre.prototype.noSmooth = createDrawingPreFunction(\"noSmooth\");\n                    DrawingPre.prototype.point = createDrawingPreFunction(\"point\");\n                    DrawingPre.prototype.vertex = createDrawingPreFunction(\"vertex\");\n                    DrawingPre.prototype.endShape = createDrawingPreFunction(\"endShape\");\n                    DrawingPre.prototype.bezierVertex = createDrawingPreFunction(\"bezierVertex\");\n                    DrawingPre.prototype.curveVertex = createDrawingPreFunction(\"curveVertex\");\n                    DrawingPre.prototype.curve = createDrawingPreFunction(\"curve\");\n                    DrawingPre.prototype.line = createDrawingPreFunction(\"line\");\n                    DrawingPre.prototype.bezier = createDrawingPreFunction(\"bezier\");\n                    DrawingPre.prototype.rect = createDrawingPreFunction(\"rect\");\n                    DrawingPre.prototype.ellipse = createDrawingPreFunction(\"ellipse\");\n                    DrawingPre.prototype.background = createDrawingPreFunction(\"background\");\n                    DrawingPre.prototype.image = createDrawingPreFunction(\"image\");\n                    DrawingPre.prototype.textWidth = createDrawingPreFunction(\"textWidth\");\n                    DrawingPre.prototype.text$line = createDrawingPreFunction(\"text$line\");\n                    DrawingPre.prototype.$ensureContext = createDrawingPreFunction(\"$ensureContext\");\n                    DrawingPre.prototype.$newPMatrix = createDrawingPreFunction(\"$newPMatrix\");\n                    DrawingPre.prototype.size = function(aWidth, aHeight, aMode) {\n                        wireDimensionalFunctions(aMode === PConstants1.WEBGL ? \"3D\" : \"2D\");\n                        p.size(aWidth, aHeight, aMode);\n                    };\n                    DrawingPre.prototype.$init = noop;\n                    Drawing2D.prototype.$init = function() {\n                        // Setup default 2d canvas context.\n                        // Moving this here removes the number of times we need to check the 3D variable\n                        p.size(p.width, p.height);\n                        curContext.lineCap = \"round\";\n                        // Set default stroke and fill color\n                        p.noSmooth();\n                        p.disableContextMenu();\n                    };\n                    Drawing3D.prototype.$init = function() {\n                        // For ref/perf test compatibility until those are fixed\n                        p.use3DContext = true;\n                        p.disableContextMenu();\n                    };\n                    DrawingShared.prototype.$ensureContext = function() {\n                        return curContext;\n                    };\n                    //////////////////////////////////////////////////////////////////////////\n                    // Keyboard Events\n                    //////////////////////////////////////////////////////////////////////////\n                    // In order to catch key events in a canvas, it needs to be \"specially focusable\",\n                    // by assigning it a tabindex. If no tabindex is specified on-page, set this to 0.\n                    if (!curElement.getAttribute(\"tabindex\")) curElement.setAttribute(\"tabindex\", 0);\n                    function getKeyCode(e) {\n                        var code = e.which || e.keyCode;\n                        switch(code){\n                            case 13:\n                                return 10;\n                            case 91:\n                            case 93:\n                            case 224:\n                                return 157;\n                            case 57392:\n                                return 17;\n                            case 46:\n                                return 127;\n                            case 45:\n                                return 155;\n                        }\n                        return code;\n                    }\n                    function getKeyChar(e) {\n                        var c = e.which || e.keyCode;\n                        var anyShiftPressed = e.shiftKey || e.ctrlKey || e.altKey || e.metaKey;\n                        switch(c){\n                            case 13:\n                                c = anyShiftPressed ? 13 : 10; // RETURN vs ENTER (Mac)\n                                break;\n                            case 8:\n                                c = anyShiftPressed ? 127 : 8; // DELETE vs BACKSPACE (Mac)\n                                break;\n                        }\n                        return new Char(c);\n                    }\n                    function suppressKeyEvent(e) {\n                        if (typeof e.preventDefault === \"function\") e.preventDefault();\n                        else if (typeof e.stopPropagation === \"function\") e.stopPropagation();\n                        return false;\n                    }\n                    function updateKeyPressed() {\n                        var ch;\n                        for(ch in pressedKeysMap)if (pressedKeysMap.hasOwnProperty(ch)) {\n                            p.__keyPressed = true;\n                            return;\n                        }\n                        p.__keyPressed = false;\n                    }\n                    function resetKeyPressed() {\n                        p.__keyPressed = false;\n                        pressedKeysMap = [];\n                        lastPressedKeyCode = null;\n                    }\n                    function simulateKeyTyped(code, c) {\n                        pressedKeysMap[code] = c;\n                        lastPressedKeyCode = null;\n                        p.key = c;\n                        p.keyCode = code;\n                        p.keyPressed();\n                        p.keyCode = 0;\n                        p.keyTyped();\n                        updateKeyPressed();\n                    }\n                    function handleKeydown(e) {\n                        var code = getKeyCode(e);\n                        if (code === PConstants1.DELETE) {\n                            simulateKeyTyped(code, new Char(127));\n                            return;\n                        }\n                        if (codedKeys.indexOf(code) < 0) {\n                            lastPressedKeyCode = code;\n                            return;\n                        }\n                        var c = new Char(PConstants1.CODED);\n                        p.key = c;\n                        p.keyCode = code;\n                        pressedKeysMap[code] = c;\n                        p.keyPressed();\n                        lastPressedKeyCode = null;\n                        updateKeyPressed();\n                        return suppressKeyEvent(e);\n                    }\n                    function handleKeypress(e) {\n                        if (lastPressedKeyCode === null) return; // processed in handleKeydown\n                        var code = lastPressedKeyCode, c = getKeyChar(e);\n                        simulateKeyTyped(code, c);\n                        return suppressKeyEvent(e);\n                    }\n                    function handleKeyup(e) {\n                        var code = getKeyCode(e), c = pressedKeysMap[code];\n                        if (c === undef) return; // no keyPressed event was generated.\n                        p.key = c;\n                        p.keyCode = code;\n                        p.keyReleased();\n                        delete pressedKeysMap[code];\n                        updateKeyPressed();\n                    }\n                    // Send aCode Processing syntax to be converted to JavaScript\n                    if (!pgraphicsMode) {\n                        if (aCode instanceof Processing1.Sketch) // Use sketch as is\n                        curSketch = aCode;\n                        else if (typeof aCode === \"function\") // Wrap function with default sketch parameters\n                        curSketch = new Processing1.Sketch(aCode);\n                        else if (!aCode) // Empty sketch\n                        curSketch = new Processing1.Sketch(function() {});\n                        else //#if PARSER\n                        // Compile the code\n                        curSketch = Processing1.compile(aCode);\n                        // Expose internal field for diagnostics and testing\n                        p.externals.sketch = curSketch;\n                        wireDimensionalFunctions();\n                        // the onfocus and onblur events are handled in two parts.\n                        // 1) the p.focused property is handled per sketch\n                        curElement.onfocus = function() {\n                            p.focused = true;\n                        };\n                        curElement.onblur = function() {\n                            p.focused = false;\n                            if (!curSketch.options.globalKeyEvents) resetKeyPressed();\n                        };\n                        // 2) looping status is handled per page, based on the pauseOnBlur @pjs directive\n                        if (curSketch.options.pauseOnBlur) {\n                            attachEventHandler(window1, \"focus\", function() {\n                                if (doLoop) p.loop();\n                            });\n                            attachEventHandler(window1, \"blur\", function() {\n                                if (doLoop && loopStarted) {\n                                    p.noLoop();\n                                    doLoop = true; // make sure to keep this true after the noLoop call\n                                }\n                                resetKeyPressed();\n                            });\n                        }\n                        // if keyboard events should be handled globally, the listeners should\n                        // be bound to the document window, rather than to the current canvas\n                        var keyTrigger = curSketch.options.globalKeyEvents ? window1 : curElement;\n                        attachEventHandler(keyTrigger, \"keydown\", handleKeydown);\n                        attachEventHandler(keyTrigger, \"keypress\", handleKeypress);\n                        attachEventHandler(keyTrigger, \"keyup\", handleKeyup);\n                        // Step through the libraries that were attached at doc load...\n                        for(var i in Processing1.lib)if (Processing1.lib.hasOwnProperty(i)) {\n                            if (Processing1.lib[i].hasOwnProperty(\"attach\")) // use attach function if present\n                            Processing1.lib[i].attach(p);\n                            else if (Processing1.lib[i] instanceof Function) // Init the libraries in the context of this p_instance (legacy)\n                            Processing1.lib[i].call(this);\n                        }\n                        // sketch execute test interval, used to reschedule\n                        // an execute when preloads have not yet finished.\n                        var retryInterval = 100;\n                        var executeSketch = function(processing) {\n                            // Don't start until all specified images and fonts in the cache are preloaded\n                            if (!(curSketch.imageCache.pending || PFont.preloading.pending(retryInterval))) {\n                                // the opera preload cache can only be cleared once we start\n                                if (window1.opera) {\n                                    var link, element, operaCache = curSketch.imageCache.operaCache;\n                                    for(link in operaCache)if (operaCache.hasOwnProperty(link)) {\n                                        element = operaCache[link];\n                                        if (element !== null) document1.body.removeChild(element);\n                                        delete operaCache[link];\n                                    }\n                                }\n                                curSketch.attach(processing, defaultScope1);\n                                // pass a reference to the p instance for this sketch.\n                                curSketch.onLoad(processing);\n                                // Run void setup()\n                                if (processing.setup) {\n                                    processing.setup();\n                                    // if any transforms were performed in setup reset to identity matrix\n                                    // so draw loop is unpolluted\n                                    processing.resetMatrix();\n                                    curSketch.onSetup();\n                                }\n                                // some pixels can be cached, flushing\n                                resetContext();\n                                if (processing.draw) {\n                                    if (!doLoop) processing.redraw();\n                                    else processing.loop();\n                                }\n                            } else window1.setTimeout(function() {\n                                executeSketch(processing);\n                            }, retryInterval);\n                        };\n                        // Only store an instance of non-createGraphics instances.\n                        addInstance(this);\n                        // The parser adds custom methods to the processing context\n                        // this renames p to processing so these methods will run\n                        executeSketch(p);\n                    } else {\n                        // No executable sketch was specified\n                        // or called via createGraphics\n                        curSketch = new Processing1.Sketch();\n                        wireDimensionalFunctions();\n                        // Hack to make PGraphics work again after splitting size()\n                        p.size = function(w, h, render) {\n                            if (render && render === PConstants1.WEBGL) wireDimensionalFunctions(\"3D\");\n                            else wireDimensionalFunctions(\"2D\");\n                            p.size(w, h, render);\n                        };\n                    }\n                };\n                // Place-holder for overridable debugging function\n                Processing1.debug = function() {\n                    if (\"console\" in window1) return function(msg) {\n                        window1.console.log(\"Processing.js: \" + msg);\n                    };\n                    return noop;\n                }();\n                // bind prototype\n                Processing1.prototype = defaultScope1;\n                /**\n   * instance store and lookup\n   */ Processing1.instances = processingInstances;\n                Processing1.getInstanceById = function(name) {\n                    return processingInstances[processingInstanceIds[name]];\n                };\n                // Unsupported Processing File and I/O operations.\n                (function(Processing1) {\n                    var unsupportedP5 = \"open() createOutput() createInput() BufferedReader selectFolder() dataPath() createWriter() selectOutput() beginRecord() saveStream() endRecord() selectInput() saveBytes() createReader() beginRaw() endRaw() PrintWriter delay()\".split(\" \"), count = unsupportedP5.length, prettyName, p5Name;\n                    function createUnsupportedFunc(n) {\n                        return function() {\n                            throw \"Processing.js does not support \" + n + \".\";\n                        };\n                    }\n                    while(count--){\n                        prettyName = unsupportedP5[count];\n                        p5Name = prettyName.replace(\"()\", \"\");\n                        Processing1[p5Name] = createUnsupportedFunc(prettyName);\n                    }\n                })(defaultScope1);\n                // we're done. Return our object.\n                return Processing1;\n            };\n        },\n        {}\n    ],\n    28: [\n        function(require1, module, exports) {\n            // Base source files\n            var source = {\n                virtEquals: require1(\"./Helpers/virtEquals\"),\n                virtHashCode: require1(\"./Helpers/virtHashCode\"),\n                ObjectIterator: require1(\"./Helpers/ObjectIterator\"),\n                PConstants: require1(\"./Helpers/PConstants\"),\n                ArrayList: require1(\"./Objects/ArrayList\"),\n                HashMap: require1(\"./Objects/HashMap\"),\n                PVector: require1(\"./Objects/PVector\"),\n                PFont: require1(\"./Objects/PFont\"),\n                Char: require1(\"./Objects/Char\"),\n                XMLAttribute: require1(\"./Objects/XMLAttribute\"),\n                XMLElement: require1(\"./Objects/XMLElement\"),\n                PMatrix2D: require1(\"./Objects/PMatrix2D\"),\n                PMatrix3D: require1(\"./Objects/PMatrix3D\"),\n                PShape: require1(\"./Objects/PShape\"),\n                colors: require1(\"./Objects/webcolors\"),\n                PShapeSVG: require1(\"./Objects/PShapeSVG\"),\n                CommonFunctions: require1(\"./P5Functions/commonFunctions\"),\n                defaultScope: require1(\"./Helpers/defaultScope\"),\n                Processing: require1(\"./Processing\"),\n                setupParser: require1(\"./Parser/Parser\"),\n                finalize: require1(\"./Helpers/finalizeProcessing\")\n            };\n            // Additional code that gets tacked onto \"p\" during\n            // instantiation of a Processing sketch.\n            source.extend = {\n                withMath: require1(\"./P5Functions/Math.js\"),\n                withProxyFunctions: require1(\"./P5Functions/JavaProxyFunctions\")(source.virtHashCode, source.virtEquals),\n                withTouch: require1(\"./P5Functions/touchmouse\"),\n                withCommonFunctions: source.CommonFunctions.withCommonFunctions\n            };\n            /**\n * Processing.js building function\n */ module.exports = function buildProcessingJS(Browser, testHarness) {\n                var noop = function() {}, virtEquals = source.virtEquals, virtHashCode = source.virtHashCode, PConstants1 = source.PConstants, CommonFunctions = source.CommonFunctions, ObjectIterator1 = source.ObjectIterator, Char1 = source.Char, XMLAttribute = source.XMLAttribute(), ArrayList = source.ArrayList({\n                    virtHashCode: virtHashCode,\n                    virtEquals: virtEquals\n                }), HashMap = source.HashMap({\n                    virtHashCode: virtHashCode,\n                    virtEquals: virtEquals\n                }), PVector1 = source.PVector({\n                    PConstants: PConstants1\n                }), PFont1 = source.PFont({\n                    Browser: Browser,\n                    noop: noop\n                }), XMLElement1 = source.XMLElement({\n                    Browser: Browser,\n                    XMLAttribute: XMLAttribute\n                }), PMatrix2D = source.PMatrix2D({\n                    p: CommonFunctions\n                }), PMatrix3D = source.PMatrix3D({\n                    p: CommonFunctions\n                }), PShape = source.PShape({\n                    PConstants: PConstants1,\n                    PMatrix2D: PMatrix2D,\n                    PMatrix3D: PMatrix3D\n                }), PShapeSVG1 = source.PShapeSVG({\n                    CommonFunctions: CommonFunctions,\n                    PConstants: PConstants1,\n                    PShape: PShape,\n                    XMLElement: XMLElement1,\n                    colors: source.colors\n                }), defaultScope1 = source.defaultScope({\n                    ArrayList: ArrayList,\n                    HashMap: HashMap,\n                    PVector: PVector1,\n                    PFont: PFont1,\n                    PShapeSVG: PShapeSVG1,\n                    ObjectIterator: ObjectIterator1,\n                    PConstants: PConstants1,\n                    Char: Char1,\n                    XMLElement: XMLElement1,\n                    XML: XMLElement1\n                }), Processing1 = source.Processing({\n                    defaultScope: defaultScope1,\n                    Browser: Browser,\n                    extend: source.extend,\n                    noop: noop\n                });\n                // set up the Processing syntax parser\n                Processing1 = source.setupParser(Processing1, {\n                    Browser: Browser,\n                    aFunctions: testHarness,\n                    defaultScope: defaultScope1\n                });\n                // finalise the Processing object\n                Processing1 = source.finalize(Processing1, {\n                    version: require1(\"../package.json\").version,\n                    isDomPresent: (0, Browser.isDomPresent),\n                    window: Browser.window,\n                    document: Browser.document,\n                    noop: noop\n                });\n                // done.\n                return Processing1;\n            };\n        },\n        {\n            \"../package.json\": 2,\n            \"./Helpers/ObjectIterator\": 3,\n            \"./Helpers/PConstants\": 4,\n            \"./Helpers/defaultScope\": 6,\n            \"./Helpers/finalizeProcessing\": 7,\n            \"./Helpers/virtEquals\": 8,\n            \"./Helpers/virtHashCode\": 9,\n            \"./Objects/ArrayList\": 10,\n            \"./Objects/Char\": 11,\n            \"./Objects/HashMap\": 12,\n            \"./Objects/PFont\": 13,\n            \"./Objects/PMatrix2D\": 14,\n            \"./Objects/PMatrix3D\": 15,\n            \"./Objects/PShape\": 16,\n            \"./Objects/PShapeSVG\": 17,\n            \"./Objects/PVector\": 18,\n            \"./Objects/XMLAttribute\": 19,\n            \"./Objects/XMLElement\": 20,\n            \"./Objects/webcolors\": 21,\n            \"./P5Functions/JavaProxyFunctions\": 22,\n            \"./P5Functions/Math.js\": 23,\n            \"./P5Functions/commonFunctions\": 24,\n            \"./P5Functions/touchmouse\": 25,\n            \"./Parser/Parser\": 26,\n            \"./Processing\": 27\n        }\n    ]\n}, {}, [\n    1\n]);\n\n//# sourceMappingURL=index.0da534d9.js.map\n","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n// build script for generating processing.js\n\nvar Browser = {\n  isDomPresent: true,\n  navigator: navigator,\n  window: window,\n  document: document,\n  ajax: function(url) {\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url, false);\n    if (xhr.overrideMimeType) {\n      xhr.overrideMimeType(\"text/plain\");\n    }\n    xhr.setRequestHeader(\"If-Modified-Since\", \"Fri, 01 Jan 1960 00:00:00 GMT\");\n    xhr.send(null);\n    // failed request?\n    if (xhr.status !== 200 && xhr.status !== 0) { throw (\"XMLHttpRequest failed, status code \" + xhr.status); }\n    return xhr.responseText;\n  }\n};\n\nwindow.Processing = require('./src/')(Browser);\n\n},{\"./src/\":28}],2:[function(require,module,exports){\nmodule.exports={\n  \"name\": \"processing-js\",\n  \"version\": \"1.6.6\",\n  \"author\": \"Processing.js\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git@github.com/processing-js/processing-js.git\"\n  },\n  \"main\": \"processing.min.js\",\n  \"bugs\": \"https://github.com/processing-js/processing-js/issues\",\n  \"devDependencies\": {\n    \"argv\": \"^0.0.2\",\n    \"browserify\": \"^17.0.0\",\n    \"express\": \"^4.18.2\",\n    \"grunt\": \"^1.6.1\",\n    \"grunt-cli\": \"^1.4.3\",\n    \"grunt-contrib-jshint\": \"^3.2.0\",\n    \"http-server\": \"^14.1.1\",\n    \"nunjucks\": \"^3.2.4\",\n    \"terser\": \"^5.26.0\"\n  },\n  \"scripts\": {\n    \"test\": \"node test\",\n    \"test:manual\": \"http-server -o test/manual\",\n    \"start\": \"browserify build.js -o processing.js && terser processing.js --compress ecma=2020,computed_props=false > processing.min.js\"\n  },\n  \"license\": \"MIT\"\n}\n\n},{}],3:[function(require,module,exports){\n/**\n* A ObjectIterator is an iterator wrapper for objects. If passed object contains\n* the iterator method, the object instance will be replaced by the result returned by\n* this method call. If passed object is an array, the ObjectIterator instance iterates\n* through its items.\n*\n* @param {Object} obj The object to be iterated.\n*/\nmodule.exports = function ObjectIterator(obj) {\n  if (obj instanceof Array) {\n    // iterate through array items\n    var index = -1;\n    this.hasNext = function() {\n      return ++index < obj.length;\n    };\n    this.next = function() {\n      return obj[index];\n    };\n  } else if (obj.iterator instanceof Function) {\n    return obj.iterator();\n  } else {\n    throw \"Unable to iterate: \" + obj;\n  }\n};\n\n},{}],4:[function(require,module,exports){\n/**\n * Processing.js environment constants\n */\nmodule.exports = {\n    X: 0,\n    Y: 1,\n    Z: 2,\n\n    R: 3,\n    G: 4,\n    B: 5,\n    A: 6,\n\n    U: 7,\n    V: 8,\n\n    NX: 9,\n    NY: 10,\n    NZ: 11,\n\n    EDGE: 12,\n\n    // Stroke\n    SR: 13,\n    SG: 14,\n    SB: 15,\n    SA: 16,\n\n    SW: 17,\n\n    // Transformations (2D and 3D)\n    TX: 18,\n    TY: 19,\n    TZ: 20,\n\n    VX: 21,\n    VY: 22,\n    VZ: 23,\n    VW: 24,\n\n    // Material properties\n    AR: 25,\n    AG: 26,\n    AB: 27,\n\n    DR: 3,\n    DG: 4,\n    DB: 5,\n    DA: 6,\n\n    SPR: 28,\n    SPG: 29,\n    SPB: 30,\n\n    SHINE: 31,\n\n    ER: 32,\n    EG: 33,\n    EB: 34,\n\n    BEEN_LIT: 35,\n\n    VERTEX_FIELD_COUNT: 36,\n\n    // Renderers\n    P2D:    1,\n    JAVA2D: 1,\n    WEBGL:  2,\n    P3D:    2,\n    OPENGL: 2,\n    PDF:    0,\n    DXF:    0,\n\n    // Platform IDs\n    OTHER:   0,\n    WINDOWS: 1,\n    MACOSX:  2,\n    LINUX:   3,\n\n    EPSILON: 0.0001,\n\n    MAX_FLOAT:  3.4028235e+38,\n    MIN_FLOAT: -3.4028235e+38,\n    MAX_INT:    2147483647,\n    MIN_INT:   -2147483648,\n\n    PI:         Math.PI,\n    TWO_PI:     2 * Math.PI,\n    TAU:        2 * Math.PI,\n    HALF_PI:    Math.PI / 2,\n    THIRD_PI:   Math.PI / 3,\n    QUARTER_PI: Math.PI / 4,\n\n    DEG_TO_RAD: Math.PI / 180,\n    RAD_TO_DEG: 180 / Math.PI,\n\n    WHITESPACE: \" \\t\\n\\r\\f\\u00A0\",\n\n    // Color modes\n    RGB:   1,\n    ARGB:  2,\n    HSB:   3,\n    ALPHA: 4,\n    CMYK:  5,\n\n    // Image file types\n    TIFF:  0,\n    TARGA: 1,\n    JPEG:  2,\n    GIF:   3,\n\n    // Filter/convert types\n    BLUR:      11,\n    GRAY:      12,\n    INVERT:    13,\n    OPAQUE:    14,\n    POSTERIZE: 15,\n    THRESHOLD: 16,\n    ERODE:     17,\n    DILATE:    18,\n\n    // Blend modes\n    REPLACE:    0,\n    BLEND:      1 << 0,\n    ADD:        1 << 1,\n    SUBTRACT:   1 << 2,\n    LIGHTEST:   1 << 3,\n    DARKEST:    1 << 4,\n    DIFFERENCE: 1 << 5,\n    EXCLUSION:  1 << 6,\n    MULTIPLY:   1 << 7,\n    SCREEN:     1 << 8,\n    OVERLAY:    1 << 9,\n    HARD_LIGHT: 1 << 10,\n    SOFT_LIGHT: 1 << 11,\n    DODGE:      1 << 12,\n    BURN:       1 << 13,\n\n    // Color component bit masks\n    ALPHA_MASK: 0xff000000,\n    RED_MASK:   0x00ff0000,\n    GREEN_MASK: 0x0000ff00,\n    BLUE_MASK:  0x000000ff,\n\n    // Projection matrices\n    CUSTOM:       0,\n    ORTHOGRAPHIC: 2,\n    PERSPECTIVE:  3,\n\n    // Shapes\n    POINT:          2,\n    POINTS:         2,\n    LINE:           4,\n    LINES:          4,\n    TRIANGLE:       8,\n    TRIANGLES:      9,\n    TRIANGLE_STRIP: 10,\n    TRIANGLE_FAN:   11,\n    QUAD:           16,\n    QUADS:          16,\n    QUAD_STRIP:     17,\n    POLYGON:        20,\n    PATH:           21,\n    RECT:           30,\n    ELLIPSE:        31,\n    ARC:            32,\n    SPHERE:         40,\n    BOX:            41,\n\n    // Arc drawing modes\n    //OPEN:          1, // shared with Shape closing modes   \n    CHORD:           2,\n    PIE:             3, \n\n\n    GROUP:          0,\n    PRIMITIVE:      1,\n    //PATH:         21, // shared with Shape PATH\n    GEOMETRY:       3,\n\n    // Shape Vertex\n    VERTEX:        0,\n    BEZIER_VERTEX: 1,\n    CURVE_VERTEX:  2,\n    BREAK:         3,\n    CLOSESHAPE:    4,\n\n    // Shape closing modes\n    OPEN:  1,\n    CLOSE: 2,\n\n    // Shape drawing modes\n    CORNER:          0, // Draw mode convention to use (x, y) to (width, height)\n    CORNERS:         1, // Draw mode convention to use (x1, y1) to (x2, y2) coordinates\n    RADIUS:          2, // Draw mode from the center, and using the radius\n    CENTER_RADIUS:   2, // Deprecated! Use RADIUS instead\n    CENTER:          3, // Draw from the center, using second pair of values as the diameter\n    DIAMETER:        3, // Synonym for the CENTER constant. Draw from the center\n    CENTER_DIAMETER: 3, // Deprecated! Use DIAMETER instead\n\n    // Text vertical alignment modes\n    BASELINE: 0,   // Default vertical alignment for text placement\n    TOP:      101, // Align text to the top\n    BOTTOM:   102, // Align text from the bottom, using the baseline\n\n    // UV Texture coordinate modes\n    NORMAL:     1,\n    NORMALIZED: 1,\n    IMAGE:      2,\n\n    // Text placement modes\n    MODEL: 4,\n    SHAPE: 5,\n\n    // Stroke modes\n    SQUARE:  'butt',\n    ROUND:   'round',\n    PROJECT: 'square',\n    MITER:   'miter',\n    BEVEL:   'bevel',\n\n    // Lighting modes\n    AMBIENT:     0,\n    DIRECTIONAL: 1,\n    //POINT:     2, Shared with Shape constant\n    SPOT:        3,\n\n    // Key constants\n\n    // Both key and keyCode will be equal to these values\n    BACKSPACE: 8,\n    TAB:       9,\n    ENTER:     10,\n    RETURN:    13,\n    ESC:       27,\n    DELETE:    127,\n    CODED:     0xffff,\n\n    // p.key will be CODED and p.keyCode will be this value\n    SHIFT:     16,\n    CONTROL:   17,\n    ALT:       18,\n    CAPSLK:    20,\n    PGUP:      33,\n    PGDN:      34,\n    END:       35,\n    HOME:      36,\n    LEFT:      37,\n    UP:        38,\n    RIGHT:     39,\n    DOWN:      40,\n    F1:        112,\n    F2:        113,\n    F3:        114,\n    F4:        115,\n    F5:        116,\n    F6:        117,\n    F7:        118,\n    F8:        119,\n    F9:        120,\n    F10:       121,\n    F11:       122,\n    F12:       123,\n    NUMLK:     144,\n    META:      157,\n    INSERT:    155,\n\n    // Cursor types\n    ARROW:    'default',\n    CROSS:    'crosshair',\n    HAND:     'pointer',\n    MOVE:     'move',\n    TEXT:     'text',\n    WAIT:     'wait',\n    NOCURSOR: \"url('data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='), auto\",\n\n    // Hints\n    DISABLE_OPENGL_2X_SMOOTH:     1,\n    ENABLE_OPENGL_2X_SMOOTH:     -1,\n    ENABLE_OPENGL_4X_SMOOTH:      2,\n    ENABLE_NATIVE_FONTS:          3,\n    DISABLE_DEPTH_TEST:           4,\n    ENABLE_DEPTH_TEST:           -4,\n    ENABLE_DEPTH_SORT:            5,\n    DISABLE_DEPTH_SORT:          -5,\n    DISABLE_OPENGL_ERROR_REPORT:  6,\n    ENABLE_OPENGL_ERROR_REPORT:  -6,\n    ENABLE_ACCURATE_TEXTURES:     7,\n    DISABLE_ACCURATE_TEXTURES:   -7,\n    HINT_COUNT:                  10,\n\n    // PJS defined constants\n    SINCOS_LENGTH:      720,       // every half degree\n    PRECISIONB:         15,        // fixed point precision is limited to 15 bits!!\n    PRECISIONF:         1 << 15,\n    PREC_MAXVAL:        (1 << 15) - 1,\n    PREC_ALPHA_SHIFT:   24 - 15,\n    PREC_RED_SHIFT:     16 - 15,\n    NORMAL_MODE_AUTO:   0,\n    NORMAL_MODE_SHAPE:  1,\n    NORMAL_MODE_VERTEX: 2,\n    MAX_LIGHTS:         8\n};\n\n},{}],5:[function(require,module,exports){\n// the logger for print() and println()\nmodule.exports = function PjsConsole(document) {\n  var e = { BufferMax: 200 },\n      style = document.createElement(\"style\"),\n      added = false;\n\n  style.textContent = [\n    \".pjsconsole.hidden {\",\n    \"  display: none!important;\",\n    \"}\"\n  ].join('\\n');\n\n  e.wrapper = document.createElement(\"div\");\n  style.textContent += [\n    \"\",\n    \".pjsconsole {\",\n    \"  opacity: .75;\",\n    \"  display: block;\",\n    \"  position: fixed;\",\n    \"  bottom: 0px;\",\n    \"  left: 0px;\",\n    \"  right: 0px;\",\n    \"  height: 50px;\",\n    \"  background-color: #aaa;\",\n    \"}\"\n  ].join('\\n');\n  e.wrapper.classList.add(\"pjsconsole\");\n\n  e.dragger = document.createElement(\"div\");\n  style.textContent += [\n    \"\",\n    \".pjsconsole .dragger {\",\n    \"  display: block;\",\n    \"  border: 3px black raised;\",\n    \"  cursor: n-resize;\",\n    \"  position: absolute;\",\n    \"  top: 0px;\",\n    \"  left: 0px;\",\n    \"  right: 0px;\",\n    \"  height: 5px;\",\n    \"  background-color: #333;\",\n    \"}\"\n  ].join('\\n');\n  e.dragger.classList.add(\"dragger\");\n\n  e.closer = document.createElement(\"div\");\n  style.textContent += [\n    \"\",\n    \".pjsconsole .closer {\",\n    \"  opacity: .5;\",\n    \"  display: block;\",\n    \"  border: 3px black raised;\",\n    \"  position: absolute;\",\n    \"  top: 10px;\",\n    \"  right: 30px;\",\n    \"  height: 20px;\",\n    \"  width: 20px;\",\n    \"  background-color: #ddd;\",\n    \"  color: #000;\",\n    \"  line-height: 20px;\",\n    \"  text-align: center;\",\n    \"  cursor: pointer\",\n    \"}\"\n  ].join('\\n');\n  e.closer.classList.add(\"closer\");\n  e.closer.innerHTML = \"&#10006;\";\n\n  e.javaconsole = document.createElement(\"div\");\n  style.textContent += [\n    \"\",\n    \".pjsconsole .console {\",\n    \"  overflow-x: auto;\",\n    \"  display: block;\",\n    \"  position: absolute;\",\n    \"  left: 10px;\",\n    \"  right: 0px;\",\n    \"  bottom: 5px;\",\n    \"  top: 10px;\",\n    \"  overflow-y: scroll;\",\n    \"  height: 40px;\",\n    \"}\"\n  ].join('\\n');\n  e.javaconsole.setAttribute(\"class\", \"console\");\n\n  e.wrapper.appendChild(e.dragger);\n  e.wrapper.appendChild(e.javaconsole);\n  e.wrapper.appendChild(e.closer);\n\n  e.dragger.onmousedown = function (t) {\n    e.divheight = e.wrapper.style.height;\n    if (document.selection) document.selection.empty();\n    else window.getSelection().removeAllRanges();\n    var n = t.screenY;\n    window.onmousemove = function (t) {\n      e.wrapper.style.height = parseFloat(e.divheight) + (n - t.screenY) + \"px\";\n      e.javaconsole.style.height = parseFloat(e.divheight) + (n - t.screenY) - 10 + \"px\";\n    };\n    window.onmouseup = function (t) {\n      if (document.selection) document.selection.empty();\n      else window.getSelection().removeAllRanges();\n      e.wrapper.style.height = parseFloat(e.divheight) + (n - t.screenY) + \"px\";\n      e.javaconsole.style.height = parseFloat(e.divheight) + (n - t.screenY) - 10 + \"px\";\n      window.onmousemove = null;\n      window.onmouseup = null;\n    };\n  };\n\n  e.BufferArray = [];\n\n  e.print = e.log = function () {\n    if(!added) {\n      document.body.appendChild(style);\n      document.body.appendChild(e.wrapper);\n      added = true;\n    }\n    var args = Array.prototype.slice.call(arguments);\n    t = args.map(function(t, idx) { return t + (idx+1 === args.length ? \"\" : \" \"); }).join('');\n    if (e.BufferArray[e.BufferArray.length - 1]) e.BufferArray[e.BufferArray.length - 1] += (t) + \"\";\n    else e.BufferArray.push(t);\n    e.javaconsole.innerHTML = e.BufferArray.join('');\n    e.showconsole();\n  };\n\n  e.println = function () {\n    var args = Array.prototype.slice.call(arguments);\n    args.push('<br>');\n    e.print.apply(e, args);\n    if (e.BufferArray.length > e.BufferMax) {\n      e.BufferArray.splice(0, 1);\n    } else {\n      e.javaconsole.scrollTop = e.javaconsole.scrollHeight;\n    }\n  };\n\n  e.showconsole = function () { e.wrapper.classList.remove(\"hidden\"); };\n  e.hideconsole = function () { e.wrapper.classList.add(\"hidden\"); };\n\n  e.closer.onclick = function () { e.hideconsole(); };\n\n  e.hideconsole();\n\n  return e;\n};\n\n},{}],6:[function(require,module,exports){\n/**\n * Processing.js default scope\n */\nmodule.exports = function(options) {\n\n  // Building defaultScope. Changing of the prototype protects\n  // internal Processing code from the changes in defaultScope\n  function DefaultScope() {}\n  DefaultScope.prototype = options.PConstants;\n\n  var defaultScope = new DefaultScope();\n\n  // copy over all known Object types and helper objects\n  Object.keys(options).forEach(function(prop) {\n    defaultScope[prop] = options[prop];\n  });\n\n  ////////////////////////////////////////////////////////////////////////////\n  // Class inheritance helper methods\n  ////////////////////////////////////////////////////////////////////////////\n\n  defaultScope.defineProperty = function(obj, name, desc) {\n    if(\"defineProperty\" in Object) {\n      Object.defineProperty(obj, name, desc);\n    } else {\n      if (desc.hasOwnProperty(\"get\")) {\n        obj.__defineGetter__(name, desc.get);\n      }\n      if (desc.hasOwnProperty(\"set\")) {\n        obj.__defineSetter__(name, desc.set);\n      }\n    }\n  };\n\n  /**\n   * class overloading, part 1\n   */\n  function overloadBaseClassFunction(object, name, basefn) {\n    if (!object.hasOwnProperty(name) || typeof object[name] !== 'function') {\n      // object method is not a function or just inherited from Object.prototype\n      object[name] = basefn;\n      return;\n    }\n    var fn = object[name];\n    if (\"$overloads\" in fn) {\n      // the object method already overloaded (see defaultScope.addMethod)\n      // let's just change a fallback method\n      fn.$defaultOverload = basefn;\n      return;\n    }\n    if (!(\"$overloads\" in basefn) && fn.length === basefn.length) {\n      // special case when we just overriding the method\n      return;\n    }\n    var overloads, defaultOverload;\n    if (\"$overloads\" in basefn) {\n      // let's inherit base class overloads to speed up things\n      overloads = basefn.$overloads.slice(0);\n      overloads[fn.length] = fn;\n      defaultOverload = basefn.$defaultOverload;\n    } else {\n      overloads = [];\n      overloads[basefn.length] = basefn;\n      overloads[fn.length] = fn;\n      defaultOverload = fn;\n    }\n    var hubfn = function() {\n      var fn = hubfn.$overloads[arguments.length] ||\n               (\"$methodArgsIndex\" in hubfn && arguments.length > hubfn.$methodArgsIndex ?\n               hubfn.$overloads[hubfn.$methodArgsIndex] : null) ||\n               hubfn.$defaultOverload;\n      return fn.apply(this, arguments);\n    };\n    hubfn.$overloads = overloads;\n    if (\"$methodArgsIndex\" in basefn) {\n      hubfn.$methodArgsIndex = basefn.$methodArgsIndex;\n    }\n    hubfn.$defaultOverload = defaultOverload;\n    hubfn.name = name;\n    object[name] = hubfn;\n  }\n\n  /**\n   * class overloading, part 2\n   */\n\n  function extendClass(subClass, baseClass) {\n    function extendGetterSetter(propertyName) {\n      defaultScope.defineProperty(subClass, propertyName, {\n        get: function() {\n          return baseClass[propertyName];\n        },\n        set: function(v) {\n          baseClass[propertyName]=v;\n        },\n        enumerable: true\n      });\n    }\n\n    var properties = [];\n    for (var propertyName in baseClass) {\n      if (typeof baseClass[propertyName] === 'function') {\n        overloadBaseClassFunction(subClass, propertyName, baseClass[propertyName]);\n      } else if(propertyName.charAt(0) !== \"$\" && !(propertyName in subClass)) {\n        // Delaying the properties extension due to the IE9 bug (see #918).\n        properties.push(propertyName);\n      }\n    }\n    while (properties.length > 0) {\n      extendGetterSetter(properties.shift());\n    }\n\n    subClass.$super = baseClass;\n  }\n\n  /**\n   * class overloading, part 3\n   */\n  defaultScope.extendClassChain = function(base) {\n    var path = [base];\n    for (var self = base.$upcast; self; self = self.$upcast) {\n      extendClass(self, base);\n      path.push(self);\n      base = self;\n    }\n    while (path.length > 0) {\n      path.pop().$self=base;\n    }\n  };\n\n  // static\n  defaultScope.extendStaticMembers = function(derived, base) {\n    extendClass(derived, base);\n  };\n\n  // interface\n  defaultScope.extendInterfaceMembers = function(derived, base) {\n    extendClass(derived, base);\n  };\n\n  /**\n   * Java methods and JavaScript functions differ enough that\n   * we need a special function to make sure it all links up\n   * as classical hierarchical class chains.\n   */\n  defaultScope.addMethod = function(object, name, fn, hasMethodArgs) {\n    var existingfn = object[name];\n    if (existingfn || hasMethodArgs) {\n      var args = fn.length;\n      // builds the overload methods table\n      if (\"$overloads\" in existingfn) {\n        existingfn.$overloads[args] = fn;\n      } else {\n        var hubfn = function() {\n          var fn = hubfn.$overloads[arguments.length] ||\n                   (\"$methodArgsIndex\" in hubfn && arguments.length > hubfn.$methodArgsIndex ?\n                   hubfn.$overloads[hubfn.$methodArgsIndex] : null) ||\n                   hubfn.$defaultOverload;\n          return fn.apply(this, arguments);\n        };\n        var overloads = [];\n        if (existingfn) {\n          overloads[existingfn.length] = existingfn;\n        }\n        overloads[args] = fn;\n        hubfn.$overloads = overloads;\n        hubfn.$defaultOverload = existingfn || fn;\n        if (hasMethodArgs) {\n          hubfn.$methodArgsIndex = args;\n        }\n        hubfn.name = name;\n        object[name] = hubfn;\n      }\n    } else {\n      object[name] = fn;\n    }\n  };\n\n  // internal helper function\n  function isNumericalJavaType(type) {\n    if (typeof type !== \"string\") {\n      return false;\n    }\n    return [\"byte\", \"int\", \"char\", \"color\", \"float\", \"long\", \"double\"].indexOf(type) !== -1;\n  }\n\n  /**\n   * Java's arrays are pre-filled when declared with\n   * an initial size, but no content. JS arrays are not.\n   */\n  defaultScope.createJavaArray = function(type, bounds) {\n    var result = null,\n        defaultValue = null;\n    if (typeof type === \"string\") {\n      if (type === \"boolean\") {\n        defaultValue = false;\n      } else if (isNumericalJavaType(type)) {\n        defaultValue = 0;\n      }\n    }\n    if (typeof bounds[0] === 'number') {\n      var itemsCount = 0 | bounds[0];\n      if (bounds.length <= 1) {\n        result = [];\n        result.length = itemsCount;\n        for (var i = 0; i < itemsCount; ++i) {\n          result[i] = defaultValue;\n        }\n      } else {\n        result = [];\n        var newBounds = bounds.slice(1);\n        for (var j = 0; j < itemsCount; ++j) {\n          result.push(defaultScope.createJavaArray(type, newBounds));\n        }\n      }\n    }\n    return result;\n  };\n\n  // screenWidth and screenHeight are shared by all instances.\n  // and return the width/height of the browser's viewport.\n  defaultScope.defineProperty(defaultScope, 'screenWidth',\n    { get: function() { return window.innerWidth; } });\n\n  defaultScope.defineProperty(defaultScope, 'screenHeight',\n    { get: function() { return window.innerHeight; } });\n\n  return defaultScope;\n};\n\n},{}],7:[function(require,module,exports){\n/**\n * Finalise the Processing.js object.\n */\nmodule.exports = function finalizeProcessing(Processing, options) {\n\n  // unpack options\n  var window = options.window,\n      document = options.document,\n      XMLHttpRequest = window.XMLHttpRequest,\n      noop = options.noop,\n      isDOMPresent = options.isDOMPresent,\n      version = options.version,\n      undef;\n\n  // versioning\n  Processing.version = (version ? version : \"@DEV-VERSION@\");\n\n  // Share lib space\n  Processing.lib = {};\n\n  /**\n   * External libraries can be added to the global Processing\n   * objects with the `registerLibrary` function.\n   */\n  Processing.registerLibrary = function(name, library) {\n    Processing.lib[name] = library;\n    if(library.hasOwnProperty(\"init\")) {\n      library.init(defaultScope);\n    }\n  };\n\n  /**\n   * This is the object that acts as our version of PApplet.\n   * This can be called as Processing.Sketch() or as\n   * Processing.Sketch(function) in which case the function\n   * must be an already-compiled-to-JS sketch function.\n   */\n  Processing.Sketch = function(attachFunction) {\n    this.attachFunction = attachFunction;\n    this.options = {\n      pauseOnBlur: false,\n      globalKeyEvents: false\n    };\n\n    /* Optional Sketch event hooks:\n     *   onLoad       - parsing/preloading is done, before sketch starts\n     *   onSetup      - setup() has been called, before first draw()\n     *   onPause      - noLoop() has been called, pausing draw loop\n     *   onLoop       - loop() has been called, resuming draw loop\n     *   onFrameStart - draw() loop about to begin\n     *   onFrameEnd   - draw() loop finished\n     *   onExit       - exit() done being called\n     */\n    this.onLoad = noop;\n    this.onSetup = noop;\n    this.onPause = noop;\n    this.onLoop = noop;\n    this.onFrameStart = noop;\n    this.onFrameEnd = noop;\n    this.onExit = noop;\n\n    this.params = {};\n    this.imageCache = {\n      pending: 0,\n      images: {},\n      // Opera requires special administration for preloading\n      operaCache: {},\n      // Specify an optional img arg if the image is already loaded in the DOM,\n      // otherwise href will get loaded.\n      add: function(href, img) {\n        // Prevent muliple loads for an image, in case it gets\n        // preloaded more than once, or is added via JS and then preloaded.\n        if (this.images[href]) {\n          return;\n        }\n\n        if (!isDOMPresent) {\n          this.images[href] = null;\n        }\n\n        // No image in the DOM, kick-off a background load\n        if (!img) {\n          img = new Image();\n          img.onload = (function(owner) {\n            return function() {\n              owner.pending--;\n            };\n          }(this));\n          this.pending++;\n          img.src = href;\n        }\n\n        this.images[href] = img;\n\n        // Opera will not load images until they are inserted into the DOM.\n        if (window.opera) {\n          var div = document.createElement(\"div\");\n          div.appendChild(img);\n          // we can't use \"display: none\", since that makes it invisible, and thus not load\n          div.style.position = \"absolute\";\n          div.style.opacity = 0;\n          div.style.width = \"1px\";\n          div.style.height= \"1px\";\n          if (!this.operaCache[href]) {\n            document.body.appendChild(div);\n            this.operaCache[href] = div;\n          }\n        }\n      }\n    };\n\n    this.sourceCode = undefined;\n    this.attach = function(processing) {\n      // either attachFunction or sourceCode must be present on attach\n      if(typeof this.attachFunction === \"function\") {\n        this.attachFunction(processing);\n      } else if(this.sourceCode) {\n        var func = ((new Function(\"return (\" + this.sourceCode + \");\"))());\n        func(processing);\n        this.attachFunction = func;\n      } else {\n        throw \"Unable to attach sketch to the processing instance\";\n      }\n    };\n\n    this.toString = function() {\n      var i;\n      var code = \"((function(Sketch) {\\n\";\n      code += \"var sketch = new Sketch(\\n\" + this.sourceCode + \");\\n\";\n      for(i in this.options) {\n        if(this.options.hasOwnProperty(i)) {\n          var value = this.options[i];\n          code += \"sketch.options.\" + i + \" = \" +\n            (typeof value === 'string' ? '\\\"' + value + '\\\"' : \"\" + value) + \";\\n\";\n        }\n      }\n      for(i in this.imageCache) {\n        if(this.options.hasOwnProperty(i)) {\n          code += \"sketch.imageCache.add(\\\"\" + i + \"\\\");\\n\";\n        }\n      }\n      // TODO serialize fonts\n      code += \"return sketch;\\n})(Processing.Sketch))\";\n      return code;\n    };\n  };\n\n  /**\n   * aggregate all source code into a single file, then rewrite that\n   * source and bind to canvas via new Processing(canvas, sourcestring).\n   * @param {CANVAS} canvas The html canvas element to bind to\n   * @param {String[]} sources The array of files that must be loaded\n   * @param {Function} onComplete A callback, called with the sketch as the argument.\n   */\n  var loadSketchFromSources = Processing.loadSketchFromSources = function(canvas, sources, onComplete) {\n    var code = [], errors = [], sourcesCount = sources.length, loaded = 0;\n\n    function ajaxAsync(url, callback) {\n      var xhr = new XMLHttpRequest();\n      xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n          var error;\n          if (xhr.status !== 200 && xhr.status !== 0) {\n            error = \"Invalid XHR status \" + xhr.status;\n          } else if (xhr.responseText === \"\") {\n            // Give a hint when loading fails due to same-origin issues on file:/// urls\n            if ( (\"withCredentials\" in new XMLHttpRequest()) &&\n                 (new XMLHttpRequest()).withCredentials === false &&\n                 window.location.protocol === \"file:\" ) {\n              error = \"XMLHttpRequest failure, possibly due to a same-origin policy violation. You can try loading this page in another browser, or load it from http://localhost using a local webserver. See the Processing.js README for a more detailed explanation of this problem and solutions.\";\n            } else {\n              error = \"File is empty.\";\n            }\n          }\n\n          callback(xhr.responseText, error);\n        }\n      };\n      xhr.open(\"GET\", url, true);\n      if (xhr.overrideMimeType) {\n        xhr.overrideMimeType(\"application/json\");\n      }\n      xhr.setRequestHeader(\"If-Modified-Since\", \"Fri, 01 Jan 1960 00:00:00 GMT\"); // no cache\n      xhr.send(null);\n    }\n\n    function loadBlock(index, filename) {\n      function callback(block, error) {\n        code[index] = block;\n        ++loaded;\n        if (error) {\n          errors.push(filename + \" ==> \" + error);\n        }\n        if (loaded === sourcesCount) {\n          if (errors.length === 0) {\n            // This used to throw, but it was constantly getting in the way of debugging where things go wrong!\n            var sketch = new Processing(canvas, code.join(\"\\n\"));\n            if (onComplete) {\n              onComplete(sketch);\n            }\n          } else {\n            throw \"Processing.js: Unable to load pjs sketch files: \" + errors.join(\"\\n\");\n          }\n        }\n      }\n      if (filename.charAt(0) === '#') {\n        // trying to get script from the element\n        var scriptElement = document.getElementById(filename.substring(1));\n        if (scriptElement) {\n          callback(scriptElement.text || scriptElement.textContent);\n        } else {\n          callback(\"\", \"Unable to load pjs sketch: element with id \\'\" + filename.substring(1) + \"\\' was not found\");\n        }\n        return;\n      }\n\n      ajaxAsync(filename, callback);\n    }\n\n    for (var i = 0; i < sourcesCount; ++i) {\n      loadBlock(i, sources[i]);\n    }\n  };\n\n  /**\n   * Automatic initialization function.\n   */\n  var init = function() {\n    document.removeEventListener('DOMContentLoaded', init, false);\n    var i;\n\n    // before running through init, clear the instances list, to prevent\n    // sketch duplication when page content is dynamically swapped without\n    // swapping out processing.js\n    while (Processing.instances.length > 0) {\n      for (i = Processing.instances.length - 1; i >= 0; i--) {\n        if (Processing.instances[i]) {\n          Processing.instances[i].exit();\n        }\n      }\n    }\n\n    var canvas = document.getElementsByTagName('canvas'),\n      filenames;\n    const l = canvas.length;\n    for (i = 0; i < l; i++) {\n      // datasrc and data-src are deprecated.\n      var processingSources = canvas[i].getAttribute('data-processing-sources');\n      if (processingSources === null) {\n        // Temporary fallback for datasrc and data-src\n        processingSources = canvas[i].getAttribute('data-src');\n        if (processingSources === null) {\n          processingSources = canvas[i].getAttribute('datasrc');\n        }\n      }\n      if (processingSources) {\n        filenames = processingSources.split(/\\s+/g);\n        for (var j = 0; j < filenames.length;) {\n          if (filenames[j]) {\n            j++;\n          } else {\n            filenames.splice(j, 1);\n          }\n        }\n        loadSketchFromSources(canvas[i], filenames);\n      }\n    }\n\n    // also process all <script>-indicated sketches, if there are any\n    var s, last, source, instance,\n        nodelist = document.getElementsByTagName('script'),\n        scripts=[];\n\n    // snapshot the DOM, as the nodelist is only a DOM view, and is\n    // updated instantly when a script element is added or removed.\n    for (s = nodelist.length - 1; s >= 0; s--) {\n      scripts.push(nodelist[s]);\n    }\n\n    // iterate over all script elements to see if they contain Processing code\n    for (s = 0, last = scripts.length; s < last; s++) {\n      var script = scripts[s];\n      if (!script.getAttribute) {\n        continue;\n      }\n\n      var type = script.getAttribute(\"type\");\n      if (type && (type.toLowerCase() === \"text/processing\" || type.toLowerCase() === \"application/processing\")) {\n        var target = script.getAttribute(\"data-processing-target\");\n        canvas = undef;\n        if (target) {\n          canvas = document.getElementById(target);\n        } else {\n          var nextSibling = script.nextSibling;\n          while (nextSibling && nextSibling.nodeType !== 1) {\n            nextSibling = nextSibling.nextSibling;\n          }\n          if (nextSibling && nextSibling.nodeName.toLowerCase() === \"canvas\") {\n            canvas = nextSibling;\n          }\n        }\n\n        if (canvas) {\n          if (script.getAttribute(\"src\")) {\n            filenames = script.getAttribute(\"src\").split(/\\s+/);\n            loadSketchFromSources(canvas, filenames);\n            continue;\n          }\n          source =  script.textContent || script.text;\n          instance = new Processing(canvas, source);\n        }\n      }\n    }\n  };\n\n  /**\n   * automatic loading of all sketches on the page\n   */\n  document.addEventListener('DOMContentLoaded', init, false);\n\n  /**\n   * Make Processing run through init after already having\n   * been set up for a page. This function exists mostly for pages\n   * that swap content in/out without reloading a page.\n   */\n  Processing.reload = init;\n\n  /**\n   * Disable the automatic loading of all sketches on the page.\n   * This will work as long as it's issued before DOMContentLoaded.\n   */\n  Processing.disableInit = function() {\n    document.removeEventListener('DOMContentLoaded', init, false);\n  };\n\n  // done.\n  return Processing;\n};\n\n},{}],8:[function(require,module,exports){\n/**\n * Returns Java equals() result for two objects. If the first object\n * has the \"equals\" function, it preforms the call of this function.\n * Otherwise the method uses the JavaScript === operator.\n *\n * @param {Object} obj          The first object.\n * @param {Object} other        The second object.\n *\n * @returns {boolean}           true if the objects are equal.\n */\nmodule.exports = function virtEquals(obj, other) {\n  if (obj === null || other === null) {\n    return (obj === null) && (other === null);\n  }\n  if (typeof (obj) === \"string\") {\n    return obj === other;\n  }\n  if (typeof(obj) !== \"object\") {\n    return obj === other;\n  }\n  if (obj.equals instanceof Function) {\n    return obj.equals(other);\n  }\n  return obj === other;\n};\n\n},{}],9:[function(require,module,exports){\n/**\n * Returns Java hashCode() result for the object. If the object has the \"hashCode\" function,\n * it preforms the call of this function. Otherwise it uses/creates the \"$id\" property,\n * which is used as the hashCode.\n *\n * @param {Object} obj          The object.\n * @returns {int}               The object's hash code.\n */\nmodule.exports = function virtHashCode(obj, undef) {\n  if (typeof(obj) === \"string\") {\n    var hash = 0;\n    for (var i = 0; i < obj.length; ++i) {\n      hash = (hash * 31 + obj.charCodeAt(i)) & 0xFFFFFFFF;\n    }\n    return hash;\n  }\n  if (typeof(obj) !== \"object\") {\n    return obj & 0xFFFFFFFF;\n  }\n  if (obj.hashCode instanceof Function) {\n    return obj.hashCode();\n  }\n  if (obj.$id === undef) {\n      obj.$id = ((Math.floor(Math.random() * 0x10000) - 0x8000) << 16) | Math.floor(Math.random() * 0x10000);\n  }\n  return obj.$id;\n};\n\n},{}],10:[function(require,module,exports){\n/**\n * An ArrayList stores a variable number of objects.\n *\n * @param {int} initialCapacity optional defines the initial capacity of the list, it's empty by default\n *\n * @returns {ArrayList} new ArrayList object\n */\nmodule.exports = function(options) {\n  var virtHashCode = options.virtHashCode,\n      virtEquals = options.virtEquals;\n\n  function Iterator(array) {\n    var index = -1;\n    this.hasNext = function() {\n      return (index + 1) < array.length;\n    };\n\n    this.next = function() {\n      return array[++index];\n    };\n\n    this.remove = function() {\n      array.splice(index--, 1);\n    };\n  }\n\n  function ArrayList(a) {\n    var array = [];\n\n    if (a && a.toArray) {\n      array = a.toArray();\n    }\n\n    /**\n     * @member ArrayList\n     * ArrayList.get() Returns the element at the specified position in this list.\n     *\n     * @param {int} i index of element to return\n     *\n     * @returns {Object} the element at the specified position in this list.\n     */\n    this.get = function(i) {\n      return array[i];\n    };\n    /**\n     * @member ArrayList\n     * ArrayList.contains() Returns true if this list contains the specified element.\n     *\n     * @param {Object} item element whose presence in this List is to be tested.\n     *\n     * @returns {boolean} true if the specified element is present; false otherwise.\n     */\n    this.contains = function(item) {\n      return this.indexOf(item)>-1;\n    };\n    /**\n     * @member ArrayList\n     * ArrayList.indexOf() Returns the position this element takes in the list, or -1 if the element is not found.\n     *\n     * @param {Object} item element whose position in this List is to be tested.\n     *\n     * @returns {int} the list position that the first match for this element holds in the list, or -1 if it is not in the list.\n     */\n    this.indexOf = function(item) {\n      for (var i = 0, len = array.length; i < len; ++i) {\n        if (virtEquals(item, array[i])) {\n          return i;\n        }\n      }\n      return -1;\n    };\n    /**\n     * @member ArrayList\n     * ArrayList.lastIndexOf() Returns the index of the last occurrence of the specified element in this list,\n     * or -1 if this list does not contain the element. More formally, returns the highest index i such that\n     * (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.\n     *\n     * @param {Object} item element to search for.\n     *\n     * @returns {int} the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element.\n     */\n    this.lastIndexOf = function(item) {\n      for (var i = array.length-1; i >= 0; --i) {\n        if (virtEquals(item, array[i])) {\n          return i;\n        }\n      }\n      return -1;\n    };\n    /**\n     * @member ArrayList\n     * ArrayList.add() Adds the specified element to this list.\n     *\n     * @param {int}    index  optional index at which the specified element is to be inserted\n     * @param {Object} object element to be added to the list\n     */\n    this.add = function() {\n      if (arguments.length === 1) {\n        array.push(arguments[0]); // for add(Object)\n      } else if (arguments.length === 2) {\n        var arg0 = arguments[0];\n        if (typeof arg0 === 'number') {\n          if (arg0 >= 0 && arg0 <= array.length) {\n            array.splice(arg0, 0, arguments[1]); // for add(i, Object)\n          } else {\n            throw(arg0 + \" is not a valid index\");\n          }\n        } else {\n          throw(typeof arg0 + \" is not a number\");\n        }\n      } else {\n        throw(\"Please use the proper number of parameters.\");\n      }\n    };\n    /**\n     * @member ArrayList\n     * ArrayList.addAll(collection) appends all of the elements in the specified\n     * Collection to the end of this list, in the order that they are returned by\n     * the specified Collection's Iterator.\n     *\n     * When called as addAll(index, collection) the elements are inserted into\n     * this list at the position indicated by index.\n     *\n     * @param {index} Optional; specifies the position the colletion should be inserted at\n     * @param {collection} Any iterable object (ArrayList, HashMap.keySet(), etc.)\n     * @throws out of bounds error for negative index, or index greater than list size.\n     */\n    this.addAll = function(arg1, arg2) {\n      // addAll(int, Collection)\n      var it;\n      if (typeof arg1 === \"number\") {\n        if (arg1 < 0 || arg1 > array.length) {\n          throw(\"Index out of bounds for addAll: \" + arg1 + \" greater or equal than \" + array.length);\n        }\n        it = new ObjectIterator(arg2);\n        while (it.hasNext()) {\n          array.splice(arg1++, 0, it.next());\n        }\n      }\n      // addAll(Collection)\n      else {\n        it = new ObjectIterator(arg1);\n        while (it.hasNext()) {\n          array.push(it.next());\n        }\n      }\n    };\n    /**\n     * @member ArrayList\n     * ArrayList.set() Replaces the element at the specified position in this list with the specified element.\n     *\n     * @param {int}    index  index of element to replace\n     * @param {Object} object element to be stored at the specified position\n     */\n    this.set = function() {\n      if (arguments.length === 2) {\n        var arg0 = arguments[0];\n        if (typeof arg0 === 'number') {\n          if (arg0 >= 0 && arg0 < array.length) {\n            array.splice(arg0, 1, arguments[1]);\n          } else {\n            throw(arg0 + \" is not a valid index.\");\n          }\n        } else {\n          throw(typeof arg0 + \" is not a number\");\n        }\n      } else {\n        throw(\"Please use the proper number of parameters.\");\n      }\n    };\n\n    /**\n     * @member ArrayList\n     * ArrayList.size() Returns the number of elements in this list.\n     *\n     * @returns {int} the number of elements in this list\n     */\n    this.size = function() {\n      return array.length;\n    };\n\n    /**\n     * @member ArrayList\n     * ArrayList.clear() Removes all of the elements from this list. The list will be empty after this call returns.\n     */\n    this.clear = function() {\n      array.length = 0;\n    };\n\n    /**\n     * @member ArrayList\n     * ArrayList.remove() Removes an element either based on index, if the argument is a number, or\n     * by equality check, if the argument is an object.\n     *\n     * @param {int|Object} item either the index of the element to be removed, or the element itself.\n     *\n     * @returns {Object|boolean} If removal is by index, the element that was removed, or null if nothing was removed. If removal is by object, true if removal occurred, otherwise false.\n     */\n    this.remove = function(item) {\n      if (typeof item === 'number') {\n        return array.splice(item, 1)[0];\n      }\n      item = this.indexOf(item);\n      if (item > -1) {\n        array.splice(item, 1);\n        return true;\n      }\n      return false;\n    };\n\n     /**\n     * @member ArrayList\n     * ArrayList.removeAll Removes from this List all of the elements from\n     * the current ArrayList which are present in the passed in paramater ArrayList 'c'.\n     * Shifts any succeeding elements to the left (reduces their index).\n     *\n     * @param {ArrayList} the ArrayList to compare to the current ArrayList\n     *\n     * @returns {boolean} true if the ArrayList had an element removed; false otherwise\n     */\n    this.removeAll = function(c) {\n      var i, x, item,\n          newList = new ArrayList();\n      newList.addAll(this);\n      this.clear();\n      // For every item that exists in the original ArrayList and not in the c ArrayList\n      // copy it into the empty 'this' ArrayList to create the new 'this' Array.\n      for (i = 0, x = 0; i < newList.size(); i++) {\n        item = newList.get(i);\n        if (!c.contains(item)) {\n          this.add(x++, item);\n        }\n      }\n      if (this.size() < newList.size()) {\n        return true;\n      }\n      return false;\n    };\n\n    /**\n     * @member ArrayList\n     * ArrayList.isEmpty() Tests if this list has no elements.\n     *\n     * @returns {boolean} true if this list has no elements; false otherwise\n     */\n    this.isEmpty = function() {\n       return !array.length;\n    };\n\n    /**\n     * @member ArrayList\n     * ArrayList.clone() Returns a shallow copy of this ArrayList instance. (The elements themselves are not copied.)\n     *\n     * @returns {ArrayList} a clone of this ArrayList instance\n     */\n    this.clone = function() {\n      return new ArrayList(this);\n    };\n\n    /**\n     * @member ArrayList\n     * ArrayList.toArray() Returns an array containing all of the elements in this list in the correct order.\n     *\n     * @returns {Object[]} Returns an array containing all of the elements in this list in the correct order\n     */\n    this.toArray = function() {\n      return array.slice(0);\n    };\n\n    this.iterator = function() {\n      return new Iterator(array);\n    };\n  }\n\n  return ArrayList;\n};\n\n},{}],11:[function(require,module,exports){\nmodule.exports = (function(charMap, undef) {\n\n  var Char = function(chr) {\n    if (typeof chr === 'string' && chr.length === 1) {\n      this.code = chr.charCodeAt(0);\n    } else if (typeof chr === 'number') {\n      this.code = chr;\n    } else if (chr instanceof Char) {\n      this.code = chr;\n    } else {\n      this.code = NaN;\n    }\n    return (charMap[this.code] === undef) ? charMap[this.code] = this : charMap[this.code];\n  };\n\n  Char.prototype.toString = function() {\n    return String.fromCharCode(this.code);\n  };\n\n  Char.prototype.valueOf = function() {\n    return this.code;\n  };\n\n  return Char;\n}({}));\n\n},{}],12:[function(require,module,exports){\n/**\n* A HashMap stores a collection of objects, each referenced by a key. This is similar to an Array, only\n* instead of accessing elements with a numeric index, a String  is used. (If you are familiar with\n* associative arrays from other languages, this is the same idea.)\n*\n* @param {int} initialCapacity          defines the initial capacity of the map, it's 16 by default\n* @param {float} loadFactor             the load factor for the map, the default is 0.75\n* @param {Map} m                        gives the new HashMap the same mappings as this Map\n*/\nmodule.exports = function(options) {\n  var virtHashCode = options.virtHashCode,\n      virtEquals = options.virtEquals;\n\n  /**\n  * @member HashMap\n  * A HashMap stores a collection of objects, each referenced by a key. This is similar to an Array, only\n  * instead of accessing elements with a numeric index, a String  is used. (If you are familiar with\n  * associative arrays from other languages, this is the same idea.)\n  *\n  * @param {int} initialCapacity          defines the initial capacity of the map, it's 16 by default\n  * @param {float} loadFactor             the load factor for the map, the default is 0.75\n  * @param {Map} m                        gives the new HashMap the same mappings as this Map\n  */\n  function HashMap() {\n    if (arguments.length === 1 && arguments[0] instanceof HashMap) {\n      return arguments[0].clone();\n    }\n\n    var initialCapacity = arguments.length > 0 ? arguments[0] : 16;\n    var loadFactor = arguments.length > 1 ? arguments[1] : 0.75;\n    var buckets = [];\n    buckets.length = initialCapacity;\n    var count = 0;\n    var hashMap = this;\n\n    function getBucketIndex(key) {\n      var index = virtHashCode(key) % buckets.length;\n      return index < 0 ? buckets.length + index : index;\n    }\n    function ensureLoad() {\n      if (count <= loadFactor * buckets.length) {\n        return;\n      }\n      var allEntries = [];\n      for (var i = 0; i < buckets.length; ++i) {\n        if (buckets[i] !== undefined) {\n          allEntries = allEntries.concat(buckets[i]);\n        }\n      }\n      var newBucketsLength = buckets.length * 2;\n      buckets = [];\n      buckets.length = newBucketsLength;\n      for (var j = 0; j < allEntries.length; ++j) {\n        var index = getBucketIndex(allEntries[j].key);\n        var bucket = buckets[index];\n        if (bucket === undefined) {\n          buckets[index] = bucket = [];\n        }\n        bucket.push(allEntries[j]);\n      }\n    }\n\n    function Iterator(conversion, removeItem) {\n      var bucketIndex = 0;\n      var itemIndex = -1;\n      var endOfBuckets = false;\n      var currentItem;\n\n      function findNext() {\n        while (!endOfBuckets) {\n          ++itemIndex;\n          if (bucketIndex >= buckets.length) {\n            endOfBuckets = true;\n          } else if (buckets[bucketIndex] === undefined || itemIndex >= buckets[bucketIndex].length) {\n            itemIndex = -1;\n            ++bucketIndex;\n          } else {\n            return;\n          }\n        }\n      }\n\n      /*\n      * @member Iterator\n      * Checks if the Iterator has more items\n      */\n      this.hasNext = function() {\n        return !endOfBuckets;\n      };\n\n      /*\n      * @member Iterator\n      * Return the next Item\n      */\n      this.next = function() {\n        currentItem = conversion(buckets[bucketIndex][itemIndex]);\n        findNext();\n        return currentItem;\n      };\n\n      /*\n      * @member Iterator\n      * Remove the current item\n      */\n      this.remove = function() {\n        if (currentItem !== undefined) {\n          removeItem(currentItem);\n          --itemIndex;\n          findNext();\n        }\n      };\n\n      findNext();\n    }\n\n    function Set(conversion, isIn, removeItem) {\n      this.clear = function() {\n        hashMap.clear();\n      };\n\n      this.contains = function(o) {\n        return isIn(o);\n      };\n\n      this.containsAll = function(o) {\n        var it = o.iterator();\n        while (it.hasNext()) {\n          if (!this.contains(it.next())) {\n            return false;\n          }\n        }\n        return true;\n      };\n\n      this.isEmpty = function() {\n        return hashMap.isEmpty();\n      };\n\n      this.iterator = function() {\n        return new Iterator(conversion, removeItem);\n      };\n\n      this.remove = function(o) {\n        if (this.contains(o)) {\n          removeItem(o);\n          return true;\n        }\n        return false;\n      };\n\n      this.removeAll = function(c) {\n        var it = c.iterator();\n        var changed = false;\n        while (it.hasNext()) {\n          var item = it.next();\n          if (this.contains(item)) {\n            removeItem(item);\n            changed = true;\n          }\n        }\n        return true;\n      };\n\n      this.retainAll = function(c) {\n        var it = this.iterator();\n        var toRemove = [];\n        while (it.hasNext()) {\n          var entry = it.next();\n          if (!c.contains(entry)) {\n            toRemove.push(entry);\n          }\n        }\n        for (var i = 0; i < toRemove.length; ++i) {\n          removeItem(toRemove[i]);\n        }\n        return toRemove.length > 0;\n      };\n\n      this.size = function() {\n        return hashMap.size();\n      };\n\n      this.toArray = function() {\n        var result = [];\n        var it = this.iterator();\n        while (it.hasNext()) {\n          result.push(it.next());\n        }\n        return result;\n      };\n    }\n\n    function Entry(pair) {\n      this._isIn = function(map) {\n        return map === hashMap && (pair.removed === undefined);\n      };\n\n      this.equals = function(o) {\n        return virtEquals(pair.key, o.getKey());\n      };\n\n      this.getKey = function() {\n        return pair.key;\n      };\n\n      this.getValue = function() {\n        return pair.value;\n      };\n\n      this.hashCode = function(o) {\n        return virtHashCode(pair.key);\n      };\n\n      this.setValue = function(value) {\n        var old = pair.value;\n        pair.value = value;\n        return old;\n      };\n    }\n\n    this.clear = function() {\n      count = 0;\n      buckets = [];\n      buckets.length = initialCapacity;\n    };\n\n    this.clone = function() {\n      var map = new HashMap();\n      map.putAll(this);\n      return map;\n    };\n\n    this.containsKey = function(key) {\n      var index = getBucketIndex(key);\n      var bucket = buckets[index];\n      if (bucket === undefined) {\n        return false;\n      }\n      for (var i = 0; i < bucket.length; ++i) {\n        if (virtEquals(bucket[i].key, key)) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    this.containsValue = function(value) {\n      for (var i = 0; i < buckets.length; ++i) {\n        var bucket = buckets[i];\n        if (bucket === undefined) {\n          continue;\n        }\n        for (var j = 0; j < bucket.length; ++j) {\n          if (virtEquals(bucket[j].value, value)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n\n    this.entrySet = function() {\n      return new Set(\n\n      function(pair) {\n        return new Entry(pair);\n      },\n\n      function(pair) {\n        return (pair instanceof Entry) && pair._isIn(hashMap);\n      },\n\n      function(pair) {\n        return hashMap.remove(pair.getKey());\n      });\n    };\n\n    this.get = function(key) {\n      var index = getBucketIndex(key);\n      var bucket = buckets[index];\n      if (bucket === undefined) {\n        return null;\n      }\n      for (var i = 0; i < bucket.length; ++i) {\n        if (virtEquals(bucket[i].key, key)) {\n          return bucket[i].value;\n        }\n      }\n      return null;\n    };\n\n    this.isEmpty = function() {\n      return count === 0;\n    };\n\n    this.keySet = function() {\n      return new Set(\n        // get key from pair\n        function(pair) {\n          return pair.key;\n        },\n        // is-in test\n        function(key) {\n          return hashMap.containsKey(key);\n        },\n        // remove from hashmap by key\n        function(key) {\n          return hashMap.remove(key);\n        }\n      );\n    };\n\n    this.values = function() {\n      return new Set(\n        // get value from pair\n        function(pair) {\n          return pair.value;\n        },\n        // is-in test\n        function(value) {\n          return hashMap.containsValue(value);\n        },\n        // remove from hashmap by value\n        function(value) {\n          return hashMap.removeByValue(value);\n        }\n      );\n    };\n\n    this.put = function(key, value) {\n      var index = getBucketIndex(key);\n      var bucket = buckets[index];\n      if (bucket === undefined) {\n        ++count;\n        buckets[index] = [{\n          key: key,\n          value: value\n        }];\n        ensureLoad();\n        return null;\n      }\n      for (var i = 0; i < bucket.length; ++i) {\n        if (virtEquals(bucket[i].key, key)) {\n          var previous = bucket[i].value;\n          bucket[i].value = value;\n          return previous;\n        }\n      }\n      ++count;\n      bucket.push({\n        key: key,\n        value: value\n      });\n      ensureLoad();\n      return null;\n    };\n\n    this.putAll = function(m) {\n      var it = m.entrySet().iterator();\n      while (it.hasNext()) {\n        var entry = it.next();\n        this.put(entry.getKey(), entry.getValue());\n      }\n    };\n\n    this.remove = function(key) {\n      var index = getBucketIndex(key);\n      var bucket = buckets[index];\n      if (bucket === undefined) {\n        return null;\n      }\n      for (var i = 0; i < bucket.length; ++i) {\n        if (virtEquals(bucket[i].key, key)) {\n          --count;\n          var previous = bucket[i].value;\n          bucket[i].removed = true;\n          if (bucket.length > 1) {\n            bucket.splice(i, 1);\n          } else {\n            buckets[index] = undefined;\n          }\n          return previous;\n        }\n      }\n      return null;\n    };\n\n    this.removeByValue = function(value) {\n      var bucket, i, ilen, pair;\n      for (bucket in buckets) {\n        if (buckets.hasOwnProperty(bucket)) {\n          for (i = 0, ilen = buckets[bucket].length; i < ilen; i++) {\n            pair = buckets[bucket][i];\n            // removal on values is based on identity, not equality\n            if (pair.value === value) {\n              buckets[bucket].splice(i, 1);\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    };\n\n    this.size = function() {\n      return count;\n    };\n  }\n\n  return HashMap;\n};\n\n},{}],13:[function(require,module,exports){\n// module export\nmodule.exports = function(options,undef) {\n  var window = options.Browser.window,\n      document = options.Browser.document,\n      noop = options.noop;\n\n  /**\n   * [internal function] computeFontMetrics() calculates various metrics for text\n   * placement. Currently this function computes the ascent, descent and leading\n   * (from \"lead\", used for vertical space) values for the currently active font.\n   */\n  function computeFontMetrics(pfont) {\n    var emQuad = 250,\n        correctionFactor = pfont.size / emQuad,\n        canvas = document.createElement(\"canvas\");\n    canvas.width = 2*emQuad;\n    canvas.height = 2*emQuad;\n    canvas.style.opacity = 0;\n    var cfmFont = pfont.getCSSDefinition(emQuad+\"px\", \"normal\"),\n        ctx = canvas.getContext(\"2d\");\n    ctx.font = cfmFont;\n\n    // Size the canvas using a string with common max-ascent and max-descent letters.\n    // Changing the canvas dimensions resets the context, so we must reset the font.\n    var protrusions = \"dbflkhyjqpg\";\n    canvas.width = ctx.measureText(protrusions).width;\n    ctx.font = cfmFont;\n\n    // for text lead values, we meaure a multiline text container.\n    var leadDiv = document.createElement(\"div\");\n    leadDiv.style.position = \"absolute\";\n    leadDiv.style.opacity = 0;\n    leadDiv.style.fontFamily = '\"' + pfont.name + '\"';\n    leadDiv.style.fontSize = emQuad + \"px\";\n    leadDiv.innerHTML = protrusions + \"<br/>\" + protrusions;\n    document.body.appendChild(leadDiv);\n\n    var w = canvas.width,\n        h = canvas.height,\n        baseline = h/2;\n\n    // Set all canvas pixeldata values to 255, with all the content\n    // data being 0. This lets us scan for data[i] != 255.\n    ctx.fillStyle = \"white\";\n    ctx.fillRect(0, 0, w, h);\n    ctx.fillStyle = \"black\";\n    ctx.fillText(protrusions, 0, baseline);\n    var pixelData = ctx.getImageData(0, 0, w, h).data;\n\n    // canvas pixel data is w*4 by h*4, because R, G, B and A are separate,\n    // consecutive values in the array, rather than stored as 32 bit ints.\n    var i = 0,\n        w4 = w * 4,\n        len = pixelData.length;\n\n    // Finding the ascent uses a normal, forward scanline\n    while (++i < len && pixelData[i] === 255) {\n      noop();\n    }\n    var ascent = Math.round(i / w4);\n\n    // Finding the descent uses a reverse scanline\n    i = len - 1;\n    while (--i > 0 && pixelData[i] === 255) {\n      noop();\n    }\n    var descent = Math.round(i / w4);\n\n    // set font metrics\n    pfont.ascent = correctionFactor * (baseline - ascent);\n    pfont.descent = correctionFactor * (descent - baseline);\n\n    // Then we try to get the real value from the browser\n    if (document.defaultView.getComputedStyle) {\n      var leadDivHeight = document.defaultView.getComputedStyle(leadDiv,null).getPropertyValue(\"height\");\n      leadDivHeight = correctionFactor * leadDivHeight.replace(\"px\",\"\");\n      if (leadDivHeight >= pfont.size * 2) {\n        pfont.leading = Math.round(leadDivHeight/2);\n      }\n    }\n    document.body.removeChild(leadDiv);\n\n    // if we're caching, cache the context used for this pfont\n    if (pfont.caching) {\n      return ctx;\n    }\n  }\n\n  /**\n   * Constructor for a system or from-file (non-SVG) font.\n   */\n  function PFont(name, size) {\n    // according to the P5 API, new PFont() is legal (albeit completely useless)\n    if (name === undef) {\n      name = \"\";\n    }\n    this.name = name;\n    if (size === undef) {\n      size = 0;\n    }\n    this.size = size;\n    this.glyph = false;\n    this.ascent = 0;\n    this.descent = 0;\n    // For leading, the \"safe\" value uses the standard TEX ratio\n    this.leading = 1.2 * size;\n\n    // Note that an italic, bold font must used \"... Bold Italic\"\n    // in P5. \"... Italic Bold\" is treated as normal/normal.\n    var illegalIndicator = name.indexOf(\" Italic Bold\");\n    if (illegalIndicator !== -1) {\n      name = name.substring(0, illegalIndicator);\n    }\n\n    // determine font style\n    this.style = \"normal\";\n    var italicsIndicator = name.indexOf(\" Italic\");\n    if (italicsIndicator !== -1) {\n      name = name.substring(0, italicsIndicator);\n      this.style = \"italic\";\n    }\n\n    // determine font weight\n    this.weight = \"normal\";\n    var boldIndicator = name.indexOf(\" Bold\");\n    if (boldIndicator !== -1) {\n      name = name.substring(0, boldIndicator);\n      this.weight = \"bold\";\n    }\n\n    // determine font-family name\n    this.family = \"sans-serif\";\n    if (name !== undef) {\n      switch(name) {\n        case \"sans-serif\":\n        case \"serif\":\n        case \"monospace\":\n        case \"fantasy\":\n        case \"cursive\":\n          this.family = name;\n          break;\n        default:\n          this.family = '\"' + name + '\", sans-serif';\n          break;\n      }\n    }\n    // Calculate the ascent/descent/leading value based on\n    // how the browser renders this font.\n    this.context2d = computeFontMetrics(this);\n    this.css = this.getCSSDefinition();\n    if (this.context2d) {\n      this.context2d.font = this.css;\n    }\n  }\n\n  /**\n   * regulates whether or not we're caching the canvas\n   * 2d context for quick text width computation.\n   */\n  PFont.prototype.caching = true;\n\n  /**\n   * This function generates the CSS \"font\" string for this PFont\n   */\n  PFont.prototype.getCSSDefinition = function(fontSize, lineHeight) {\n    if(fontSize===undef) {\n      fontSize = this.size + \"px\";\n    }\n    if(lineHeight===undef) {\n      lineHeight = this.leading + \"px\";\n    }\n    // CSS \"font\" definition: font-style font-variant font-weight font-size/line-height font-family\n    var components = [this.style, \"normal\", this.weight, fontSize + \"/\" + lineHeight, this.family];\n    return components.join(\" \");\n  };\n\n  /**\n   * Rely on the cached context2d measureText function.\n   */\n  PFont.prototype.measureTextWidth = function(string) {\n    return this.context2d.measureText(string).width;\n  };\n\n  /**\n   * FALLBACK FUNCTION -- replaces Pfont.prototype.measureTextWidth\n   * when the font cache becomes too large. This contructs a new\n   * canvas 2d context object for calling measureText on.\n   */\n  PFont.prototype.measureTextWidthFallback = function(string) {\n    var canvas = document.createElement(\"canvas\"),\n        ctx = canvas.getContext(\"2d\");\n    ctx.font = this.css;\n    return ctx.measureText(string).width;\n  };\n\n  /**\n   * Global \"loaded fonts\" list, internal to PFont\n   */\n  PFont.PFontCache = { length: 0 };\n\n  /**\n   * This function acts as single access point for getting and caching\n   * fonts across all sketches handled by an instance of Processing.js\n   */\n  PFont.get = function(fontName, fontSize) {\n    // round fontSize to one decimal point\n    fontSize = ((fontSize*10)+0.5|0)/10;\n    var cache = PFont.PFontCache,\n        idx = fontName+\"/\"+fontSize;\n    if (!cache[idx]) {\n      cache[idx] = new PFont(fontName, fontSize);\n      cache.length++;\n\n      // FALLBACK FUNCTIONALITY 1:\n      // If the cache has become large, switch over from full caching\n      // to caching only the static metrics for each new font request.\n      if (cache.length === 50) {\n        PFont.prototype.measureTextWidth = PFont.prototype.measureTextWidthFallback;\n        PFont.prototype.caching = false;\n        // clear contexts stored for each cached font\n        var entry;\n        for (entry in cache) {\n          if (entry !== \"length\") {\n            cache[entry].context2d = null;\n          }\n        }\n        return new PFont(fontName, fontSize);\n      }\n\n      // FALLBACK FUNCTIONALITY 2:\n      // If the cache has become too large, switch off font caching entirely.\n      if (cache.length === 400) {\n        PFont.PFontCache = {};\n        PFont.get = PFont.getFallback;\n        return new PFont(fontName, fontSize);\n      }\n    }\n    return cache[idx];\n  };\n\n  /**\n   * FALLBACK FUNCTION -- replaces PFont.get when the font cache\n   * becomes too large. This function bypasses font caching entirely.\n   */\n  PFont.getFallback = function(fontName, fontSize) {\n    return new PFont(fontName, fontSize);\n  };\n\n  /**\n   * Lists all standard fonts. Due to browser limitations, this list is\n   * not the system font list, like in P5, but the CSS \"genre\" list.\n   */\n  PFont.list = function() {\n    return [\"sans-serif\", \"serif\", \"monospace\", \"fantasy\", \"cursive\"];\n  };\n\n  /**\n   * Loading external fonts through @font-face rules is handled by PFont,\n   * to ensure fonts loaded in this way are globally available.\n   */\n  PFont.preloading = {\n    // template element used to compare font sizes\n    template: {},\n    // indicates whether or not the reference tiny font has been loaded\n    initialized: false,\n    // load the reference tiny font via a css @font-face rule\n    initialize: function() {\n      var generateTinyFont = function() {\n        var encoded = \"#E3KAI2wAgT1MvMg7Eo3VmNtYX7ABi3CxnbHlm\" +\n                      \"7Abw3kaGVhZ7ACs3OGhoZWE7A53CRobXR47AY3\" +\n                      \"AGbG9jYQ7G03Bm1heH7ABC3CBuYW1l7Ae3AgcG\" +\n                      \"9zd7AI3AE#B3AQ2kgTY18PPPUACwAg3ALSRoo3\" +\n                      \"#yld0xg32QAB77#E777773B#E3C#I#Q77773E#\" +\n                      \"Q7777777772CMAIw7AB77732B#M#Q3wAB#g3B#\" +\n                      \"E#E2BB//82BB////w#B7#gAEg3E77x2B32B#E#\" +\n                      \"Q#MTcBAQ32gAe#M#QQJ#E32M#QQJ#I#g32Q77#\";\n        var expand = function(input) {\n                       return \"AAAAAAAA\".substr(~~input ? 7-input : 6);\n                     };\n        return encoded.replace(/[#237]/g, expand);\n      };\n      var fontface = document.createElement(\"style\");\n      fontface.setAttribute(\"type\",\"text/css\");\n      fontface.innerHTML =  \"@font-face {\\n\" +\n                            '  font-family: \"PjsEmptyFont\";' + \"\\n\" +\n                            \"  src: url('data:application/x-font-ttf;base64,\"+generateTinyFont()+\"')\\n\" +\n                            \"       format('truetype');\\n\" +\n                            \"}\";\n      document.head.appendChild(fontface);\n\n      // set up the template element\n      var element = document.createElement(\"span\");\n      element.style.cssText = 'position: absolute; top: -1000; left: 0; opacity: 0; font-family: \"PjsEmptyFont\", fantasy;';\n      element.innerHTML = \"AAAAAAAA\";\n      document.body.appendChild(element);\n      this.template = element;\n\n      this.initialized = true;\n    },\n    // Shorthand function to get the computed width for an element.\n    getElementWidth: function(element) {\n      return document.defaultView.getComputedStyle(element,\"\").getPropertyValue(\"width\");\n    },\n    // time taken so far in attempting to load a font\n    timeAttempted: 0,\n    // returns false if no fonts are pending load, or true otherwise.\n    pending: function(intervallength) {\n      if (!this.initialized) {\n        this.initialize();\n      }\n      var element,\n          computedWidthFont,\n          computedWidthRef = this.getElementWidth(this.template);\n      for (var i = 0; i < this.fontList.length; i++) {\n        // compares size of text in pixels. if equal, custom font is not yet loaded\n        element = this.fontList[i];\n        computedWidthFont = this.getElementWidth(element);\n        if (this.timeAttempted < 4000 && computedWidthFont === computedWidthRef) {\n          this.timeAttempted += intervallength;\n          return true;\n        } else {\n          document.body.removeChild(element);\n          this.fontList.splice(i--, 1);\n          this.timeAttempted = 0;\n        }\n      }\n      // if there are no more fonts to load, pending is false\n      if (this.fontList.length === 0) {\n        return false;\n      }\n      // We should have already returned before getting here.\n      // But, if we do get here, length!=0 so fonts are pending.\n      return true;\n    },\n    // fontList contains elements to compare font sizes against a template\n    fontList: [],\n    // addedList contains the fontnames of all the fonts loaded via @font-face\n    addedList: {},\n    // adds a font to the font cache\n    // creates an element using the font, to start loading the font,\n    // and compare against a default font to see if the custom font is loaded\n    add: function(fontSrc) {\n      if (!this.initialized) {\n       this.initialize();\n      }\n      // fontSrc can be a string or a javascript object\n      // acceptable fonts are .ttf, .otf, and data uri\n      var fontName = (typeof fontSrc === 'object' ? fontSrc.fontFace : fontSrc),\n          fontUrl = (typeof fontSrc === 'object' ? fontSrc.url : fontSrc);\n\n      // check whether we already created the @font-face rule for this font\n      if (this.addedList[fontName]) {\n        return;\n      }\n\n      // if we didn't, create the @font-face rule\n      var style = document.createElement(\"style\");\n      style.setAttribute(\"type\",\"text/css\");\n      style.innerHTML = \"@font-face{\\n  font-family: '\" + fontName + \"';\\n  src:  url('\" + fontUrl + \"');\\n}\\n\";\n      document.head.appendChild(style);\n      this.addedList[fontName] = true;\n\n      // also create the element to load and compare the new font\n      var element = document.createElement(\"span\");\n      element.style.cssText = \"position: absolute; top: 0; left: 0; opacity: 0;\";\n      element.style.fontFamily = '\"' + fontName + '\", \"PjsEmptyFont\", fantasy';\n      element.innerHTML = \"AAAAAAAA\";\n      document.body.appendChild(element);\n      this.fontList.push(element);\n    }\n  };\n\n  return PFont;\n};\n},{}],14:[function(require,module,exports){\nmodule.exports = function(options, undef) {\n\n  // FIXME: hack\n  var p = options.p;\n\n  /**\n   * PMatrix2D is a 3x2 affine matrix implementation. The constructor accepts another PMatrix2D or a list of six float elements.\n   * If no parameters are provided the matrix is set to the identity matrix.\n   *\n   * @param {PMatrix2D} matrix  the initial matrix to set to\n   * @param {float} m00         the first element of the matrix\n   * @param {float} m01         the second element of the matrix\n   * @param {float} m02         the third element of the matrix\n   * @param {float} m10         the fourth element of the matrix\n   * @param {float} m11         the fifth element of the matrix\n   * @param {float} m12         the sixth element of the matrix\n   */\n  var PMatrix2D = function() {\n    if (arguments.length === 0) {\n      this.reset();\n    } else if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) {\n      this.set(arguments[0].array());\n    } else if (arguments.length === 6) {\n      this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);\n    }\n  };\n\n  /**\n   * PMatrix2D methods\n   */\n  PMatrix2D.prototype = {\n    /**\n     * @member PMatrix2D\n     * The set() function sets the matrix elements. The function accepts either another PMatrix2D, an array of elements, or a list of six floats.\n     *\n     * @param {PMatrix2D} matrix    the matrix to set this matrix to\n     * @param {float[]} elements    an array of elements to set this matrix to\n     * @param {float} m00           the first element of the matrix\n     * @param {float} m01           the third element of the matrix\n     * @param {float} m10           the fourth element of the matrix\n     * @param {float} m11           the fith element of the matrix\n     * @param {float} m12           the sixth element of the matrix\n     */\n    set: function() {\n      if (arguments.length === 6) {\n        var a = arguments;\n        this.set([a[0], a[1], a[2],\n                  a[3], a[4], a[5]]);\n      } else if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) {\n        this.elements = arguments[0].array();\n      } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n        this.elements = arguments[0].slice();\n      }\n    },\n    /**\n     * @member PMatrix2D\n     * The get() function returns a copy of this PMatrix2D.\n     *\n     * @return {PMatrix2D} a copy of this PMatrix2D\n     */\n    get: function() {\n      var outgoing = new PMatrix2D();\n      outgoing.set(this.elements);\n      return outgoing;\n    },\n    /**\n     * @member PMatrix2D\n     * The reset() function sets this PMatrix2D to the identity matrix.\n     */\n    reset: function() {\n      this.set([1, 0, 0, 0, 1, 0]);\n    },\n    /**\n     * @member PMatrix2D\n     * The array() function returns a copy of the element values.\n     * @addon\n     *\n     * @return {float[]} returns a copy of the element values\n     */\n    array: function array() {\n      return this.elements.slice();\n    },\n    /**\n     * @member PMatrix2D\n     * The translate() function translates this matrix by moving the current coordinates to the location specified by tx and ty.\n     *\n     * @param {float} tx  the x-axis coordinate to move to\n     * @param {float} ty  the y-axis coordinate to move to\n     */\n    translate: function(tx, ty) {\n      this.elements[2] = tx * this.elements[0] + ty * this.elements[1] + this.elements[2];\n      this.elements[5] = tx * this.elements[3] + ty * this.elements[4] + this.elements[5];\n    },\n    /**\n     * @member PMatrix2D\n     * The invTranslate() function translates this matrix by moving the current coordinates to the negative location specified by tx and ty.\n     *\n     * @param {float} tx  the x-axis coordinate to move to\n     * @param {float} ty  the y-axis coordinate to move to\n     */\n    invTranslate: function(tx, ty) {\n      this.translate(-tx, -ty);\n    },\n     /**\n     * @member PMatrix2D\n     * The transpose() function is not used in processingjs.\n     */\n    transpose: function() {\n      // Does nothing in Processing.\n    },\n    /**\n     * @member PMatrix2D\n     * The mult() function multiplied this matrix.\n     * If two array elements are passed in the function will multiply a two element vector against this matrix.\n     * If target is null or not length four, a new float array will be returned.\n     * The values for vec and target can be the same (though that's less efficient).\n     * If two PVectors are passed in the function multiply the x and y coordinates of a PVector against this matrix.\n     *\n     * @param {PVector} source, target  the PVectors used to multiply this matrix\n     * @param {float[]} source, target  the arrays used to multiply this matrix\n     *\n     * @return {PVector|float[]} returns a PVector or an array representing the new matrix\n     */\n    mult: function(source, target) {\n      var x, y;\n      if (source instanceof PVector) {\n        x = source.x;\n        y = source.y;\n        if (!target) {\n          target = new PVector();\n        }\n      } else if (source instanceof Array) {\n        x = source[0];\n        y = source[1];\n        if (!target) {\n          target = [];\n        }\n      }\n      if (target instanceof Array) {\n        target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2];\n        target[1] = this.elements[3] * x + this.elements[4] * y + this.elements[5];\n      } else if (target instanceof PVector) {\n        target.x = this.elements[0] * x + this.elements[1] * y + this.elements[2];\n        target.y = this.elements[3] * x + this.elements[4] * y + this.elements[5];\n        target.z = 0;\n      }\n      return target;\n    },\n    /**\n     * @member PMatrix2D\n     * The multX() function calculates the x component of a vector from a transformation.\n     *\n     * @param {float} x the x component of the vector being transformed\n     * @param {float} y the y component of the vector being transformed\n     *\n     * @return {float} returnes the result of the calculation\n     */\n    multX: function(x, y) {\n      return (x * this.elements[0] + y * this.elements[1] + this.elements[2]);\n    },\n    /**\n     * @member PMatrix2D\n     * The multY() function calculates the y component of a vector from a transformation.\n     *\n     * @param {float} x the x component of the vector being transformed\n     * @param {float} y the y component of the vector being transformed\n     *\n     * @return {float} returnes the result of the calculation\n     */\n    multY: function(x, y) {\n      return (x * this.elements[3] + y * this.elements[4] + this.elements[5]);\n    },\n    /**\n     * @member PMatrix2D\n     * The skewX() function skews the matrix along the x-axis the amount specified by the angle parameter.\n     * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n     *\n     * @param {float} angle  angle of skew specified in radians\n     */\n    skewX: function(angle) {\n      this.apply(1, 0, 1, angle, 0, 0);\n    },\n    /**\n     * @member PMatrix2D\n     * The skewY() function skews the matrix along the y-axis the amount specified by the angle parameter.\n     * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n     *\n     * @param {float} angle  angle of skew specified in radians\n     */\n    skewY: function(angle) {\n      this.apply(1, 0, 1,  0, angle, 0);\n    },\n    /**\n     * @member PMatrix2D\n     * The shearX() function shears the matrix along the x-axis the amount specified by the angle parameter.\n     * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n     *\n     * @param {float} angle  angle of skew specified in radians\n     */\n    shearX: function(angle) {\n      this.apply(1, 0, 1, Math.tan(angle) , 0, 0);\n    },\n    /**\n     * @member PMatrix2D\n     * The shearY() function shears the matrix along the y-axis the amount specified by the angle parameter.\n     * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n     *\n     * @param {float} angle  angle of skew specified in radians\n     */\n    shearY: function(angle) {\n      this.apply(1, 0, 1,  0, Math.tan(angle), 0);\n    },\n    /**\n     * @member PMatrix2D\n     * The determinant() function calvculates the determinant of this matrix.\n     *\n     * @return {float} the determinant of the matrix\n     */\n    determinant: function() {\n      return (this.elements[0] * this.elements[4] - this.elements[1] * this.elements[3]);\n    },\n    /**\n     * @member PMatrix2D\n     * The invert() function inverts this matrix\n     *\n     * @return {boolean} true if successful\n     */\n    invert: function() {\n      var d = this.determinant();\n      if (Math.abs( d ) > PConstants.MIN_INT) {\n        var old00 = this.elements[0];\n        var old01 = this.elements[1];\n        var old02 = this.elements[2];\n        var old10 = this.elements[3];\n        var old11 = this.elements[4];\n        var old12 = this.elements[5];\n        this.elements[0] =  old11 / d;\n        this.elements[3] = -old10 / d;\n        this.elements[1] = -old01 / d;\n        this.elements[4] =  old00 / d;\n        this.elements[2] = (old01 * old12 - old11 * old02) / d;\n        this.elements[5] = (old10 * old02 - old00 * old12) / d;\n        return true;\n      }\n      return false;\n    },\n    /**\n     * @member PMatrix2D\n     * The scale() function increases or decreases the size of a shape by expanding and contracting vertices. When only one parameter is specified scale will occur in all dimensions.\n     * This is equivalent to a two parameter call.\n     *\n     * @param {float} sx  the amount to scale on the x-axis\n     * @param {float} sy  the amount to scale on the y-axis\n     */\n    scale: function(sx, sy) {\n      if (sx && sy === undef) {\n        sy = sx;\n      }\n      if (sx && sy) {\n        this.elements[0] *= sx;\n        this.elements[1] *= sy;\n        this.elements[3] *= sx;\n        this.elements[4] *= sy;\n      }\n    },\n     /**\n      * @member PMatrix2D\n      * The invScale() function decreases or increases the size of a shape by contracting and expanding vertices. When only one parameter is specified scale will occur in all dimensions.\n      * This is equivalent to a two parameter call.\n      *\n      * @param {float} sx  the amount to scale on the x-axis\n      * @param {float} sy  the amount to scale on the y-axis\n      */\n    invScale: function(sx, sy) {\n      if (sx && !sy) {\n        sy = sx;\n      }\n      this.scale(1 / sx, 1 / sy);\n    },\n    /**\n     * @member PMatrix2D\n     * The apply() function multiplies the current matrix by the one specified through the parameters. Note that either a PMatrix2D or a list of floats can be passed in.\n     *\n     * @param {PMatrix2D} matrix    the matrix to apply this matrix to\n     * @param {float} m00           the first element of the matrix\n     * @param {float} m01           the third element of the matrix\n     * @param {float} m10           the fourth element of the matrix\n     * @param {float} m11           the fith element of the matrix\n     * @param {float} m12           the sixth element of the matrix\n     */\n    apply: function() {\n      var source;\n      if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) {\n        source = arguments[0].array();\n      } else if (arguments.length === 6) {\n        source = Array.prototype.slice.call(arguments);\n      } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n        source = arguments[0];\n      }\n\n      var result = [0, 0, this.elements[2],\n                    0, 0, this.elements[5]];\n      var e = 0;\n      for (var row = 0; row < 2; row++) {\n        for (var col = 0; col < 3; col++, e++) {\n          result[e] += this.elements[row * 3 + 0] * source[col + 0] +\n                       this.elements[row * 3 + 1] * source[col + 3];\n        }\n      }\n      this.elements = result.slice();\n    },\n    /**\n     * @member PMatrix2D\n     * The preApply() function applies another matrix to the left of this one. Note that either a PMatrix2D or elements of a matrix can be passed in.\n     *\n     * @param {PMatrix2D} matrix    the matrix to apply this matrix to\n     * @param {float} m00           the first element of the matrix\n     * @param {float} m01           the third element of the matrix\n     * @param {float} m10           the fourth element of the matrix\n     * @param {float} m11           the fith element of the matrix\n     * @param {float} m12           the sixth element of the matrix\n     */\n    preApply: function() {\n      var source;\n      if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) {\n        source = arguments[0].array();\n      } else if (arguments.length === 6) {\n        source = Array.prototype.slice.call(arguments);\n      } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n        source = arguments[0];\n      }\n      var result = [0, 0, source[2],\n                    0, 0, source[5]];\n      result[2] = source[2] + this.elements[2] * source[0] + this.elements[5] * source[1];\n      result[5] = source[5] + this.elements[2] * source[3] + this.elements[5] * source[4];\n      result[0] = this.elements[0] * source[0] + this.elements[3] * source[1];\n      result[3] = this.elements[0] * source[3] + this.elements[3] * source[4];\n      result[1] = this.elements[1] * source[0] + this.elements[4] * source[1];\n      result[4] = this.elements[1] * source[3] + this.elements[4] * source[4];\n      this.elements = result.slice();\n    },\n    /**\n     * @member PMatrix2D\n     * The rotate() function rotates the matrix.\n     *\n     * @param {float} angle         the angle of rotation in radiants\n     */\n    rotate: function(angle) {\n      var c = Math.cos(angle);\n      var s = Math.sin(angle);\n      var temp1 = this.elements[0];\n      var temp2 = this.elements[1];\n      this.elements[0] =  c * temp1 + s * temp2;\n      this.elements[1] = -s * temp1 + c * temp2;\n      temp1 = this.elements[3];\n      temp2 = this.elements[4];\n      this.elements[3] =  c * temp1 + s * temp2;\n      this.elements[4] = -s * temp1 + c * temp2;\n    },\n    /**\n     * @member PMatrix2D\n     * The rotateZ() function rotates the matrix.\n     *\n     * @param {float} angle         the angle of rotation in radiants\n     */\n    rotateZ: function(angle) {\n      this.rotate(angle);\n    },\n    /**\n     * @member PMatrix2D\n     * The invRotateZ() function rotates the matrix in opposite direction.\n     *\n     * @param {float} angle         the angle of rotation in radiants\n     */\n    invRotateZ: function(angle) {\n      this.rotateZ(angle - Math.PI);\n    },\n    /**\n     * @member PMatrix2D\n     * The print() function prints out the elements of this matrix\n     */\n    print: function() {\n      var digits = printMatrixHelper(this.elements);\n      var output = \"\" + p.nfs(this.elements[0], digits, 4) + \" \" +\n                        p.nfs(this.elements[1], digits, 4) + \" \" +\n                        p.nfs(this.elements[2], digits, 4) + \"\\n\" +\n                        p.nfs(this.elements[3], digits, 4) + \" \" +\n                        p.nfs(this.elements[4], digits, 4) + \" \" +\n                        p.nfs(this.elements[5], digits, 4) + \"\\n\\n\";\n      p.println(output);\n    }\n  };\n\n  return PMatrix2D;\n};\n\n},{}],15:[function(require,module,exports){\nmodule.exports = function(options, undef) {\n\n  // FIXME: hack\n  var p = options.p;\n\n  /**\n   * PMatrix3D is a 4x4  matrix implementation. The constructor accepts another PMatrix3D or a list of six or sixteen float elements.\n   * If no parameters are provided the matrix is set to the identity matrix.\n   */\n  var PMatrix3D = function() {\n    // When a matrix is created, it is set to an identity matrix\n    this.reset();\n  };\n\n  /**\n   * PMatrix3D methods\n   */\n  PMatrix3D.prototype = {\n    /**\n     * @member PMatrix2D\n     * The set() function sets the matrix elements. The function accepts either another PMatrix3D, an array of elements, or a list of six or sixteen floats.\n     *\n     * @param {PMatrix3D} matrix    the initial matrix to set to\n     * @param {float[]} elements    an array of elements to set this matrix to\n     * @param {float} m00           the first element of the matrix\n     * @param {float} m01           the second element of the matrix\n     * @param {float} m02           the third element of the matrix\n     * @param {float} m03           the fourth element of the matrix\n     * @param {float} m10           the fifth element of the matrix\n     * @param {float} m11           the sixth element of the matrix\n     * @param {float} m12           the seventh element of the matrix\n     * @param {float} m13           the eight element of the matrix\n     * @param {float} m20           the nineth element of the matrix\n     * @param {float} m21           the tenth element of the matrix\n     * @param {float} m22           the eleventh element of the matrix\n     * @param {float} m23           the twelveth element of the matrix\n     * @param {float} m30           the thirteenth element of the matrix\n     * @param {float} m31           the fourtheenth element of the matrix\n     * @param {float} m32           the fivetheenth element of the matrix\n     * @param {float} m33           the sixteenth element of the matrix\n     */\n    set: function() {\n      if (arguments.length === 16) {\n        this.elements = Array.prototype.slice.call(arguments);\n      } else if (arguments.length === 1 && arguments[0] instanceof PMatrix3D) {\n        this.elements = arguments[0].array();\n      } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n        this.elements = arguments[0].slice();\n      }\n    },\n    /**\n     * @member PMatrix3D\n     * The get() function returns a copy of this PMatrix3D.\n     *\n     * @return {PMatrix3D} a copy of this PMatrix3D\n     */\n    get: function() {\n      var outgoing = new PMatrix3D();\n      outgoing.set(this.elements);\n      return outgoing;\n    },\n    /**\n     * @member PMatrix3D\n     * The reset() function sets this PMatrix3D to the identity matrix.\n     */\n    reset: function() {\n      this.elements = [1,0,0,0,\n                       0,1,0,0,\n                       0,0,1,0,\n                       0,0,0,1];\n    },\n    /**\n     * @member PMatrix3D\n     * The array() function returns a copy of the element values.\n     * @addon\n     *\n     * @return {float[]} returns a copy of the element values\n     */\n    array: function array() {\n      return this.elements.slice();\n    },\n    /**\n     * @member PMatrix3D\n     * The translate() function translates this matrix by moving the current coordinates to the location specified by tx, ty, and tz.\n     *\n     * @param {float} tx  the x-axis coordinate to move to\n     * @param {float} ty  the y-axis coordinate to move to\n     * @param {float} tz  the z-axis coordinate to move to\n     */\n    translate: function(tx, ty, tz) {\n      if (tz === undef) {\n        tz = 0;\n      }\n\n      this.elements[3]  += tx * this.elements[0]  + ty * this.elements[1]  + tz * this.elements[2];\n      this.elements[7]  += tx * this.elements[4]  + ty * this.elements[5]  + tz * this.elements[6];\n      this.elements[11] += tx * this.elements[8]  + ty * this.elements[9]  + tz * this.elements[10];\n      this.elements[15] += tx * this.elements[12] + ty * this.elements[13] + tz * this.elements[14];\n    },\n    /**\n     * @member PMatrix3D\n     * The transpose() function transpose this matrix.\n     */\n    transpose: function() {\n      var temp = this.elements[4];\n      this.elements[4] = this.elements[1];\n      this.elements[1] = temp;\n\n      temp = this.elements[8];\n      this.elements[8] = this.elements[2];\n      this.elements[2] = temp;\n\n      temp = this.elements[6];\n      this.elements[6] = this.elements[9];\n      this.elements[9] = temp;\n\n      temp = this.elements[3];\n      this.elements[3] = this.elements[12];\n      this.elements[12] = temp;\n\n      temp = this.elements[7];\n      this.elements[7] = this.elements[13];\n      this.elements[13] = temp;\n\n      temp = this.elements[11];\n      this.elements[11] = this.elements[14];\n      this.elements[14] = temp;\n    },\n    /**\n     * @member PMatrix3D\n     * The mult() function multiplied this matrix.\n     * If two array elements are passed in the function will multiply a two element vector against this matrix.\n     * If target is null or not length four, a new float array will be returned.\n     * The values for vec and target can be the same (though that's less efficient).\n     * If two PVectors are passed in the function multiply the x and y coordinates of a PVector against this matrix.\n     *\n     * @param {PVector} source, target  the PVectors used to multiply this matrix\n     * @param {float[]} source, target  the arrays used to multiply this matrix\n     *\n     * @return {PVector|float[]} returns a PVector or an array representing the new matrix\n     */\n    mult: function(source, target) {\n      var x, y, z, w;\n      if (source instanceof PVector) {\n        x = source.x;\n        y = source.y;\n        z = source.z;\n        w = 1;\n        if (!target) {\n          target = new PVector();\n        }\n      } else if (source instanceof Array) {\n        x = source[0];\n        y = source[1];\n        z = source[2];\n        w = source[3] || 1;\n\n        if ( !target || (target.length !== 3 && target.length !== 4) ) {\n          target = [0, 0, 0];\n        }\n      }\n\n      if (target instanceof Array) {\n        if (target.length === 3) {\n          target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];\n          target[1] = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];\n          target[2] = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];\n        } else if (target.length === 4) {\n          target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3] * w;\n          target[1] = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7] * w;\n          target[2] = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11] * w;\n          target[3] = this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15] * w;\n        }\n      }\n      if (target instanceof PVector) {\n        target.x = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];\n        target.y = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];\n        target.z = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];\n      }\n      return target;\n    },\n    /**\n     * @member PMatrix3D\n     * The preApply() function applies another matrix to the left of this one. Note that either a PMatrix3D or elements of a matrix can be passed in.\n     *\n     * @param {PMatrix3D} matrix    the matrix to apply this matrix to\n     * @param {float} m00           the first element of the matrix\n     * @param {float} m01           the second element of the matrix\n     * @param {float} m02           the third element of the matrix\n     * @param {float} m03           the fourth element of the matrix\n     * @param {float} m10           the fifth element of the matrix\n     * @param {float} m11           the sixth element of the matrix\n     * @param {float} m12           the seventh element of the matrix\n     * @param {float} m13           the eight element of the matrix\n     * @param {float} m20           the nineth element of the matrix\n     * @param {float} m21           the tenth element of the matrix\n     * @param {float} m22           the eleventh element of the matrix\n     * @param {float} m23           the twelveth element of the matrix\n     * @param {float} m30           the thirteenth element of the matrix\n     * @param {float} m31           the fourtheenth element of the matrix\n     * @param {float} m32           the fivetheenth element of the matrix\n     * @param {float} m33           the sixteenth element of the matrix\n     */\n    preApply: function() {\n      var source;\n      if (arguments.length === 1 && arguments[0] instanceof PMatrix3D) {\n        source = arguments[0].array();\n      } else if (arguments.length === 16) {\n        source = Array.prototype.slice.call(arguments);\n      } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n        source = arguments[0];\n      }\n\n      var result = [0, 0, 0, 0,\n                    0, 0, 0, 0,\n                    0, 0, 0, 0,\n                    0, 0, 0, 0];\n      var e = 0;\n      for (var row = 0; row < 4; row++) {\n        for (var col = 0; col < 4; col++, e++) {\n          result[e] += this.elements[col + 0] * source[row * 4 + 0] + this.elements[col + 4] *\n                       source[row * 4 + 1] + this.elements[col + 8] * source[row * 4 + 2] +\n                       this.elements[col + 12] * source[row * 4 + 3];\n        }\n      }\n      this.elements = result.slice();\n    },\n    /**\n     * @member PMatrix3D\n     * The apply() function multiplies the current matrix by the one specified through the parameters. Note that either a PMatrix3D or a list of floats can be passed in.\n     *\n     * @param {PMatrix3D} matrix    the matrix to apply this matrix to\n     * @param {float} m00           the first element of the matrix\n     * @param {float} m01           the second element of the matrix\n     * @param {float} m02           the third element of the matrix\n     * @param {float} m03           the fourth element of the matrix\n     * @param {float} m10           the fifth element of the matrix\n     * @param {float} m11           the sixth element of the matrix\n     * @param {float} m12           the seventh element of the matrix\n     * @param {float} m13           the eight element of the matrix\n     * @param {float} m20           the nineth element of the matrix\n     * @param {float} m21           the tenth element of the matrix\n     * @param {float} m22           the eleventh element of the matrix\n     * @param {float} m23           the twelveth element of the matrix\n     * @param {float} m30           the thirteenth element of the matrix\n     * @param {float} m31           the fourtheenth element of the matrix\n     * @param {float} m32           the fivetheenth element of the matrix\n     * @param {float} m33           the sixteenth element of the matrix\n     */\n    apply: function() {\n      var source;\n      if (arguments.length === 1 && arguments[0] instanceof PMatrix3D) {\n        source = arguments[0].array();\n      } else if (arguments.length === 16) {\n        source = Array.prototype.slice.call(arguments);\n      } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n        source = arguments[0];\n      }\n\n      var result = [0, 0, 0, 0,\n                    0, 0, 0, 0,\n                    0, 0, 0, 0,\n                    0, 0, 0, 0];\n      var e = 0;\n      for (var row = 0; row < 4; row++) {\n        for (var col = 0; col < 4; col++, e++) {\n          result[e] += this.elements[row * 4 + 0] * source[col + 0] + this.elements[row * 4 + 1] *\n                       source[col + 4] + this.elements[row * 4 + 2] * source[col + 8] +\n                       this.elements[row * 4 + 3] * source[col + 12];\n        }\n      }\n      this.elements = result.slice();\n    },\n    /**\n     * @member PMatrix3D\n     * The rotate() function rotates the matrix.\n     *\n     * @param {float} angle         the angle of rotation in radiants\n     */\n    rotate: function(angle, v0, v1, v2) {\n      if (!v1) {\n        this.rotateZ(angle);\n      } else {\n        // TODO should make sure this vector is normalized\n        var c = Math.cos(angle);\n        var s = Math.sin(angle);\n        var t = 1.0 - c;\n\n        this.apply((t * v0 * v0) + c,\n                   (t * v0 * v1) - (s * v2),\n                   (t * v0 * v2) + (s * v1),\n                   0,\n                   (t * v0 * v1) + (s * v2),\n                   (t * v1 * v1) + c,\n                   (t * v1 * v2) - (s * v0),\n                   0,\n                   (t * v0 * v2) - (s * v1),\n                   (t * v1 * v2) + (s * v0),\n                   (t * v2 * v2) + c,\n                   0,\n                   0, 0, 0, 1);\n      }\n    },\n    /**\n     * @member PMatrix3D\n     * The invApply() function applies the inverted matrix to this matrix.\n     *\n     * @param {float} m00           the first element of the matrix\n     * @param {float} m01           the second element of the matrix\n     * @param {float} m02           the third element of the matrix\n     * @param {float} m03           the fourth element of the matrix\n     * @param {float} m10           the fifth element of the matrix\n     * @param {float} m11           the sixth element of the matrix\n     * @param {float} m12           the seventh element of the matrix\n     * @param {float} m13           the eight element of the matrix\n     * @param {float} m20           the nineth element of the matrix\n     * @param {float} m21           the tenth element of the matrix\n     * @param {float} m22           the eleventh element of the matrix\n     * @param {float} m23           the twelveth element of the matrix\n     * @param {float} m30           the thirteenth element of the matrix\n     * @param {float} m31           the fourtheenth element of the matrix\n     * @param {float} m32           the fivetheenth element of the matrix\n     * @param {float} m33           the sixteenth element of the matrix\n     *\n     * @return {boolean} returns true if the operation was successful.\n     */\n    invApply: function() {\n      if (inverseCopy === undef) {\n        inverseCopy = new PMatrix3D();\n      }\n      var a = arguments;\n      inverseCopy.set(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8],\n                      a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n\n      if (!inverseCopy.invert()) {\n        return false;\n      }\n      this.preApply(inverseCopy);\n      return true;\n    },\n    /**\n     * @member PMatrix3D\n     * The rotateZ() function rotates the matrix.\n     *\n     * @param {float} angle         the angle of rotation in radiants\n     */\n    rotateX: function(angle) {\n      var c = Math.cos(angle);\n      var s = Math.sin(angle);\n      this.apply([1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]);\n    },\n    /**\n     * @member PMatrix3D\n     * The rotateY() function rotates the matrix.\n     *\n     * @param {float} angle         the angle of rotation in radiants\n     */\n    rotateY: function(angle) {\n      var c = Math.cos(angle);\n      var s = Math.sin(angle);\n      this.apply([c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1]);\n    },\n    /**\n     * @member PMatrix3D\n     * The rotateZ() function rotates the matrix.\n     *\n     * @param {float} angle         the angle of rotation in radiants\n     */\n    rotateZ: function(angle) {\n      var c = Math.cos(angle);\n      var s = Math.sin(angle);\n      this.apply([c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n    },\n    /**\n     * @member PMatrix3D\n     * The scale() function increases or decreases the size of a matrix by expanding and contracting vertices. When only one parameter is specified scale will occur in all dimensions.\n     * This is equivalent to a three parameter call.\n     *\n     * @param {float} sx  the amount to scale on the x-axis\n     * @param {float} sy  the amount to scale on the y-axis\n     * @param {float} sz  the amount to scale on the z-axis\n     */\n    scale: function(sx, sy, sz) {\n      if (sx && sy === undef && sz === undef) {\n        sy = sz = sx;\n      } else if (sx && sy && sz === undef) {\n        sz = 1;\n      }\n\n      if (sx && sy && sz) {\n        this.elements[0]  *= sx;\n        this.elements[1]  *= sy;\n        this.elements[2]  *= sz;\n        this.elements[4]  *= sx;\n        this.elements[5]  *= sy;\n        this.elements[6]  *= sz;\n        this.elements[8]  *= sx;\n        this.elements[9]  *= sy;\n        this.elements[10] *= sz;\n        this.elements[12] *= sx;\n        this.elements[13] *= sy;\n        this.elements[14] *= sz;\n      }\n    },\n    /**\n     * @member PMatrix3D\n     * The skewX() function skews the matrix along the x-axis the amount specified by the angle parameter.\n     * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n     *\n     * @param {float} angle  angle of skew specified in radians\n     */\n    skewX: function(angle) {\n      var t = Math.tan(angle);\n      this.apply(1, t, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    },\n    /**\n     * @member PMatrix3D\n     * The skewY() function skews the matrix along the y-axis the amount specified by the angle parameter.\n     * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n     *\n     * @param {float} angle  angle of skew specified in radians\n     */\n    skewY: function(angle) {\n      var t = Math.tan(angle);\n      this.apply(1, 0, 0, 0, t, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    },\n    /**\n     * @member PMatrix3D\n     * The shearX() function shears the matrix along the x-axis the amount specified by the angle parameter.\n     * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n     *\n     * @param {float} angle  angle of shear specified in radians\n     */\n    shearX: function(angle) {\n      var t = Math.tan(angle);\n      this.apply(1, t, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    },\n    /**\n     * @member PMatrix3D\n     * The shearY() function shears the matrix along the y-axis the amount specified by the angle parameter.\n     * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n     *\n     * @param {float} angle  angle of shear specified in radians\n     */\n    shearY: function(angle) {\n      var t = Math.tan(angle);\n      this.apply(1, 0, 0, 0, t, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    },\n    multX: function(x, y, z, w) {\n      if (!z) {\n        return this.elements[0] * x + this.elements[1] * y + this.elements[3];\n      }\n      if (!w) {\n        return this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];\n      }\n      return this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3] * w;\n    },\n    multY: function(x, y, z, w) {\n      if (!z) {\n        return this.elements[4] * x + this.elements[5] * y + this.elements[7];\n      }\n      if (!w) {\n        return this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];\n      }\n      return this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7] * w;\n    },\n    multZ: function(x, y, z, w) {\n      if (!w) {\n        return this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];\n      }\n      return this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11] * w;\n    },\n    multW: function(x, y, z, w) {\n      if (!w) {\n        return this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15];\n      }\n      return this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15] * w;\n    },\n    /**\n     * @member PMatrix3D\n     * The invert() function inverts this matrix\n     *\n     * @return {boolean} true if successful\n     */\n    invert: function() {\n      var fA0 = this.elements[0] * this.elements[5] - this.elements[1] * this.elements[4];\n      var fA1 = this.elements[0] * this.elements[6] - this.elements[2] * this.elements[4];\n      var fA2 = this.elements[0] * this.elements[7] - this.elements[3] * this.elements[4];\n      var fA3 = this.elements[1] * this.elements[6] - this.elements[2] * this.elements[5];\n      var fA4 = this.elements[1] * this.elements[7] - this.elements[3] * this.elements[5];\n      var fA5 = this.elements[2] * this.elements[7] - this.elements[3] * this.elements[6];\n      var fB0 = this.elements[8] * this.elements[13] - this.elements[9] * this.elements[12];\n      var fB1 = this.elements[8] * this.elements[14] - this.elements[10] * this.elements[12];\n      var fB2 = this.elements[8] * this.elements[15] - this.elements[11] * this.elements[12];\n      var fB3 = this.elements[9] * this.elements[14] - this.elements[10] * this.elements[13];\n      var fB4 = this.elements[9] * this.elements[15] - this.elements[11] * this.elements[13];\n      var fB5 = this.elements[10] * this.elements[15] - this.elements[11] * this.elements[14];\n\n      // Determinant\n      var fDet = fA0 * fB5 - fA1 * fB4 + fA2 * fB3 + fA3 * fB2 - fA4 * fB1 + fA5 * fB0;\n\n      // Account for a very small value\n      // return false if not successful.\n      if (Math.abs(fDet) <= 1e-9) {\n        return false;\n      }\n\n      var kInv = [];\n      kInv[0]  = +this.elements[5] * fB5 - this.elements[6] * fB4 + this.elements[7] * fB3;\n      kInv[4]  = -this.elements[4] * fB5 + this.elements[6] * fB2 - this.elements[7] * fB1;\n      kInv[8]  = +this.elements[4] * fB4 - this.elements[5] * fB2 + this.elements[7] * fB0;\n      kInv[12] = -this.elements[4] * fB3 + this.elements[5] * fB1 - this.elements[6] * fB0;\n      kInv[1]  = -this.elements[1] * fB5 + this.elements[2] * fB4 - this.elements[3] * fB3;\n      kInv[5]  = +this.elements[0] * fB5 - this.elements[2] * fB2 + this.elements[3] * fB1;\n      kInv[9]  = -this.elements[0] * fB4 + this.elements[1] * fB2 - this.elements[3] * fB0;\n      kInv[13] = +this.elements[0] * fB3 - this.elements[1] * fB1 + this.elements[2] * fB0;\n      kInv[2]  = +this.elements[13] * fA5 - this.elements[14] * fA4 + this.elements[15] * fA3;\n      kInv[6]  = -this.elements[12] * fA5 + this.elements[14] * fA2 - this.elements[15] * fA1;\n      kInv[10] = +this.elements[12] * fA4 - this.elements[13] * fA2 + this.elements[15] * fA0;\n      kInv[14] = -this.elements[12] * fA3 + this.elements[13] * fA1 - this.elements[14] * fA0;\n      kInv[3]  = -this.elements[9] * fA5 + this.elements[10] * fA4 - this.elements[11] * fA3;\n      kInv[7]  = +this.elements[8] * fA5 - this.elements[10] * fA2 + this.elements[11] * fA1;\n      kInv[11] = -this.elements[8] * fA4 + this.elements[9] * fA2 - this.elements[11] * fA0;\n      kInv[15] = +this.elements[8] * fA3 - this.elements[9] * fA1 + this.elements[10] * fA0;\n\n      // Inverse using Determinant\n      var fInvDet = 1.0 / fDet;\n      kInv[0]  *= fInvDet;\n      kInv[1]  *= fInvDet;\n      kInv[2]  *= fInvDet;\n      kInv[3]  *= fInvDet;\n      kInv[4]  *= fInvDet;\n      kInv[5]  *= fInvDet;\n      kInv[6]  *= fInvDet;\n      kInv[7]  *= fInvDet;\n      kInv[8]  *= fInvDet;\n      kInv[9]  *= fInvDet;\n      kInv[10] *= fInvDet;\n      kInv[11] *= fInvDet;\n      kInv[12] *= fInvDet;\n      kInv[13] *= fInvDet;\n      kInv[14] *= fInvDet;\n      kInv[15] *= fInvDet;\n\n      this.elements = kInv.slice();\n      return true;\n    },\n    toString: function() {\n      var str = \"\";\n      for (var i = 0; i < 15; i++) {\n        str += this.elements[i] + \", \";\n      }\n      str += this.elements[15];\n      return str;\n    },\n    /**\n     * @member PMatrix3D\n     * The print() function prints out the elements of this matrix\n     */\n    print: function() {\n      var digits = printMatrixHelper(this.elements);\n\n      var output = \"\"   + p.nfs(this.elements[0], digits, 4)  + \" \" + p.nfs(this.elements[1], digits, 4)  +\n                   \" \"  + p.nfs(this.elements[2], digits, 4)  + \" \" + p.nfs(this.elements[3], digits, 4)  +\n                   \"\\n\" + p.nfs(this.elements[4], digits, 4)  + \" \" + p.nfs(this.elements[5], digits, 4)  +\n                   \" \"  + p.nfs(this.elements[6], digits, 4)  + \" \" + p.nfs(this.elements[7], digits, 4)  +\n                   \"\\n\" + p.nfs(this.elements[8], digits, 4)  + \" \" + p.nfs(this.elements[9], digits, 4)  +\n                   \" \"  + p.nfs(this.elements[10], digits, 4) + \" \" + p.nfs(this.elements[11], digits, 4) +\n                   \"\\n\" + p.nfs(this.elements[12], digits, 4) + \" \" + p.nfs(this.elements[13], digits, 4) +\n                   \" \"  + p.nfs(this.elements[14], digits, 4) + \" \" + p.nfs(this.elements[15], digits, 4) + \"\\n\\n\";\n      p.println(output);\n    },\n    invTranslate: function(tx, ty, tz) {\n      this.preApply(1, 0, 0, -tx, 0, 1, 0, -ty, 0, 0, 1, -tz, 0, 0, 0, 1);\n    },\n    invRotateX: function(angle) {\n      var c = Math.cos(-angle);\n      var s = Math.sin(-angle);\n      this.preApply([1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]);\n    },\n    invRotateY: function(angle) {\n      var c = Math.cos(-angle);\n      var s = Math.sin(-angle);\n      this.preApply([c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1]);\n    },\n    invRotateZ: function(angle) {\n      var c = Math.cos(-angle);\n      var s = Math.sin(-angle);\n      this.preApply([c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n    },\n    invScale: function(x, y, z) {\n      this.preApply([1 / x, 0, 0, 0, 0, 1 / y, 0, 0, 0, 0, 1 / z, 0, 0, 0, 0, 1]);\n    }\n  };\n\n  return PMatrix3D;\n};\n},{}],16:[function(require,module,exports){\nmodule.exports = function(options) {\n  var PConstants = options.PConstants,\n      PMatrix2D = options.PMatrix2D,\n      PMatrix3D = options.PMatrix3D;\n\n  /**\n   * Datatype for storing shapes. Processing can currently load and display SVG (Scalable Vector Graphics) shapes.\n   * Before a shape is used, it must be loaded with the <b>loadShape()</b> function. The <b>shape()</b> function is used to draw the shape to the display window.\n   * The <b>PShape</b> object contain a group of methods, linked below, that can operate on the shape data.\n   * <br><br>The <b>loadShape()</b> method supports SVG files created with Inkscape and Adobe Illustrator.\n   * It is not a full SVG implementation, but offers some straightforward support for handling vector data.\n   *\n   * @param {int} family the shape type, one of GROUP, PRIMITIVE, PATH, or GEOMETRY\n   *\n   * @see #shape()\n   * @see #loadShape()\n   * @see #shapeMode()\n   */\n  var PShape = function(family) {\n    this.family    = family || PConstants.GROUP;\n    this.visible   = true;\n    this.style     = true;\n    this.children  = [];\n    this.nameTable = [];\n    this.params    = [];\n    this.name      = \"\";\n    this.image     = null;  //type PImage\n    this.matrix    = null;\n    this.kind      = null;\n    this.close     = null;\n    this.width     = null;\n    this.height    = null;\n    this.parent    = null;\n  };\n  /**\n    * PShape methods\n    * missing: findChild(), apply(), contains(), findChild(), getPrimitive(), getParams(), getVertex() , getVertexCount(),\n    * getVertexCode() , getVertexCodes() , getVertexCodeCount(), getVertexX(), getVertexY(), getVertexZ()\n    */\n  PShape.prototype = {\n    /**\n     * @member PShape\n     * The isVisible() function returns a boolean value \"true\" if the image is set to be visible, \"false\" if not. This is modified with the <b>setVisible()</b> parameter.\n     * <br><br>The visibility of a shape is usually controlled by whatever program created the SVG file.\n     * For instance, this parameter is controlled by showing or hiding the shape in the layers palette in Adobe Illustrator.\n     *\n     * @return {boolean}  returns \"true\" if the image is set to be visible, \"false\" if not\n     */\n    isVisible: function(){\n      return this.visible;\n    },\n    /**\n     * @member PShape\n     * The setVisible() function sets the shape to be visible or invisible. This is determined by the value of the <b>visible</b> parameter.\n     * <br><br>The visibility of a shape is usually controlled by whatever program created the SVG file.\n     * For instance, this parameter is controlled by showing or hiding the shape in the layers palette in Adobe Illustrator.\n     *\n     * @param {boolean} visible \"false\" makes the shape invisible and \"true\" makes it visible\n     */\n    setVisible: function (visible){\n      this.visible = visible;\n    },\n    /**\n     * @member PShape\n     * The disableStyle() function disables the shape's style data and uses Processing's current styles. Styles include attributes such as colors, stroke weight, and stroke joints.\n     * Overrides this shape's style information and uses PGraphics styles and colors. Identical to ignoreStyles(true). Also disables styles for all child shapes.\n     */\n    disableStyle: function(){\n      this.style = false;\n      for(var i = 0, j=this.children.length; i<j; i++) {\n        this.children[i].disableStyle();\n      }\n    },\n    /**\n     * @member PShape\n     * The enableStyle() function enables the shape's style data and ignores Processing's current styles. Styles include attributes such as colors, stroke weight, and stroke joints.\n     */\n    enableStyle: function(){\n      this.style = true;\n      for(var i = 0, j=this.children.length; i<j; i++) {\n        this.children[i].enableStyle();\n      }\n    },\n    /**\n     * @member PShape\n     * The getFamily function returns the shape type\n     *\n     * @return {int} the shape type, one of GROUP, PRIMITIVE, PATH, or GEOMETRY\n     */\n    getFamily: function(){\n      return this.family;\n    },\n    /**\n     * @member PShape\n     * The getWidth() function gets the width of the drawing area (not necessarily the shape boundary).\n     */\n    getWidth: function(){\n      return this.width;\n    },\n    /**\n     * @member PShape\n     * The getHeight() function gets the height of the drawing area (not necessarily the shape boundary).\n     */\n    getHeight: function(){\n      return this.height;\n    },\n    /**\n     * @member PShape\n     * The setName() function sets the name of the shape\n     *\n     * @param {String} name the name of the shape\n     */\n    setName: function(name){\n      this.name = name;\n    },\n    /**\n     * @member PShape\n     * The getName() function returns the name of the shape\n     *\n     * @return {String} the name of the shape\n     */\n    getName: function(){\n      return this.name;\n    },\n    /**\n     * @member PShape\n     * Called by the following (the shape() command adds the g)\n     * PShape s = loadShapes(\"blah.svg\");\n     * shape(s);\n     */\n    draw: function(renderContext) {\n      if(!renderContext) {\n        throw \"render context missing for draw() in PShape\";\n      }\n      if (this.visible) {\n        this.pre(renderContext);\n        this.drawImpl(renderContext);\n        this.post(renderContext);\n      }\n    },\n    /**\n     * @member PShape\n     * the drawImpl() function draws the SVG document.\n     */\n    drawImpl: function(renderContext) {\n      if (this.family === PConstants.GROUP) {\n        this.drawGroup(renderContext);\n      } else if (this.family === PConstants.PRIMITIVE) {\n        this.drawPrimitive(renderContext);\n      } else if (this.family === PConstants.GEOMETRY) {\n        this.drawGeometry(renderContext);\n      } else if (this.family === PConstants.PATH) {\n        this.drawPath(renderContext);\n      }\n    },\n    /**\n     * @member PShape\n     * The drawPath() function draws the <path> part of the SVG document.\n     */\n    drawPath: function(renderContext) {\n      var i, j;\n      if (this.vertices.length === 0) { return; }\n      renderContext.beginShape();\n      if (this.vertexCodes.length === 0) {  // each point is a simple vertex\n        if (this.vertices[0].length === 2) {  // drawing 2D vertices\n          for (i = 0, j = this.vertices.length; i < j; i++) {\n            renderContext.vertex(this.vertices[i][0], this.vertices[i][1]);\n          }\n        } else {  // drawing 3D vertices\n          for (i = 0, j = this.vertices.length; i < j; i++) {\n            renderContext.vertex(this.vertices[i][0],\n                                 this.vertices[i][1],\n                                 this.vertices[i][2]);\n          }\n        }\n      } else {  // coded set of vertices\n        var index = 0;\n        if (this.vertices[0].length === 2) {  // drawing a 2D path\n          for (i = 0, j = this.vertexCodes.length; i < j; i++) {\n            if (this.vertexCodes[i] === PConstants.VERTEX) {\n              renderContext.vertex(this.vertices[index][0], this.vertices[index][1], this.vertices[index].moveTo);\n              renderContext.breakShape = false;\n              index++;\n            } else if (this.vertexCodes[i] === PConstants.BEZIER_VERTEX) {\n              renderContext.bezierVertex(this.vertices[index+0][0],\n                                         this.vertices[index+0][1],\n                                         this.vertices[index+1][0],\n                                         this.vertices[index+1][1],\n                                         this.vertices[index+2][0],\n                                         this.vertices[index+2][1]);\n              index += 3;\n            } else if (this.vertexCodes[i] === PConstants.CURVE_VERTEX) {\n              renderContext.curveVertex(this.vertices[index][0],\n                                        this.vertices[index][1]);\n              index++;\n            } else if (this.vertexCodes[i] ===  PConstants.BREAK) {\n              renderContext.breakShape = true;\n            }\n          }\n        } else {  // drawing a 3D path\n          for (i = 0, j = this.vertexCodes.length; i < j; i++) {\n            if (this.vertexCodes[i] === PConstants.VERTEX) {\n              renderContext.vertex(this.vertices[index][0],\n                                   this.vertices[index][1],\n                                   this.vertices[index][2]);\n              if (this.vertices[index].moveTo === true) {\n                vertArray[vertArray.length-1].moveTo = true;\n              } else if (this.vertices[index].moveTo === false) {\n                vertArray[vertArray.length-1].moveTo = false;\n              }\n              renderContext.breakShape = false;\n            } else if (this.vertexCodes[i] ===  PConstants.BEZIER_VERTEX) {\n              renderContext.bezierVertex(this.vertices[index+0][0],\n                                         this.vertices[index+0][1],\n                                         this.vertices[index+0][2],\n                                         this.vertices[index+1][0],\n                                         this.vertices[index+1][1],\n                                         this.vertices[index+1][2],\n                                         this.vertices[index+2][0],\n                                         this.vertices[index+2][1],\n                                         this.vertices[index+2][2]);\n              index += 3;\n            } else if (this.vertexCodes[i] === PConstants.CURVE_VERTEX) {\n              renderContext.curveVertex(this.vertices[index][0],\n                                        this.vertices[index][1],\n                                        this.vertices[index][2]);\n              index++;\n            } else if (this.vertexCodes[i] === PConstants.BREAK) {\n              renderContext.breakShape = true;\n            }\n          }\n        }\n      }\n      renderContext.endShape(this.close ? PConstants.CLOSE : PConstants.OPEN);\n    },\n    /**\n     * @member PShape\n     * The drawGeometry() function draws the geometry part of the SVG document.\n     */\n    drawGeometry: function(renderContext) {\n      var i, j;\n      renderContext.beginShape(this.kind);\n      if (this.style) {\n        for (i = 0, j = this.vertices.length; i < j; i++) {\n          renderContext.vertex(this.vertices[i]);\n        }\n      } else {\n        for (i = 0, j = this.vertices.length; i < j; i++) {\n          var vert = this.vertices[i];\n          if (vert[2] === 0) {\n            renderContext.vertex(vert[0], vert[1]);\n          } else {\n            renderContext.vertex(vert[0], vert[1], vert[2]);\n          }\n        }\n      }\n      renderContext.endShape();\n    },\n    /**\n     * @member PShape\n     * The drawGroup() function draws the <g> part of the SVG document.\n     */\n    drawGroup: function(renderContext) {\n      for (var i = 0, j = this.children.length; i < j; i++) {\n        this.children[i].draw(renderContext);\n      }\n    },\n    /**\n     * @member PShape\n     * The drawPrimitive() function draws SVG document shape elements. These can be point, line, triangle, quad, rect, ellipse, arc, box, or sphere.\n     */\n    drawPrimitive: function(renderContext) {\n      if (this.kind === PConstants.POINT) {\n        renderContext.point(this.params[0], this.params[1]);\n      } else if (this.kind === PConstants.LINE) {\n        if (this.params.length === 4) {  // 2D\n          renderContext.line(this.params[0], this.params[1],\n                            this.params[2], this.params[3]);\n        } else {  // 3D\n          renderContext.line(this.params[0], this.params[1], this.params[2],\n                             this.params[3], this.params[4], this.params[5]);\n        }\n      } else if (this.kind === PConstants.TRIANGLE) {\n        renderContext.triangle(this.params[0], this.params[1],\n                               this.params[2], this.params[3],\n                               this.params[4], this.params[5]);\n      } else if (this.kind === PConstants.QUAD) {\n        renderContext.quad(this.params[0], this.params[1],\n                           this.params[2], this.params[3],\n                           this.params[4], this.params[5],\n                           this.params[6], this.params[7]);\n      } else if (this.kind === PConstants.RECT) {\n        if (this.image !== null) {\n          var imMode = imageModeConvert;\n          renderContext.imageMode(PConstants.CORNER);\n          renderContext.image(this.image,\n                              this.params[0],\n                              this.params[1],\n                              this.params[2],\n                              this.params[3]);\n          imageModeConvert = imMode;\n        } else {\n          var rcMode = renderContext.curRectMode;\n          renderContext.rectMode(PConstants.CORNER);\n          renderContext.rect(this.params[0],\n                             this.params[1],\n                             this.params[2],\n                             this.params[3]);\n          renderContext.curRectMode = rcMode;\n        }\n      } else if (this.kind === PConstants.ELLIPSE) {\n        var elMode = renderContext.curEllipseMode;\n        renderContext.ellipseMode(PConstants.CORNER);\n        renderContext.ellipse(this.params[0],\n                              this.params[1],\n                              this.params[2],\n                              this.params[3]);\n        renderContext.curEllipseMode = elMode;\n      } else if (this.kind === PConstants.ARC) {\n        var eMode = curEllipseMode;\n        renderContext.ellipseMode(PConstants.CORNER);\n        renderContext.arc(this.params[0],\n                          this.params[1],\n                          this.params[2],\n                          this.params[3],\n                          this.params[4],\n                          this.params[5]);\n        curEllipseMode = eMode;\n      } else if (this.kind === PConstants.BOX) {\n        if (this.params.length === 1) {\n          renderContext.box(this.params[0]);\n        } else {\n          renderContext.box(this.params[0], this.params[1], this.params[2]);\n        }\n      } else if (this.kind === PConstants.SPHERE) {\n        renderContext.sphere(this.params[0]);\n      }\n    },\n    /**\n     * @member PShape\n     * The pre() function performs the preparations before the SVG is drawn. This includes doing transformations and storing previous styles.\n     */\n    pre: function(renderContext) {\n      if (this.matrix) {\n        renderContext.pushMatrix();\n        renderContext.transform(this.matrix);\n      }\n      if (this.style) {\n        renderContext.pushStyle();\n        this.styles(renderContext);\n      }\n    },\n    /**\n     * @member PShape\n     * The post() function performs the necessary actions after the SVG is drawn. This includes removing transformations and removing added styles.\n     */\n    post: function(renderContext) {\n      if (this.matrix) {\n        renderContext.popMatrix();\n      }\n      if (this.style) {\n        renderContext.popStyle();\n      }\n    },\n    /**\n     * @member PShape\n     * The styles() function changes the Processing's current styles\n     */\n    styles: function(renderContext) {\n      if (this.stroke) {\n        renderContext.stroke(this.strokeColor);\n        renderContext.strokeWeight(this.strokeWeight);\n        renderContext.strokeCap(this.strokeCap);\n        renderContext.strokeJoin(this.strokeJoin);\n      } else {\n        renderContext.noStroke();\n      }\n\n      if (this.fill) {\n        renderContext.fill(this.fillColor);\n\n      } else {\n        renderContext.noFill();\n      }\n    },\n    /**\n     * @member PShape\n     * The getChild() function extracts a child shape from a parent shape. Specify the name of the shape with the <b>target</b> parameter or the\n     * layer position of the shape to get with the <b>index</b> parameter.\n     * The shape is returned as a <b>PShape</b> object, or <b>null</b> is returned if there is an error.\n     *\n     * @param {String} target   the name of the shape to get\n     * @param {int} index   the layer position of the shape to get\n     *\n     * @return {PShape} returns a child element of a shape as a PShape object or null if there is an error\n     */\n    getChild: function(child) {\n      var i, j;\n      if (typeof child === 'number') {\n        return this.children[child];\n      }\n      var found;\n      if(child === \"\" || this.name === child){\n        return this;\n      }\n      if(this.nameTable.length > 0) {\n        for(i = 0, j = this.nameTable.length; i < j || found; i++) {\n          if(this.nameTable[i].getName === child) {\n            found = this.nameTable[i];\n            break;\n          }\n        }\n        if (found) { return found; }\n      }\n      for(i = 0, j = this.children.length; i < j; i++) {\n        found = this.children[i].getChild(child);\n        if(found) { return found; }\n      }\n      return null;\n    },\n    /**\n     * @member PShape\n     * The getChildCount() returns the number of children\n     *\n     * @return {int} returns a count of children\n     */\n    getChildCount: function () {\n      return this.children.length;\n    },\n    /**\n     * @member PShape\n     * The addChild() adds a child to the PShape.\n     *\n     * @param {PShape} child the child to add\n     */\n    addChild: function( child ) {\n      this.children.push(child);\n      child.parent = this;\n      if (child.getName() !== null) {\n        this.addName(child.getName(), child);\n      }\n    },\n    /**\n     * @member PShape\n     * The addName() functions adds a shape to the name lookup table.\n     *\n     * @param {String} name   the name to be added\n     * @param {PShape} shape  the shape\n     */\n    addName: function(name,  shape) {\n      if (this.parent !== null) {\n        this.parent.addName( name, shape );\n      } else {\n        this.nameTable.push( [name, shape] );\n      }\n    },\n    /**\n     * @member PShape\n     * The translate() function specifies an amount to displace the shape. The <b>x</b> parameter specifies left/right translation, the <b>y</b> parameter specifies up/down translation, and the <b>z</b> parameter specifies translations toward/away from the screen.\n     * Subsequent calls to the method accumulates the effect. For example, calling <b>translate(50, 0)</b> and then <b>translate(20, 0)</b> is the same as <b>translate(70, 0)</b>.\n     * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.\n     * <br><br>Using this method with the <b>z</b> parameter requires using the P3D or OPENGL parameter in combination with size.\n     *\n     * @param {int|float} x left/right translation\n     * @param {int|float} y up/down translation\n     * @param {int|float} z forward/back translation\n     *\n     * @see PMatrix2D#translate\n     * @see PMatrix3D#translate\n     */\n    translate: function() {\n      if(arguments.length === 2)\n      {\n        this.checkMatrix(2);\n        this.matrix.translate(arguments[0], arguments[1]);\n      } else {\n        this.checkMatrix(3);\n        this.matrix.translate(arguments[0], arguments[1], 0);\n      }\n    },\n    /**\n     * @member PShape\n     * The checkMatrix() function makes sure that the shape's matrix is 1) not null, and 2) has a matrix\n     * that can handle <em>at least</em> the specified number of dimensions.\n     *\n     * @param {int} dimensions the specified number of dimensions\n     */\n    checkMatrix: function(dimensions) {\n      if(this.matrix === null) {\n        if(dimensions === 2) {\n          this.matrix = new PMatrix2D();\n        } else {\n          this.matrix = new PMatrix3D();\n        }\n      }else if(dimensions === 3 && this.matrix instanceof PMatrix2D) {\n        this.matrix = new PMatrix3D();\n      }\n    },\n    /**\n     * @member PShape\n     * The rotateX() function rotates a shape around the x-axis the amount specified by the <b>angle</b> parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the <b>radians()</b> method.\n     * <br><br>Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction.\n     * Subsequent calls to the method accumulates the effect. For example, calling <b>rotateX(HALF_PI)</b> and then <b>rotateX(HALF_PI)</b> is the same as <b>rotateX(PI)</b>.\n     * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.\n     * <br><br>This method requires a 3D renderer. You need to pass P3D or OPENGL as a third parameter into the <b>size()</b> method as shown in the example above.\n     *\n     * @param {float}angle angle of rotation specified in radians\n     *\n     * @see PMatrix3D#rotateX\n     */\n    rotateX: function(angle) {\n      this.rotate(angle, 1, 0, 0);\n    },\n    /**\n     * @member PShape\n     * The rotateY() function rotates a shape around the y-axis the amount specified by the <b>angle</b> parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the <b>radians()</b> method.\n     * <br><br>Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction.\n     * Subsequent calls to the method accumulates the effect. For example, calling <b>rotateY(HALF_PI)</b> and then <b>rotateY(HALF_PI)</b> is the same as <b>rotateY(PI)</b>.\n     * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.\n     * <br><br>This method requires a 3D renderer. You need to pass P3D or OPENGL as a third parameter into the <b>size()</b> method as shown in the example above.\n     *\n     * @param {float}angle angle of rotation specified in radians\n     *\n     * @see PMatrix3D#rotateY\n     */\n    rotateY: function(angle) {\n      this.rotate(angle, 0, 1, 0);\n    },\n    /**\n     * @member PShape\n     * The rotateZ() function rotates a shape around the z-axis the amount specified by the <b>angle</b> parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the <b>radians()</b> method.\n     * <br><br>Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction.\n     * Subsequent calls to the method accumulates the effect. For example, calling <b>rotateZ(HALF_PI)</b> and then <b>rotateZ(HALF_PI)</b> is the same as <b>rotateZ(PI)</b>.\n     * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.\n     * <br><br>This method requires a 3D renderer. You need to pass P3D or OPENGL as a third parameter into the <b>size()</b> method as shown in the example above.\n     *\n     * @param {float}angle angle of rotation specified in radians\n     *\n     * @see PMatrix3D#rotateZ\n     */\n    rotateZ: function(angle) {\n      this.rotate(angle, 0, 0, 1);\n    },\n    /**\n     * @member PShape\n     * The rotate() function rotates a shape the amount specified by the <b>angle</b> parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the <b>radians()</b> method.\n     * <br><br>Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction.\n     * Transformations apply to everything that happens after and subsequent calls to the method accumulates the effect.\n     * For example, calling <b>rotate(HALF_PI)</b> and then <b>rotate(HALF_PI)</b> is the same as <b>rotate(PI)</b>.\n     * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.\n     * If optional parameters x,y,z are supplied, the rotate is about the point (x, y, z).\n     *\n     * @param {float}angle  angle of rotation specified in radians\n     * @param {float}x      x-coordinate of the point\n     * @param {float}y      y-coordinate of the point\n     * @param {float}z      z-coordinate of the point\n     * @see PMatrix2D#rotate\n     * @see PMatrix3D#rotate\n     */\n    rotate: function() {\n      if(arguments.length === 1){\n        this.checkMatrix(2);\n        this.matrix.rotate(arguments[0]);\n      } else {\n        this.checkMatrix(3);\n        this.matrix.rotate(arguments[0],\n                           arguments[1],\n                           arguments[2],\n                           arguments[3]);\n      }\n    },\n    /**\n     * @member PShape\n     * The scale() function increases or decreases the size of a shape by expanding and contracting vertices. Shapes always scale from the relative origin of their bounding box.\n     * Scale values are specified as decimal percentages. For example, the method call <b>scale(2.0)</b> increases the dimension of a shape by 200%.\n     * Subsequent calls to the method multiply the effect. For example, calling <b>scale(2.0)</b> and then <b>scale(1.5)</b> is the same as <b>scale(3.0)</b>.\n     * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.\n     * <br><br>Using this fuction with the <b>z</b> parameter requires passing P3D or OPENGL into the size() parameter.\n     *\n     * @param {float}s      percentage to scale the object\n     * @param {float}x      percentage to scale the object in the x-axis\n     * @param {float}y      percentage to scale the object in the y-axis\n     * @param {float}z      percentage to scale the object in the z-axis\n     *\n     * @see PMatrix2D#scale\n     * @see PMatrix3D#scale\n     */\n    scale: function() {\n      if(arguments.length === 2) {\n        this.checkMatrix(2);\n        this.matrix.scale(arguments[0], arguments[1]);\n      } else if (arguments.length === 3) {\n        this.checkMatrix(2);\n        this.matrix.scale(arguments[0], arguments[1], arguments[2]);\n      } else {\n        this.checkMatrix(2);\n        this.matrix.scale(arguments[0]);\n      }\n    },\n    /**\n     * @member PShape\n     * The resetMatrix() function resets the matrix\n     *\n     * @see PMatrix2D#reset\n     * @see PMatrix3D#reset\n     */\n    resetMatrix: function() {\n      this.checkMatrix(2);\n      this.matrix.reset();\n    },\n    /**\n     * @member PShape\n     * The applyMatrix() function multiplies this matrix by another matrix of type PMatrix3D or PMatrix2D.\n     * Individual elements can also be provided\n     *\n     * @param {PMatrix3D|PMatrix2D} matrix   the matrix to multiply by\n     *\n     * @see PMatrix2D#apply\n     * @see PMatrix3D#apply\n     */\n    applyMatrix: function(matrix) {\n      if (arguments.length === 1) {\n        this.applyMatrix(matrix.elements[0],\n                         matrix.elements[1], 0,\n                         matrix.elements[2],\n                         matrix.elements[3],\n                         matrix.elements[4], 0,\n                         matrix.elements[5],\n                         0, 0, 1, 0,\n                         0, 0, 0, 1);\n      } else if (arguments.length === 6) {\n        this.checkMatrix(2);\n        this.matrix.apply(arguments[0], arguments[1], arguments[2], 0,\n                          arguments[3], arguments[4], arguments[5], 0,\n                          0,   0,   1,   0,\n                          0,   0,   0,   1);\n\n      } else if (arguments.length === 16) {\n        this.checkMatrix(3);\n        this.matrix.apply(arguments[0],\n                          arguments[1],\n                          arguments[2],\n                          arguments[3],\n                          arguments[4],\n                          arguments[5],\n                          arguments[6],\n                          arguments[7],\n                          arguments[8],\n                          arguments[9],\n                          arguments[10],\n                          arguments[11],\n                          arguments[12],\n                          arguments[13],\n                          arguments[14],\n                          arguments[15]);\n      }\n    }\n  };\n\n  return PShape;\n};\n},{}],17:[function(require,module,exports){\n/**\n * SVG stands for Scalable Vector Graphics, a portable graphics format. It is\n * a vector format so it allows for infinite resolution and relatively small\n * file sizes. Most modern media software can view SVG files, including Adobe\n * products, Firefox, etc. Illustrator and Inkscape can edit SVG files.\n *\n * @param {PApplet} parent     typically use \"this\"\n * @param {String} filename    name of the SVG file to load\n * @param {XMLElement} xml     an XMLElement element\n * @param {PShapeSVG} parent   the parent PShapeSVG\n *\n * @see PShape\n */\nmodule.exports = function(options) {\n  var CommonFunctions = options.CommonFunctions,\n      PConstants = options.PConstants,\n      PShape = options.PShape,\n      XMLElement = options.XMLElement,\n      colors = options.colors;\n\n  var PShapeSVG = function() {\n    PShape.call(this);                // PShape is the base class.\n    if (arguments.length === 1) {     // xml element coming in\n      this.element  = arguments[0];\n\n      // set values to their defaults according to the SVG spec\n      this.vertexCodes         = [];\n      this.vertices            = [];\n      this.opacity             = 1;\n\n      this.stroke              = false;\n      this.strokeColor         = PConstants.ALPHA_MASK;\n      this.strokeWeight        = 1;\n      this.strokeCap           = PConstants.SQUARE;  // BUTT in svg spec\n      this.strokeJoin          = PConstants.MITER;\n      this.strokeGradient      = null;\n      this.strokeGradientPaint = null;\n      this.strokeName          = null;\n      this.strokeOpacity       = 1;\n\n      this.fill                = true;\n      this.fillColor           = PConstants.ALPHA_MASK;\n      this.fillGradient        = null;\n      this.fillGradientPaint   = null;\n      this.fillName            = null;\n      this.fillOpacity         = 1;\n\n      if (this.element.getName() !== \"svg\") {\n        throw(\"root is not <svg>, it's <\" + this.element.getName() + \">\");\n      }\n    }\n    else if (arguments.length === 2) {\n      if (typeof arguments[1] === 'string') {\n        if (arguments[1].indexOf(\".svg\") > -1) { //its a filename\n          this.element = new XMLElement(true, arguments[1]);\n          // set values to their defaults according to the SVG spec\n          this.vertexCodes         = [];\n          this.vertices            = [];\n          this.opacity             = 1;\n\n          this.stroke              = false;\n          this.strokeColor         = PConstants.ALPHA_MASK;\n          this.strokeWeight        = 1;\n          this.strokeCap           = PConstants.SQUARE;  // BUTT in svg spec\n          this.strokeJoin          = PConstants.MITER;\n          this.strokeGradient      = \"\";\n          this.strokeGradientPaint = \"\";\n          this.strokeName          = \"\";\n          this.strokeOpacity       = 1;\n\n          this.fill                = true;\n          this.fillColor           = PConstants.ALPHA_MASK;\n          this.fillGradient        = null;\n          this.fillGradientPaint   = null;\n          this.fillOpacity         = 1;\n\n        }\n      } else { // XMLElement\n        if (arguments[0]) { // PShapeSVG\n          this.element             = arguments[1];\n          this.vertexCodes         = arguments[0].vertexCodes.slice();\n          this.vertices            = arguments[0].vertices.slice();\n\n          this.stroke              = arguments[0].stroke;\n          this.strokeColor         = arguments[0].strokeColor;\n          this.strokeWeight        = arguments[0].strokeWeight;\n          this.strokeCap           = arguments[0].strokeCap;\n          this.strokeJoin          = arguments[0].strokeJoin;\n          this.strokeGradient      = arguments[0].strokeGradient;\n          this.strokeGradientPaint = arguments[0].strokeGradientPaint;\n          this.strokeName          = arguments[0].strokeName;\n\n          this.fill                = arguments[0].fill;\n          this.fillColor           = arguments[0].fillColor;\n          this.fillGradient        = arguments[0].fillGradient;\n          this.fillGradientPaint   = arguments[0].fillGradientPaint;\n          this.fillName            = arguments[0].fillName;\n          this.strokeOpacity       = arguments[0].strokeOpacity;\n          this.fillOpacity         = arguments[0].fillOpacity;\n          this.opacity             = arguments[0].opacity;\n        }\n      }\n    }\n\n    this.name      = this.element.getStringAttribute(\"id\");\n    var displayStr = this.element.getStringAttribute(\"display\", \"inline\");\n    this.visible   = displayStr !== \"none\";\n    var str = this.element.getAttribute(\"transform\");\n    if (str) {\n      this.matrix = this.parseMatrix(str);\n    }\n    // not proper parsing of the viewBox, but will cover us for cases where\n    // the width and height of the object is not specified\n    var viewBoxStr = this.element.getStringAttribute(\"viewBox\");\n    if ( viewBoxStr !== null ) {\n      var viewBox = viewBoxStr.split(\" \");\n      this.width  = viewBox[2];\n      this.height = viewBox[3];\n    }\n\n    // TODO if viewbox is not same as width/height, then use it to scale\n    // the original objects. for now, viewbox only used when width/height\n    // are empty values (which by the spec means w/h of \"100%\"\n    var unitWidth  = this.element.getStringAttribute(\"width\");\n    var unitHeight = this.element.getStringAttribute(\"height\");\n    if (unitWidth !== null) {\n      this.width  = this.parseUnitSize(unitWidth);\n      this.height = this.parseUnitSize(unitHeight);\n    } else {\n      if ((this.width === 0) || (this.height === 0)) {\n        // For the spec, the default is 100% and 100%. For purposes\n        // here, insert a dummy value because this is prolly just a\n        // font or something for which the w/h doesn't matter.\n        this.width  = 1;\n        this.height = 1;\n\n        //show warning\n        throw(\"The width and/or height is not \" +\n              \"readable in the <svg> tag of this file.\");\n      }\n    }\n    this.parseColors(this.element);\n    this.parseChildren(this.element);\n\n  };\n  /**\n   * PShapeSVG methods are inherited from the PShape prototype\n   */\n  PShapeSVG.prototype = new PShape();\n  /**\n   * @member PShapeSVG\n   * The parseMatrix() function parses the specified SVG matrix into a PMatrix2D. Note that PMatrix2D\n   * is rotated relative to the SVG definition, so parameters are rearranged\n   * here. More about the transformation matrices in\n   * <a href=\"http://www.w3.org/TR/SVG/coords.html#TransformAttribute\">this section</a>\n   * of the SVG documentation.\n   *\n   * @param {String} str text of the matrix param.\n   *\n   * @return {PMatrix2D} a PMatrix2D\n   */\n  PShapeSVG.prototype.parseMatrix = (function() {\n    function getCoords(s) {\n      var m = [];\n      s.replace(/\\((.*?)\\)/, (function() {\n        return function(all, params) {\n          // get the coordinates that can be separated by spaces or a comma\n          m = params.replace(/,+/g, \" \").split(/\\s+/);\n        };\n      }()));\n      return m;\n    }\n\n    return function(str) {\n      this.checkMatrix(2);\n      var pieces = [];\n      str.replace(/\\s*(\\w+)\\((.*?)\\)/g, function(all) {\n        // get a list of transform definitions\n        pieces.push(CommonFunctions.trim(all));\n      });\n      if (pieces.length === 0) {\n        return null;\n      }\n\n      for (var i = 0, j = pieces.length; i < j; i++) {\n        var m = getCoords(pieces[i]);\n\n        if (pieces[i].indexOf(\"matrix\") !== -1) {\n          this.matrix.set(m[0], m[2], m[4], m[1], m[3], m[5]);\n        } else if (pieces[i].indexOf(\"translate\") !== -1) {\n          var tx = m[0];\n          var ty = (m.length === 2) ? m[1] : 0;\n          this.matrix.translate(tx,ty);\n        } else if (pieces[i].indexOf(\"scale\") !== -1) {\n          var sx = m[0];\n          var sy = (m.length === 2) ? m[1] : m[0];\n          this.matrix.scale(sx,sy);\n        } else if (pieces[i].indexOf(\"rotate\") !== -1) {\n          var angle = m[0];\n          if (m.length === 1) {\n            this.matrix.rotate(CommonFunctions.radians(angle));\n          } else if (m.length === 3) {\n            this.matrix.translate(m[1], m[2]);\n            this.matrix.rotate(CommonFunctions.radians(m[0]));\n            this.matrix.translate(-m[1], -m[2]);\n          }\n        } else if (pieces[i].indexOf(\"skewX\") !== -1) {\n          this.matrix.skewX(parseFloat(m[0]));\n        } else if (pieces[i].indexOf(\"skewY\") !== -1) {\n          this.matrix.skewY(m[0]);\n        } else if (pieces[i].indexOf(\"shearX\") !== -1) {\n          this.matrix.shearX(m[0]);\n        } else if (pieces[i].indexOf(\"shearY\") !== -1) {\n          this.matrix.shearY(m[0]);\n        }\n      }\n      return this.matrix;\n    };\n  }());\n\n  /**\n   * @member PShapeSVG\n   * The parseChildren() function parses the specified XMLElement\n   *\n   * @param {XMLElement}element the XMLElement to parse\n   */\n  PShapeSVG.prototype.parseChildren = function(element) {\n    var newelement = element.getChildren();\n    var base = new PShape();\n    var i, j;\n    for (i = 0, j = newelement.length; i < j; i++) {\n      var kid = this.parseChild(newelement[i]);\n      if (kid) {\n        base.addChild(kid);\n      }\n    }\n    for (i = 0, j = base.children.length; i < j; i++) {\n      this.children.push(base.children[i]);\n    }\n  };\n  /**\n   * @member PShapeSVG\n   * The getName() function returns the name\n   *\n   * @return {String} the name\n   */\n  PShapeSVG.prototype.getName = function() {\n    return this.name;\n  };\n  /**\n   * @member PShapeSVG\n   * The parseChild() function parses a child XML element.\n   *\n   * @param {XMLElement} elem the element to parse\n   *\n   * @return {PShape} the newly created PShape\n   */\n  PShapeSVG.prototype.parseChild = function( elem ) {\n    var name = elem.getName();\n    var shape;\n    if (name === \"g\") {\n      shape = new PShapeSVG(this, elem);\n    } else if (name === \"defs\") {\n      // generally this will contain gradient info, so may\n      // as well just throw it into a group element for parsing\n      shape = new PShapeSVG(this, elem);\n    } else if (name === \"line\") {\n      shape = new PShapeSVG(this, elem);\n      shape.parseLine();\n    } else if (name === \"circle\") {\n      shape = new PShapeSVG(this, elem);\n      shape.parseEllipse(true);\n    } else if (name === \"ellipse\") {\n      shape = new PShapeSVG(this, elem);\n      shape.parseEllipse(false);\n    } else if (name === \"rect\") {\n      shape = new PShapeSVG(this, elem);\n      shape.parseRect();\n    } else if (name === \"polygon\") {\n      shape = new PShapeSVG(this, elem);\n      shape.parsePoly(true);\n    } else if (name === \"polyline\") {\n      shape = new PShapeSVG(this, elem);\n      shape.parsePoly(false);\n    } else if (name === \"path\") {\n      shape = new PShapeSVG(this, elem);\n      shape.parsePath();\n    } else if (name === \"radialGradient\") {\n      //return new RadialGradient(this, elem);\n      unimplemented('PShapeSVG.prototype.parseChild, name = radialGradient');\n    } else if (name === \"linearGradient\") {\n      //return new LinearGradient(this, elem);\n      unimplemented('PShapeSVG.prototype.parseChild, name = linearGradient');\n    } else if (name === \"text\") {\n      unimplemented('PShapeSVG.prototype.parseChild, name = text');\n    } else if (name === \"filter\") {\n      unimplemented('PShapeSVG.prototype.parseChild, name = filter');\n    } else if (name === \"mask\") {\n      unimplemented('PShapeSVG.prototype.parseChild, name = mask');\n    } else {\n      // ignoring\n    }\n    return shape;\n  };\n  /**\n   * @member PShapeSVG\n   * The parsePath() function parses the <path> element of the svg file\n   * A path is defined by including a path element which contains a d=\"(path data)\" attribute, where the d attribute contains\n   * the moveto, line, curve (both cubic and quadratic Beziers), arc and closepath instructions.\n   **/\n  PShapeSVG.prototype.parsePath = function() {\n    this.family = PConstants.PATH;\n    this.kind = 0;\n    var pathDataChars = [];\n    var c;\n    //change multiple spaces and commas to single space\n    var pathData = CommonFunctions.trim(this.element.getStringAttribute(\"d\").replace(/[\\s,]+/g,' '));\n    if (pathData === null) {\n      return;\n    }\n    pathData = pathData.split('');\n    var cx     = 0,\n        cy     = 0,\n        ctrlX  = 0,\n        ctrlY  = 0,\n        ctrlX1 = 0,\n        ctrlX2 = 0,\n        ctrlY1 = 0,\n        ctrlY2 = 0,\n        endX   = 0,\n        endY   = 0,\n        ppx    = 0,\n        ppy    = 0,\n        px     = 0,\n        py     = 0,\n        i      = 0,\n        valOf  = 0;\n    var str = \"\";\n    var tmpArray = [];\n    var flag = false;\n    var lastInstruction;\n    var command;\n    var j, k;\n    while (i< pathData.length) {\n      valOf = pathData[i].charCodeAt(0);\n      if ((valOf >= 65 && valOf <= 90) || (valOf >= 97 && valOf <= 122)) {\n        // if it's a letter\n        // populate the tmpArray with coordinates\n        j = i;\n        i++;\n        if (i < pathData.length) { // don't go over boundary of array\n          tmpArray = [];\n          valOf = pathData[i].charCodeAt(0);\n          while (!((valOf >= 65 && valOf <= 90) ||\n                   (valOf >= 97 && valOf <= 100) ||\n                   (valOf >= 102 && valOf <= 122)) && flag === false) { // if its NOT a letter\n            if (valOf === 32) { //if its a space and the str isn't empty\n              // sometimes you get a space after the letter\n              if (str !== \"\") {\n                tmpArray.push(parseFloat(str));\n                str = \"\";\n              }\n              i++;\n            } else if (valOf === 45) { //if it's a -\n              // allow for 'e' notation in numbers, e.g. 2.10e-9\n              if (pathData[i-1].charCodeAt(0) === 101) {\n                str += pathData[i].toString();\n                i++;\n              } else {\n                // sometimes no space separator after (ex: 104.535-16.322)\n                if (str !== \"\") {\n                  tmpArray.push(parseFloat(str));\n                }\n                str = pathData[i].toString();\n                i++;\n              }\n            } else {\n              str += pathData[i].toString();\n              i++;\n            }\n            if (i === pathData.length) { // don't go over boundary of array\n              flag = true;\n            } else {\n              valOf = pathData[i].charCodeAt(0);\n            }\n          }\n        }\n        if (str !== \"\") {\n          tmpArray.push(parseFloat(str));\n          str = \"\";\n        }\n        command = pathData[j];\n        valOf = command.charCodeAt(0);\n        if (valOf === 77) {  // M - move to (absolute)\n          if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {\n            // need one+ pairs of co-ordinates\n            cx = tmpArray[0];\n            cy = tmpArray[1];\n            this.parsePathMoveto(cx, cy);\n            if (tmpArray.length > 2) {\n              for (j = 2, k = tmpArray.length; j < k; j+=2) {\n                // absolute line to\n                cx = tmpArray[j];\n                cy = tmpArray[j+1];\n                this.parsePathLineto(cx,cy);\n              }\n            }\n          }\n        } else if (valOf === 109) {  // m - move to (relative)\n          if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {\n            // need one+ pairs of co-ordinates\n            cx += tmpArray[0];\n            cy += tmpArray[1];\n            this.parsePathMoveto(cx,cy);\n            if (tmpArray.length > 2) {\n              for (j = 2, k = tmpArray.length; j < k; j+=2) {\n                // relative line to\n                cx += tmpArray[j];\n                cy += tmpArray[j + 1];\n                this.parsePathLineto(cx,cy);\n              }\n            }\n          }\n        } else if (valOf === 76) { // L - lineto (absolute)\n          if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {\n            // need one+ pairs of co-ordinates\n            for (j = 0, k = tmpArray.length; j < k; j+=2) {\n              cx = tmpArray[j];\n              cy = tmpArray[j + 1];\n              this.parsePathLineto(cx,cy);\n            }\n          }\n        } else if (valOf === 108) { // l - lineto (relative)\n          if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {\n            // need one+ pairs of co-ordinates\n            for (j = 0, k = tmpArray.length; j < k; j+=2) {\n              cx += tmpArray[j];\n              cy += tmpArray[j+1];\n              this.parsePathLineto(cx,cy);\n            }\n          }\n        } else if (valOf === 72) { // H - horizontal lineto (absolute)\n          for (j = 0, k = tmpArray.length; j < k; j++) {\n            // multiple x co-ordinates can be provided\n            cx = tmpArray[j];\n            this.parsePathLineto(cx, cy);\n          }\n        } else if (valOf === 104) { // h - horizontal lineto (relative)\n          for (j = 0, k = tmpArray.length; j < k; j++) {\n            // multiple x co-ordinates can be provided\n            cx += tmpArray[j];\n            this.parsePathLineto(cx, cy);\n          }\n        } else if (valOf === 86) { // V - vertical lineto (absolute)\n          for (j = 0, k = tmpArray.length; j < k; j++) {\n            // multiple y co-ordinates can be provided\n            cy = tmpArray[j];\n            this.parsePathLineto(cx, cy);\n          }\n        } else if (valOf === 118) { // v - vertical lineto (relative)\n          for (j = 0, k = tmpArray.length; j < k; j++) {\n            // multiple y co-ordinates can be provided\n            cy += tmpArray[j];\n            this.parsePathLineto(cx, cy);\n          }\n        } else if (valOf === 67) { // C - curve to (absolute)\n          if (tmpArray.length >= 6 && tmpArray.length % 6 === 0) {\n            // need one+ multiples of 6 co-ordinates\n            for (j = 0, k = tmpArray.length; j < k; j+=6) {\n              ctrlX1 = tmpArray[j];\n              ctrlY1 = tmpArray[j + 1];\n              ctrlX2 = tmpArray[j + 2];\n              ctrlY2 = tmpArray[j + 3];\n              endX   = tmpArray[j + 4];\n              endY   = tmpArray[j + 5];\n              this.parsePathCurveto(ctrlX1,\n                                    ctrlY1,\n                                    ctrlX2,\n                                    ctrlY2,\n                                    endX,\n                                    endY);\n              cx = endX;\n              cy = endY;\n            }\n          }\n        } else if (valOf === 99) { // c - curve to (relative)\n          if (tmpArray.length >= 6 && tmpArray.length % 6 === 0) {\n            // need one+ multiples of 6 co-ordinates\n            for (j = 0, k = tmpArray.length; j < k; j+=6) {\n              ctrlX1 = cx + tmpArray[j];\n              ctrlY1 = cy + tmpArray[j + 1];\n              ctrlX2 = cx + tmpArray[j + 2];\n              ctrlY2 = cy + tmpArray[j + 3];\n              endX   = cx + tmpArray[j + 4];\n              endY   = cy + tmpArray[j + 5];\n              this.parsePathCurveto(ctrlX1,\n                                    ctrlY1,\n                                    ctrlX2,\n                                    ctrlY2,\n                                    endX,\n                                    endY);\n              cx = endX;\n              cy = endY;\n            }\n          }\n        } else if (valOf === 83) { // S - curve to shorthand (absolute)\n          if (tmpArray.length >= 4 && tmpArray.length % 4 === 0) {\n            // need one+ multiples of 4 co-ordinates\n            for (j = 0, k = tmpArray.length; j < k; j+=4) {\n              if (lastInstruction.toLowerCase() ===  \"c\" ||\n                  lastInstruction.toLowerCase() ===  \"s\") {\n                ppx    = this.vertices[ this.vertices.length-2 ][0];\n                ppy    = this.vertices[ this.vertices.length-2 ][1];\n                px     = this.vertices[ this.vertices.length-1 ][0];\n                py     = this.vertices[ this.vertices.length-1 ][1];\n                ctrlX1 = px + (px - ppx);\n                ctrlY1 = py + (py - ppy);\n              } else {\n                //If there is no previous curve,\n                //the current point will be used as the first control point.\n                ctrlX1 = this.vertices[this.vertices.length-1][0];\n                ctrlY1 = this.vertices[this.vertices.length-1][1];\n              }\n              ctrlX2 = tmpArray[j];\n              ctrlY2 = tmpArray[j + 1];\n              endX   = tmpArray[j + 2];\n              endY   = tmpArray[j + 3];\n              this.parsePathCurveto(ctrlX1,\n                                    ctrlY1,\n                                    ctrlX2,\n                                    ctrlY2,\n                                    endX,\n                                    endY);\n              cx = endX;\n              cy = endY;\n            }\n          }\n        } else if (valOf === 115) { // s - curve to shorthand (relative)\n          if (tmpArray.length >= 4 && tmpArray.length % 4 === 0) {\n            // need one+ multiples of 4 co-ordinates\n            for (j = 0, k = tmpArray.length; j < k; j+=4) {\n              if (lastInstruction.toLowerCase() ===  \"c\" ||\n                  lastInstruction.toLowerCase() ===  \"s\") {\n                ppx    = this.vertices[this.vertices.length-2][0];\n                ppy    = this.vertices[this.vertices.length-2][1];\n                px     = this.vertices[this.vertices.length-1][0];\n                py     = this.vertices[this.vertices.length-1][1];\n                ctrlX1 = px + (px - ppx);\n                ctrlY1 = py + (py - ppy);\n              } else {\n                //If there is no previous curve,\n                //the current point will be used as the first control point.\n                ctrlX1 = this.vertices[this.vertices.length-1][0];\n                ctrlY1 = this.vertices[this.vertices.length-1][1];\n              }\n              ctrlX2 = cx + tmpArray[j];\n              ctrlY2 = cy + tmpArray[j + 1];\n              endX   = cx + tmpArray[j + 2];\n              endY   = cy + tmpArray[j + 3];\n              this.parsePathCurveto(ctrlX1,\n                                    ctrlY1,\n                                    ctrlX2,\n                                    ctrlY2,\n                                    endX,\n                                    endY);\n              cx = endX;\n              cy = endY;\n            }\n          }\n        } else if (valOf === 81) { // Q - quadratic curve to (absolute)\n          if (tmpArray.length >= 4 && tmpArray.length % 4 === 0) {\n            // need one+ multiples of 4 co-ordinates\n            for (j = 0, k = tmpArray.length; j < k; j+=4) {\n              ctrlX = tmpArray[j];\n              ctrlY = tmpArray[j + 1];\n              endX  = tmpArray[j + 2];\n              endY  = tmpArray[j + 3];\n              this.parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);\n              cx = endX;\n              cy = endY;\n            }\n          }\n        } else if (valOf === 113) { // q - quadratic curve to (relative)\n          if (tmpArray.length >= 4 && tmpArray.length % 4 === 0) {\n            // need one+ multiples of 4 co-ordinates\n            for (j = 0, k = tmpArray.length; j < k; j+=4) {\n              ctrlX = cx + tmpArray[j];\n              ctrlY = cy + tmpArray[j + 1];\n              endX  = cx + tmpArray[j + 2];\n              endY  = cy + tmpArray[j + 3];\n              this.parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);\n              cx = endX;\n              cy = endY;\n            }\n          }\n        } else if (valOf === 84) {\n          // T - quadratic curve to shorthand (absolute)\n          if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {\n            // need one+ pairs of co-ordinates\n            for (j = 0, k = tmpArray.length; j < k; j+=2) {\n              if (lastInstruction.toLowerCase() ===  \"q\" ||\n                  lastInstruction.toLowerCase() ===  \"t\") {\n                ppx   = this.vertices[this.vertices.length-2][0];\n                ppy   = this.vertices[this.vertices.length-2][1];\n                px    = this.vertices[this.vertices.length-1][0];\n                py    = this.vertices[this.vertices.length-1][1];\n                ctrlX = px + (px - ppx);\n                ctrlY = py + (py - ppy);\n              } else {\n                // If there is no previous command or if the previous command\n                // was not a Q, q, T or t, assume the control point is\n                // coincident with the current point.\n                ctrlX = cx;\n                ctrlY = cy;\n              }\n              endX  = tmpArray[j];\n              endY  = tmpArray[j + 1];\n              this.parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);\n              cx = endX;\n              cy = endY;\n            }\n          }\n        } else if (valOf === 116) {\n          // t - quadratic curve to shorthand (relative)\n          if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {\n            // need one+ pairs of co-ordinates\n            for (j = 0, k = tmpArray.length; j < k; j+=2) {\n              if (lastInstruction.toLowerCase() ===  \"q\" ||\n                  lastInstruction.toLowerCase() ===  \"t\") {\n                ppx   = this.vertices[this.vertices.length-2][0];\n                ppy   = this.vertices[this.vertices.length-2][1];\n                px    = this.vertices[this.vertices.length-1][0];\n                py    = this.vertices[this.vertices.length-1][1];\n                ctrlX = px + (px - ppx);\n                ctrlY = py + (py - ppy);\n              } else {\n                // If there is no previous command or if the previous command\n                // was not a Q, q, T or t, assume the control point is\n                // coincident with the current point.\n                ctrlX = cx;\n                ctrlY = cy;\n              }\n              endX  = cx + tmpArray[j];\n              endY  = cy + tmpArray[j + 1];\n              this.parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);\n              cx = endX;\n              cy = endY;\n            }\n          }\n        } else if (valOf === 90 || valOf === 122) { // Z or z (these do the same thing)\n          this.close = true;\n        }\n        lastInstruction = command.toString();\n      } else { i++;}\n    }\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parsePath() helper function\n   *\n   * @see PShapeSVG#parsePath\n   */\n  PShapeSVG.prototype.parsePathQuadto = function(x1, y1, cx, cy, x2, y2) {\n    if (this.vertices.length > 0) {\n      this.parsePathCode(PConstants.BEZIER_VERTEX);\n      // x1/y1 already covered by last moveto, lineto, or curveto\n      this.parsePathVertex(x1 + ((cx-x1)*2/3), y1 + ((cy-y1)*2/3));\n      this.parsePathVertex(x2 + ((cx-x2)*2/3), y2 + ((cy-y2)*2/3));\n      this.parsePathVertex(x2, y2);\n    } else {\n      throw (\"Path must start with M/m\");\n    }\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parsePath() helper function\n   *\n   * @see PShapeSVG#parsePath\n   */\n  PShapeSVG.prototype.parsePathCurveto = function(x1,  y1, x2, y2, x3, y3) {\n    if (this.vertices.length > 0) {\n      this.parsePathCode(PConstants.BEZIER_VERTEX );\n      this.parsePathVertex(x1, y1);\n      this.parsePathVertex(x2, y2);\n      this.parsePathVertex(x3, y3);\n    } else {\n      throw (\"Path must start with M/m\");\n    }\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parsePath() helper function\n   *\n   * @see PShapeSVG#parsePath\n   */\n  PShapeSVG.prototype.parsePathLineto = function(px, py) {\n    if (this.vertices.length > 0) {\n      this.parsePathCode(PConstants.VERTEX);\n      this.parsePathVertex(px, py);\n      // add property to distinguish between curContext.moveTo\n      // or curContext.lineTo\n      this.vertices[this.vertices.length-1].moveTo = false;\n    } else {\n      throw (\"Path must start with M/m\");\n    }\n  };\n\n  PShapeSVG.prototype.parsePathMoveto = function(px, py) {\n    if (this.vertices.length > 0) {\n      this.parsePathCode(PConstants.BREAK);\n    }\n    this.parsePathCode(PConstants.VERTEX);\n    this.parsePathVertex(px, py);\n    // add property to distinguish between curContext.moveTo\n    // or curContext.lineTo\n    this.vertices[this.vertices.length-1].moveTo = true;\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parsePath() helper function\n   *\n   * @see PShapeSVG#parsePath\n   */\n  PShapeSVG.prototype.parsePathVertex = function(x,  y) {\n    var verts = [];\n    verts[0]  = x;\n    verts[1]  = y;\n    this.vertices.push(verts);\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parsePath() helper function\n   *\n   * @see PShapeSVG#parsePath\n   */\n  PShapeSVG.prototype.parsePathCode = function(what) {\n    this.vertexCodes.push(what);\n  };\n  /**\n   * @member PShapeSVG\n   * The parsePoly() function parses a polyline or polygon from an SVG file.\n   *\n   * @param {boolean}val true if shape is closed (polygon), false if not (polyline)\n   */\n  PShapeSVG.prototype.parsePoly = function(val) {\n    this.family    = PConstants.PATH;\n    this.close     = val;\n    var pointsAttr = CommonFunctions.trim(this.element.getStringAttribute(\"points\").replace(/[,\\s]+/g,' '));\n    if (pointsAttr !== null) {\n      //split into array\n      var pointsBuffer = pointsAttr.split(\" \");\n      if (pointsBuffer.length % 2 === 0) {\n        for (var i = 0, j = pointsBuffer.length; i < j; i++) {\n          var verts = [];\n          verts[0]  = pointsBuffer[i];\n          verts[1]  = pointsBuffer[++i];\n          this.vertices.push(verts);\n        }\n      } else {\n        throw(\"Error parsing polygon points: odd number of coordinates provided\");\n      }\n    }\n  };\n  /**\n   * @member PShapeSVG\n   * The parseRect() function parses a rect from an SVG file.\n   */\n  PShapeSVG.prototype.parseRect = function() {\n    this.kind      = PConstants.RECT;\n    this.family    = PConstants.PRIMITIVE;\n    this.params    = [];\n    this.params[0] = this.element.getFloatAttribute(\"x\");\n    this.params[1] = this.element.getFloatAttribute(\"y\");\n    this.params[2] = this.element.getFloatAttribute(\"width\");\n    this.params[3] = this.element.getFloatAttribute(\"height\");\n    if (this.params[2] < 0 || this.params[3] < 0) {\n      throw(\"svg error: negative width or height found while parsing <rect>\");\n    }\n  };\n  /**\n   * @member PShapeSVG\n   * The parseEllipse() function handles parsing ellipse and circle tags.\n   *\n   * @param {boolean}val true if this is a circle and not an ellipse\n   */\n  PShapeSVG.prototype.parseEllipse = function(val) {\n    this.kind   = PConstants.ELLIPSE;\n    this.family = PConstants.PRIMITIVE;\n    this.params = [];\n\n    this.params[0] = this.element.getFloatAttribute(\"cx\") | 0 ;\n    this.params[1] = this.element.getFloatAttribute(\"cy\") | 0;\n\n    var rx, ry;\n    if (val) {\n      rx = ry = this.element.getFloatAttribute(\"r\");\n      if (rx < 0) {\n        throw(\"svg error: negative radius found while parsing <circle>\");\n      }\n    } else {\n      rx = this.element.getFloatAttribute(\"rx\");\n      ry = this.element.getFloatAttribute(\"ry\");\n      if (rx < 0 || ry < 0) {\n        throw(\"svg error: negative x-axis radius or y-axis radius found while parsing <ellipse>\");\n      }\n    }\n    this.params[0] -= rx;\n    this.params[1] -= ry;\n\n    this.params[2] = rx*2;\n    this.params[3] = ry*2;\n  };\n  /**\n   * @member PShapeSVG\n   * The parseLine() function handles parsing line tags.\n   *\n   * @param {boolean}val true if this is a circle and not an ellipse\n   */\n  PShapeSVG.prototype.parseLine = function() {\n    this.kind = PConstants.LINE;\n    this.family = PConstants.PRIMITIVE;\n    this.params = [];\n    this.params[0] = this.element.getFloatAttribute(\"x1\");\n    this.params[1] = this.element.getFloatAttribute(\"y1\");\n    this.params[2] = this.element.getFloatAttribute(\"x2\");\n    this.params[3] = this.element.getFloatAttribute(\"y2\");\n  };\n  /**\n   * @member PShapeSVG\n   * The parseColors() function handles parsing the opacity, strijem stroke-width, stroke-linejoin,stroke-linecap, fill, and style attributes\n   *\n   * @param {XMLElement}element the element of which attributes to parse\n   */\n  PShapeSVG.prototype.parseColors = function(element) {\n    if (element.hasAttribute(\"opacity\")) {\n      this.setOpacity(element.getAttribute(\"opacity\"));\n    }\n    if (element.hasAttribute(\"stroke\")) {\n      this.setStroke(element.getAttribute(\"stroke\"));\n    }\n    if (element.hasAttribute(\"stroke-width\")) {\n      // if NaN (i.e. if it's 'inherit') then default\n      // back to the inherit setting\n      this.setStrokeWeight(element.getAttribute(\"stroke-width\"));\n    }\n    if (element.hasAttribute(\"stroke-linejoin\") ) {\n      this.setStrokeJoin(element.getAttribute(\"stroke-linejoin\"));\n    }\n    if (element.hasAttribute(\"stroke-linecap\")) {\n      this.setStrokeCap(element.getStringAttribute(\"stroke-linecap\"));\n    }\n    // fill defaults to black (though stroke defaults to \"none\")\n    // http://www.w3.org/TR/SVG/painting.html#FillProperties\n    if (element.hasAttribute(\"fill\")) {\n      this.setFill(element.getStringAttribute(\"fill\"));\n    }\n    if (element.hasAttribute(\"style\")) {\n      var styleText   = element.getStringAttribute(\"style\");\n      var styleTokens = styleText.toString().split( \";\" );\n\n      for (var i = 0, j = styleTokens.length; i < j; i++) {\n        var tokens = CommonFunctions.trim(styleTokens[i].split( \":\" ));\n        if (tokens[0] === \"fill\") {\n            this.setFill(tokens[1]);\n        } else if (tokens[0] === \"fill-opacity\") {\n            this.setFillOpacity(tokens[1]);\n        } else if (tokens[0] === \"stroke\") {\n            this.setStroke(tokens[1]);\n        } else if (tokens[0] === \"stroke-width\") {\n            this.setStrokeWeight(tokens[1]);\n        } else if (tokens[0] === \"stroke-linecap\") {\n            this.setStrokeCap(tokens[1]);\n        } else if (tokens[0] === \"stroke-linejoin\") {\n            this.setStrokeJoin(tokens[1]);\n        } else if (tokens[0] === \"stroke-opacity\") {\n            this.setStrokeOpacity(tokens[1]);\n        } else if (tokens[0] === \"opacity\") {\n            this.setOpacity(tokens[1]);\n        } // Other attributes are not yet implemented\n      }\n    }\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parseColors() helper function\n   *\n   * @param {String} opacityText the value of fillOpacity\n   *\n   * @see PShapeSVG#parseColors\n   */\n  PShapeSVG.prototype.setFillOpacity = function(opacityText) {\n    this.fillOpacity = parseFloat(opacityText);\n    this.fillColor   = this.fillOpacity * 255  << 24 |\n                       this.fillColor & 0xFFFFFF;\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parseColors() helper function\n   *\n   * @param {String} fillText the value of fill\n   *\n   * @see PShapeSVG#parseColors\n   */\n  PShapeSVG.prototype.setFill = function (fillText) {\n    var opacityMask = this.fillColor & 0xFF000000;\n    if (fillText === \"none\") {\n      this.fill = false;\n    } else if (fillText.indexOf(\"#\") === 0) {\n      this.fill      = true;\n      if (fillText.length === 4) {\n        // convert #00F to #0000FF\n        fillText = fillText.replace(/#(.)(.)(.)/,\"#$1$1$2$2$3$3\");\n      }\n      this.fillColor = opacityMask |\n                       (parseInt(fillText.substring(1), 16 )) &\n                       0xFFFFFF;\n    } else if (fillText.indexOf(\"rgb\") === 0) {\n      this.fill      = true;\n      this.fillColor = opacityMask | this.parseRGB(fillText);\n    } else if (fillText.indexOf(\"url(#\") === 0) {\n      this.fillName = fillText.substring(5, fillText.length - 1 );\n    } else if (colors[fillText]) {\n      this.fill      = true;\n      this.fillColor = opacityMask |\n                       (parseInt(colors[fillText].substring(1), 16)) &\n                       0xFFFFFF;\n    }\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parseColors() helper function\n   *\n   * @param {String} opacity the value of opacity\n   *\n   * @see PShapeSVG#parseColors\n   */\n  PShapeSVG.prototype.setOpacity = function(opacity) {\n    this.strokeColor = parseFloat(opacity) * 255 << 24 |\n                       this.strokeColor & 0xFFFFFF;\n    this.fillColor   = parseFloat(opacity) * 255 << 24 |\n                       this.fillColor & 0xFFFFFF;\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parseColors() helper function\n   *\n   * @param {String} strokeText the value to set stroke to\n   *\n   * @see PShapeSVG#parseColors\n   */\n  PShapeSVG.prototype.setStroke = function(strokeText) {\n    var opacityMask = this.strokeColor & 0xFF000000;\n    if (strokeText === \"none\") {\n      this.stroke = false;\n    } else if (strokeText.charAt( 0 ) === \"#\") {\n      this.stroke      = true;\n      if (strokeText.length === 4) {\n        // convert #00F to #0000FF\n        strokeText = strokeText.replace(/#(.)(.)(.)/,\"#$1$1$2$2$3$3\");\n      }\n      this.strokeColor = opacityMask |\n                         (parseInt( strokeText.substring( 1 ), 16 )) &\n                         0xFFFFFF;\n    } else if (strokeText.indexOf( \"rgb\" ) === 0 ) {\n      this.stroke = true;\n      this.strokeColor = opacityMask | this.parseRGB(strokeText);\n    } else if (strokeText.indexOf( \"url(#\" ) === 0) {\n      this.strokeName = strokeText.substring(5, strokeText.length - 1);\n    } else if (colors[strokeText]) {\n      this.stroke      = true;\n      this.strokeColor = opacityMask |\n                         (parseInt(colors[strokeText].substring(1), 16)) &\n                         0xFFFFFF;\n    }\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parseColors() helper function\n   *\n   * @param {String} weight the value to set strokeWeight to\n   *\n   * @see PShapeSVG#parseColors\n   */\n  PShapeSVG.prototype.setStrokeWeight = function(weight) {\n    this.strokeWeight = this.parseUnitSize(weight);\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parseColors() helper function\n   *\n   * @param {String} linejoin the value to set strokeJoin to\n   *\n   * @see PShapeSVG#parseColors\n   */\n  PShapeSVG.prototype.setStrokeJoin = function(linejoin) {\n    if (linejoin === \"miter\") {\n      this.strokeJoin = PConstants.MITER;\n\n    } else if (linejoin === \"round\") {\n      this.strokeJoin = PConstants.ROUND;\n\n    } else if (linejoin === \"bevel\") {\n      this.strokeJoin = PConstants.BEVEL;\n    }\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parseColors() helper function\n   *\n   * @param {String} linecap the value to set strokeCap to\n   *\n   * @see PShapeSVG#parseColors\n   */\n  PShapeSVG.prototype.setStrokeCap = function (linecap) {\n    if (linecap === \"butt\") {\n      this.strokeCap = PConstants.SQUARE;\n\n    } else if (linecap === \"round\") {\n      this.strokeCap = PConstants.ROUND;\n\n    } else if (linecap === \"square\") {\n      this.strokeCap = PConstants.PROJECT;\n    }\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parseColors() helper function\n   *\n   * @param {String} opacityText the value to set stroke opacity to\n   *\n   * @see PShapeSVG#parseColors\n   */\n  PShapeSVG.prototype.setStrokeOpacity =  function (opacityText) {\n    this.strokeOpacity = parseFloat(opacityText);\n    this.strokeColor   = this.strokeOpacity * 255 << 24 |\n                         this.strokeColor &\n                         0xFFFFFF;\n  };\n  /**\n   * @member PShapeSVG\n   * The parseRGB() function parses an rbg() color string and returns a color int\n   *\n   * @param {String} color the color to parse in rbg() format\n   *\n   * @return {int} the equivalent color int\n   */\n  PShapeSVG.prototype.parseRGB = function(color) {\n    var sub    = color.substring(color.indexOf('(') + 1, color.indexOf(')'));\n    var values = sub.split(\", \");\n    return (values[0] << 16) | (values[1] << 8) | (values[2]);\n  };\n  /**\n   * @member PShapeSVG\n   * The parseUnitSize() function parse a size that may have a suffix for its units.\n   * Ignoring cases where this could also be a percentage.\n   * The <A HREF=\"http://www.w3.org/TR/SVG/coords.html#Units\">units</A> spec:\n   * <UL>\n   * <LI>\"1pt\" equals \"1.25px\" (and therefore 1.25 user units)\n   * <LI>\"1pc\" equals \"15px\" (and therefore 15 user units)\n   * <LI>\"1mm\" would be \"3.543307px\" (3.543307 user units)\n   * <LI>\"1cm\" equals \"35.43307px\" (and therefore 35.43307 user units)\n   * <LI>\"1in\" equals \"90px\" (and therefore 90 user units)\n   * </UL>\n   */\n  PShapeSVG.prototype.parseUnitSize = function (text) {\n    var len = text.length - 2;\n    if (len < 0) { return text; }\n    if (text.indexOf(\"pt\") === len) {\n      return parseFloat(text.substring(0, len)) * 1.25;\n    }\n    if (text.indexOf(\"pc\") === len) {\n      return parseFloat( text.substring( 0, len)) * 15;\n    }\n    if (text.indexOf(\"mm\") === len) {\n      return parseFloat( text.substring(0, len)) * 3.543307;\n    }\n    if (text.indexOf(\"cm\") === len) {\n      return parseFloat(text.substring(0, len)) * 35.43307;\n    }\n    if (text.indexOf(\"in\") === len) {\n      return parseFloat(text.substring(0, len)) * 90;\n    }\n    if (text.indexOf(\"px\") === len) {\n      return parseFloat(text.substring(0, len));\n    }\n    return parseFloat(text);\n  };\n\n  return PShapeSVG;\n};\n\n},{}],18:[function(require,module,exports){\nmodule.exports = function(options, undef) {\n  var PConstants = options.PConstants;\n\n  function PVector(x, y, z) {\n    this.x = x || 0;\n    this.y = y || 0;\n    this.z = z || 0;\n  }\n\n  PVector.fromAngle = function(angle, v) {\n    if (v === undef || v === null) {\n      v = new PVector();\n    }\n    v.x = Math.cos(angle);\n    v.y = Math.sin(angle);\n    return v;\n  };\n\n  PVector.random2D = function(v) {\n    return PVector.fromAngle(Math.random() * PConstants.TWO_PI, v);\n  };\n\n  PVector.random3D = function(v) {\n    var angle = Math.random() * PConstants.TWO_PI;\n    var vz = Math.random() * 2 - 1;\n    var mult = Math.sqrt(1 - vz * vz);\n    var vx = mult * Math.cos(angle);\n    var vy = mult * Math.sin(angle);\n    if (v === undef || v === null) {\n      v = new PVector(vx, vy, vz);\n    } else {\n      v.set(vx, vy, vz);\n    }\n    return v;\n  };\n\n  PVector.dist = function(v1, v2) {\n    return v1.dist(v2);\n  };\n\n  PVector.dot = function(v1, v2) {\n    return v1.dot(v2);\n  };\n\n  PVector.cross = function(v1, v2) {\n    return v1.cross(v2);\n  };\n\n  PVector.sub = function(v1, v2) {\n    return new PVector(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);\n  };\n\n  PVector.angleBetween = function(v1, v2) {\n    return Math.acos(v1.dot(v2) / Math.sqrt(v1.magSq() * v2.magSq()));\n  };\n\n  PVector.lerp = function(v1, v2, amt) {\n    // non-static lerp mutates object, but this version returns a new vector\n    var retval = new PVector(v1.x, v1.y, v1.z);\n    retval.lerp(v2, amt);\n    return retval;\n  };\n\n  // Common vector operations for PVector\n  PVector.prototype = {\n    set: function(v, y, z) {\n      if (arguments.length === 1) {\n        this.set(v.x || v[0] || 0,\n                 v.y || v[1] || 0,\n                 v.z || v[2] || 0);\n      } else {\n        this.x = v;\n        this.y = y;\n        this.z = z;\n      }\n    },\n    get: function() {\n      return new PVector(this.x, this.y, this.z);\n    },\n    mag: function() {\n      var x = this.x,\n          y = this.y,\n          z = this.z;\n      return Math.sqrt(x * x + y * y + z * z);\n    },\n    magSq: function() {\n      var x = this.x,\n          y = this.y,\n          z = this.z;\n      return (x * x + y * y + z * z);\n    },\n    setMag: function(v_or_len, len) {\n      if (len === undef) {\n        len = v_or_len;\n        this.normalize();\n        this.mult(len);\n      } else {\n        var v = v_or_len;\n        v.normalize();\n        v.mult(len);\n        return v;\n      }\n    },\n    add: function(v, y, z) {\n      if (arguments.length === 1) {\n        this.x += v.x;\n        this.y += v.y;\n        this.z += v.z;\n      } else if (arguments.length === 2) {\n        // 2D Vector\n        this.x += v;\n        this.y += y;\n      } else {\n        this.x += v;\n        this.y += y;\n        this.z += z;\n      }\n    },\n    sub: function(v, y, z) {\n      if (arguments.length === 1) {\n        this.x -= v.x;\n        this.y -= v.y;\n        this.z -= v.z;\n      } else if (arguments.length === 2) {\n        // 2D Vector\n        this.x -= v;\n        this.y -= y;\n      } else {\n        this.x -= v;\n        this.y -= y;\n        this.z -= z;\n      }\n    },\n    mult: function(v) {\n      if (typeof v === 'number') {\n        this.x *= v;\n        this.y *= v;\n        this.z *= v;\n      } else {\n        this.x *= v.x;\n        this.y *= v.y;\n        this.z *= v.z;\n      }\n    },\n    div: function(v) {\n      if (typeof v === 'number') {\n        this.x /= v;\n        this.y /= v;\n        this.z /= v;\n      } else {\n        this.x /= v.x;\n        this.y /= v.y;\n        this.z /= v.z;\n      }\n    },\n    rotate: function(angle) {\n      var prev_x = this.x;\n      var c = Math.cos(angle);\n      var s = Math.sin(angle);\n      this.x = c * this.x - s * this.y;\n      this.y = s * prev_x + c * this.y;\n    },\n    dist: function(v) {\n      var dx = this.x - v.x,\n          dy = this.y - v.y,\n          dz = this.z - v.z;\n      return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    },\n    dot: function(v, y, z) {\n      if (arguments.length === 1) {\n        return (this.x * v.x + this.y * v.y + this.z * v.z);\n      }\n      return (this.x * v + this.y * y + this.z * z);\n    },\n    cross: function(v) {\n      var x = this.x,\n          y = this.y,\n          z = this.z;\n      return new PVector(y * v.z - v.y * z,\n                         z * v.x - v.z * x,\n                         x * v.y - v.x * y);\n    },\n    lerp: function(v_or_x, amt_or_y, z, amt) {\n      var lerp_val = function(start, stop, amt) {\n        return start + (stop - start) * amt;\n      };\n      var x, y;\n      if (arguments.length === 2) {\n        // given vector and amt\n        amt = amt_or_y;\n        x = v_or_x.x;\n        y = v_or_x.y;\n        z = v_or_x.z;\n      } else {\n        // given x, y, z and amt\n        x = v_or_x;\n        y = amt_or_y;\n      }\n      this.x = lerp_val(this.x, x, amt);\n      this.y = lerp_val(this.y, y, amt);\n      this.z = lerp_val(this.z, z, amt);\n    },\n    normalize: function() {\n      var m = this.mag();\n      if (m > 0) {\n        this.div(m);\n      }\n    },\n    limit: function(high) {\n      if (this.mag() > high) {\n        this.normalize();\n        this.mult(high);\n      }\n    },\n    heading: function() {\n      return (-Math.atan2(-this.y, this.x));\n    },\n    heading2D: function() {\n      return this.heading();\n    },\n    toString: function() {\n      return \"[\" + this.x + \", \" + this.y + \", \" + this.z + \"]\";\n    },\n    array: function() {\n      return [this.x, this.y, this.z];\n    }\n  };\n\n  function createPVectorMethod(method) {\n    return function(v1, v2) {\n      var v = v1.get();\n      v[method](v2);\n      return v;\n    };\n  }\n\n  for (var method in PVector.prototype) {\n    if (PVector.prototype.hasOwnProperty(method) && !PVector.hasOwnProperty(method)) {\n      PVector[method] = createPVectorMethod(method);\n    }\n  }\n\n  return PVector;\n};\n\n},{}],19:[function(require,module,exports){\n/**\n * XMLAttribute is an attribute of a XML element.\n *\n * @param {String} fname     the full name of the attribute\n * @param {String} n         the short name of the attribute\n * @param {String} namespace the namespace URI of the attribute\n * @param {String} v         the value of the attribute\n * @param {String }t         the type of the attribute\n *\n * @see XMLElement\n */\nmodule.exports = function() {\n\n  var XMLAttribute = function (fname, n, nameSpace, v, t){\n    this.fullName = fname || \"\";\n    this.name = n || \"\";\n    this.namespace = nameSpace || \"\";\n    this.value = v;\n    this.type = t;\n  };\n\n  XMLAttribute.prototype = {\n    /**\n     * @member XMLAttribute\n     * The getName() function returns the short name of the attribute\n     *\n     * @return {String} the short name of the attribute\n     */\n    getName: function() {\n      return this.name;\n    },\n    /**\n     * @member XMLAttribute\n     * The getFullName() function returns the full name of the attribute\n     *\n     * @return {String} the full name of the attribute\n     */\n    getFullName: function() {\n      return this.fullName;\n    },\n    /**\n     * @member XMLAttribute\n     * The getNamespace() function returns the namespace of the attribute\n     *\n     * @return {String} the namespace of the attribute\n     */\n    getNamespace: function() {\n      return this.namespace;\n    },\n    /**\n     * @member XMLAttribute\n     * The getValue() function returns the value of the attribute\n     *\n     * @return {String} the value of the attribute\n     */\n    getValue: function() {\n      return this.value;\n    },\n    /**\n     * @member XMLAttribute\n     * The getValue() function returns the type of the attribute\n     *\n     * @return {String} the type of the attribute\n     */\n    getType: function() {\n      return this.type;\n    },\n    /**\n     * @member XMLAttribute\n     * The setValue() function sets the value of the attribute\n     *\n     * @param {String} newval the new value\n     */\n    setValue: function(newval) {\n      this.value = newval;\n    }\n  };\n\n  return XMLAttribute;\n};\n\n},{}],20:[function(require,module,exports){\n/**\n * XMLElement is a representation of an XML object. The object is able to parse XML code\n *\n * @param {PApplet} parent   typically use \"this\"\n * @param {String} filename  name of the XML/SVG file to load\n * @param {String} xml       the xml/svg string\n * @param {String} fullname  the full name of the element\n * @param {String} namespace the namespace  of the URI\n * @param {String} systemID  the system ID of the XML data where the element starts\n * @param {Integer }lineNr   the line in the XML data where the element starts\n */\nmodule.exports = function(options, undef) {\n\n  var Browser = options.Browser,\n      ajax = Browser.ajax,\n      window = Browser.window,\n      XMLHttpRequest = window.XMLHttpRequest,\n      DOMParser = window.DOMParser,\n      XMLAttribute = options. XMLAttribute;\n\n  var XMLElement = function(selector, uri, sysid, line) {\n    this.attributes = [];\n    this.children   = [];\n    this.fullName   = null;\n    this.name       = null;\n    this.namespace  = \"\";\n    this.content = null;\n    this.parent    = null;\n    this.lineNr     = \"\";\n    this.systemID   = \"\";\n    this.type = \"ELEMENT\";\n\n    if (selector) {\n      if (typeof selector === \"string\") {\n        if (uri === undef && selector.indexOf(\"<\") > -1) {\n          // load XML from text string\n          this.parse(selector);\n        } else {\n          // XMLElement(fullname, namespace, sysid, line) format\n          this.fullName = selector;\n          this.namespace = uri;\n          this.systemId = sysid;\n          this.lineNr = line;\n        }\n      } else {\n        // XMLElement(this, file uri) format\n        this.parse(uri, true);\n      }\n    }\n  };\n  /**\n   * XMLElement methods\n   * missing: enumerateAttributeNames(), enumerateChildren(),\n   * NOTE: parse does not work when a url is passed in\n   */\n  XMLElement.prototype = {\n    /**\n     * @member XMLElement\n     * The parse() function retrieves the file via ajax() and uses DOMParser()\n     * parseFromString method to make an XML document\n     * @addon\n     *\n     * @param {String} filename name of the XML/SVG file to load\n     *\n     * @throws ExceptionType Error loading document\n     *\n     * @see XMLElement#parseChildrenRecursive\n     */\n    parse: function(textstring, stringIsURI) {\n      var xmlDoc;\n      try {\n        if (stringIsURI) {\n          textstring = ajax(textstring);\n        }\n        xmlDoc = new DOMParser().parseFromString(textstring, \"text/xml\");\n        var elements = xmlDoc.documentElement;\n        if (elements) {\n          this.parseChildrenRecursive(null, elements);\n        } else {\n          throw (\"Error loading document\");\n        }\n        return this;\n      } catch(e) {\n        throw(e);\n      }\n    },\n    /**\n     * @member XMLElement\n     * Internal helper function for parse().\n     * Loops through the\n     * @addon\n     *\n     * @param {XMLElement} parent                      the parent node\n     * @param {XML document childNodes} elementpath    the remaining nodes that need parsing\n     *\n     * @return {XMLElement} the new element and its children elements\n     */\n    parseChildrenRecursive: function (parent, elementpath){\n      var xmlelement,\n        xmlattribute,\n        tmpattrib,\n        l, m,\n        child;\n      if (!parent) { // this element is the root element\n        this.fullName = elementpath.localName;\n        this.name     = elementpath.nodeName;\n        xmlelement    = this;\n      } else { // this element has a parent\n        xmlelement         = new XMLElement(elementpath.nodeName);\n        xmlelement.parent  = parent;\n      }\n\n      // if this is a text node, return a PCData element (parsed character data)\n      if (elementpath.nodeType === 3 && elementpath.textContent !== \"\") {\n        return this.createPCDataElement(elementpath.textContent);\n      }\n\n      // if this is a CDATA node, return a CData element (unparsed character data)\n      if (elementpath.nodeType === 4) {\n       return this.createCDataElement(elementpath.textContent);\n      }\n\n      // bind all attributes, if there are any\n      if (elementpath.attributes) {\n        for (l = 0, m = elementpath.attributes.length; l < m; l++) {\n          tmpattrib    = elementpath.attributes[l];\n          xmlattribute = new XMLAttribute(tmpattrib.getname,\n                                          tmpattrib.nodeName,\n                                          tmpattrib.namespaceURI,\n                                          tmpattrib.nodeValue,\n                                          tmpattrib.nodeType);\n          xmlelement.attributes.push(xmlattribute);\n        }\n      }\n\n      // bind all children, if there are any\n      if (elementpath.childNodes) {\n        for (l = 0, m = elementpath.childNodes.length; l < m; l++) {\n          var node = elementpath.childNodes[l];\n          child = xmlelement.parseChildrenRecursive(xmlelement, node);\n          if (child !== null) {\n            xmlelement.children.push(child);\n          }\n        }\n      }\n\n      return xmlelement;\n    },\n    /**\n     * @member XMLElement\n     * The createElement() function Creates an empty element\n     *\n     * @param {String} fullName   the full name of the element\n     * @param {String} namespace  the namespace URI\n     * @param {String} systemID   the system ID of the XML data where the element starts\n     * @param {int} lineNr    the line in the XML data where the element starts\n     */\n    createElement: function (fullname, namespaceuri, sysid, line) {\n      if (sysid === undef) {\n        return new XMLElement(fullname, namespaceuri);\n      }\n      return new XMLElement(fullname, namespaceuri, sysid, line);\n    },\n    /**\n     * @member XMLElement\n     * The createPCDataElement() function creates an element to be used for #PCDATA content.\n     * Because Processing discards whitespace TEXT nodes, this method will not build an element\n     * if the passed content is empty after trimming for whitespace.\n     *\n     * @return {XMLElement} new \"pcdata\" XMLElement, or null if content consists only of whitespace\n     */\n    createPCDataElement: function (content, isCDATA) {\n      if (content.replace(/^\\s+$/g,\"\") === \"\") {\n        return null;\n      }\n      var pcdata = new XMLElement();\n      pcdata.type = \"TEXT\";\n      pcdata.content = content;\n      return pcdata;\n    },\n    /**\n     * @member XMLElement\n     * The createCDataElement() function creates an element to be used for CDATA content.\n     *\n     * @return {XMLElement} new \"cdata\" XMLElement, or null if content consists only of whitespace\n     */\n    createCDataElement: function (content) {\n      var cdata = this.createPCDataElement(content);\n      if (cdata === null) {\n        return null;\n      }\n\n      cdata.type = \"CDATA\";\n      var htmlentities = {\"<\": \"&lt;\", \">\": \"&gt;\", \"'\": \"&apos;\", '\"': \"&quot;\"},\n          entity;\n      for (entity in htmlentities) {\n        if (!Object.hasOwnProperty(htmlentities,entity)) {\n          content = content.replace(new RegExp(entity, \"g\"), htmlentities[entity]);\n        }\n      }\n      cdata.cdata = content;\n      return cdata;\n    },\n    /**\n     * @member XMLElement\n     * The hasAttribute() function returns whether an attribute exists\n     *\n     * @param {String} name      name of the attribute\n     * @param {String} namespace the namespace URI of the attribute\n     *\n     * @return {boolean} true if the attribute exists\n     */\n    hasAttribute: function () {\n      if (arguments.length === 1) {\n        return this.getAttribute(arguments[0]) !== null;\n      }\n      if (arguments.length === 2) {\n        return this.getAttribute(arguments[0],arguments[1]) !== null;\n      }\n    },\n    /**\n     * @member XMLElement\n     * The equals() function checks to see if the XMLElement being passed in equals another XMLElement\n     *\n     * @param {XMLElement} rawElement the element to compare to\n     *\n     * @return {boolean} true if the element equals another element\n     */\n    equals: function(other) {\n      if (!(other instanceof XMLElement)) {\n        return false;\n      }\n      var i, j;\n      if (this.fullName !== other.fullName) { return false; }\n      if (this.attributes.length !== other.getAttributeCount()) { return false; }\n      // attributes may be ordered differently\n      if (this.attributes.length !== other.attributes.length) { return false; }\n      var attr_name, attr_ns, attr_value, attr_type, attr_other;\n      for (i = 0, j = this.attributes.length; i < j; i++) {\n        attr_name = this.attributes[i].getName();\n        attr_ns = this.attributes[i].getNamespace();\n        attr_other = other.findAttribute(attr_name, attr_ns);\n        if (attr_other === null) { return false; }\n        if (this.attributes[i].getValue() !== attr_other.getValue()) { return false; }\n        if (this.attributes[i].getType() !== attr_other.getType()) { return false; }\n      }\n      // children must be ordered identically\n      if (this.children.length !== other.getChildCount()) { return false; }\n      if (this.children.length>0) {\n        var child1, child2;\n        for (i = 0, j = this.children.length; i < j; i++) {\n          child1 = this.getChild(i);\n          child2 = other.getChild(i);\n          if (!child1.equals(child2)) { return false; }\n        }\n        return true;\n      }\n      return (this.content === other.content);\n    },\n    /**\n     * @member XMLElement\n     * The getContent() function returns the content of an element. If there is no such content, null is returned\n     *\n     * @return {String} the (possibly null) content\n     */\n    getContent: function(){\n      if (this.type === \"TEXT\" || this.type === \"CDATA\") {\n        return this.content;\n      }\n      var children = this.children;\n      if (children.length === 1 && (children[0].type === \"TEXT\" || children[0].type === \"CDATA\")) {\n        return children[0].content;\n      }\n      return null;\n    },\n    /**\n     * @member XMLElement\n     * The getAttribute() function returns the value of an attribute\n     *\n     * @param {String} name         the non-null full name of the attribute\n     * @param {String} namespace    the namespace URI, which may be null\n     * @param {String} defaultValue the default value of the attribute\n     *\n     * @return {String} the value, or defaultValue if the attribute does not exist\n     */\n    getAttribute: function (){\n      var attribute;\n      if (arguments.length === 2) {\n        attribute = this.findAttribute(arguments[0]);\n        if (attribute) {\n          return attribute.getValue();\n        }\n        return arguments[1];\n      } else if (arguments.length === 1) {\n        attribute = this.findAttribute(arguments[0]);\n        if (attribute) {\n          return attribute.getValue();\n        }\n        return null;\n      } else if (arguments.length === 3) {\n        attribute = this.findAttribute(arguments[0],arguments[1]);\n        if (attribute) {\n          return attribute.getValue();\n        }\n        return arguments[2];\n      }\n    },\n    /**\n     * @member XMLElement\n     * The getStringAttribute() function returns the string attribute of the element\n     * If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> value is returned.\n     * When calling the function without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value 0 is returned.\n     *\n     * @param name         the name of the attribute\n     * @param defaultValue value returned if the attribute is not found\n     *\n     * @return {String} the value, or defaultValue if the attribute does not exist\n     */\n    getStringAttribute: function() {\n      if (arguments.length === 1) {\n        return this.getAttribute(arguments[0]);\n      }\n      if (arguments.length === 2) {\n        return this.getAttribute(arguments[0], arguments[1]);\n      }\n      return this.getAttribute(arguments[0], arguments[1],arguments[2]);\n    },\n    /**\n     * Processing 1.5 XML API wrapper for the generic String\n     * attribute getter. This may only take one argument.\n     */\n    getString: function(attributeName) {\n      return this.getStringAttribute(attributeName);\n    },\n    /**\n     * @member XMLElement\n     * The getFloatAttribute() function returns the float attribute of the element.\n     * If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> value is returned.\n     * When calling the function without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value 0 is returned.\n     *\n     * @param name         the name of the attribute\n     * @param defaultValue value returned if the attribute is not found\n     *\n     * @return {float} the value, or defaultValue if the attribute does not exist\n     */\n    getFloatAttribute: function() {\n      if (arguments.length === 1 ) {\n        return parseFloat(this.getAttribute(arguments[0], 0));\n      }\n      if (arguments.length === 2 ) {\n        return this.getAttribute(arguments[0], arguments[1]);\n      }\n      return this.getAttribute(arguments[0], arguments[1],arguments[2]);\n    },\n    /**\n     * Processing 1.5 XML API wrapper for the generic float\n     * attribute getter. This may only take one argument.\n     */\n    getFloat: function(attributeName) {\n      return this.getFloatAttribute(attributeName);\n    },\n    /**\n     * @member XMLElement\n     * The getIntAttribute() function returns the integer attribute of the element.\n     * If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> value is returned.\n     * When calling the function without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value 0 is returned.\n     *\n     * @param name         the name of the attribute\n     * @param defaultValue value returned if the attribute is not found\n     *\n     * @return {int} the value, or defaultValue if the attribute does not exist\n     */\n    getIntAttribute: function () {\n      if (arguments.length === 1) {\n        return this.getAttribute( arguments[0], 0 );\n      }\n      if (arguments.length === 2) {\n        return this.getAttribute(arguments[0], arguments[1]);\n      }\n      return this.getAttribute(arguments[0], arguments[1],arguments[2]);\n    },\n    /**\n     * Processing 1.5 XML API wrapper for the generic int\n     * attribute getter. This may only take one argument.\n     */\n    getInt: function(attributeName) {\n      return this.getIntAttribute(attributeName);\n    },\n    /**\n     * @member XMLElement\n     * The hasChildren() function returns whether the element has children.\n     *\n     * @return {boolean} true if the element has children.\n     */\n    hasChildren: function () {\n      return this.children.length > 0 ;\n    },\n    /**\n     * @member XMLElement\n     * The addChild() function adds a child element\n     *\n     * @param {XMLElement} child the non-null child to add.\n     */\n    addChild: function (child) {\n      if (child !== null) {\n        child.parent = this;\n        this.children.push(child);\n      }\n    },\n    /**\n     * @member XMLElement\n     * The insertChild() function inserts a child element at the index provided\n     *\n     * @param {XMLElement} child  the non-null child to add.\n     * @param {int} index     where to put the child.\n     */\n    insertChild: function (child, index) {\n      if (child) {\n        if ((child.getLocalName() === null) && (! this.hasChildren())) {\n          var lastChild = this.children[this.children.length -1];\n          if (lastChild.getLocalName() === null) {\n              lastChild.setContent(lastChild.getContent() + child.getContent());\n              return;\n          }\n        }\n        child.parent = this;\n        this.children.splice(index,0,child);\n      }\n    },\n    /**\n     * @member XMLElement\n     * The getChild() returns the child XMLElement as specified by the <b>index</b> parameter.\n     * The value of the <b>index</b> parameter must be less than the total number of children to avoid going out of the array storing the child elements.\n     * When the <b>path</b> parameter is specified, then it will return all children that match that path. The path is a series of elements and sub-elements, separated by slashes.\n     *\n     * @param {int} index     where to put the child.\n     * @param {String} path       path to a particular element\n     *\n     * @return {XMLElement} the element\n     */\n    getChild: function (selector) {\n      if (typeof selector === \"number\") {\n        return this.children[selector];\n      }\n      if (selector.indexOf('/') !== -1) {\n        // path traversal is required\n        return this.getChildRecursive(selector.split(\"/\"), 0);\n      }\n      var kid, kidName;\n      for (var i = 0, j = this.getChildCount(); i < j; i++) {\n        kid = this.getChild(i);\n        kidName = kid.getName();\n        if (kidName !== null && kidName === selector) {\n            return kid;\n        }\n      }\n      return null;\n    },\n    /**\n     * @member XMLElement\n     * The getChildren() returns all of the children as an XMLElement array.\n     * When the <b>path</b> parameter is specified, then it will return all children that match that path.\n     * The path is a series of elements and sub-elements, separated by slashes.\n     *\n     * @param {String} path       element name or path/to/element\n     *\n     * @return {XMLElement} array of child elements that match\n     *\n     * @see XMLElement#getChildCount()\n     * @see XMLElement#getChild()\n     */\n    getChildren: function(){\n      if (arguments.length === 1) {\n        if (typeof arguments[0] === \"number\") {\n          return this.getChild( arguments[0]);\n        }\n        if (arguments[0].indexOf('/') !== -1) { // path was given\n          return this.getChildrenRecursive( arguments[0].split(\"/\"), 0);\n        }\n        var matches = [];\n        var kid, kidName;\n        for (var i = 0, j = this.getChildCount(); i < j; i++) {\n          kid = this.getChild(i);\n          kidName = kid.getName();\n          if (kidName !== null && kidName === arguments[0]) {\n            matches.push(kid);\n          }\n        }\n        return matches;\n      }\n      return this.children;\n    },\n    /**\n     * @member XMLElement\n     * The getChildCount() returns the number of children for the element.\n     *\n     * @return {int} the count\n     *\n     * @see XMLElement#getChild()\n     * @see XMLElement#getChildren()\n     */\n    getChildCount: function() {\n      return this.children.length;\n    },\n    /**\n     * @member XMLElement\n     * Internal helper function for getChild().\n     *\n     * @param {String[]} items   result of splitting the query on slashes\n     * @param {int} offset   where in the items[] array we're currently looking\n     *\n     * @return {XMLElement} matching element or null if no match\n     */\n    getChildRecursive: function (items, offset) {\n      // terminating clause: we are the requested candidate\n      if (offset === items.length) {\n        return this;\n      }\n      // continuation clause\n      var kid, kidName, matchName = items[offset];\n      for(var i = 0, j = this.getChildCount(); i < j; i++) {\n          kid = this.getChild(i);\n          kidName = kid.getName();\n          if (kidName !== null && kidName === matchName) {\n            return kid.getChildRecursive(items, offset+1);\n          }\n      }\n      return null;\n    },\n    /**\n     * @member XMLElement\n     * Internal helper function for getChildren().\n     *\n     * @param {String[]} items   result of splitting the query on slashes\n     * @param {int} offset   where in the items[] array we're currently looking\n     *\n     * @return {XMLElement[]} matching elements or empty array if no match\n     */\n    getChildrenRecursive: function (items, offset) {\n      if (offset === items.length-1) {\n        return this.getChildren(items[offset]);\n      }\n      var matches = this.getChildren(items[offset]);\n      var kidMatches = [];\n      for (var i = 0; i < matches.length; i++) {\n        kidMatches = kidMatches.concat(matches[i].getChildrenRecursive(items, offset+1));\n      }\n      return kidMatches;\n    },\n    /**\n     * @member XMLElement\n     * The isLeaf() function returns whether the element is a leaf element.\n     *\n     * @return {boolean} true if the element has no children.\n     */\n    isLeaf: function() {\n      return !this.hasChildren();\n    },\n    /**\n     * @member XMLElement\n     * The listChildren() function put the names of all children into an array. Same as looping through\n     * each child and calling getName() on each XMLElement.\n     *\n     * @return {String[]} a list of element names.\n     */\n    listChildren: function() {\n      var arr = [];\n      for (var i = 0, j = this.children.length; i < j; i++) {\n        arr.push( this.getChild(i).getName());\n      }\n      return arr;\n    },\n    /**\n     * @member XMLElement\n     * The removeAttribute() function removes an attribute\n     *\n     * @param {String} name        the non-null name of the attribute.\n     * @param {String} namespace   the namespace URI of the attribute, which may be null.\n     */\n    removeAttribute: function (name , namespace) {\n      this.namespace = namespace || \"\";\n      for (var i = 0, j = this.attributes.length; i < j; i++) {\n        if (this.attributes[i].getName() === name && this.attributes[i].getNamespace() === this.namespace) {\n          this.attributes.splice(i, 1);\n          break;\n        }\n      }\n    },\n    /**\n     * @member XMLElement\n     * The removeChild() removes a child element.\n     *\n     * @param {XMLElement} child      the the non-null child to be renoved\n     */\n    removeChild: function(child) {\n      if (child) {\n        for (var i = 0, j = this.children.length; i < j; i++) {\n          if (this.children[i].equals(child)) {\n            this.children.splice(i, 1);\n            break;\n          }\n        }\n      }\n    },\n    /**\n     * @member XMLElement\n     * The removeChildAtIndex() removes the child located at a certain index\n     *\n     * @param {int} index      the index of the child, where the first child has index 0\n     */\n    removeChildAtIndex: function(index) {\n      if (this.children.length > index) { //make sure its not outofbounds\n        this.children.splice(index, 1);\n      }\n    },\n    /**\n     * @member XMLElement\n     * The findAttribute() function searches an attribute\n     *\n     * @param {String} name        fullName the non-null full name of the attribute\n     * @param {String} namespace   the name space, which may be null\n     *\n     * @return {XMLAttribute} the attribute, or null if the attribute does not exist.\n     */\n    findAttribute: function (name, namespace) {\n      this.namespace = namespace || \"\";\n      for (var i = 0, j = this.attributes.length; i < j; i++) {\n        if (this.attributes[i].getName() === name && this.attributes[i].getNamespace() === this.namespace) {\n           return this.attributes[i];\n        }\n      }\n      return null;\n    },\n    /**\n     * @member XMLElement\n     * The setAttribute() function sets an attribute.\n     *\n     * @param {String} name        the non-null full name of the attribute\n     * @param {String} namespace   the non-null value of the attribute\n     */\n    setAttribute: function() {\n      var attr;\n      if (arguments.length === 3) {\n        var index = arguments[0].indexOf(':');\n        var name  = arguments[0].substring(index + 1);\n        attr      = this.findAttribute(name, arguments[1]);\n        if (attr) {\n          attr.setValue(arguments[2]);\n        } else {\n          attr = new XMLAttribute(arguments[0], name, arguments[1], arguments[2], \"CDATA\");\n          this.attributes.push(attr);\n        }\n      } else {\n        attr = this.findAttribute(arguments[0]);\n        if (attr) {\n          attr.setValue(arguments[1]);\n        } else {\n          attr = new XMLAttribute(arguments[0], arguments[0], null, arguments[1], \"CDATA\");\n          this.attributes.push(attr);\n        }\n      }\n    },\n    /**\n     * Processing 1.5 XML API wrapper for the generic String\n     * attribute setter. This must take two arguments.\n     */\n    setString: function(attribute, value) {\n      this.setAttribute(attribute, value);\n    },\n    /**\n     * Processing 1.5 XML API wrapper for the generic int\n     * attribute setter. This must take two arguments.\n     */\n    setInt: function(attribute, value) {\n      this.setAttribute(attribute, value);\n    },\n    /**\n     * Processing 1.5 XML API wrapper for the generic float\n     * attribute setter. This must take two arguments.\n     */\n    setFloat: function(attribute, value) {\n      this.setAttribute(attribute, value);\n    },\n    /**\n     * @member XMLElement\n     * The setContent() function sets the #PCDATA content. It is an error to call this method with a\n     * non-null value if there are child objects.\n     *\n     * @param {String} content     the (possibly null) content\n     */\n    setContent: function(content) {\n      if (this.children.length > 0) {\n        Processing.debug(\"Tried to set content for XMLElement with children\"); }\n      this.content = content;\n    },\n    /**\n     * @member XMLElement\n     * The setName() function sets the full name. This method also sets the short name and clears the\n     * namespace URI.\n     *\n     * @param {String} name        the non-null name\n     * @param {String} namespace   the namespace URI, which may be null.\n     */\n    setName: function() {\n      if (arguments.length === 1) {\n        this.name      = arguments[0];\n        this.fullName  = arguments[0];\n        this.namespace = null;\n      } else {\n        var index = arguments[0].indexOf(':');\n        if ((arguments[1] === null) || (index < 0)) {\n            this.name = arguments[0];\n        } else {\n            this.name = arguments[0].substring(index + 1);\n        }\n        this.fullName  = arguments[0];\n        this.namespace = arguments[1];\n      }\n    },\n    /**\n     * @member XMLElement\n     * The getName() function returns the full name (i.e. the name including an eventual namespace\n     * prefix) of the element.\n     *\n     * @return {String} the name, or null if the element only contains #PCDATA.\n     */\n    getName: function() {\n      return this.fullName;\n    },\n    /**\n     * @member XMLElement\n     * The getLocalName() function returns the local name (i.e. the name excluding an eventual namespace\n     * prefix) of the element.\n     *\n     * @return {String} the name, or null if the element only contains #PCDATA.\n     */\n    getLocalName: function() {\n      return this.name;\n    },\n    /**\n     * @member XMLElement\n     * The getAttributeCount() function returns the number of attributes for the node\n     * that this XMLElement represents.\n     *\n     * @return {int} the number of attributes in this XMLElement\n     */\n    getAttributeCount: function() {\n      return this.attributes.length;\n    },\n    /**\n     * @member XMLElement\n     * The toString() function returns the XML definition of an XMLElement.\n     *\n     * @return {String} the XML definition of this XMLElement\n     */\n    toString: function() {\n      // shortcut for text and cdata nodes\n      if (this.type === \"TEXT\") {\n        return this.content || \"\";\n      }\n\n      if (this.type === \"CDATA\") {\n        return this.cdata || \"\";\n      }\n\n      // real XMLElements\n      var tagstring = this.fullName;\n      var xmlstring =  \"<\" + tagstring;\n      var a,c;\n\n      // serialize the attributes to XML string\n      for (a = 0; a<this.attributes.length; a++) {\n        var attr = this.attributes[a];\n        xmlstring += \" \"  + attr.getName() + \"=\" + '\"' + attr.getValue() + '\"';\n      }\n\n      // serialize all children to XML string\n      if (this.children.length === 0) {\n        if (this.content === \"\" || this.content === null || this.content === undefined) {\n          xmlstring += \"/>\";\n        } else {\n          xmlstring += \">\" + this.content + \"</\"+tagstring+\">\";\n        }\n      } else {\n        xmlstring += \">\";\n        for (c = 0; c<this.children.length; c++) {\n          xmlstring += this.children[c].toString();\n        }\n        xmlstring += \"</\" + tagstring + \">\";\n      }\n      return xmlstring;\n     }\n  };\n\n  /**\n   * static Processing 1.5 XML API wrapper for the\n   * parse method. This may only take one argument.\n   */\n  XMLElement.parse = function(xmlstring) {\n    var element = new XMLElement();\n    element.parse(xmlstring);\n    return element;\n  };\n\n  return XMLElement;\n};\n\n},{}],21:[function(require,module,exports){\n/**\n * web colors, by name\n */\nmodule.exports = {\n    aliceblue:            \"#f0f8ff\",\n    antiquewhite:         \"#faebd7\",\n    aqua:                 \"#00ffff\",\n    aquamarine:           \"#7fffd4\",\n    azure:                \"#f0ffff\",\n    beige:                \"#f5f5dc\",\n    bisque:               \"#ffe4c4\",\n    black:                \"#000000\",\n    blanchedalmond:       \"#ffebcd\",\n    blue:                 \"#0000ff\",\n    blueviolet:           \"#8a2be2\",\n    brown:                \"#a52a2a\",\n    burlywood:            \"#deb887\",\n    cadetblue:            \"#5f9ea0\",\n    chartreuse:           \"#7fff00\",\n    chocolate:            \"#d2691e\",\n    coral:                \"#ff7f50\",\n    cornflowerblue:       \"#6495ed\",\n    cornsilk:             \"#fff8dc\",\n    crimson:              \"#dc143c\",\n    cyan:                 \"#00ffff\",\n    darkblue:             \"#00008b\",\n    darkcyan:             \"#008b8b\",\n    darkgoldenrod:        \"#b8860b\",\n    darkgray:             \"#a9a9a9\",\n    darkgreen:            \"#006400\",\n    darkkhaki:            \"#bdb76b\",\n    darkmagenta:          \"#8b008b\",\n    darkolivegreen:       \"#556b2f\",\n    darkorange:           \"#ff8c00\",\n    darkorchid:           \"#9932cc\",\n    darkred:              \"#8b0000\",\n    darksalmon:           \"#e9967a\",\n    darkseagreen:         \"#8fbc8f\",\n    darkslateblue:        \"#483d8b\",\n    darkslategray:        \"#2f4f4f\",\n    darkturquoise:        \"#00ced1\",\n    darkviolet:           \"#9400d3\",\n    deeppink:             \"#ff1493\",\n    deepskyblue:          \"#00bfff\",\n    dimgray:              \"#696969\",\n    dodgerblue:           \"#1e90ff\",\n    firebrick:            \"#b22222\",\n    floralwhite:          \"#fffaf0\",\n    forestgreen:          \"#228b22\",\n    fuchsia:              \"#ff00ff\",\n    gainsboro:            \"#dcdcdc\",\n    ghostwhite:           \"#f8f8ff\",\n    gold:                 \"#ffd700\",\n    goldenrod:            \"#daa520\",\n    gray:                 \"#808080\",\n    green:                \"#008000\",\n    greenyellow:          \"#adff2f\",\n    honeydew:             \"#f0fff0\",\n    hotpink:              \"#ff69b4\",\n    indianred:            \"#cd5c5c\",\n    indigo:               \"#4b0082\",\n    ivory:                \"#fffff0\",\n    khaki:                \"#f0e68c\",\n    lavender:             \"#e6e6fa\",\n    lavenderblush:        \"#fff0f5\",\n    lawngreen:            \"#7cfc00\",\n    lemonchiffon:         \"#fffacd\",\n    lightblue:            \"#add8e6\",\n    lightcoral:           \"#f08080\",\n    lightcyan:            \"#e0ffff\",\n    lightgoldenrodyellow: \"#fafad2\",\n    lightgrey:            \"#d3d3d3\",\n    lightgreen:           \"#90ee90\",\n    lightpink:            \"#ffb6c1\",\n    lightsalmon:          \"#ffa07a\",\n    lightseagreen:        \"#20b2aa\",\n    lightskyblue:         \"#87cefa\",\n    lightslategray:       \"#778899\",\n    lightsteelblue:       \"#b0c4de\",\n    lightyellow:          \"#ffffe0\",\n    lime:                 \"#00ff00\",\n    limegreen:            \"#32cd32\",\n    linen:                \"#faf0e6\",\n    magenta:              \"#ff00ff\",\n    maroon:               \"#800000\",\n    mediumaquamarine:     \"#66cdaa\",\n    mediumblue:           \"#0000cd\",\n    mediumorchid:         \"#ba55d3\",\n    mediumpurple:         \"#9370d8\",\n    mediumseagreen:       \"#3cb371\",\n    mediumslateblue:      \"#7b68ee\",\n    mediumspringgreen:    \"#00fa9a\",\n    mediumturquoise:      \"#48d1cc\",\n    mediumvioletred:      \"#c71585\",\n    midnightblue:         \"#191970\",\n    mintcream:            \"#f5fffa\",\n    mistyrose:            \"#ffe4e1\",\n    moccasin:             \"#ffe4b5\",\n    navajowhite:          \"#ffdead\",\n    navy:                 \"#000080\",\n    oldlace:              \"#fdf5e6\",\n    olive:                \"#808000\",\n    olivedrab:            \"#6b8e23\",\n    orange:               \"#ffa500\",\n    orangered:            \"#ff4500\",\n    orchid:               \"#da70d6\",\n    palegoldenrod:        \"#eee8aa\",\n    palegreen:            \"#98fb98\",\n    paleturquoise:        \"#afeeee\",\n    palevioletred:        \"#d87093\",\n    papayawhip:           \"#ffefd5\",\n    peachpuff:            \"#ffdab9\",\n    peru:                 \"#cd853f\",\n    pink:                 \"#ffc0cb\",\n    plum:                 \"#dda0dd\",\n    powderblue:           \"#b0e0e6\",\n    purple:               \"#800080\",\n    red:                  \"#ff0000\",\n    rosybrown:            \"#bc8f8f\",\n    royalblue:            \"#4169e1\",\n    saddlebrown:          \"#8b4513\",\n    salmon:               \"#fa8072\",\n    sandybrown:           \"#f4a460\",\n    seagreen:             \"#2e8b57\",\n    seashell:             \"#fff5ee\",\n    sienna:               \"#a0522d\",\n    silver:               \"#c0c0c0\",\n    skyblue:              \"#87ceeb\",\n    slateblue:            \"#6a5acd\",\n    slategray:            \"#708090\",\n    snow:                 \"#fffafa\",\n    springgreen:          \"#00ff7f\",\n    steelblue:            \"#4682b4\",\n    tan:                  \"#d2b48c\",\n    teal:                 \"#008080\",\n    thistle:              \"#d8bfd8\",\n    tomato:               \"#ff6347\",\n    turquoise:            \"#40e0d0\",\n    violet:               \"#ee82ee\",\n    wheat:                \"#f5deb3\",\n    white:                \"#ffffff\",\n    whitesmoke:           \"#f5f5f5\",\n    yellow:               \"#ffff00\",\n    yellowgreen:          \"#9acd32\"\n  };\n\n},{}],22:[function(require,module,exports){\nmodule.exports = function(virtHashCode, virtEquals, undef) {\n\n  return function withProxyFunctions(p, removeFirstArgument) {\n    /**\n     * The contains(string) function returns true if the string passed in the parameter\n     * is a substring of this string. It returns false if the string passed\n     * in the parameter is not a substring of this string.\n     *\n     * @param {String} The string to look for in the current string\n     *\n     * @return {boolean} returns true if this string contains\n     * the string passed as parameter. returns false, otherwise.\n     *\n     */\n    p.__contains = function (subject, subStr) {\n      if (typeof subject !== \"string\") {\n        return subject.contains.apply(subject, removeFirstArgument(arguments));\n      }\n      //Parameter is not null AND\n      //The type of the parameter is the same as this object (string)\n      //The javascript function that finds a substring returns 0 or higher\n      return (\n        (subject !== null) &&\n        (subStr !== null) &&\n        (typeof subStr === \"string\") &&\n        (subject.indexOf(subStr) > -1)\n      );\n    };\n\n    /**\n     * The __replaceAll() function searches all matches between a substring (or regular expression) and a string,\n     * and replaces the matched substring with a new substring\n     *\n     * @param {String} subject    a substring\n     * @param {String} regex      a substring or a regular expression\n     * @param {String} replace    the string to replace the found value\n     *\n     * @return {String} returns result\n     *\n     * @see #match\n     */\n    p.__replaceAll = function(subject, regex, replacement) {\n      if (typeof subject !== \"string\") {\n        return subject.replaceAll.apply(subject, removeFirstArgument(arguments));\n      }\n\n      return subject.replace(new RegExp(regex, \"g\"), replacement);\n    };\n\n    /**\n     * The __replaceFirst() function searches first matche between a substring (or regular expression) and a string,\n     * and replaces the matched substring with a new substring\n     *\n     * @param {String} subject    a substring\n     * @param {String} regex      a substring or a regular expression\n     * @param {String} replace    the string to replace the found value\n     *\n     * @return {String} returns result\n     *\n     * @see #match\n     */\n    p.__replaceFirst = function(subject, regex, replacement) {\n      if (typeof subject !== \"string\") {\n        return subject.replaceFirst.apply(subject, removeFirstArgument(arguments));\n      }\n\n      return subject.replace(new RegExp(regex, \"\"), replacement);\n    };\n\n    /**\n     * The __replace() function searches all matches between a substring and a string,\n     * and replaces the matched substring with a new substring\n     *\n     * @param {String} subject         a substring\n     * @param {String} what         a substring to find\n     * @param {String} replacement    the string to replace the found value\n     *\n     * @return {String} returns result\n     */\n    p.__replace = function(subject, what, replacement) {\n      if (typeof subject !== \"string\") {\n        return subject.replace.apply(subject, removeFirstArgument(arguments));\n      }\n      if (what instanceof RegExp) {\n        return subject.replace(what, replacement);\n      }\n\n      if (typeof what !== \"string\") {\n        what = what.toString();\n      }\n      if (what === \"\") {\n        return subject;\n      }\n\n      var i = subject.indexOf(what);\n      if (i < 0) {\n        return subject;\n      }\n\n      var j = 0, result = \"\";\n      do {\n        result += subject.substring(j, i) + replacement;\n        j = i + what.length;\n      } while ( (i = subject.indexOf(what, j)) >= 0);\n      return result + subject.substring(j);\n    };\n\n    /**\n     * The __equals() function compares two strings (or objects) to see if they are the same.\n     * This method is necessary because it's not possible to compare strings using the equality operator (==).\n     * Returns true if the strings are the same and false if they are not.\n     *\n     * @param {String} subject  a string used for comparison\n     * @param {String} other  a string used for comparison with\n     *\n     * @return {boolean} true is the strings are the same false otherwise\n     */\n    p.__equals = function(subject, other) {\n      if (subject.equals instanceof Function) {\n        return subject.equals.apply(subject, removeFirstArgument(arguments));\n      }\n\n      return virtEquals(subject, other);\n    };\n\n    /**\n     * The __equalsIgnoreCase() function compares two strings to see if they are the same.\n     * Returns true if the strings are the same, either when forced to all lower case or\n     * all upper case.\n     *\n     * @param {String} subject  a string used for comparison\n     * @param {String} other  a string used for comparison with\n     *\n     * @return {boolean} true is the strings are the same, ignoring case. false otherwise\n     */\n    p.__equalsIgnoreCase = function(subject, other) {\n      if (typeof subject !== \"string\") {\n        return subject.equalsIgnoreCase.apply(subject, removeFirstArgument(arguments));\n      }\n\n      return subject.toLowerCase() === other.toLowerCase();\n    };\n\n    /**\n     * The __toCharArray() function splits the string into a char array.\n     *\n     * @param {String} subject The string\n     *\n     * @return {Char[]} a char array\n     */\n    p.__toCharArray = function(subject) {\n      if (typeof subject !== \"string\") {\n        return subject.toCharArray.apply(subject, removeFirstArgument(arguments));\n      }\n\n      var chars = [];\n      for (var i = 0, len = subject.length; i < len; ++i) {\n        chars[i] = new Char(subject.charAt(i));\n      }\n      return chars;\n    };\n\n    /**\n     * The __split() function splits a string using the regex delimiter\n     * specified. If limit is specified, the resultant array will have number\n     * of elements equal to or less than the limit.\n     *\n     * @param {String} subject string to be split\n     * @param {String} regexp  regex string used to split the subject\n     * @param {int}    limit   max number of tokens to be returned\n     *\n     * @return {String[]} an array of tokens from the split string\n     */\n    p.__split = function(subject, regex, limit) {\n      if (typeof subject !== \"string\") {\n        return subject.split.apply(subject, removeFirstArgument(arguments));\n      }\n\n      var pattern = new RegExp(regex);\n\n      // If limit is not specified, use JavaScript's built-in String.split.\n      if ((limit === undef) || (limit < 1)) {\n        return subject.split(pattern);\n      }\n\n      // If limit is specified, JavaScript's built-in String.split has a\n      // different behaviour than Java's. A Java-compatible implementation is\n      // provided here.\n      var result = [], currSubject = subject, pos;\n      while (((pos = currSubject.search(pattern)) !== -1) && (result.length < (limit - 1))) {\n        var match = pattern.exec(currSubject).toString();\n        result.push(currSubject.substring(0, pos));\n        currSubject = currSubject.substring(pos + match.length);\n      }\n      if ((pos !== -1) || (currSubject !== \"\")) {\n        result.push(currSubject);\n      }\n      return result;\n    };\n\n    /**\n     * The codePointAt() function returns the unicode value of the character at a given index of a string.\n     *\n     * @param  {int} idx         the index of the character\n     *\n     * @return {String} code     the String containing the unicode value of the character\n     */\n    p.__codePointAt = function(subject, idx) {\n      var code = subject.charCodeAt(idx),\n          hi,\n          low;\n      if (0xD800 <= code && code <= 0xDBFF) {\n        hi = code;\n        low = subject.charCodeAt(idx + 1);\n        return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;\n      }\n      return code;\n    };\n\n    /**\n     * The matches() function checks whether or not a string matches a given regular expression.\n     *\n     * @param {String} str      the String on which the match is tested\n     * @param {String} regexp   the regexp for which a match is tested\n     *\n     * @return {boolean} true if the string fits the regexp, false otherwise\n     */\n    p.__matches = function(str, regexp) {\n      return (new RegExp(regexp)).test(str);\n    };\n\n    /**\n     * The startsWith() function tests if a string starts with the specified prefix.  If the prefix\n     * is the empty String or equal to the subject String, startsWith() will also return true.\n     *\n     * @param {String} prefix   the String used to compare against the start of the subject String.\n     * @param {int}    toffset  (optional) an offset into the subject String where searching should begin.\n     *\n     * @return {boolean} true if the subject String starts with the prefix.\n     */\n    p.__startsWith = function(subject, prefix, toffset) {\n      if (typeof subject !== \"string\") {\n        return subject.startsWith.apply(subject, removeFirstArgument(arguments));\n      }\n\n      toffset = toffset || 0;\n      if (toffset < 0 || toffset > subject.length) {\n        return false;\n      }\n      return (prefix === '' || prefix === subject) ? true : (subject.indexOf(prefix) === toffset);\n    };\n\n    /**\n     * The endsWith() function tests if a string ends with the specified suffix.  If the suffix\n     * is the empty String, endsWith() will also return true.\n     *\n     * @param {String} suffix   the String used to compare against the end of the subject String.\n     *\n     * @return {boolean} true if the subject String starts with the prefix.\n     */\n    p.__endsWith = function(subject, suffix) {\n      if (typeof subject !== \"string\") {\n        return subject.endsWith.apply(subject, removeFirstArgument(arguments));\n      }\n\n      var suffixLen = suffix ? suffix.length : 0;\n      return (suffix === '' || suffix === subject) ? true :\n        (subject.indexOf(suffix) === subject.length - suffixLen);\n    };\n\n    /**\n     * The returns hash code of the.\n     *\n     * @param {Object} subject The string\n     *\n     * @return {int} a hash code\n     */\n    p.__hashCode = function(subject) {\n      if (subject.hashCode instanceof Function) {\n        return subject.hashCode.apply(subject, removeFirstArgument(arguments));\n      }\n      return virtHashCode(subject);\n    };\n\n    /**\n     * The __printStackTrace() prints stack trace to the console.\n     *\n     * @param {Exception} subject The error\n     */\n    p.__printStackTrace = function(subject) {\n      p.println(\"Exception: \" + subject.toString() );\n    };\n  };\n\n};\n\n},{}],23:[function(require,module,exports){\n/**\n * For many \"math\" functions, we can delegate\n * to the Math object. For others, we can't.\n */\nmodule.exports = function withMath(p, undef) {\n  var internalRandomGenerator = function() { return Math.random(); };\n\n  /**\n  * Calculates the absolute value (magnitude) of a number. The absolute value of a number is always positive.\n  *\n  * @param {int|float} value   int or float\n  *\n  * @returns {int|float}\n  */\n  p.abs = Math.abs;\n\n  /**\n  * Calculates the closest int value that is greater than or equal to the value of the parameter.\n  * For example, ceil(9.03) returns the value 10.\n  *\n  * @param {float} value   float\n  *\n  * @returns {int}\n  *\n  * @see floor\n  * @see round\n  */\n  p.ceil = Math.ceil;\n\n  /**\n  * Returns Euler's number e (2.71828...) raised to the power of the value parameter.\n  *\n  * @param {int|float} value   int or float: the exponent to raise e to\n  *\n  * @returns {float}\n  */\n  p.exp = Math.exp;\n\n  /**\n  * Calculates the closest int value that is less than or equal to the value of the parameter.\n  *\n  * @param {int|float} value        the value to floor\n  *\n  * @returns {int|float}\n  *\n  * @see ceil\n  * @see round\n  */\n  p.floor = Math.floor;\n\n  /**\n  * Calculates the natural logarithm (the base-e logarithm) of a number. This function\n  * expects the values greater than 0.0.\n  *\n  * @param {int|float} value        int or float: number must be greater then 0.0\n  *\n  * @returns {float}\n  */\n  p.log = Math.log;\n\n  /**\n  * Facilitates exponential expressions. The pow() function is an efficient way of\n  * multiplying numbers by themselves (or their reciprocal) in large quantities.\n  * For example, pow(3, 5) is equivalent to the expression 3*3*3*3*3 and pow(3, -5)\n  * is equivalent to 1 / 3*3*3*3*3.\n  *\n  * @param {int|float} num        base of the exponential expression\n  * @param {int|float} exponent   power of which to raise the base\n  *\n  * @returns {float}\n  *\n  * @see sqrt\n  */\n  p.pow = Math.pow;\n\n  /**\n  * Calculates the integer closest to the value parameter. For example, round(9.2) returns the value 9.\n  *\n  * @param {float} value        number to round\n  *\n  * @returns {int}\n  *\n  * @see floor\n  * @see ceil\n  */\n  p.round = Math.round;\n  /**\n  * Calculates the square root of a number. The square root of a number is always positive,\n  * even though there may be a valid negative root. The square root s of number a is such\n  * that s*s = a. It is the opposite of squaring.\n  *\n  * @param {float} value        int or float, non negative\n  *\n  * @returns {float}\n  *\n  * @see pow\n  * @see sq\n  */\n\n  p.sqrt = Math.sqrt;\n\n  // Trigonometry\n  /**\n  * The inverse of cos(), returns the arc cosine of a value. This function expects the\n  * values in the range of -1 to 1 and values are returned in the range 0 to PI (3.1415927).\n  *\n  * @param {float} value        the value whose arc cosine is to be returned\n  *\n  * @returns {float}\n  *\n  * @see cos\n  * @see asin\n  * @see atan\n  */\n  p.acos = Math.acos;\n\n  /**\n  * The inverse of sin(), returns the arc sine of a value. This function expects the values\n  * in the range of -1 to 1 and values are returned in the range -PI/2 to PI/2.\n  *\n  * @param {float} value        the value whose arc sine is to be returned\n  *\n  * @returns {float}\n  *\n  * @see sin\n  * @see acos\n  * @see atan\n  */\n  p.asin = Math.asin;\n\n  /**\n  * The inverse of tan(), returns the arc tangent of a value. This function expects the values\n  * in the range of -Infinity to Infinity (exclusive) and values are returned in the range -PI/2 to PI/2 .\n  *\n  * @param {float} value        -Infinity to Infinity (exclusive)\n  *\n  * @returns {float}\n  *\n  * @see tan\n  * @see asin\n  * @see acos\n  */\n  p.atan = Math.atan;\n\n  /**\n  * Calculates the angle (in radians) from a specified point to the coordinate origin as measured from\n  * the positive x-axis. Values are returned as a float in the range from PI to -PI. The atan2() function\n  * is most often used for orienting geometry to the position of the cursor. Note: The y-coordinate of the\n  * point is the first parameter and the x-coordinate is the second due the the structure of calculating the tangent.\n  *\n  * @param {float} y        y-coordinate of the point\n  * @param {float} x        x-coordinate of the point\n  *\n  * @returns {float}\n  *\n  * @see tan\n  */\n  p.atan2 = Math.atan2;\n\n  /**\n  * Calculates the cosine of an angle. This function expects the values of the angle parameter to be provided\n  * in radians (values from 0 to PI*2). Values are returned in the range -1 to 1.\n  *\n  * @param {float} value        an angle in radians\n  *\n  * @returns {float}\n  *\n  * @see tan\n  * @see sin\n  */\n  p.cos = Math.cos;\n\n  /**\n  * Calculates the sine of an angle. This function expects the values of the angle parameter to be provided in\n  * radians (values from 0 to 6.28). Values are returned in the range -1 to 1.\n  *\n  * @param {float} value        an angle in radians\n  *\n  * @returns {float}\n  *\n  * @see cos\n  * @see radians\n  */\n  p.sin = Math.sin;\n\n  /**\n  * Calculates the ratio of the sine and cosine of an angle. This function expects the values of the angle\n  * parameter to be provided in radians (values from 0 to PI*2). Values are returned in the range infinity to -infinity.\n  *\n  * @param {float} value        an angle in radians\n  *\n  * @returns {float}\n  *\n  * @see cos\n  * @see sin\n  * @see radians\n  */\n  p.tan = Math.tan;\n\n  /**\n  * Constrains a value to not exceed a maximum and minimum value.\n  *\n  * @param {int|float} value   the value to constrain\n  * @param {int|float} value   minimum limit\n  * @param {int|float} value   maximum limit\n  *\n  * @returns {int|float}\n  *\n  * @see max\n  * @see min\n  */\n  p.constrain = function(aNumber, aMin, aMax) {\n    return aNumber > aMax ? aMax : aNumber < aMin ? aMin : aNumber;\n  };\n\n  /**\n  * Calculates the distance between two points.\n  *\n  * @param {int|float} x1     int or float: x-coordinate of the first point\n  * @param {int|float} y1     int or float: y-coordinate of the first point\n  * @param {int|float} z1     int or float: z-coordinate of the first point\n  * @param {int|float} x2     int or float: x-coordinate of the second point\n  * @param {int|float} y2     int or float: y-coordinate of the second point\n  * @param {int|float} z2     int or float: z-coordinate of the second point\n  *\n  * @returns {float}\n  */\n  p.dist = function() {\n    var dx, dy, dz;\n    if (arguments.length === 4) {\n      dx = arguments[0] - arguments[2];\n      dy = arguments[1] - arguments[3];\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n    if (arguments.length === 6) {\n      dx = arguments[0] - arguments[3];\n      dy = arguments[1] - arguments[4];\n      dz = arguments[2] - arguments[5];\n      return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n  };\n\n  /**\n  * Calculates a number between two numbers at a specific increment. The amt  parameter is the\n  * amount to interpolate between the two values where 0.0 equal to the first point, 0.1 is very\n  * near the first point, 0.5 is half-way in between, etc. The lerp function is convenient for\n  * creating motion along a straight path and for drawing dotted lines.\n  *\n  * @param {int|float} value1       float or int: first value\n  * @param {int|float} value2       float or int: second value\n  * @param {int|float} amt          float: between 0.0 and 1.0\n  *\n  * @returns {float}\n  *\n  * @see curvePoint\n  * @see bezierPoint\n  */\n  p.lerp = function(value1, value2, amt) {\n    return ((value2 - value1) * amt) + value1;\n  };\n\n  /**\n  * Calculates the magnitude (or length) of a vector. A vector is a direction in space commonly\n  * used in computer graphics and linear algebra. Because it has no \"start\" position, the magnitude\n  * of a vector can be thought of as the distance from coordinate (0,0) to its (x,y) value.\n  * Therefore, mag() is a shortcut for writing \"dist(0, 0, x, y)\".\n  *\n  * @param {int|float} a       float or int: first value\n  * @param {int|float} b       float or int: second value\n  * @param {int|float} c       float or int: third value\n  *\n  * @returns {float}\n  *\n  * @see dist\n  */\n  p.mag = function(a, b, c) {\n    if (c) {\n      return Math.sqrt(a * a + b * b + c * c);\n    }\n\n    return Math.sqrt(a * a + b * b);\n  };\n\n  /**\n  * Re-maps a number from one range to another. In the example above, the number '25' is converted from\n  * a value in the range 0..100 into a value that ranges from the left edge (0) to the right edge (width) of the screen.\n  * Numbers outside the range are not clamped to 0 and 1, because out-of-range values are often intentional and useful.\n  *\n  * @param {float} value        The incoming value to be converted\n  * @param {float} istart       Lower bound of the value's current range\n  * @param {float} istop        Upper bound of the value's current range\n  * @param {float} ostart       Lower bound of the value's target range\n  * @param {float} ostop        Upper bound of the value's target range\n  *\n  * @returns {float}\n  *\n  * @see norm\n  * @see lerp\n  */\n  p.map = function(value, istart, istop, ostart, ostop) {\n    return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));\n  };\n\n  /**\n  * Determines the largest value in a sequence of numbers.\n  *\n  * @param {int|float} value1         int or float\n  * @param {int|float} value2         int or float\n  * @param {int|float} value3         int or float\n  * @param {int|float} array          int or float array\n  *\n  * @returns {int|float}\n  *\n  * @see min\n  */\n  p.max = function() {\n    if (arguments.length === 2) {\n      return arguments[0] < arguments[1] ? arguments[1] : arguments[0];\n    }\n    var numbers = arguments.length === 1 ? arguments[0] : arguments; // if single argument, array is used\n    if (! (\"length\" in numbers && numbers.length > 0)) {\n      throw \"Non-empty array is expected\";\n    }\n    var max = numbers[0],\n      count = numbers.length;\n    for (var i = 1; i < count; ++i) {\n      if (max < numbers[i]) {\n        max = numbers[i];\n      }\n    }\n    return max;\n  };\n\n  /**\n  * Determines the smallest value in a sequence of numbers.\n  *\n  * @param {int|float} value1         int or float\n  * @param {int|float} value2         int or float\n  * @param {int|float} value3         int or float\n  * @param {int|float} array          int or float array\n  *\n  * @returns {int|float}\n  *\n  * @see max\n  */\n  p.min = function() {\n    if (arguments.length === 2) {\n      return arguments[0] < arguments[1] ? arguments[0] : arguments[1];\n    }\n    var numbers = arguments.length === 1 ? arguments[0] : arguments; // if single argument, array is used\n    if (! (\"length\" in numbers && numbers.length > 0)) {\n      throw \"Non-empty array is expected\";\n    }\n    var min = numbers[0],\n      count = numbers.length;\n    for (var i = 1; i < count; ++i) {\n      if (min > numbers[i]) {\n        min = numbers[i];\n      }\n    }\n    return min;\n  };\n\n  /**\n  * Normalizes a number from another range into a value between 0 and 1.\n  * Identical to map(value, low, high, 0, 1);\n  * Numbers outside the range are not clamped to 0 and 1, because out-of-range\n  * values are often intentional and useful.\n  *\n  * @param {float} aNumber    The incoming value to be converted\n  * @param {float} low        Lower bound of the value's current range\n  * @param {float} high       Upper bound of the value's current range\n  *\n  * @returns {float}\n  *\n  * @see map\n  * @see lerp\n  */\n  p.norm = function(aNumber, low, high) {\n    return (aNumber - low) / (high - low);\n  };\n\n  /**\n  * Squares a number (multiplies a number by itself). The result is always a positive number,\n  * as multiplying two negative numbers always yields a positive result. For example, -1 * -1 = 1.\n  *\n  * @param {float} value        int or float\n  *\n  * @returns {float}\n  *\n  * @see sqrt\n  */\n  p.sq = function(aNumber) {\n    return aNumber * aNumber;\n  };\n\n  /**\n  * Converts a radian measurement to its corresponding value in degrees. Radians and degrees are two ways of\n  * measuring the same thing. There are 360 degrees in a circle and 2*PI radians in a circle. For example,\n  * 90 degrees = PI/2 = 1.5707964. All trigonometric methods in Processing require their parameters to be specified in radians.\n  *\n  * @param {int|float} value        an angle in radians\n  *\n  * @returns {float}\n  *\n  * @see radians\n  */\n  p.degrees = function(aAngle) {\n    return (aAngle * 180) / Math.PI;\n  };\n\n  /**\n  * Generates random numbers. Each time the random() function is called, it returns an unexpected value within\n  * the specified range. If one parameter is passed to the function it will return a float between zero and the\n  * value of the high parameter. The function call random(5) returns values between 0 and 5 (starting at zero,\n  * up to but not including 5). If two parameters are passed, it will return a float with a value between the\n  * parameters. The function call random(-5, 10.2) returns values starting at -5 up to (but not including) 10.2.\n  * To convert a floating-point random number to an integer, use the int() function.\n  *\n  * @param {int|float} value1         if one parameter is used, the top end to random from, if two params the low end\n  * @param {int|float} value2         the top end of the random range\n  *\n  * @returns {float}\n  *\n  * @see randomSeed\n  * @see noise\n  */\n  p.random = function(aMin, aMax) {\n    if (arguments.length === 0) {\n      aMax = 1;\n      aMin = 0;\n    } else if (arguments.length === 1) {\n      aMax = aMin;\n      aMin = 0;\n    }\n    if (aMin === aMax) {\n      return aMin;\n    }\n    for (var i = 0; i < 100; i++) {\n      var ir = internalRandomGenerator();\n      var result = ir * (aMax - aMin) + aMin;\n      if (result !== aMax) {\n        return result;\n      }\n      // assertion: ir is never less than 0.5\n    }\n    return aMin;\n  };\n\n  // Pseudo-random generator\n  function Marsaglia(i1, i2) {\n    // from http://www.math.uni-bielefeld.de/~sillke/ALGORITHMS/random/marsaglia-c\n    var z=i1 || 362436069, w= i2 || 521288629;\n    var intGenerator = function() {\n      z=(36969*(z&65535)+(z>>>16)) & 0xFFFFFFFF;\n      w=(18000*(w&65535)+(w>>>16)) & 0xFFFFFFFF;\n      return (((z&0xFFFF)<<16) | (w&0xFFFF)) & 0xFFFFFFFF;\n    };\n\n    this.doubleGenerator = function() {\n      var i = intGenerator() / 4294967296;\n      return i < 0 ? 1 + i : i;\n    };\n    this.intGenerator = intGenerator;\n  }\n\n  Marsaglia.createRandomized = function() {\n    var now = new Date();\n    return new Marsaglia((now / 60000) & 0xFFFFFFFF, now & 0xFFFFFFFF);\n  };\n\n  /**\n  * Sets the seed value for random(). By default, random() produces different results each time the\n  * program is run. Set the value parameter to a constant to return the same pseudo-random numbers\n  * each time the software is run.\n  *\n  * @param {int|float} seed         int\n  *\n  * @see random\n  * @see noise\n  * @see noiseSeed\n  */\n  p.randomSeed = function(seed) {\n    internalRandomGenerator = (new Marsaglia(seed, (seed<<16)+(seed>>16))).doubleGenerator;\n    this.haveNextNextGaussian = false;\n  };\n\n  /**\n  * Returns a float from a random series of numbers having a mean of 0 and standard deviation of 1. Each time\n  * the randomGaussian() function is called, it returns a number fitting a Gaussian, or normal, distribution.\n  * There is theoretically no minimum or maximum value that randomGaussian() might return. Rather, there is just a\n  * very low probability that values far from the mean will be returned; and a higher probability that numbers\n  * near the mean will be returned.\n  *\n  * @returns {float}\n  *\n  * @see random\n  * @see noise\n  */\n  p.randomGaussian = function() {\n    if (this.haveNextNextGaussian) {\n      this.haveNextNextGaussian = false;\n      return this.nextNextGaussian;\n    }\n    var v1, v2, s;\n    do {\n      v1 = 2 * internalRandomGenerator() - 1; // between -1.0 and 1.0\n      v2 = 2 * internalRandomGenerator() - 1; // between -1.0 and 1.0\n      s = v1 * v1 + v2 * v2;\n    }\n    while (s >= 1 || s === 0);\n\n    var multiplier = Math.sqrt(-2 * Math.log(s) / s);\n    this.nextNextGaussian = v2 * multiplier;\n    this.haveNextNextGaussian = true;\n\n    return v1 * multiplier;\n  };\n\n  // Noise functions and helpers\n  function PerlinNoise(seed) {\n    var rnd = seed !== undef ? new Marsaglia(seed, (seed<<16)+(seed>>16)) : Marsaglia.createRandomized();\n    var i, j;\n    // http://www.noisemachine.com/talk1/17b.html\n    // http://mrl.nyu.edu/~perlin/noise/\n    // generate permutation\n    var perm = new Uint8Array(512);\n    for(i=0;i<256;++i) { perm[i] = i; }\n    for(i=0;i<256;++i) {\n      // NOTE: we can only do this because we've made sure the Marsaglia generator\n      //       gives us numbers where the last byte in a pseudo-random number is\n      //       still pseudo-random. If no 2nd argument is passed in the constructor,\n      //       that is no longer the case and this pair swap will always run identically.\n      var t = perm[j = rnd.intGenerator() & 0xFF];\n      perm[j] = perm[i];\n      perm[i] = t;\n    }\n    // copy to avoid taking mod in perm[0];\n    for(i=0;i<256;++i) { perm[i + 256] = perm[i]; }\n\n    function grad3d(i,x,y,z) {\n      var h = i & 15; // convert into 12 gradient directions\n      var u = h<8 ? x : y,\n          v = h<4 ? y : h===12||h===14 ? x : z;\n      return ((h&1) === 0 ? u : -u) + ((h&2) === 0 ? v : -v);\n    }\n\n    function grad2d(i,x,y) {\n      var v = (i & 1) === 0 ? x : y;\n      return (i&2) === 0 ? -v : v;\n    }\n\n    function grad1d(i,x) {\n      return (i&1) === 0 ? -x : x;\n    }\n\n    function lerp(t,a,b) { return a + t * (b - a); }\n\n    this.noise3d = function(x, y, z) {\n      var X = Math.floor(x)&255, Y = Math.floor(y)&255, Z = Math.floor(z)&255;\n      x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);\n      var fx = (3-2*x)*x*x, fy = (3-2*y)*y*y, fz = (3-2*z)*z*z;\n      var p0 = perm[X]+Y, p00 = perm[p0] + Z, p01 = perm[p0 + 1] + Z,\n          p1 = perm[X + 1] + Y, p10 = perm[p1] + Z, p11 = perm[p1 + 1] + Z;\n      return lerp(fz,\n        lerp(fy, lerp(fx, grad3d(perm[p00], x, y, z), grad3d(perm[p10], x-1, y, z)),\n                 lerp(fx, grad3d(perm[p01], x, y-1, z), grad3d(perm[p11], x-1, y-1,z))),\n        lerp(fy, lerp(fx, grad3d(perm[p00 + 1], x, y, z-1), grad3d(perm[p10 + 1], x-1, y, z-1)),\n                 lerp(fx, grad3d(perm[p01 + 1], x, y-1, z-1), grad3d(perm[p11 + 1], x-1, y-1,z-1))));\n    };\n\n    this.noise2d = function(x, y) {\n      var X = Math.floor(x)&255, Y = Math.floor(y)&255;\n      x -= Math.floor(x); y -= Math.floor(y);\n      var fx = (3-2*x)*x*x, fy = (3-2*y)*y*y;\n      var p0 = perm[X]+Y, p1 = perm[X + 1] + Y;\n      return lerp(fy,\n        lerp(fx, grad2d(perm[p0], x, y), grad2d(perm[p1], x-1, y)),\n        lerp(fx, grad2d(perm[p0 + 1], x, y-1), grad2d(perm[p1 + 1], x-1, y-1)));\n    };\n\n    this.noise1d = function(x) {\n      var X = Math.floor(x)&255;\n      x -= Math.floor(x);\n      var fx = (3-2*x)*x*x;\n      return lerp(fx, grad1d(perm[X], x), grad1d(perm[X+1], x-1));\n    };\n  }\n\n  // processing defaults\n  var noiseProfile = { generator: undef, octaves: 4, fallout: 0.5, seed: undef};\n\n  /**\n  * Returns the Perlin noise value at specified coordinates. Perlin noise is a random sequence\n  * generator producing a more natural ordered, harmonic succession of numbers compared to the\n  * standard random() function. It was invented by Ken Perlin in the 1980s and been used since\n  * in graphical applications to produce procedural textures, natural motion, shapes, terrains etc.\n  * The main difference to the random() function is that Perlin noise is defined in an infinite\n  * n-dimensional space where each pair of coordinates corresponds to a fixed semi-random value\n  * (fixed only for the lifespan of the program). The resulting value will always be between 0.0\n  * and 1.0. Processing can compute 1D, 2D and 3D noise, depending on the number of coordinates\n  * given. The noise value can be animated by moving through the noise space as demonstrated in\n  * the example above. The 2nd and 3rd dimension can also be interpreted as time.\n  * The actual noise is structured similar to an audio signal, in respect to the function's use\n  * of frequencies. Similar to the concept of harmonics in physics, perlin noise is computed over\n  * several octaves which are added together for the final result.\n  * Another way to adjust the character of the resulting sequence is the scale of the input\n  * coordinates. As the function works within an infinite space the value of the coordinates\n  * doesn't matter as such, only the distance between successive coordinates does (eg. when using\n  * noise() within a loop). As a general rule the smaller the difference between coordinates, the\n  * smoother the resulting noise sequence will be. Steps of 0.005-0.03 work best for most applications,\n  * but this will differ depending on use.\n  *\n  * @param {float} x          x coordinate in noise space\n  * @param {float} y          y coordinate in noise space\n  * @param {float} z          z coordinate in noise space\n  *\n  * @returns {float}\n  *\n  * @see random\n  * @see noiseDetail\n  */\n  p.noise = function(x, y, z) {\n    if(noiseProfile.generator === undef) {\n      // caching\n      noiseProfile.generator = new PerlinNoise(noiseProfile.seed);\n    }\n    var generator = noiseProfile.generator;\n    var effect = 1, k = 1, sum = 0;\n    for(var i=0; i<noiseProfile.octaves; ++i) {\n      effect *= noiseProfile.fallout;\n      switch (arguments.length) {\n      case 1:\n        sum += effect * (1 + generator.noise1d(k*x))/2; break;\n      case 2:\n        sum += effect * (1 + generator.noise2d(k*x, k*y))/2; break;\n      case 3:\n        sum += effect * (1 + generator.noise3d(k*x, k*y, k*z))/2; break;\n      }\n      k *= 2;\n    }\n    return sum;\n  };\n\n  /**\n  * Adjusts the character and level of detail produced by the Perlin noise function.\n  * Similar to harmonics in physics, noise is computed over several octaves. Lower octaves\n  * contribute more to the output signal and as such define the overal intensity of the noise,\n  * whereas higher octaves create finer grained details in the noise sequence. By default,\n  * noise is computed over 4 octaves with each octave contributing exactly half than its\n  * predecessor, starting at 50% strength for the 1st octave. This falloff amount can be\n  * changed by adding an additional function parameter. Eg. a falloff factor of 0.75 means\n  * each octave will now have 75% impact (25% less) of the previous lower octave. Any value\n  * between 0.0 and 1.0 is valid, however note that values greater than 0.5 might result in\n  * greater than 1.0 values returned by noise(). By changing these parameters, the signal\n  * created by the noise() function can be adapted to fit very specific needs and characteristics.\n  *\n  * @param {int} octaves          number of octaves to be used by the noise() function\n  * @param {float} falloff        falloff factor for each octave\n  *\n  * @see noise\n  */\n  p.noiseDetail = function(octaves, fallout) {\n    noiseProfile.octaves = octaves;\n    if(fallout !== undef) {\n      noiseProfile.fallout = fallout;\n    }\n  };\n\n  /**\n  * Sets the seed value for noise(). By default, noise() produces different results each\n  * time the program is run. Set the value parameter to a constant to return the same\n  * pseudo-random numbers each time the software is run.\n  *\n  * @param {int} seed         int\n  *\n  * @returns {float}\n  *\n  * @see random\n  * @see radomSeed\n  * @see noise\n  * @see noiseDetail\n  */\n  p.noiseSeed = function(seed) {\n    noiseProfile.seed = seed;\n    noiseProfile.generator = undef;\n  };\n};\n\n},{}],24:[function(require,module,exports){\n/**\n * Common functions traditionally on \"p\" that should be class functions\n * that get bound to \"p\" when an instance is actually built, instead.\n */\nmodule.exports = (function commonFunctions(undef) {\n\n  var CommonFunctions = {\n    /**\n     * Remove whitespace characters from the beginning and ending\n     * of a String or a String array. Works like String.trim() but includes the\n     * unicode nbsp character as well. If an array is passed in the function will return a new array not effecting the array passed in.\n     *\n     * @param {String} str    the string to trim\n     * @param {String[]} str  the string array to trim\n     *\n     * @return {String|String[]} retrurns a string or an array will removed whitespaces\n     */\n    trim: function(str) {\n      if (str instanceof Array) {\n        var arr = [];\n        for (var i = 0; i < str.length; i++) {\n          arr.push(str[i].replace(/^\\s*/, '').replace(/\\s*$/, '').replace(/\\r*$/, ''));\n        }\n        return arr;\n      }\n      return str.replace(/^\\s*/, '').replace(/\\s*$/, '').replace(/\\r*$/, '');\n    },\n\n    /**\n     * Converts a degree measurement to its corresponding value in radians. Radians and degrees are two ways of\n     * measuring the same thing. There are 360 degrees in a circle and 2*PI radians in a circle. For example,\n     * 90 degrees = PI/2 = 1.5707964. All trigonometric methods in Processing require their parameters to be specified in radians.\n     *\n     * @param {int|float} value        an angle in radians\n     *\n     * @returns {float}\n     *\n     * @see degrees\n     */\n    radians: function(aAngle) {\n      return (aAngle / 180) * Math.PI;\n    },\n\n    /**\n     * Number-to-String formatting function. Prepends \"plus\" or \"minus\" depending\n     * on whether the value is positive or negative, respectively, after padding\n     * the value with zeroes on the left and right, the number of zeroes used dictated\n     * by the values 'leftDigits' and 'rightDigits'. 'value' cannot be an array.\n     *\n     * @param {int|float} value                 the number to format\n     * @param {String} plus                     the prefix for positive numbers\n     * @param {String} minus                    the prefix for negative numbers\n     * @param {int} left                        number of digits to the left of the decimal point\n     * @param {int} right                       number of digits to the right of the decimal point\n     * @param {String} group                    string delimited for groups, such as the comma in \"1,000\"\n     *\n     * @returns {String or String[]}\n     *\n     * @see nfCore\n     */\n    nfCoreScalar: function (value, plus, minus, leftDigits, rightDigits, group) {\n      var sign = (value < 0) ? minus : plus;\n      var autoDetectDecimals = rightDigits === 0;\n      var rightDigitsOfDefault = (rightDigits === undef || rightDigits < 0) ? 0 : rightDigits;\n\n      var absValue = Math.abs(value);\n      if (autoDetectDecimals) {\n        rightDigitsOfDefault = 1;\n        absValue *= 10;\n        while (Math.abs(Math.round(absValue) - absValue) > 1e-6 && rightDigitsOfDefault < 7) {\n          ++rightDigitsOfDefault;\n          absValue *= 10;\n        }\n      } else if (rightDigitsOfDefault !== 0) {\n        absValue *= Math.pow(10, rightDigitsOfDefault);\n      }\n\n      // Using Java's default rounding policy HALF_EVEN. This policy is based\n      // on the idea that 0.5 values round to the nearest even number, and\n      // everything else is rounded normally.\n      var number, doubled = absValue * 2;\n      if (Math.floor(absValue) === absValue) {\n        number = absValue;\n      } else if (Math.floor(doubled) === doubled) {\n        var floored = Math.floor(absValue);\n        number = floored + (floored % 2);\n      } else {\n        number = Math.round(absValue);\n      }\n\n      var buffer = \"\";\n      var totalDigits = leftDigits + rightDigitsOfDefault;\n      while (totalDigits > 0 || number > 0) {\n        totalDigits--;\n        buffer = \"\" + (number % 10) + buffer;\n        number = Math.floor(number / 10);\n      }\n      if (group !== undef) {\n        var i = buffer.length - 3 - rightDigitsOfDefault;\n        while(i > 0) {\n          buffer = buffer.substring(0,i) + group + buffer.substring(i);\n          i-=3;\n        }\n      }\n      if (rightDigitsOfDefault > 0) {\n        return sign + buffer.substring(0, buffer.length - rightDigitsOfDefault) +\n               \".\" + buffer.substring(buffer.length - rightDigitsOfDefault, buffer.length);\n      }\n      return sign + buffer;\n    },\n\n    /**\n    * Number-to-String formatting function. Prepends \"plus\" or \"minus\" depending\n    * on whether the value is positive or negative, respectively, after padding\n    * the value with zeroes on the left and right, the number of zeroes used dictated\n    * by the values 'leftDigits' and 'rightDigits'. 'value' can be an array;\n    * if the input is an array, each value in it is formatted separately, and\n    * an array with formatted values is returned.\n    *\n    * @param {int|int[]|float|float[]} value   the number(s) to format\n    * @param {String} plus                     the prefix for positive numbers\n    * @param {String} minus                    the prefix for negative numbers\n    * @param {int} left                        number of digits to the left of the decimal point\n    * @param {int} right                       number of digits to the right of the decimal point\n    * @param {String} group                    string delimited for groups, such as the comma in \"1,000\"\n    *\n    * @returns {String or String[]}\n    *\n    * @see nfCoreScalar\n    */\n    nfCore: function(value, plus, minus, leftDigits, rightDigits, group) {\n      if (value instanceof Array) {\n        var arr = [];\n        for (var i = 0, len = value.length; i < len; i++) {\n          arr.push(CommonFunctions.nfCoreScalar(value[i], plus, minus, leftDigits, rightDigits, group));\n        }\n        return arr;\n      }\n      return CommonFunctions.nfCoreScalar(value, plus, minus, leftDigits, rightDigits, group);\n    },\n\n    /**\n    * Utility function for formatting numbers into strings. There are two versions, one for\n    * formatting floats and one for formatting ints. The values for the digits, left, and\n    * right parameters should always be positive integers.\n    * As shown in the above example, nf() is used to add zeros to the left and/or right\n    * of a number. This is typically for aligning a list of numbers. To remove digits from\n    * a floating-point number, use the int(), ceil(), floor(), or round() functions.\n    *\n    * @param {int|int[]|float|float[]} value   the number(s) to format\n    * @param {int} left                        number of digits to the left of the decimal point\n    * @param {int} right                       number of digits to the right of the decimal point\n    *\n    * @returns {String or String[]}\n    *\n    * @see nfs\n    * @see nfp\n    * @see nfc\n    */\n    nf: function(value, leftDigits, rightDigits) {\n      return CommonFunctions.nfCore(value, \"\", \"-\", leftDigits, rightDigits);\n    },\n\n    /**\n    * Utility function for formatting numbers into strings. Similar to nf()  but leaves a blank space in front\n    * of positive numbers so they align with negative numbers in spite of the minus symbol. There are two\n    * versions, one for formatting floats and one for formatting ints. The values for the digits, left,\n    * and right parameters should always be positive integers.\n    *\n    * @param {int|int[]|float|float[]} value   the number(s) to format\n    * @param {int} left                        number of digits to the left of the decimal point\n    * @param {int} right                       number of digits to the right of the decimal point\n    *\n    * @returns {String or String[]}\n    *\n    * @see nf\n    * @see nfp\n    * @see nfc\n    */\n    nfs: function(value, leftDigits, rightDigits) {\n      return CommonFunctions.nfCore(value, \" \", \"-\", leftDigits, rightDigits);\n    },\n\n    /**\n    * Utility function for formatting numbers into strings. Similar to nf()  but puts a \"+\" in front of\n    * positive numbers and a \"-\" in front of negative numbers. There are two versions, one for formatting\n    * floats and one for formatting ints. The values for the digits, left, and right parameters should\n    * always be positive integers.\n    *\n    * @param {int|int[]|float|float[]} value   the number(s) to format\n    * @param {int} left                        number of digits to the left of the decimal point\n    * @param {int} right                       number of digits to the right of the decimal point\n    *\n    * @returns {String or String[]}\n    *\n    * @see nfs\n    * @see nf\n    * @see nfc\n    */\n    nfp: function(value, leftDigits, rightDigits) {\n      return CommonFunctions.nfCore(value, \"+\", \"-\", leftDigits, rightDigits);\n    },\n\n    /**\n    * Utility function for formatting numbers into strings and placing appropriate commas to mark\n    * units of 1000. There are two versions, one for formatting ints and one for formatting an array\n    * of ints. The value for the digits parameter should always be a positive integer.\n    *\n    * @param {int|int[]|float|float[]} value   the number(s) to format\n    * @param {int} left                        number of digits to the left of the decimal point\n    * @param {int} right                       number of digits to the right of the decimal point\n    *\n    * @returns {String or String[]}\n    *\n    * @see nf\n    * @see nfs\n    * @see nfp\n    */\n    nfc: function(value, rightDigits) {\n      return CommonFunctions.nfCore(value, \"\", \"-\", 0, rightDigits, \",\");\n    },\n\n    // used to bind all common functions to \"p\"\n    withCommonFunctions: function withCommonFunctions(p) {\n      [\"trim\", \"radians\", \"nf\", \"nfs\", \"nfp\", \"nfc\"].forEach(function(f){\n        p[f] = CommonFunctions[f];\n      });\n    }\n  };\n\n  return CommonFunctions;\n}());\n\n},{}],25:[function(require,module,exports){\n/**\n * Touch and Mouse event handling\n */\nmodule.exports = function withTouch(p, curElement, attachEventHandler, detachEventHandlersByType, document, PConstants, undef) {\n\n  // List of mouse event types\n  var mouseTypes = ['mouseout','mousemove','mousedown','mouseup','DOMMouseScroll','mousewheel','touchstart'];\n\n  /**\n   * Determine the location of the (mouse) pointer.\n   */\n  function calculateOffset(curElement, event) {\n    var element = curElement,\n      offsetX = 0,\n      offsetY = 0;\n\n    p.pmouseX = p.mouseX;\n    p.pmouseY = p.mouseY;\n\n    // Find element offset\n    if (element.offsetParent) {\n      do {\n        offsetX += element.offsetLeft;\n        offsetY += element.offsetTop;\n      } while (!!(element = element.offsetParent));\n    }\n\n    // Find Scroll offset\n    element = curElement;\n    do {\n      offsetX -= element.scrollLeft || 0;\n      offsetY -= element.scrollTop || 0;\n    } while (!!(element = element.parentNode));\n\n    // Get padding and border style widths for mouse offsets\n    var stylePaddingLeft, stylePaddingTop, styleBorderLeft, styleBorderTop;\n    if (document.defaultView && document.defaultView.getComputedStyle) {\n      stylePaddingLeft = parseInt(document.defaultView.getComputedStyle(curElement, null).paddingLeft, 10)      || 0;\n      stylePaddingTop  = parseInt(document.defaultView.getComputedStyle(curElement, null).paddingTop, 10)       || 0;\n      styleBorderLeft  = parseInt(document.defaultView.getComputedStyle(curElement, null).borderLeftWidth, 10)  || 0;\n      styleBorderTop   = parseInt(document.defaultView.getComputedStyle(curElement, null).borderTopWidth, 10)   || 0;\n    }\n\n    // Add padding and border style widths to offset\n    offsetX += stylePaddingLeft;\n    offsetY += stylePaddingTop;\n\n    offsetX += styleBorderLeft;\n    offsetY += styleBorderTop;\n\n    // Take into account any scrolling done\n    offsetX += window.pageXOffset;\n    offsetY += window.pageYOffset;\n\n    return {'X':offsetX,'Y':offsetY};\n  }\n\n  // simple relative position\n  function updateMousePosition(curElement, event) {\n    var offset = calculateOffset(curElement, event);\n    // Dropping support for IE clientX and clientY, switching to pageX and pageY\n    // so we don't have to calculate scroll offset.\n    // Removed in ticket #184. See rev: 2f106d1c7017fed92d045ba918db47d28e5c16f4\n    p.mouseX = event.pageX - offset.X;\n    p.mouseY = event.pageY - offset.Y;\n  }\n\n  /**\n   * Return a TouchEvent with canvas-specific x/y co-ordinates\n   */\n  function addTouchEventOffset(t) {\n    var offset = calculateOffset(t.changedTouches[0].target, t.changedTouches[0]),\n        i;\n\n    for (i = 0; i < t.touches.length; i++) {\n      var touch = t.touches[i];\n      touch.offsetX = touch.pageX - offset.X;\n      touch.offsetY = touch.pageY - offset.Y;\n    }\n    for (i = 0; i < t.targetTouches.length; i++) {\n      var targetTouch = t.targetTouches[i];\n      targetTouch.offsetX = targetTouch.pageX - offset.X;\n      targetTouch.offsetY = targetTouch.pageY - offset.Y;\n    }\n    for (i = 0; i < t.changedTouches.length; i++) {\n      var changedTouch = t.changedTouches[i];\n      changedTouch.offsetX = changedTouch.pageX - offset.X;\n      changedTouch.offsetY = changedTouch.pageY - offset.Y;\n    }\n\n    return t;\n  }\n\n  /**\n   * Touch event support.\n   */\n  attachEventHandler(curElement, \"touchstart\", function (t) {\n    // Removes unwanted behaviour of the canvas when touching canvas\n    curElement.setAttribute(\"style\",\"-webkit-user-select: none\");\n    curElement.setAttribute(\"onclick\",\"void(0)\");\n    curElement.setAttribute(\"style\",\"-webkit-tap-highlight-color:rgba(0,0,0,0)\");\n\n    // Remove mouse-type event listeners\n    detachEventHandlersByType(curElement, mouseTypes);\n\n    // If there are any native touch events defined in the sketch, connect all of them\n    // Otherwise, connect all of the emulated mouse events\n    if (p.touchStart !== undef || p.touchMove !== undef ||\n        p.touchEnd !== undef || p.touchCancel !== undef) {\n      attachEventHandler(curElement, \"touchstart\", function(t) {\n        if (p.touchStart !== undef) {\n          t = addTouchEventOffset(t);\n          p.touchStart(t);\n        }\n      });\n\n      attachEventHandler(curElement, \"touchmove\", function(t) {\n        if (p.touchMove !== undef) {\n          t.preventDefault(); // Stop the viewport from scrolling\n          t = addTouchEventOffset(t);\n          p.touchMove(t);\n        }\n      });\n\n      attachEventHandler(curElement, \"touchend\", function(t) {\n        if (p.touchEnd !== undef) {\n          t = addTouchEventOffset(t);\n          p.touchEnd(t);\n        }\n      });\n\n      attachEventHandler(curElement, \"touchcancel\", function(t) {\n        if (p.touchCancel !== undef) {\n          t = addTouchEventOffset(t);\n          p.touchCancel(t);\n        }\n      });\n\n    } else {\n      // Emulated touch start/mouse down event\n      attachEventHandler(curElement, \"touchstart\", function(e) {\n        updateMousePosition(curElement, e.touches[0]);\n\n        p.__mousePressed = true;\n        p.mouseDragging = false;\n        p.mouseButton = PConstants.LEFT;\n\n        if (typeof p.mousePressed === \"function\") {\n          p.mousePressed();\n        }\n      });\n\n      // Emulated touch move/mouse move event\n      attachEventHandler(curElement, \"touchmove\", function(e) {\n        e.preventDefault();\n        updateMousePosition(curElement, e.touches[0]);\n\n        if (typeof p.mouseMoved === \"function\" && !p.__mousePressed) {\n          p.mouseMoved();\n        }\n        if (typeof p.mouseDragged === \"function\" && p.__mousePressed) {\n          p.mouseDragged();\n          p.mouseDragging = true;\n        }\n      });\n\n      // Emulated touch up/mouse up event\n      attachEventHandler(curElement, \"touchend\", function(e) {\n        p.__mousePressed = false;\n\n        if (typeof p.mouseClicked === \"function\" && !p.mouseDragging) {\n          p.mouseClicked();\n        }\n\n        if (typeof p.mouseReleased === \"function\") {\n          p.mouseReleased();\n        }\n      });\n    }\n  });\n\n  /**\n   * Context menu toggles. Most often you will not want the\n   * browser's context menu to show on a right click, but\n   * sometimes, you do, so we add two unofficial functions\n   * that can be used to trigger context menu behaviour.\n   */\n  (function() {\n    var enabled = true,\n        contextMenu = function(e) {\n          e.preventDefault();\n          e.stopPropagation();\n        };\n\n    p.disableContextMenu = function() {\n      if (!enabled) {\n        return;\n      }\n      attachEventHandler(curElement, 'contextmenu', contextMenu);\n      enabled = false;\n    };\n\n    p.enableContextMenu = function() {\n      if (enabled) {\n        return;\n      }\n      detachEventHandler({elem: curElement, type: 'contextmenu', fn: contextMenu});\n      enabled = true;\n    };\n  }());\n\n  /**\n   * Mouse moved or dragged\n   */\n  attachEventHandler(curElement, \"mousemove\", function(e) {\n    updateMousePosition(curElement, e);\n    if (typeof p.mouseMoved === \"function\" && !p.__mousePressed) {\n      p.mouseMoved();\n    }\n    if (typeof p.mouseDragged === \"function\" && p.__mousePressed) {\n      p.mouseDragged();\n      p.mouseDragging = true;\n    }\n  });\n\n  /**\n   * Unofficial mouse-out handling\n   */\n  attachEventHandler(curElement, \"mouseout\", function(e) {\n    if (typeof p.mouseOut === \"function\") {\n      p.mouseOut();\n    }\n  });\n\n  /**\n   * Mouse over\n   */\n  attachEventHandler(curElement, \"mouseover\", function(e) {\n    updateMousePosition(curElement, e);\n    if (typeof p.mouseOver === \"function\") {\n      p.mouseOver();\n    }\n  });\n\n  /**\n   * Disable browser's default handling for click-drag of a canvas.\n   */\n  curElement.onmousedown = function () {\n    // make sure focus happens, but nothing else\n    curElement.focus();\n    return false;\n  };\n\n  /**\n   * Mouse pressed or drag\n   */\n  attachEventHandler(curElement, \"mousedown\", function(e) {\n    p.__mousePressed = true;\n    p.mouseDragging = false;\n    switch (e.which) {\n    case 1:\n      p.mouseButton = PConstants.LEFT;\n      break;\n    case 2:\n      p.mouseButton = PConstants.CENTER;\n      break;\n    case 3:\n      p.mouseButton = PConstants.RIGHT;\n      break;\n    }\n\n    if (typeof p.mousePressed === \"function\") {\n      p.mousePressed();\n    }\n  });\n\n  /**\n   * Mouse clicked or released\n   */\n  attachEventHandler(curElement, \"mouseup\", function(e) {\n    p.__mousePressed = false;\n\n    if (typeof p.mouseClicked === \"function\" && !p.mouseDragging) {\n      p.mouseClicked();\n    }\n\n    if (typeof p.mouseReleased === \"function\") {\n      p.mouseReleased();\n    }\n  });\n\n  /**\n   * Unofficial scroll wheel handling.\n   */\n  var mouseWheelHandler = function(e) {\n    // do not handle scroll wheel if initiated outside of the sketch\n    if (e.target !== curElement) return;\n\n    var delta = 0;\n\n    if (e.wheelDelta) {\n      delta = e.wheelDelta / 120;\n      if (window.opera) {\n        delta = -delta;\n      }\n    } else if (e.detail) {\n      delta = -e.detail / 3;\n    }\n\n    p.mouseScroll = delta;\n\n    if (delta && typeof p.mouseScrolled === 'function') {\n      // If this sketch has explicit scroll handling,\n      // prevent scroll from kicking in globally before\n      // calling the scroll handler.\n      e.stopPropagation();\n      e.preventDefault();   \n      p.mouseScrolled();\n    }\n  };\n\n  // Support Gecko and non-Gecko scroll events\n  attachEventHandler(document, 'DOMMouseScroll', mouseWheelHandler);\n  attachEventHandler(document, 'mousewheel', mouseWheelHandler);\n\n};\n\n\n},{}],26:[function(require,module,exports){\n/**\n * The parser for turning Processing syntax into Pjs JavaScript.\n * This code is not trivial; unless you know what you're doing,\n * you shouldn't be changing things in here =)\n */\nmodule.exports = function setupParser(Processing, options) {\n\n  var defaultScope = options.defaultScope,\n      PConstants = defaultScope.PConstants,\n      aFunctions = options.aFunctions,\n      Browser = options.Browser,\n      document = Browser.document,\n      undef;\n\n  // Processing global methods and constants for the parser\n  function getGlobalMembers() {\n    // The names array contains the names of everything that is inside \"p.\"\n    // When something new is added to \"p.\" it must also be added to this list.\n    var names = [ /* this code is generated by jsglobals.js */\n      \"abs\", \"acos\", \"alpha\", \"ambient\", \"ambientLight\", \"append\", \"applyMatrix\",\n      \"arc\", \"arrayCopy\", \"asin\", \"atan\", \"atan2\", \"background\", \"beginCamera\",\n      \"beginDraw\", \"beginShape\", \"bezier\", \"bezierDetail\", \"bezierPoint\",\n      \"bezierTangent\", \"bezierVertex\", \"binary\", \"blend\", \"blendColor\",\n      \"blit_resize\", \"blue\", \"box\", \"breakShape\", \"brightness\",\n      \"camera\", \"ceil\", \"Character\", \"color\", \"colorMode\",\n      \"concat\", \"constrain\", \"copy\", \"cos\", \"createFont\",\n      \"createGraphics\", \"createImage\", \"cursor\", \"curve\", \"curveDetail\",\n      \"curvePoint\", \"curveTangent\", \"curveTightness\", \"curveVertex\", \"day\",\n      \"degrees\", \"directionalLight\", \"disableContextMenu\",\n      \"dist\", \"draw\", \"ellipse\", \"ellipseMode\", \"emissive\", \"enableContextMenu\",\n      \"endCamera\", \"endDraw\", \"endShape\", \"exit\", \"exp\", \"expand\", \"externals\",\n      \"fill\", \"filter\", \"floor\", \"focused\", \"frameCount\", \"frameRate\", \"frustum\",\n      \"get\", \"glyphLook\", \"glyphTable\", \"green\", \"height\", \"hex\", \"hint\", \"hour\",\n      \"hue\", \"image\", \"imageMode\", \"intersect\", \"join\", \"key\",\n      \"keyCode\", \"keyPressed\", \"keyReleased\", \"keyTyped\", \"lerp\", \"lerpColor\",\n      \"lightFalloff\", \"lights\", \"lightSpecular\", \"line\", \"link\", \"loadBytes\",\n      \"loadFont\", \"loadGlyphs\", \"loadImage\", \"loadPixels\", \"loadShape\", \"loadXML\",\n      \"loadStrings\", \"log\", \"loop\", \"mag\", \"map\", \"match\", \"matchAll\", \"max\",\n      \"millis\", \"min\", \"minute\", \"mix\", \"modelX\", \"modelY\", \"modelZ\", \"modes\",\n      \"month\", \"mouseButton\", \"mouseClicked\", \"mouseDragged\", \"mouseMoved\",\n      \"mouseOut\", \"mouseOver\", \"mousePressed\", \"mouseReleased\", \"mouseScroll\",\n      \"mouseScrolled\", \"mouseX\", \"mouseY\", \"name\", \"nf\", \"nfc\", \"nfp\", \"nfs\",\n      \"noCursor\", \"noFill\", \"noise\", \"noiseDetail\", \"noiseSeed\", \"noLights\",\n      \"noLoop\", \"norm\", \"normal\", \"noSmooth\", \"noStroke\", \"noTint\", \"ortho\",\n      \"param\", \"parseBoolean\", \"parseByte\", \"parseChar\", \"parseFloat\",\n      \"parseInt\", \"parseXML\", \"peg\", \"perspective\", \"PImage\", \"pixels\",\n      \"PMatrix2D\", \"PMatrix3D\", \"PMatrixStack\", \"pmouseX\", \"pmouseY\", \"point\",\n      \"pointLight\", \"popMatrix\", \"popStyle\", \"pow\", \"print\", \"printCamera\",\n      \"println\", \"printMatrix\", \"printProjection\", \"PShape\", \"PShapeSVG\",\n      \"pushMatrix\", \"pushStyle\", \"quad\", \"radians\", \"random\", \"randomGaussian\",\n      \"randomSeed\", \"rect\", \"rectMode\", \"red\", \"redraw\", \"requestImage\",\n      \"resetMatrix\", \"reverse\", \"rotate\", \"rotateX\", \"rotateY\", \"rotateZ\",\n      \"round\", \"saturation\", \"save\", \"saveFrame\", \"saveStrings\", \"scale\",\n      \"screenX\", \"screenY\", \"screenZ\", \"second\", \"set\", \"setup\", \"shape\",\n      \"shapeMode\", \"shared\", \"shearX\", \"shearY\", \"shininess\", \"shorten\", \"sin\", \"size\", \"smooth\",\n      \"sort\", \"specular\", \"sphere\", \"sphereDetail\", \"splice\", \"split\",\n      \"splitTokens\", \"spotLight\", \"sq\", \"sqrt\", \"status\", \"str\", \"stroke\",\n      \"strokeCap\", \"strokeJoin\", \"strokeWeight\", \"subset\", \"tan\", \"text\",\n      \"textAlign\", \"textAscent\", \"textDescent\", \"textFont\", \"textLeading\",\n      \"textMode\", \"textSize\", \"texture\", \"textureMode\", \"textWidth\", \"tint\", \"toImageData\",\n      \"touchCancel\", \"touchEnd\", \"touchMove\", \"touchStart\", \"translate\", \"transform\",\n      \"triangle\", \"trim\", \"unbinary\", \"unhex\", \"updatePixels\", \"use3DContext\",\n      \"vertex\", \"width\", \"XMLElement\", \"XML\", \"year\", \"__contains\", \"__equals\",\n      \"__equalsIgnoreCase\", \"__frameRate\", \"__hashCode\", \"__int_cast\",\n      \"__instanceof\", \"__keyPressed\", \"__mousePressed\", \"__printStackTrace\",\n      \"__replace\", \"__replaceAll\", \"__replaceFirst\", \"__toCharArray\", \"__split\",\n      \"__codePointAt\", \"__startsWith\", \"__endsWith\", \"__matches\"];\n\n    // custom functions and properties are added here\n    if(aFunctions) {\n      Object.keys(aFunctions).forEach(function(name) {\n        names.push(name);\n      });\n    }\n\n    // custom libraries that were attached to Processing\n    var members = {};\n    var i, l;\n    for (i = 0, l = names.length; i < l ; ++i) {\n      members[names[i]] = null;\n    }\n    for (var lib in Processing.lib) {\n      if (Processing.lib.hasOwnProperty(lib)) {\n        if (Processing.lib[lib].exports) {\n          var exportedNames = Processing.lib[lib].exports;\n          for (i = 0, l = exportedNames.length; i < l; ++i) {\n           members[exportedNames[i]] = null;\n          }\n        }\n      }\n    }\n    return members;\n  }\n\n  /*\n\n    Parser converts Java-like syntax into JavaScript.\n    Creates an Abstract Syntax Tree -- \"Light AST\" from the Java-like code.\n\n    It is an object tree. The root object is created from the AstRoot class, which contains statements.\n\n    A statement object can be of type: AstForStatement, AstCatchStatement, AstPrefixStatement, AstMethod, AstClass,\n    AstInterface, AstFunction, AstStatementBlock and AstLabel.\n\n    AstPrefixStatement can be a statement of type: if, switch, while, with, do, else, finally, return, throw, try, break, and continue.\n\n    These object's toString function returns the JavaScript code for the statement.\n\n    Any processing calls need \"processing.\" prepended to them.\n\n    Similarly, calls from inside classes need \"$this_1.\", prepended to them,\n    with 1 being the depth level for inner classes.\n    This includes members passed down from inheritance.\n\n    The resulting code is then eval'd and run.\n\n  */\n\n  function parseProcessing(code) {\n    var globalMembers = getGlobalMembers();\n\n    // masks parentheses, brackets and braces with '\"A5\"'\n    // where A is the bracket type, and 5 is the index in an array containing all brackets split into atoms\n    // 'while(true){}' -> 'while\"B1\"\"A2\"'\n    // parentheses() = B, brackets[] = C and braces{} = A\n    function splitToAtoms(code) {\n      var atoms = [];\n      var items = code.split(/([\\{\\[\\(\\)\\]\\}])/);\n      var result = items[0];\n\n      var stack = [];\n      for(var i=1; i < items.length; i += 2) {\n        var item = items[i];\n        if(item === '[' || item === '{' || item === '(') {\n          stack.push(result); result = item;\n        } else if(item === ']' || item === '}' || item === ')') {\n          var kind = item === '}' ? 'A' : item === ')' ? 'B' : 'C';\n          var index = atoms.length; atoms.push(result + item);\n          result = stack.pop() + '\"' + kind + (index + 1) + '\"';\n        }\n        result += items[i + 1];\n      }\n      atoms.unshift(result);\n      return atoms;\n    }\n\n    // replaces strings and regexs keyed by index with an array of strings\n    function injectStrings(code, strings) {\n      return code.replace(/'(\\d+)'/g, function(all, index) {\n        var val = strings[index];\n        if(val.charAt(0) === \"/\") {\n          return val;\n        }\n        return (/^'((?:[^'\\\\\\n])|(?:\\\\.[0-9A-Fa-f]*))'$/).test(val) ? \"(new $p.Character(\" + val + \"))\" : val;\n      });\n    }\n\n    // trims off leading and trailing spaces\n    // returns an object. object.left, object.middle, object.right, object.untrim\n    function trimSpaces(string) {\n      var m1 = /^\\s*/.exec(string), result;\n      if(m1[0].length === string.length) {\n        result = {left: m1[0], middle: \"\", right: \"\"};\n      } else {\n        var m2 = /\\s*$/.exec(string);\n        result = {left: m1[0], middle: string.substring(m1[0].length, m2.index), right: m2[0]};\n      }\n      result.untrim = function(t) { return this.left + t + this.right; };\n      return result;\n    }\n\n    // simple trim of leading and trailing spaces\n    function trim(string) {\n      return string.replace(/^\\s+/,'').replace(/\\s+$/,'');\n    }\n\n    function appendToLookupTable(table, array) {\n      for(var i=0,l=array.length;i<l;++i) {\n        table[array[i]] = null;\n      }\n      return table;\n    }\n\n    function isLookupTableEmpty(table) {\n      for(var i in table) {\n        if(table.hasOwnProperty(i)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    function getAtomIndex(templ) { return templ.substring(2, templ.length - 1); }\n\n    // remove carriage returns \"\\r\"\n    var codeWoExtraCr = code.replace(/\\r\\n?|\\n\\r/g, \"\\n\");\n\n    // masks strings and regexs with \"'5'\", where 5 is the index in an array containing all strings and regexs\n    // also removes all comments\n    var strings = [];\n    var codeWoStrings = codeWoExtraCr.replace(/(\"(?:[^\"\\\\\\n]|\\\\.)*\")|('(?:[^'\\\\\\n]|\\\\.)*')|(([\\[\\(=|&!\\^:?]\\s*)(\\/(?![*\\/])(?:[^\\/\\\\\\n]|\\\\.)*\\/[gim]*)\\b)|(\\/\\/[^\\n]*\\n)|(\\/\\*(?:(?!\\*\\/)(?:.|\\n))*\\*\\/)/g,\n    function(all, quoted, aposed, regexCtx, prefix, regex, singleComment, comment) {\n      var index;\n      if(quoted || aposed) { // replace strings\n        index = strings.length; strings.push(all);\n        return \"'\" + index + \"'\";\n      }\n      if(regexCtx) { // replace RegExps\n        index = strings.length; strings.push(regex);\n        return prefix + \"'\" + index + \"'\";\n      }\n      // kill comments\n      return comment !== \"\" ? \" \" : \"\\n\";\n    });\n\n    // protect character codes from namespace collision\n    codeWoStrings = codeWoStrings.replace(/__x([0-9A-F]{4})/g, function(all, hexCode) {\n      // $ = __x0024\n      // _ = __x005F\n      // this protects existing character codes from conversion\n      // __x0024 = __x005F_x0024\n      return \"__x005F_x\" + hexCode;\n    });\n\n    // convert dollar sign to character code\n    codeWoStrings = codeWoStrings.replace(/\\$/g, \"__x0024\");\n\n    // Remove newlines after return statements\n    codeWoStrings = codeWoStrings.replace(/return\\s*[\\n\\r]+/g, \"return \");\n\n    // removes generics\n    var genericsWereRemoved;\n    var codeWoGenerics = codeWoStrings;\n    var replaceFunc = function(all, before, types, after) {\n      if(!!before || !!after) {\n        return all;\n      }\n      genericsWereRemoved = true;\n      return \"\";\n    };\n\n    do {\n      genericsWereRemoved = false;\n      codeWoGenerics = codeWoGenerics.replace(/([<]?)<\\s*((?:\\?|[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)(?:\\[\\])*(?:\\s+(?:extends|super)\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)?(?:\\s*,\\s*(?:\\?|[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)(?:\\[\\])*(?:\\s+(?:extends|super)\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)?)*)\\s*>([=]?)/g, replaceFunc);\n    } while (genericsWereRemoved);\n\n    var atoms = splitToAtoms(codeWoGenerics);\n    var replaceContext;\n    var declaredClasses = {}, currentClassId, classIdSeed = 0;\n\n    function addAtom(text, type) {\n      var lastIndex = atoms.length;\n      atoms.push(text);\n      return '\"' + type + lastIndex + '\"';\n    }\n\n    function generateClassId() {\n      return \"class\" + (++classIdSeed);\n    }\n\n    function appendClass(class_, classId, scopeId) {\n      class_.classId = classId;\n      class_.scopeId = scopeId;\n      declaredClasses[classId] = class_;\n    }\n\n    // functions defined below\n    var transformClassBody, transformInterfaceBody, transformStatementsBlock, transformStatements, transformMain, transformExpression;\n\n    var classesRegex = /\\b((?:(?:public|private|final|protected|static|abstract)\\s+)*)(class|interface)\\s+([A-Za-z_$][\\w$]*\\b)(\\s+extends\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*,\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*\\b)*)?(\\s+implements\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*,\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*\\b)*)?\\s*(\"A\\d+\")/g;\n    var methodsRegex = /\\b((?:(?:public|private|final|protected|static|abstract|synchronized)\\s+)*)((?!(?:else|new|return|throw|function|public|private|protected)\\b)[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*\"C\\d+\")*)\\s*([A-Za-z_$][\\w$]*\\b)\\s*(\"B\\d+\")(\\s*throws\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*,\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)*)?\\s*(\"A\\d+\"|;)/g;\n    var fieldTest = /^((?:(?:public|private|final|protected|static)\\s+)*)((?!(?:else|new|return|throw)\\b)[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*\"C\\d+\")*)\\s*([A-Za-z_$][\\w$]*\\b)\\s*(?:\"C\\d+\"\\s*)*([=,]|$)/;\n    var cstrsRegex = /\\b((?:(?:public|private|final|protected|static|abstract)\\s+)*)((?!(?:new|return|throw)\\b)[A-Za-z_$][\\w$]*\\b)\\s*(\"B\\d+\")(\\s*throws\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*,\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)*)?\\s*(\"A\\d+\")/g;\n    var attrAndTypeRegex = /^((?:(?:public|private|final|protected|static)\\s+)*)((?!(?:new|return|throw)\\b)[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*\"C\\d+\")*)\\s*/;\n    var functionsRegex = /\\bfunction(?:\\s+([A-Za-z_$][\\w$]*))?\\s*(\"B\\d+\")\\s*(\"A\\d+\")/g;\n\n    // This converts classes, methods and functions into atoms, and adds them to the atoms array.\n    // classes = E, methods = D and functions = H\n    function extractClassesAndMethods(code) {\n      var s = code;\n      s = s.replace(classesRegex, function(all) {\n        return addAtom(all, 'E');\n      });\n      s = s.replace(methodsRegex, function(all) {\n        return addAtom(all, 'D');\n      });\n      s = s.replace(functionsRegex, function(all) {\n        return addAtom(all, 'H');\n      });\n      return s;\n    }\n\n    // This converts constructors into atoms, and adds them to the atoms array.\n    // constructors = G\n    function extractConstructors(code, className) {\n      var result = code.replace(cstrsRegex, function(all, attr, name, params, throws_, body) {\n        if(name !== className) {\n          return all;\n        }\n        return addAtom(all, 'G');\n      });\n      return result;\n    }\n\n    // AstParam contains the name of a parameter inside a function declaration\n    function AstParam(name) {\n      this.name = name;\n    }\n    AstParam.prototype.toString = function() {\n      return this.name;\n    };\n    // AstParams contains an array of AstParam objects\n    function AstParams(params, methodArgsParam) {\n      this.params = params;\n      this.methodArgsParam = methodArgsParam;\n    }\n    AstParams.prototype.getNames = function() {\n      var names = [];\n      for(var i=0,l=this.params.length;i<l;++i) {\n        names.push(this.params[i].name);\n      }\n      return names;\n    };\n    AstParams.prototype.prependMethodArgs = function(body) {\n      if (!this.methodArgsParam) {\n        return body;\n      }\n      return \"{\\nvar \" + this.methodArgsParam.name +\n        \" = Array.prototype.slice.call(arguments, \" +\n        this.params.length + \");\\n\" + body.substring(1);\n    };\n    AstParams.prototype.toString = function() {\n      if(this.params.length === 0) {\n        return \"()\";\n      }\n      var result = \"(\";\n      for(var i=0,l=this.params.length;i<l;++i) {\n        result += this.params[i] + \", \";\n      }\n      return result.substring(0, result.length - 2) + \")\";\n    };\n\n    function transformParams(params) {\n      var paramsWoPars = trim(params.substring(1, params.length - 1));\n      var result = [], methodArgsParam = null;\n      if(paramsWoPars !== \"\") {\n        var paramList = paramsWoPars.split(\",\");\n        for(var i=0; i < paramList.length; ++i) {\n          var param = /\\b([A-Za-z_$][\\w$]*\\b)(\\s*\"[ABC][\\d]*\")*\\s*$/.exec(paramList[i]);\n          if (i === paramList.length - 1 && paramList[i].indexOf('...') >= 0) {\n            methodArgsParam = new AstParam(param[1]);\n            break;\n          }\n          result.push(new AstParam(param[1]));\n        }\n      }\n      return new AstParams(result, methodArgsParam);\n    }\n\n    function preExpressionTransform(expr) {\n      var s = expr;\n      // new type[] {...} --> {...}\n      s = s.replace(/\\bnew\\s+([A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)(?:\\s*\"C\\d+\")+\\s*(\"A\\d+\")/g, function(all, type, init) {\n        return init;\n      });\n      // new Runnable() {...} --> \"F???\"\n      s = s.replace(/\\bnew\\s+([A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)(?:\\s*\"B\\d+\")\\s*(\"A\\d+\")/g, function(all, type, init) {\n        return addAtom(all, 'F');\n      });\n      // function(...) { } --> \"H???\"\n      s = s.replace(functionsRegex, function(all) {\n        return addAtom(all, 'H');\n      });\n      // new type[?] --> createJavaArray('type', [?])\n      s = s.replace(/\\bnew\\s+([A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)\\s*(\"C\\d+\"(?:\\s*\"C\\d+\")*)/g, function(all, type, index) {\n        var args = index.replace(/\"C(\\d+)\"/g, function(all, j) { return atoms[j]; })\n          .replace(/\\[\\s*\\]/g, \"[null]\").replace(/\\s*\\]\\s*\\[\\s*/g, \", \");\n        var arrayInitializer = \"{\" + args.substring(1, args.length - 1) + \"}\";\n        var createArrayArgs = \"('\" + type + \"', \" + addAtom(arrayInitializer, 'A') + \")\";\n        return '$p.createJavaArray' + addAtom(createArrayArgs, 'B');\n      });\n      // .length() --> .length\n      s = s.replace(/(\\.\\s*length)\\s*\"B\\d+\"/g, \"$1\");\n      // #000000 --> 0x000000\n      s = s.replace(/#([0-9A-Fa-f]{6})\\b/g, function(all, digits) {\n        return \"0xFF\" + digits;\n      });\n      // delete (type)???, except (int)???\n      s = s.replace(/\"B(\\d+)\"(\\s*(?:[\\w$']|\"B))/g, function(all, index, next) {\n        var atom = atoms[index];\n        if(!/^\\(\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*\\s*(?:\"C\\d+\"\\s*)*\\)$/.test(atom)) {\n          return all;\n        }\n        if(/^\\(\\s*int\\s*\\)$/.test(atom)) {\n          return \"(int)\" + next;\n        }\n        var indexParts = atom.split(/\"C(\\d+)\"/g);\n        if(indexParts.length > 1) {\n          // even items contains atom numbers, can check only first\n          if(! /^\\[\\s*\\]$/.test(atoms[indexParts[1]])) {\n            return all; // fallback - not a cast\n          }\n        }\n        return \"\" + next;\n      });\n      // (int)??? -> __int_cast(???)\n      s = s.replace(/\\(int\\)([^,\\]\\)\\}\\?\\:\\*\\+\\-\\/\\^\\|\\%\\&\\~<\\>\\=]+)/g, function(all, arg) {\n        var trimmed = trimSpaces(arg);\n        return trimmed.untrim(\"__int_cast(\" + trimmed.middle + \")\");\n      });\n      // super() -> $superCstr(), super. -> $super.;\n      s = s.replace(/\\bsuper(\\s*\"B\\d+\")/g, \"$$superCstr$1\").replace(/\\bsuper(\\s*\\.)/g, \"$$super$1\");\n      // 000.43->0.43 and 0010f->10, but not 0010\n      s = s.replace(/\\b0+((\\d*)(?:\\.[\\d*])?(?:[eE][\\-\\+]?\\d+)?[fF]?)\\b/, function(all, numberWo0, intPart) {\n        if( numberWo0 === intPart) {\n          return all;\n        }\n        return intPart === \"\" ? \"0\" + numberWo0 : numberWo0;\n      });\n      // 3.0f -> 3.0\n      s = s.replace(/\\b(\\.?\\d+\\.?)[fF]\\b/g, \"$1\");\n      // Weird (?) parsing errors with %\n      s = s.replace(/([^\\s])%([^=\\s])/g, \"$1 % $2\");\n      // Since frameRate() and frameRate are different things,\n      // we need to differentiate them somehow. So when we parse\n      // the Processing.js source, replace frameRate so it isn't\n      // confused with frameRate(), as well as keyPressed and mousePressed\n      s = s.replace(/\\b(frameRate|keyPressed|mousePressed)\\b(?!\\s*\"B)/g, \"__$1\");\n      // \"boolean\", \"byte\", \"int\", etc. => \"parseBoolean\", \"parseByte\", \"parseInt\", etc.\n      s = s.replace(/\\b(boolean|byte|char|float|int)\\s*\"B/g, function(all, name) {\n        return \"parse\" + name.substring(0, 1).toUpperCase() + name.substring(1) + \"\\\"B\";\n      });\n      // \"pixels\" replacements:\n      //   pixels[i] = c => pixels.setPixel(i,c) | pixels[i] => pixels.getPixel(i)\n      //   pixels.length => pixels.getLength()\n      //   pixels = ar => pixels.set(ar) | pixels => pixels.toArray()\n      s = s.replace(/\\bpixels\\b\\s*((\"C(\\d+)\")|\\.length)?(\\s*=(?!=)([^,\\]\\)\\}]+))?/g,\n        function(all, indexOrLength, index, atomIndex, equalsPart, rightSide) {\n          if(index) {\n            var atom = atoms[atomIndex];\n            if(equalsPart) {\n              return \"pixels.setPixel\" + addAtom(\"(\" +atom.substring(1, atom.length - 1) +\n                \",\" + rightSide + \")\", 'B');\n            }\n            return \"pixels.getPixel\" + addAtom(\"(\" + atom.substring(1, atom.length - 1) +\n              \")\", 'B');\n          }\n          if(indexOrLength) {\n            // length\n            return \"pixels.getLength\" + addAtom(\"()\", 'B');\n          }\n          if(equalsPart) {\n            return \"pixels.set\" + addAtom(\"(\" + rightSide + \")\", 'B');\n          }\n          return \"pixels.toArray\" + addAtom(\"()\", 'B');\n        });\n      // Java method replacements for: replace, replaceAll, replaceFirst, equals, hashCode, etc.\n      //   xxx.replace(yyy) -> __replace(xxx, yyy)\n      //   \"xx\".replace(yyy) -> __replace(\"xx\", yyy)\n      var repeatJavaReplacement;\n      function replacePrototypeMethods(all, subject, method, atomIndex) {\n        var atom = atoms[atomIndex];\n        repeatJavaReplacement = true;\n        var trimmed = trimSpaces(atom.substring(1, atom.length - 1));\n        return \"__\" + method  + ( trimmed.middle === \"\" ? addAtom(\"(\" + subject.replace(/\\.\\s*$/, \"\") + \")\", 'B') :\n          addAtom(\"(\" + subject.replace(/\\.\\s*$/, \"\") + \",\" + trimmed.middle + \")\", 'B') );\n      }\n      do {\n        repeatJavaReplacement = false;\n        s = s.replace(/((?:'\\d+'|\\b[A-Za-z_$][\\w$]*\\s*(?:\"[BC]\\d+\")*)\\s*\\.\\s*(?:[A-Za-z_$][\\w$]*\\s*(?:\"[BC]\\d+\"\\s*)*\\.\\s*)*)(replace|replaceAll|replaceFirst|contains|equals|equalsIgnoreCase|hashCode|toCharArray|printStackTrace|split|startsWith|endsWith|codePointAt|matches)\\s*\"B(\\d+)\"/g,\n          replacePrototypeMethods);\n      } while (repeatJavaReplacement);\n      // xxx instanceof yyy -> __instanceof(xxx, yyy)\n      function replaceInstanceof(all, subject, type) {\n        repeatJavaReplacement = true;\n        return \"__instanceof\" + addAtom(\"(\" + subject + \", \" + type + \")\", 'B');\n      }\n      do {\n        repeatJavaReplacement = false;\n        s = s.replace(/((?:'\\d+'|\\b[A-Za-z_$][\\w$]*\\s*(?:\"[BC]\\d+\")*)\\s*(?:\\.\\s*[A-Za-z_$][\\w$]*\\s*(?:\"[BC]\\d+\"\\s*)*)*)instanceof\\s+([A-Za-z_$][\\w$]*\\s*(?:\\.\\s*[A-Za-z_$][\\w$]*)*)/g,\n          replaceInstanceof);\n      } while (repeatJavaReplacement);\n      // this() -> $constr()\n      s = s.replace(/\\bthis(\\s*\"B\\d+\")/g, \"$$constr$1\");\n\n      return s;\n    }\n\n    function AstInlineClass(baseInterfaceName, body) {\n      this.baseInterfaceName = baseInterfaceName;\n      this.body = body;\n      body.owner = this;\n    }\n    AstInlineClass.prototype.toString = function() {\n      return \"new (\" + this.body + \")\";\n    };\n\n    function transformInlineClass(class_) {\n      var m = new RegExp(/\\bnew\\s*([A-Za-z_$][\\w$]*\\s*(?:\\.\\s*[A-Za-z_$][\\w$]*)*)\\s*\"B\\d+\"\\s*\"A(\\d+)\"/).exec(class_);\n      var oldClassId = currentClassId, newClassId = generateClassId();\n      currentClassId = newClassId;\n      var uniqueClassName = m[1] + \"$\" + newClassId;\n      var inlineClass = new AstInlineClass(uniqueClassName,\n        transformClassBody(atoms[m[2]], uniqueClassName, \"\", \"implements \" + m[1]));\n      appendClass(inlineClass, newClassId, oldClassId);\n      currentClassId = oldClassId;\n      return inlineClass;\n    }\n\n    function AstFunction(name, params, body) {\n      this.name = name;\n      this.params = params;\n      this.body = body;\n    }\n    AstFunction.prototype.toString = function() {\n      var oldContext = replaceContext;\n      // saving \"this.\" and parameters\n      var names = appendToLookupTable({\"this\":null}, this.params.getNames());\n      replaceContext = function (subject) {\n        return names.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);\n      };\n      var result = \"function\";\n      if(this.name) {\n        result += \" \" + this.name;\n      }\n      var body = this.params.prependMethodArgs(this.body.toString());\n      result += this.params + \" \" + body;\n      replaceContext = oldContext;\n      return result;\n    };\n\n    function transformFunction(class_) {\n      var m = new RegExp(/\\b([A-Za-z_$][\\w$]*)\\s*\"B(\\d+)\"\\s*\"A(\\d+)\"/).exec(class_);\n      return new AstFunction( m[1] !== \"function\" ? m[1] : null,\n        transformParams(atoms[m[2]]), transformStatementsBlock(atoms[m[3]]));\n    }\n\n    function AstInlineObject(members) {\n      this.members = members;\n    }\n    AstInlineObject.prototype.toString = function() {\n      var oldContext = replaceContext;\n      replaceContext = function (subject) {\n          return subject.name === \"this\" ? \"this\" : oldContext(subject); // saving \"this.\"\n      };\n      var result = \"\";\n      for(var i=0,l=this.members.length;i<l;++i) {\n        if(this.members[i].label) {\n          result += this.members[i].label + \": \";\n        }\n        result += this.members[i].value.toString() + \", \";\n      }\n      replaceContext = oldContext;\n      return result.substring(0, result.length - 2);\n    };\n\n    function transformInlineObject(obj) {\n      var members = obj.split(',');\n      for(var i=0; i < members.length; ++i) {\n        var label = members[i].indexOf(':');\n        if(label < 0) {\n          members[i] = { value: transformExpression(members[i]) };\n        } else {\n          members[i] = { label: trim(members[i].substring(0, label)),\n            value: transformExpression( trim(members[i].substring(label + 1)) ) };\n        }\n      }\n      return new AstInlineObject(members);\n    }\n\n    function expandExpression(expr) {\n      if(expr.charAt(0) === '(' || expr.charAt(0) === '[') {\n        return expr.charAt(0) + expandExpression(expr.substring(1, expr.length - 1)) + expr.charAt(expr.length - 1);\n      }\n      if(expr.charAt(0) === '{') {\n        if(/^\\{\\s*(?:[A-Za-z_$][\\w$]*|'\\d+')\\s*:/.test(expr)) {\n          return \"{\" + addAtom(expr.substring(1, expr.length - 1), 'I') + \"}\";\n        }\n        return \"[\" + expandExpression(expr.substring(1, expr.length - 1)) + \"]\";\n      }\n      var trimmed = trimSpaces(expr);\n      var result = preExpressionTransform(trimmed.middle);\n      result = result.replace(/\"[ABC](\\d+)\"/g, function(all, index) {\n        return expandExpression(atoms[index]);\n      });\n      return trimmed.untrim(result);\n    }\n\n    function replaceContextInVars(expr) {\n      return expr.replace(/(\\.\\s*)?((?:\\b[A-Za-z_]|\\$)[\\w$]*)(\\s*\\.\\s*([A-Za-z_$][\\w$]*)(\\s*\\()?)?/g,\n        function(all, memberAccessSign, identifier, suffix, subMember, callSign) {\n          if(memberAccessSign) {\n            return all;\n          }\n          var subject = { name: identifier, member: subMember, callSign: !!callSign };\n          return replaceContext(subject) + (suffix === undef ? \"\" : suffix);\n        });\n    }\n\n    function AstExpression(expr, transforms) {\n      this.expr = expr;\n      this.transforms = transforms;\n    }\n    AstExpression.prototype.toString = function() {\n      var transforms = this.transforms;\n      var expr = replaceContextInVars(this.expr);\n      return expr.replace(/\"!(\\d+)\"/g, function(all, index) {\n        return transforms[index].toString();\n      });\n    };\n\n    transformExpression = function(expr) {\n      var transforms = [];\n      var s = expandExpression(expr);\n      s = s.replace(/\"H(\\d+)\"/g, function(all, index) {\n        transforms.push(transformFunction(atoms[index]));\n        return '\"!' + (transforms.length - 1) + '\"';\n      });\n      s = s.replace(/\"F(\\d+)\"/g, function(all, index) {\n        transforms.push(transformInlineClass(atoms[index]));\n        return '\"!' + (transforms.length - 1) + '\"';\n      });\n      s = s.replace(/\"I(\\d+)\"/g, function(all, index) {\n        transforms.push(transformInlineObject(atoms[index]));\n        return '\"!' + (transforms.length - 1) + '\"';\n      });\n\n      return new AstExpression(s, transforms);\n    };\n\n    function AstVarDefinition(name, value, isDefault) {\n      this.name = name;\n      this.value = value;\n      this.isDefault = isDefault;\n    }\n    AstVarDefinition.prototype.toString = function() {\n      return this.name + ' = ' + this.value;\n    };\n\n    function transformVarDefinition(def, defaultTypeValue) {\n      var eqIndex = def.indexOf(\"=\");\n      var name, value, isDefault;\n      if(eqIndex < 0) {\n        name = def;\n        value = defaultTypeValue;\n        isDefault = true;\n      } else {\n        name = def.substring(0, eqIndex);\n        value = transformExpression(def.substring(eqIndex + 1));\n        isDefault = false;\n      }\n      return new AstVarDefinition( trim(name.replace(/(\\s*\"C\\d+\")+/g, \"\")),\n        value, isDefault);\n    }\n\n    function getDefaultValueForType(type) {\n        if(type === \"int\" || type === \"float\") {\n          return \"0\";\n        }\n        if(type === \"boolean\") {\n          return \"false\";\n        }\n        if(type === \"color\") {\n          return \"0x00000000\";\n        }\n        return \"null\";\n    }\n\n    function AstVar(definitions, varType) {\n      this.definitions = definitions;\n      this.varType = varType;\n    }\n    AstVar.prototype.getNames = function() {\n      var names = [];\n      for(var i=0,l=this.definitions.length;i<l;++i) {\n        names.push(this.definitions[i].name);\n      }\n      return names;\n    };\n    AstVar.prototype.toString = function() {\n      return \"var \" + this.definitions.join(\",\");\n    };\n    function AstStatement(expression) {\n      this.expression = expression;\n    }\n    AstStatement.prototype.toString = function() {\n      return this.expression.toString();\n    };\n\n    function transformStatement(statement) {\n      if(fieldTest.test(statement)) {\n        var attrAndType = attrAndTypeRegex.exec(statement);\n        var definitions = statement.substring(attrAndType[0].length).split(\",\");\n        var defaultTypeValue = getDefaultValueForType(attrAndType[2]);\n        for(var i=0; i < definitions.length; ++i) {\n          definitions[i] = transformVarDefinition(definitions[i], defaultTypeValue);\n        }\n        return new AstVar(definitions, attrAndType[2]);\n      }\n      return new AstStatement(transformExpression(statement));\n    }\n\n    function AstForExpression(initStatement, condition, step) {\n      this.initStatement = initStatement;\n      this.condition = condition;\n      this.step = step;\n    }\n    AstForExpression.prototype.toString = function() {\n      return \"(\" + this.initStatement + \"; \" + this.condition + \"; \" + this.step + \")\";\n    };\n\n    function AstForInExpression(initStatement, container) {\n      this.initStatement = initStatement;\n      this.container = container;\n    }\n    AstForInExpression.prototype.toString = function() {\n      var init = this.initStatement.toString();\n      if(init.indexOf(\"=\") >= 0) { // can be without var declaration\n        init = init.substring(0, init.indexOf(\"=\"));\n      }\n      return \"(\" + init + \" in \" + this.container + \")\";\n    };\n\n    function AstForEachExpression(initStatement, container) {\n      this.initStatement = initStatement;\n      this.container = container;\n    }\n    AstForEachExpression.iteratorId = 0;\n    AstForEachExpression.prototype.toString = function() {\n      var init = this.initStatement.toString();\n      var iterator = \"$it\" + (AstForEachExpression.iteratorId++);\n      var variableName = init.replace(/^\\s*var\\s*/, \"\").split(\"=\")[0];\n      var initIteratorAndVariable = \"var \" + iterator + \" = new $p.ObjectIterator(\" + this.container + \"), \" +\n         variableName + \" = void(0)\";\n      var nextIterationCondition = iterator + \".hasNext() && ((\" +\n         variableName + \" = \" + iterator + \".next()) || true)\";\n      return \"(\" + initIteratorAndVariable + \"; \" + nextIterationCondition + \";)\";\n    };\n\n    function transformForExpression(expr) {\n      var content;\n      if (/\\bin\\b/.test(expr)) {\n        content = expr.substring(1, expr.length - 1).split(/\\bin\\b/g);\n        return new AstForInExpression( transformStatement(trim(content[0])),\n          transformExpression(content[1]));\n      }\n      if (expr.indexOf(\":\") >= 0 && expr.indexOf(\";\") < 0) {\n        content = expr.substring(1, expr.length - 1).split(\":\");\n        return new AstForEachExpression( transformStatement(trim(content[0])),\n          transformExpression(content[1]));\n      }\n      content = expr.substring(1, expr.length - 1).split(\";\");\n      return new AstForExpression( transformStatement(trim(content[0])),\n        transformExpression(content[1]), transformExpression(content[2]));\n    }\n\n    function sortByWeight(array) {\n      array.sort(function (a,b) {\n        return b.weight - a.weight;\n      });\n    }\n\n    function AstInnerInterface(name, body, isStatic) {\n      this.name = name;\n      this.body = body;\n      this.isStatic = isStatic;\n      body.owner = this;\n    }\n    AstInnerInterface.prototype.toString = function() {\n      return \"\" + this.body;\n    };\n    function AstInnerClass(name, body, isStatic) {\n      this.name = name;\n      this.body = body;\n      this.isStatic = isStatic;\n      body.owner = this;\n    }\n    AstInnerClass.prototype.toString = function() {\n      return \"\" + this.body;\n    };\n\n    function transformInnerClass(class_) {\n      var m = classesRegex.exec(class_); // 1 - attr, 2 - class|int, 3 - name, 4 - extends, 5 - implements, 6 - body\n      classesRegex.lastIndex = 0;\n      var isStatic = m[1].indexOf(\"static\") >= 0;\n      var body = atoms[getAtomIndex(m[6])], innerClass;\n      var oldClassId = currentClassId, newClassId = generateClassId();\n      currentClassId = newClassId;\n      if(m[2] === \"interface\") {\n        innerClass = new AstInnerInterface(m[3], transformInterfaceBody(body, m[3], m[4]), isStatic);\n      } else {\n        innerClass = new AstInnerClass(m[3], transformClassBody(body, m[3], m[4], m[5]), isStatic);\n      }\n      appendClass(innerClass, newClassId, oldClassId);\n      currentClassId = oldClassId;\n      return innerClass;\n    }\n\n    function AstClassMethod(name, params, body, isStatic) {\n      this.name = name;\n      this.params = params;\n      this.body = body;\n      this.isStatic = isStatic;\n    }\n    AstClassMethod.prototype.toString = function(){\n      var paramNames = appendToLookupTable({}, this.params.getNames());\n      var oldContext = replaceContext;\n      replaceContext = function (subject) {\n        return paramNames.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);\n      };\n      var body = this.params.prependMethodArgs(this.body.toString());\n      var result = \"function \" + this.methodId + this.params + \" \" + body +\"\\n\";\n      replaceContext = oldContext;\n      return result;\n    };\n\n    function transformClassMethod(method) {\n      var m = methodsRegex.exec(method);\n      methodsRegex.lastIndex = 0;\n      var isStatic = m[1].indexOf(\"static\") >= 0;\n      var body = m[6] !== ';' ? atoms[getAtomIndex(m[6])] : \"{}\";\n      return new AstClassMethod(m[3], transformParams(atoms[getAtomIndex(m[4])]),\n        transformStatementsBlock(body), isStatic );\n    }\n\n    function AstClassField(definitions, fieldType, isStatic) {\n      this.definitions = definitions;\n      this.fieldType = fieldType;\n      this.isStatic = isStatic;\n    }\n    AstClassField.prototype.getNames = function() {\n      var names = [];\n      for(var i=0,l=this.definitions.length;i<l;++i) {\n        names.push(this.definitions[i].name);\n      }\n      return names;\n    };\n    AstClassField.prototype.toString = function() {\n      var thisPrefix = replaceContext({ name: \"[this]\" });\n      if(this.isStatic) {\n        var className = this.owner.name;\n        var staticDeclarations = [];\n        for(var i=0,l=this.definitions.length;i<l;++i) {\n          var definition = this.definitions[i];\n          var name = definition.name, staticName = className + \".\" + name;\n          var declaration = \"if(\" + staticName + \" === void(0)) {\\n\" +\n            \" \" + staticName + \" = \" + definition.value + \"; }\\n\" +\n            \"$p.defineProperty(\" + thisPrefix + \", \" +\n            \"'\" + name + \"', { get: function(){return \" + staticName + \";}, \" +\n            \"set: function(val){\" + staticName + \" = val;} });\\n\";\n          staticDeclarations.push(declaration);\n        }\n        return staticDeclarations.join(\"\");\n      }\n      return thisPrefix + \".\" + this.definitions.join(\"; \" + thisPrefix + \".\");\n    };\n\n    function transformClassField(statement) {\n      var attrAndType = attrAndTypeRegex.exec(statement);\n      var isStatic = attrAndType[1].indexOf(\"static\") >= 0;\n      var definitions = statement.substring(attrAndType[0].length).split(/,\\s*/g);\n      var defaultTypeValue = getDefaultValueForType(attrAndType[2]);\n      for(var i=0; i < definitions.length; ++i) {\n        definitions[i] = transformVarDefinition(definitions[i], defaultTypeValue);\n      }\n      return new AstClassField(definitions, attrAndType[2], isStatic);\n    }\n\n    function AstConstructor(params, body) {\n      this.params = params;\n      this.body = body;\n    }\n    AstConstructor.prototype.toString = function() {\n      var paramNames = appendToLookupTable({}, this.params.getNames());\n      var oldContext = replaceContext;\n      replaceContext = function (subject) {\n        return paramNames.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);\n      };\n      var prefix = \"function $constr_\" + this.params.params.length + this.params.toString();\n      var body = this.params.prependMethodArgs(this.body.toString());\n      if(!/\\$(superCstr|constr)\\b/.test(body)) {\n        body = \"{\\n$superCstr();\\n\" + body.substring(1);\n      }\n      replaceContext = oldContext;\n      return prefix + body + \"\\n\";\n    };\n\n    function transformConstructor(cstr) {\n      var m = new RegExp(/\"B(\\d+)\"\\s*\"A(\\d+)\"/).exec(cstr);\n      var params = transformParams(atoms[m[1]]);\n\n      return new AstConstructor(params, transformStatementsBlock(atoms[m[2]]));\n    }\n\n    function AstInterfaceBody(name, interfacesNames, methodsNames, fields, innerClasses, misc) {\n      var i,l;\n      this.name = name;\n      this.interfacesNames = interfacesNames;\n      this.methodsNames = methodsNames;\n      this.fields = fields;\n      this.innerClasses = innerClasses;\n      this.misc = misc;\n      for(i=0,l=fields.length; i<l; ++i) {\n        fields[i].owner = this;\n      }\n    }\n    AstInterfaceBody.prototype.getMembers = function(classFields, classMethods, classInners) {\n      if(this.owner.base) {\n        this.owner.base.body.getMembers(classFields, classMethods, classInners);\n      }\n      var i, j, l, m;\n      for(i=0,l=this.fields.length;i<l;++i) {\n        var fieldNames = this.fields[i].getNames();\n        for(j=0,m=fieldNames.length;j<m;++j) {\n          classFields[fieldNames[j]] = this.fields[i];\n        }\n      }\n      for(i=0,l=this.methodsNames.length;i<l;++i) {\n        var methodName = this.methodsNames[i];\n        classMethods[methodName] = true;\n      }\n      for(i=0,l=this.innerClasses.length;i<l;++i) {\n        var innerClass = this.innerClasses[i];\n        classInners[innerClass.name] = innerClass;\n      }\n    };\n    AstInterfaceBody.prototype.toString = function() {\n      function getScopeLevel(p) {\n        var i = 0;\n        while(p) {\n          ++i;\n          p=p.scope;\n        }\n        return i;\n      }\n\n      var scopeLevel = getScopeLevel(this.owner);\n\n      var className = this.name;\n      var staticDefinitions = \"\";\n      var metadata = \"\";\n\n      var thisClassFields = {}, thisClassMethods = {}, thisClassInners = {};\n      this.getMembers(thisClassFields, thisClassMethods, thisClassInners);\n\n      var i, l, j, m;\n\n      if (this.owner.interfaces) {\n        // interface name can be present, but interface is not\n        var resolvedInterfaces = [], resolvedInterface;\n        for (i = 0, l = this.interfacesNames.length; i < l; ++i) {\n          if (!this.owner.interfaces[i]) {\n            continue;\n          }\n          resolvedInterface = replaceContext({name: this.interfacesNames[i]});\n          resolvedInterfaces.push(resolvedInterface);\n          staticDefinitions += \"$p.extendInterfaceMembers(\" + className + \", \" + resolvedInterface + \");\\n\";\n        }\n        metadata += className + \".$interfaces = [\" + resolvedInterfaces.join(\", \") + \"];\\n\";\n      }\n      metadata += className + \".$isInterface = true;\\n\";\n      metadata += className + \".$methods = [\\'\" + this.methodsNames.join(\"\\', \\'\") + \"\\'];\\n\";\n\n      sortByWeight(this.innerClasses);\n      for (i = 0, l = this.innerClasses.length; i < l; ++i) {\n        var innerClass = this.innerClasses[i];\n        if (innerClass.isStatic) {\n          staticDefinitions += className + \".\" + innerClass.name + \" = \" + innerClass + \";\\n\";\n        }\n      }\n\n      for (i = 0, l = this.fields.length; i < l; ++i) {\n        var field = this.fields[i];\n        if (field.isStatic) {\n          staticDefinitions += className + \".\" + field.definitions.join(\";\\n\" + className + \".\") + \";\\n\";\n        }\n      }\n\n      return \"(function() {\\n\" +\n        \"function \" + className + \"() { throw \\'Unable to create the interface\\'; }\\n\" +\n        staticDefinitions +\n        metadata +\n        \"return \" + className + \";\\n\" +\n        \"})()\";\n    };\n\n    transformInterfaceBody = function(body, name, baseInterfaces) {\n      var declarations = body.substring(1, body.length - 1);\n      declarations = extractClassesAndMethods(declarations);\n      declarations = extractConstructors(declarations, name);\n      var methodsNames = [], classes = [];\n      declarations = declarations.replace(/\"([DE])(\\d+)\"/g, function(all, type, index) {\n        if(type === 'D') { methodsNames.push(index); }\n        else if(type === 'E') { classes.push(index); }\n        return \"\";\n      });\n      var fields = declarations.split(/;(?:\\s*;)*/g);\n      var baseInterfaceNames;\n      var i, l;\n\n      if(baseInterfaces !== undef) {\n        baseInterfaceNames = baseInterfaces.replace(/^\\s*extends\\s+(.+?)\\s*$/g, \"$1\").split(/\\s*,\\s*/g);\n      }\n\n      for(i = 0, l = methodsNames.length; i < l; ++i) {\n        var method = transformClassMethod(atoms[methodsNames[i]]);\n        methodsNames[i] = method.name;\n      }\n      for(i = 0, l = fields.length - 1; i < l; ++i) {\n        var field = trimSpaces(fields[i]);\n        fields[i] = transformClassField(field.middle);\n      }\n      var tail = fields.pop();\n      for(i = 0, l = classes.length; i < l; ++i) {\n        classes[i] = transformInnerClass(atoms[classes[i]]);\n      }\n\n      return new AstInterfaceBody(name, baseInterfaceNames, methodsNames, fields, classes, { tail: tail });\n    };\n\n    function AstClassBody(name, baseClassName, interfacesNames, functions, methods, fields, cstrs, innerClasses, misc) {\n      var i,l;\n      this.name = name;\n      this.baseClassName = baseClassName;\n      this.interfacesNames = interfacesNames;\n      this.functions = functions;\n      this.methods = methods;\n      this.fields = fields;\n      this.cstrs = cstrs;\n      this.innerClasses = innerClasses;\n      this.misc = misc;\n      for(i=0,l=fields.length; i<l; ++i) {\n        fields[i].owner = this;\n      }\n    }\n    AstClassBody.prototype.getMembers = function(classFields, classMethods, classInners) {\n      if(this.owner.base) {\n        this.owner.base.body.getMembers(classFields, classMethods, classInners);\n      }\n      var i, j, l, m;\n      for(i=0,l=this.fields.length;i<l;++i) {\n        var fieldNames = this.fields[i].getNames();\n        for(j=0,m=fieldNames.length;j<m;++j) {\n          classFields[fieldNames[j]] = this.fields[i];\n        }\n      }\n      for(i=0,l=this.methods.length;i<l;++i) {\n        var method = this.methods[i];\n        classMethods[method.name] = method;\n      }\n      for(i=0,l=this.innerClasses.length;i<l;++i) {\n        var innerClass = this.innerClasses[i];\n        classInners[innerClass.name] = innerClass;\n      }\n    };\n    AstClassBody.prototype.toString = function() {\n      function getScopeLevel(p) {\n        var i = 0;\n        while(p) {\n          ++i;\n          p=p.scope;\n        }\n        return i;\n      }\n\n      var scopeLevel = getScopeLevel(this.owner);\n\n      var selfId = \"$this_\" + scopeLevel;\n      var className = this.name;\n      var result = \"var \" + selfId + \" = this;\\n\";\n      var staticDefinitions = \"\";\n      var metadata = \"\";\n\n      var thisClassFields = {}, thisClassMethods = {}, thisClassInners = {};\n      this.getMembers(thisClassFields, thisClassMethods, thisClassInners);\n\n      var oldContext = replaceContext;\n      replaceContext = function (subject) {\n        var name = subject.name;\n        if(name === \"this\") {\n          // returns \"$this_N.$self\" pointer instead of \"this\" in cases:\n          // \"this()\", \"this.XXX()\", \"this\", but not for \"this.XXX\"\n          return subject.callSign || !subject.member ? selfId + \".$self\" : selfId;\n        }\n        if(thisClassFields.hasOwnProperty(name)) {\n          return thisClassFields[name].isStatic ? className + \".\" + name : selfId + \".\" + name;\n        }\n        if(thisClassInners.hasOwnProperty(name)) {\n          return selfId + \".\" + name;\n        }\n        if(thisClassMethods.hasOwnProperty(name)) {\n          return thisClassMethods[name].isStatic ? className + \".\" + name : selfId + \".$self.\" + name;\n        }\n        return oldContext(subject);\n      };\n\n      var resolvedBaseClassName;\n      if (this.baseClassName) {\n        resolvedBaseClassName = oldContext({name: this.baseClassName});\n        result += \"var $super = { $upcast: \" + selfId + \" };\\n\";\n        result += \"function $superCstr(){\" + resolvedBaseClassName +\n          \".apply($super,arguments);if(!('$self' in $super)) $p.extendClassChain($super)}\\n\";\n        metadata += className + \".$base = \" + resolvedBaseClassName + \";\\n\";\n      } else {\n        result += \"function $superCstr(){$p.extendClassChain(\"+ selfId +\")}\\n\";\n      }\n\n      if (this.owner.base) {\n        // base class name can be present, but class is not\n        staticDefinitions += \"$p.extendStaticMembers(\" + className + \", \" + resolvedBaseClassName + \");\\n\";\n      }\n\n      var i, l, j, m;\n\n      if (this.owner.interfaces) {\n        // interface name can be present, but interface is not\n        var resolvedInterfaces = [], resolvedInterface;\n        for (i = 0, l = this.interfacesNames.length; i < l; ++i) {\n          if (!this.owner.interfaces[i]) {\n            continue;\n          }\n          resolvedInterface = oldContext({name: this.interfacesNames[i]});\n          resolvedInterfaces.push(resolvedInterface);\n          staticDefinitions += \"$p.extendInterfaceMembers(\" + className + \", \" + resolvedInterface + \");\\n\";\n        }\n        metadata += className + \".$interfaces = [\" + resolvedInterfaces.join(\", \") + \"];\\n\";\n      }\n\n      if (this.functions.length > 0) {\n        result += this.functions.join('\\n') + '\\n';\n      }\n\n      sortByWeight(this.innerClasses);\n      for (i = 0, l = this.innerClasses.length; i < l; ++i) {\n        var innerClass = this.innerClasses[i];\n        if (innerClass.isStatic) {\n          staticDefinitions += className + \".\" + innerClass.name + \" = \" + innerClass + \";\\n\";\n          result += selfId + \".\" + innerClass.name + \" = \" + className + \".\" + innerClass.name + \";\\n\";\n        } else {\n          result += selfId + \".\" + innerClass.name + \" = \" + innerClass + \";\\n\";\n        }\n      }\n\n      for (i = 0, l = this.fields.length; i < l; ++i) {\n        var field = this.fields[i];\n        if (field.isStatic) {\n          staticDefinitions += className + \".\" + field.definitions.join(\";\\n\" + className + \".\") + \";\\n\";\n          for (j = 0, m = field.definitions.length; j < m; ++j) {\n            var fieldName = field.definitions[j].name, staticName = className + \".\" + fieldName;\n            result += \"$p.defineProperty(\" + selfId + \", '\" + fieldName + \"', {\" +\n              \"get: function(){return \" + staticName + \"}, \" +\n              \"set: function(val){\" + staticName + \" = val}});\\n\";\n          }\n        } else {\n          result += selfId + \".\" + field.definitions.join(\";\\n\" + selfId + \".\") + \";\\n\";\n        }\n      }\n      var methodOverloads = {};\n      for (i = 0, l = this.methods.length; i < l; ++i) {\n        var method = this.methods[i];\n        var overload = methodOverloads[method.name];\n        var methodId = method.name + \"$\" + method.params.params.length;\n        var hasMethodArgs = !!method.params.methodArgsParam;\n        if (overload) {\n          ++overload;\n          methodId += \"_\" + overload;\n        } else {\n          overload = 1;\n        }\n        method.methodId = methodId;\n        methodOverloads[method.name] = overload;\n        if (method.isStatic) {\n          staticDefinitions += method;\n          staticDefinitions += \"$p.addMethod(\" + className + \", '\" + method.name + \"', \" + methodId + \", \" + hasMethodArgs + \");\\n\";\n          result += \"$p.addMethod(\" + selfId + \", '\" + method.name + \"', \" + methodId + \", \" + hasMethodArgs + \");\\n\";\n        } else {\n          result += method;\n          result += \"$p.addMethod(\" + selfId + \", '\" + method.name + \"', \" + methodId + \", \" + hasMethodArgs + \");\\n\";\n        }\n      }\n      result += trim(this.misc.tail);\n\n      if (this.cstrs.length > 0) {\n        result += this.cstrs.join('\\n') + '\\n';\n      }\n\n      result += \"function $constr() {\\n\";\n      var cstrsIfs = [];\n      for (i = 0, l = this.cstrs.length; i < l; ++i) {\n        var paramsLength = this.cstrs[i].params.params.length;\n        var methodArgsPresent = !!this.cstrs[i].params.methodArgsParam;\n        cstrsIfs.push(\"if(arguments.length \" + (methodArgsPresent ? \">=\" : \"===\") +\n          \" \" + paramsLength + \") { \" +\n          \"$constr_\" + paramsLength + \".apply(\" + selfId + \", arguments); }\");\n      }\n      if(cstrsIfs.length > 0) {\n        result += cstrsIfs.join(\" else \") + \" else \";\n      }\n      // ??? add check if length is 0, otherwise fail\n      result += \"$superCstr();\\n}\\n\";\n      result += \"$constr.apply(null, arguments);\\n\";\n\n      replaceContext = oldContext;\n      return \"(function() {\\n\" +\n        \"function \" + className + \"() {\\n\" + result + \"}\\n\" +\n        staticDefinitions +\n        metadata +\n        \"return \" + className + \";\\n\" +\n        \"})()\";\n    };\n\n    transformClassBody = function(body, name, baseName, interfaces) {\n      var declarations = body.substring(1, body.length - 1);\n      declarations = extractClassesAndMethods(declarations);\n      declarations = extractConstructors(declarations, name);\n      var methods = [], classes = [], cstrs = [], functions = [];\n      declarations = declarations.replace(/\"([DEGH])(\\d+)\"/g, function(all, type, index) {\n        if(type === 'D') { methods.push(index); }\n        else if(type === 'E') { classes.push(index); }\n        else if(type === 'H') { functions.push(index); }\n        else { cstrs.push(index); }\n        return \"\";\n      });\n      var fields = declarations.replace(/^(?:\\s*;)+/, \"\").split(/;(?:\\s*;)*/g);\n      var baseClassName, interfacesNames;\n      var i;\n\n      if(baseName !== undef) {\n        baseClassName = baseName.replace(/^\\s*extends\\s+([A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)\\s*$/g, \"$1\");\n      }\n\n      if(interfaces !== undef) {\n        interfacesNames = interfaces.replace(/^\\s*implements\\s+(.+?)\\s*$/g, \"$1\").split(/\\s*,\\s*/g);\n      }\n\n      for(i = 0; i < functions.length; ++i) {\n        functions[i] = transformFunction(atoms[functions[i]]);\n      }\n      for(i = 0; i < methods.length; ++i) {\n        methods[i] = transformClassMethod(atoms[methods[i]]);\n      }\n      for(i = 0; i < fields.length - 1; ++i) {\n        var field = trimSpaces(fields[i]);\n        fields[i] = transformClassField(field.middle);\n      }\n      var tail = fields.pop();\n      for(i = 0; i < cstrs.length; ++i) {\n        cstrs[i] = transformConstructor(atoms[cstrs[i]]);\n      }\n      for(i = 0; i < classes.length; ++i) {\n        classes[i] = transformInnerClass(atoms[classes[i]]);\n      }\n\n      return new AstClassBody(name, baseClassName, interfacesNames, functions, methods, fields, cstrs,\n        classes, { tail: tail });\n    };\n\n    function AstInterface(name, body) {\n      this.name = name;\n      this.body = body;\n      body.owner = this;\n    }\n    AstInterface.prototype.toString = function() {\n      return \"var \" + this.name + \" = \" + this.body + \";\\n\" +\n        \"$p.\" + this.name + \" = \" + this.name + \";\\n\";\n    };\n    function AstClass(name, body) {\n      this.name = name;\n      this.body = body;\n      body.owner = this;\n    }\n    AstClass.prototype.toString = function() {\n      return \"var \" + this.name + \" = \" + this.body + \";\\n\" +\n        \"$p.\" + this.name + \" = \" + this.name + \";\\n\";\n    };\n\n    function transformGlobalClass(class_) {\n      var m = classesRegex.exec(class_); // 1 - attr, 2 - class|int, 3 - name, 4 - extends, 5 - implements, 6 - body\n      classesRegex.lastIndex = 0;\n      var body = atoms[getAtomIndex(m[6])];\n      var oldClassId = currentClassId, newClassId = generateClassId();\n      currentClassId = newClassId;\n      var globalClass;\n      if(m[2] === \"interface\") {\n        globalClass = new AstInterface(m[3], transformInterfaceBody(body, m[3], m[4]) );\n      } else {\n        globalClass = new AstClass(m[3], transformClassBody(body, m[3], m[4], m[5]) );\n      }\n      appendClass(globalClass, newClassId, oldClassId);\n      currentClassId = oldClassId;\n      return globalClass;\n    }\n\n    function AstMethod(name, params, body) {\n      this.name = name;\n      this.params = params;\n      this.body = body;\n    }\n    AstMethod.prototype.toString = function(){\n      var paramNames = appendToLookupTable({}, this.params.getNames());\n      var oldContext = replaceContext;\n      replaceContext = function (subject) {\n        return paramNames.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);\n      };\n      var body = this.params.prependMethodArgs(this.body.toString());\n      var result = \"function \" + this.name + this.params + \" \" + body + \"\\n\" +\n                   \"$p.\" + this.name + \" = \" + this.name + \";\\n\" +\n                   this.name + \" = \" + this.name + \".bind($p);\";\n//        \"$p.\" + this.name + \" = \" + this.name + \";\";\n      replaceContext = oldContext;\n      return result;\n    };\n\n    function transformGlobalMethod(method) {\n      var m = methodsRegex.exec(method);\n      var result =\n      methodsRegex.lastIndex = 0;\n      return new AstMethod(m[3], transformParams(atoms[getAtomIndex(m[4])]),\n        transformStatementsBlock(atoms[getAtomIndex(m[6])]));\n    }\n\n    function preStatementsTransform(statements) {\n      var s = statements;\n      // turns multiple catch blocks into one, because we have no way to properly get into them anyway.\n      s = s.replace(/\\b(catch\\s*\"B\\d+\"\\s*\"A\\d+\")(\\s*catch\\s*\"B\\d+\"\\s*\"A\\d+\")+/g, \"$1\");\n      return s;\n    }\n\n    function AstForStatement(argument, misc) {\n      this.argument = argument;\n      this.misc = misc;\n    }\n    AstForStatement.prototype.toString = function() {\n      return this.misc.prefix + this.argument.toString();\n    };\n    function AstCatchStatement(argument, misc) {\n      this.argument = argument;\n      this.misc = misc;\n    }\n    AstCatchStatement.prototype.toString = function() {\n      return this.misc.prefix + this.argument.toString();\n    };\n    function AstPrefixStatement(name, argument, misc) {\n      this.name = name;\n      this.argument = argument;\n      this.misc = misc;\n    }\n    AstPrefixStatement.prototype.toString = function() {\n      var result = this.misc.prefix;\n      if(this.argument !== undef) {\n        result += this.argument.toString();\n      }\n      return result;\n    };\n    function AstSwitchCase(expr) {\n      this.expr = expr;\n    }\n    AstSwitchCase.prototype.toString = function() {\n      return \"case \" + this.expr + \":\";\n    };\n    function AstLabel(label) {\n      this.label = label;\n    }\n    AstLabel.prototype.toString = function() {\n      return this.label;\n    };\n\n    transformStatements = function(statements, transformMethod, transformClass) {\n      var nextStatement = new RegExp(/\\b(catch|for|if|switch|while|with)\\s*\"B(\\d+)\"|\\b(do|else|finally|return|throw|try|break|continue)\\b|(\"[ADEH](\\d+)\")|\\b(case)\\s+([^:]+):|\\b([A-Za-z_$][\\w$]*\\s*:)|(;)/g);\n      var res = [];\n      statements = preStatementsTransform(statements);\n      var lastIndex = 0, m, space;\n      // m contains the matches from the nextStatement regexp, null if there are no matches.\n      // nextStatement.exec starts searching at nextStatement.lastIndex.\n      while((m = nextStatement.exec(statements)) !== null) {\n        if(m[1] !== undef) { // catch, for ...\n          var i = statements.lastIndexOf('\"B', nextStatement.lastIndex);\n          var statementsPrefix = statements.substring(lastIndex, i);\n          if(m[1] === \"for\") {\n            res.push(new AstForStatement(transformForExpression(atoms[m[2]]),\n              { prefix: statementsPrefix }) );\n          } else if(m[1] === \"catch\") {\n            res.push(new AstCatchStatement(transformParams(atoms[m[2]]),\n              { prefix: statementsPrefix }) );\n          } else {\n            res.push(new AstPrefixStatement(m[1], transformExpression(atoms[m[2]]),\n              { prefix: statementsPrefix }) );\n          }\n        } else if(m[3] !== undef) { // do, else, ...\n            res.push(new AstPrefixStatement(m[3], undef,\n              { prefix: statements.substring(lastIndex, nextStatement.lastIndex) }) );\n        } else if(m[4] !== undef) { // block, class and methods\n          space = statements.substring(lastIndex, nextStatement.lastIndex - m[4].length);\n          if(trim(space).length !== 0) { continue; } // avoiding new type[] {} construct\n          res.push(space);\n          var kind = m[4].charAt(1), atomIndex = m[5];\n          if(kind === 'D') {\n            res.push(transformMethod(atoms[atomIndex]));\n          } else if(kind === 'E') {\n            res.push(transformClass(atoms[atomIndex]));\n          } else if(kind === 'H') {\n            res.push(transformFunction(atoms[atomIndex]));\n          } else {\n            res.push(transformStatementsBlock(atoms[atomIndex]));\n          }\n        } else if(m[6] !== undef) { // switch case\n          res.push(new AstSwitchCase(transformExpression(trim(m[7]))));\n        } else if(m[8] !== undef) { // label\n          space = statements.substring(lastIndex, nextStatement.lastIndex - m[8].length);\n          if(trim(space).length !== 0) { continue; } // avoiding ?: construct\n          res.push(new AstLabel(statements.substring(lastIndex, nextStatement.lastIndex)) );\n        } else { // semicolon\n          var statement = trimSpaces(statements.substring(lastIndex, nextStatement.lastIndex - 1));\n          res.push(statement.left);\n          res.push(transformStatement(statement.middle));\n          res.push(statement.right + \";\");\n        }\n        lastIndex = nextStatement.lastIndex;\n      }\n      var statementsTail = trimSpaces(statements.substring(lastIndex));\n      res.push(statementsTail.left);\n      if(statementsTail.middle !== \"\") {\n        res.push(transformStatement(statementsTail.middle));\n        res.push(\";\" + statementsTail.right);\n      }\n      return res;\n    };\n\n    function getLocalNames(statements) {\n      var localNames = [];\n      for(var i=0,l=statements.length;i<l;++i) {\n        var statement = statements[i];\n        if(statement instanceof AstVar) {\n          localNames = localNames.concat(statement.getNames());\n        } else if(statement instanceof AstForStatement &&\n          statement.argument.initStatement instanceof AstVar) {\n          localNames = localNames.concat(statement.argument.initStatement.getNames());\n        } else if(statement instanceof AstInnerInterface || statement instanceof AstInnerClass ||\n          statement instanceof AstInterface || statement instanceof AstClass ||\n          statement instanceof AstMethod || statement instanceof AstFunction) {\n          localNames.push(statement.name);\n        }\n      }\n      return appendToLookupTable({}, localNames);\n    }\n\n    function AstStatementsBlock(statements) {\n      this.statements = statements;\n    }\n    AstStatementsBlock.prototype.toString = function() {\n      var localNames = getLocalNames(this.statements);\n      var oldContext = replaceContext;\n\n      // replacing context only when necessary\n      if(!isLookupTableEmpty(localNames)) {\n        replaceContext = function (subject) {\n          return localNames.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);\n        };\n      }\n\n      var result = \"{\\n\" + this.statements.join('') + \"\\n}\";\n      replaceContext = oldContext;\n      return result;\n    };\n\n    transformStatementsBlock = function(block) {\n      var content = trimSpaces(block.substring(1, block.length - 1));\n      return new AstStatementsBlock(transformStatements(content.middle));\n    };\n\n    function AstRoot(statements) {\n      this.statements = statements;\n    }\n    AstRoot.prototype.toString = function() {\n      var classes = [], otherStatements = [], statement;\n      for (var i = 0, len = this.statements.length; i < len; ++i) {\n        statement = this.statements[i];\n        if (statement instanceof AstClass || statement instanceof AstInterface) {\n          classes.push(statement);\n        } else {\n          otherStatements.push(statement);\n        }\n      }\n      sortByWeight(classes);\n\n      var localNames = getLocalNames(this.statements);\n      replaceContext = function (subject) {\n        var name = subject.name;\n        if(localNames.hasOwnProperty(name)) {\n          return name;\n        }\n        if(globalMembers.hasOwnProperty(name) ||\n           PConstants.hasOwnProperty(name) ||\n           defaultScope.hasOwnProperty(name)) {\n          return \"$p.\" + name;\n        }\n        return name;\n      };\n      var result = \"// this code was autogenerated from PJS\\n\" +\n        \"(function($p) {\\n\" +\n        classes.join('') + \"\\n\" +\n        otherStatements.join('') + \"\\n})\";\n      replaceContext = null;\n      return result;\n    };\n\n    transformMain = function() {\n      var statements = extractClassesAndMethods(atoms[0]);\n      statements = statements.replace(/\\bimport\\s+[^;]+;/g, \"\");\n      return new AstRoot( transformStatements(statements,\n        transformGlobalMethod, transformGlobalClass) );\n    };\n\n    function generateMetadata(ast) {\n      var globalScope = {};\n      var id, class_;\n      for(id in declaredClasses) {\n        if(declaredClasses.hasOwnProperty(id)) {\n          class_ = declaredClasses[id];\n          var scopeId = class_.scopeId, name = class_.name;\n          if(scopeId) {\n            var scope = declaredClasses[scopeId];\n            class_.scope = scope;\n            if(scope.inScope === undef) {\n              scope.inScope = {};\n            }\n            scope.inScope[name] = class_;\n          } else {\n            globalScope[name] = class_;\n          }\n        }\n      }\n\n      function findInScopes(class_, name) {\n        var parts = name.split('.');\n        var currentScope = class_.scope, found;\n        while(currentScope) {\n          if(currentScope.hasOwnProperty(parts[0])) {\n            found = currentScope[parts[0]]; break;\n          }\n          currentScope = currentScope.scope;\n        }\n        if(found === undef) {\n          found = globalScope[parts[0]];\n        }\n        for(var i=1,l=parts.length;i<l && found;++i) {\n          found = found.inScope[parts[i]];\n        }\n        return found;\n      }\n\n      for(id in declaredClasses) {\n        if(declaredClasses.hasOwnProperty(id)) {\n          class_ = declaredClasses[id];\n          var baseClassName = class_.body.baseClassName;\n          if(baseClassName) {\n            var parent = findInScopes(class_, baseClassName);\n            if (parent) {\n              class_.base = parent;\n              if (!parent.derived) {\n                parent.derived = [];\n              }\n              parent.derived.push(class_);\n            }\n          }\n          var interfacesNames = class_.body.interfacesNames,\n            interfaces = [], i, l;\n          if (interfacesNames && interfacesNames.length > 0) {\n            for (i = 0, l = interfacesNames.length; i < l; ++i) {\n              var interface_ = findInScopes(class_, interfacesNames[i]);\n              interfaces.push(interface_);\n              if (!interface_) {\n                continue;\n              }\n              if (!interface_.derived) {\n                interface_.derived = [];\n              }\n              interface_.derived.push(class_);\n            }\n            if (interfaces.length > 0) {\n              class_.interfaces = interfaces;\n            }\n          }\n        }\n      }\n    }\n\n    function setWeight(ast) {\n      var queue = [], tocheck = {};\n      var id, scopeId, class_;\n      // queue most inner and non-inherited\n      for (id in declaredClasses) {\n        if (declaredClasses.hasOwnProperty(id)) {\n          class_ = declaredClasses[id];\n          if (!class_.inScope && !class_.derived) {\n            queue.push(id);\n            class_.weight = 0;\n          } else {\n            var dependsOn = [];\n            if (class_.inScope) {\n              for (scopeId in class_.inScope) {\n                if (class_.inScope.hasOwnProperty(scopeId)) {\n                  dependsOn.push(class_.inScope[scopeId]);\n                }\n              }\n            }\n            if (class_.derived) {\n              dependsOn = dependsOn.concat(class_.derived);\n            }\n            tocheck[id] = dependsOn;\n          }\n        }\n      }\n      function removeDependentAndCheck(targetId, from) {\n        var dependsOn = tocheck[targetId];\n        if (!dependsOn) {\n          return false; // no need to process\n        }\n        var i = dependsOn.indexOf(from);\n        if (i < 0) {\n          return false;\n        }\n        dependsOn.splice(i, 1);\n        if (dependsOn.length > 0) {\n          return false;\n        }\n        delete tocheck[targetId];\n        return true;\n      }\n      while (queue.length > 0) {\n        id = queue.shift();\n        class_ = declaredClasses[id];\n        if (class_.scopeId && removeDependentAndCheck(class_.scopeId, class_)) {\n          queue.push(class_.scopeId);\n          declaredClasses[class_.scopeId].weight = class_.weight + 1;\n        }\n        if (class_.base && removeDependentAndCheck(class_.base.classId, class_)) {\n          queue.push(class_.base.classId);\n          class_.base.weight = class_.weight + 1;\n        }\n        if (class_.interfaces) {\n          var i, l;\n          for (i = 0, l = class_.interfaces.length; i < l; ++i) {\n            if (!class_.interfaces[i] ||\n                !removeDependentAndCheck(class_.interfaces[i].classId, class_)) {\n              continue;\n            }\n            queue.push(class_.interfaces[i].classId);\n            class_.interfaces[i].weight = class_.weight + 1;\n          }\n        }\n      }\n    }\n\n    var transformed = transformMain();\n    generateMetadata(transformed);\n    setWeight(transformed);\n\n    var redendered = transformed.toString();\n\n    // remove empty extra lines with space\n    redendered = redendered.replace(/\\s*\\n(?:[\\t ]*\\n)+/g, \"\\n\\n\");\n\n    // convert character codes to characters\n    redendered = redendered.replace(/__x([0-9A-F]{4})/g, function(all, hexCode) {\n      return String.fromCharCode(parseInt(hexCode,16));\n    });\n\n    return injectStrings(redendered, strings);\n  }// Parser ends\n\n  function preprocessCode(aCode, sketch) {\n    // Parse out @pjs directive, if any.\n    var dm = new RegExp(/\\/\\*\\s*@pjs\\s+((?:[^\\*]|\\*+[^\\*\\/])*)\\*\\//g).exec(aCode);\n    if (dm && dm.length === 2) {\n      // masks contents of a JSON to be replaced later\n      // to protect the contents from further parsing\n      var jsonItems = [],\n          directives = dm.splice(1, 2)[0].replace(/\\{([\\s\\S]*?)\\}/g, (function() {\n            return function(all, item) {\n              jsonItems.push(item);\n              return \"{\" + (jsonItems.length-1) + \"}\";\n            };\n          }())).replace('\\n', '').replace('\\r', '').split(\";\");\n\n      // We'll L/RTrim, and also remove any surrounding double quotes (e.g., just take string contents)\n      var clean = function(s) {\n        return s.replace(/^\\s*[\"']?/, '').replace(/[\"']?\\s*$/, '');\n      };\n\n      for (var i = 0, dl = directives.length; i < dl; i++) {\n        var pair = directives[i].split('=');\n        if (pair && pair.length === 2) {\n          var key = clean(pair[0]),\n              value = clean(pair[1]),\n              list = [];\n          // A few directives require work beyond storying key/value pairings\n          if (key === \"preload\") {\n            list = value.split(',');\n            // All pre-loaded images will get put in imageCache, keyed on filename\n            for (var j = 0, jl = list.length; j < jl; j++) {\n              var imageName = clean(list[j]);\n              sketch.imageCache.add(imageName);\n            }\n          // fonts can be declared as a string containing a url,\n          // or a JSON object, containing a font name, and a url\n          } else if (key === \"font\") {\n            list = value.split(\",\");\n            for (var x = 0, xl = list.length; x < xl; x++) {\n              var fontName = clean(list[x]),\n                  index = /^\\{(\\d*?)\\}$/.exec(fontName);\n              // if index is not null, send JSON, otherwise, send string\n              PFont.preloading.add(index ? JSON.parse(\"{\" + jsonItems[index[1]] + \"}\") : fontName);\n            }\n          } else if (key === \"pauseOnBlur\") {\n            sketch.options.pauseOnBlur = value === \"true\";\n          } else if (key === \"globalKeyEvents\") {\n            sketch.options.globalKeyEvents = value === \"true\";\n          } else if (key.substring(0, 6) === \"param-\") {\n            sketch.params[key.substring(6)] = value;\n          } else {\n            sketch.options[key] = value;\n          }\n        }\n      }\n    }\n    return aCode;\n  }\n\n  // Parse/compiles Processing (Java-like) syntax to JavaScript syntax\n  Processing.compile = function(pdeCode) {\n    var sketch = new Processing.Sketch();\n    var code = preprocessCode(pdeCode, sketch);\n    var compiledPde = parseProcessing(code);\n    sketch.sourceCode = compiledPde;\n    return sketch;\n  };\n\n  var PjsConsole = require(\"../Helpers/PjsConsole\");\n  Processing.logger = new PjsConsole(document);\n\n  // done\n  return Processing;\n};\n\n},{\"../Helpers/PjsConsole\":5}],27:[function(require,module,exports){\n/**\n * Processing.js object\n */\n module.exports = function(options, undef) {\n  var defaultScope = options.defaultScope,\n      extend = options.extend,\n      Browser = options.Browser,\n      ajax = Browser.ajax,\n      navigator = Browser.navigator,\n      window = Browser.window,\n      XMLHttpRequest = window.XMLHttpRequest,\n      document = Browser.document,\n      noop = options.noop,\n\n      PConstants = defaultScope.PConstants;\n      PFont = defaultScope.PFont,\n      PShapeSVG = defaultScope.PShapeSVG,\n      PVector = defaultScope.PVector,\n      Char = Character = defaultScope.Char,\n      ObjectIterator = defaultScope.ObjectIterator,\n      XMLElement = defaultScope.XMLElement,\n      XML = defaultScope.XML;\n\n  // fascinating \"read only\" jshint error if we don't start a new var block here.\n  var HTMLCanvasElement = window.HTMLCanvasElement,\n      HTMLImageElement = window.HTMLImageElement;\n\n  // window.localStorage cannot be accessed if a user is blocking cookies.\n  // In that case, we make it a temporary source cache object.\n  var localStorage;\n  try { localStorage = window.localStorage; } catch (e) { localStorage = {}; }\n\n  var isDOMPresent = (\"document\" in this) && !(\"fake\" in this.document);\n\n  // document.head polyfill for the benefit of Firefox 3.6\n  if (!document.head) {\n    document.head = document.getElementsByTagName('head')[0];\n  }\n\n  var Float32Array = setupTypedArray(\"Float32Array\", \"WebGLFloatArray\"),\n      Int32Array   = setupTypedArray(\"Int32Array\",   \"WebGLIntArray\"),\n      Uint16Array  = setupTypedArray(\"Uint16Array\",  \"WebGLUnsignedShortArray\"),\n      Uint8Array   = setupTypedArray(\"Uint8Array\",   \"WebGLUnsignedByteArray\");\n\n  // Typed Arrays: fallback to WebGL arrays or Native JS arrays if unavailable\n  function setupTypedArray(name, fallback) {\n    // Check if TypedArray exists, and use if so.\n    if (name in window) {\n      return window[name];\n    }\n\n    // Check if WebGLArray exists\n    if (typeof window[fallback] === \"function\") {\n      return window[fallback];\n    }\n\n    // Use Native JS array\n    return function(obj) {\n      if (obj instanceof Array) {\n        return obj;\n      }\n      if (typeof obj === \"number\") {\n        var arr = [];\n        arr.length = obj;\n        return arr;\n      }\n    };\n  }\n\n  /* IE9+ quirks mode check - ticket #1606 */\n  if (document.documentMode >= 9 && !document.doctype) {\n    throw(\"The doctype directive is missing. The recommended doctype in Internet Explorer is the HTML5 doctype: <!DOCTYPE html>\");\n  }\n\n  // Manage multiple Processing instances\n  var processingInstances = [];\n  var processingInstanceIds = {};\n\n  /**\n   * instance tracking - adding new instances\n   */\n  var addInstance = function(processing) {\n    if (processing.externals.canvas.id === undef || !processing.externals.canvas.id.length) {\n      processing.externals.canvas.id = \"__processing\" + processingInstances.length;\n    }\n    processingInstanceIds[processing.externals.canvas.id] = processingInstances.length;\n    processingInstances.push(processing);\n  };\n\n  /**\n   * instance tracking - removal\n   */\n  var removeInstance = function(id) {\n    processingInstances.splice(processingInstanceIds[id], 1);\n    delete processingInstanceIds[id];\n  };\n\n\n  /**\n   * The Processing object\n   */\n  var Processing = this.Processing = function(aCanvas, aCode, aFunctions) {\n\n    if (!(this instanceof Processing)) {\n      throw(\"called Processing constructor as if it were a function: missing 'new'.\");\n    }\n\n    var curElement = {},\n      pgraphicsMode = (aCanvas === undef && aCode === undef);\n\n    if (pgraphicsMode) {\n      curElement = document.createElement(\"canvas\");\n    } else {\n      // We'll take a canvas element or a string for a canvas element's id\n      curElement = typeof aCanvas === \"string\" ? document.getElementById(aCanvas) : aCanvas;\n    }\n\n    if (!('getContext' in curElement)) {\n      throw(\"called Processing constructor without passing canvas element reference or id.\");\n    }\n\n    function unimplemented(s) {\n      Processing.debug('Unimplemented - ' + s);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    // JavaScript event binding and releasing\n    ////////////////////////////////////////////////////////////////////////////\n\tvar eventHandlers = [];\n    function attachEventHandler(elem, type, fn) {\n      if (elem.addEventListener) {\n        elem.addEventListener(type, fn, false);\n      } else {\n        elem.attachEvent(\"on\" + type, fn);\n      }\n      eventHandlers.push({elem: elem, type: type, fn: fn});\n    }\n\n    function detachEventHandler(eventHandler) {\n      var elem = eventHandler.elem,\n          type = eventHandler.type,\n          fn   = eventHandler.fn;\n      if (elem.removeEventListener) {\n        elem.removeEventListener(type, fn, false);\n      } else if (elem.detachEvent) {\n        elem.detachEvent(\"on\" + type, fn);\n      }\n    }\n\n    function detachEventHandlersByType(element, types) {\n      Object.keys(eventHandlers).forEach(function(eventHandler) {\n        if (types.indexOf(eventHandler.type) > -1 && (eventHandler.elem == element)) {\n          detachEventHandler(eventHandler.type);\n        }\n      });\n    }\n\n    function removeFirstArgument(args) {\n      return Array.prototype.slice.call(args, 1);\n    }\n\n    // When something new is added to \"p.\" it must also be added to the \"names\" array.\n    // The names array contains the names of everything that is inside \"p.\"\n    var p = this;\n\n    p.Char = p.Character = Char;\n\n    // add in the Processing API functions\n    eventHandlers = [];\n    extend.withCommonFunctions(p);\n    extend.withMath(p);\n    extend.withProxyFunctions(p, removeFirstArgument);\n    extend.withTouch(p, curElement, attachEventHandler, detachEventHandlersByType, document, PConstants);\n\n    // custom functions and properties are added here\n    if(aFunctions) {\n      Object.keys(aFunctions).forEach(function(name) {\n        p[name] = aFunctions[name];\n      });\n    }\n\n    // PJS specific (non-p5) methods and properties to externalize\n    p.externals = {\n      canvas:  curElement,\n      context: undef,\n      sketch:  undef,\n      window: window\n    };\n\n    p.name            = 'Processing.js Instance'; // Set Processing defaults / environment variables\n    p.use3DContext    = false; // default '2d' canvas context\n\n    /**\n     * Confirms if a Processing program is \"focused\", meaning that it is\n     * active and will accept input from mouse or keyboard. This variable\n     * is \"true\" if it is focused and \"false\" if not. This variable is\n     * often used when you want to warn people they need to click on the\n     * browser before it will work.\n    */\n    p.focused         = false;\n    p.breakShape      = false;\n\n    // Glyph path storage for textFonts\n    p.glyphTable      = {};\n\n    // Global vars for tracking mouse position\n    p.pmouseX         = 0;\n    p.pmouseY         = 0;\n    p.mouseX          = 0;\n    p.mouseY          = 0;\n    p.mouseButton     = 0;\n    p.mouseScroll     = 0;\n\n    // Undefined event handlers to be replaced by user when needed\n    p.mouseClicked    = undef;\n    p.mouseDragged    = undef;\n    p.mouseMoved      = undef;\n    p.mousePressed    = undef;\n    p.mouseReleased   = undef;\n    p.mouseScrolled   = undef;\n    p.mouseOver       = undef;\n    p.mouseOut        = undef;\n    p.touchStart      = undef;\n    p.touchEnd        = undef;\n    p.touchMove       = undef;\n    p.touchCancel     = undef;\n    p.key             = undef;\n    p.keyCode         = undef;\n    p.keyPressed      = noop; // needed to remove function checks\n    p.keyReleased     = noop;\n    p.keyTyped        = noop;\n    p.draw            = undef;\n    p.setup           = undef;\n\n    // Remapped vars\n    p.__mousePressed  = false;\n    p.__keyPressed    = false;\n    p.__frameRate     = 60;\n\n    // The current animation frame\n    p.frameCount      = 0;\n\n    // The height/width of the canvas\n    p.width           = 100;\n    p.height          = 100;\n\n    // \"Private\" variables used to maintain state\n    var curContext,\n        curSketch,\n        drawing, // hold a Drawing2D or Drawing3D object\n        doFill = true,\n        fillStyle = [1.0, 1.0, 1.0, 1.0],\n        currentFillColor = 0xFFFFFFFF,\n        isFillDirty = true,\n        doStroke = true,\n        strokeStyle = [0.0, 0.0, 0.0, 1.0],\n        currentStrokeColor = 0xFF000000,\n        isStrokeDirty = true,\n        lineWidth = 1,\n        loopStarted = false,\n        renderSmooth = false,\n        doLoop = true,\n        looping = 0,\n        curRectMode = PConstants.CORNER,\n        curEllipseMode = PConstants.CENTER,\n        normalX = 0,\n        normalY = 0,\n        normalZ = 0,\n        normalMode = PConstants.NORMAL_MODE_AUTO,\n        curFrameRate = 60,\n        curMsPerFrame = 1000/curFrameRate,\n        curCursor = PConstants.ARROW,\n        oldCursor = curElement.style.cursor,\n        curShape = PConstants.POLYGON,\n        curShapeCount = 0,\n        curvePoints = [],\n        curTightness = 0,\n        curveDet = 20,\n        curveInited = false,\n        backgroundObj = -3355444, // rgb(204, 204, 204) is the default gray background colour\n        bezDetail = 20,\n        colorModeA = 255,\n        colorModeX = 255,\n        colorModeY = 255,\n        colorModeZ = 255,\n        pathOpen = false,\n        mouseDragging = false,\n        pmouseXLastFrame = 0,\n        pmouseYLastFrame = 0,\n        curColorMode = PConstants.RGB,\n        curTint = null,\n        curTint3d = null,\n        getLoaded = false,\n        start = Date.now(),\n        timeSinceLastFPS = start,\n        framesSinceLastFPS = 0,\n        textcanvas,\n        curveBasisMatrix,\n        curveToBezierMatrix,\n        curveDrawMatrix,\n        bezierDrawMatrix,\n        bezierBasisInverse,\n        bezierBasisMatrix,\n        curContextCache = { attributes: {}, locations: {} },\n        // Shaders\n        programObject3D,\n        programObject2D,\n        programObjectUnlitShape,\n        boxBuffer,\n        boxNormBuffer,\n        boxOutlineBuffer,\n        rectBuffer,\n        rectNormBuffer,\n        sphereBuffer,\n        lineBuffer,\n        fillBuffer,\n        fillColorBuffer,\n        strokeColorBuffer,\n        pointBuffer,\n        shapeTexVBO,\n        canTex,   // texture for createGraphics\n        textTex,   // texture for 3d tex\n        curTexture = {width:0,height:0},\n        curTextureMode = PConstants.IMAGE,\n        usingTexture = false,\n        textBuffer,\n        textureBuffer,\n        indexBuffer,\n        // Text alignment\n        horizontalTextAlignment = PConstants.LEFT,\n        verticalTextAlignment = PConstants.BASELINE,\n        textMode = PConstants.MODEL,\n        // Font state\n        curFontName = \"Arial\",\n        curTextSize = 12,\n        curTextAscent = 9,\n        curTextDescent = 2,\n        curTextLeading = 14,\n        curTextFont = PFont.get(curFontName, curTextSize),\n        // Pixels cache\n        originalContext,\n        proxyContext = null,\n        isContextReplaced = false,\n        setPixelsCached,\n        maxPixelsCached = 1000,\n        pressedKeysMap = [],\n        lastPressedKeyCode = null,\n        codedKeys = [ PConstants.SHIFT, PConstants.CONTROL, PConstants.ALT, PConstants.CAPSLK, PConstants.PGUP, PConstants.PGDN,\n                      PConstants.END, PConstants.HOME, PConstants.LEFT, PConstants.UP, PConstants.RIGHT, PConstants.DOWN, PConstants.NUMLK,\n                      PConstants.INSERT, PConstants.F1, PConstants.F2, PConstants.F3, PConstants.F4, PConstants.F5, PConstants.F6, PConstants.F7,\n                      PConstants.F8, PConstants.F9, PConstants.F10, PConstants.F11, PConstants.F12, PConstants.META ];\n\n    // User can only have MAX_LIGHTS lights\n    var lightCount = 0;\n\n    //sphere stuff\n    var sphereDetailV = 0,\n        sphereDetailU = 0,\n        sphereX = [],\n        sphereY = [],\n        sphereZ = [],\n        sinLUT = new Float32Array(PConstants.SINCOS_LENGTH),\n        cosLUT = new Float32Array(PConstants.SINCOS_LENGTH),\n        sphereVerts,\n        sphereNorms;\n\n    // Camera defaults and settings\n    var cam,\n        cameraInv,\n        modelView,\n        modelViewInv,\n        userMatrixStack,\n        userReverseMatrixStack,\n        inverseCopy,\n        projection,\n        manipulatingCamera = false,\n        frustumMode = false,\n        cameraFOV = 60 * (Math.PI / 180),\n        cameraX = p.width / 2,\n        cameraY = p.height / 2,\n        cameraZ = cameraY / Math.tan(cameraFOV / 2),\n        cameraNear = cameraZ / 10,\n        cameraFar = cameraZ * 10,\n        cameraAspect = p.width / p.height;\n\n    var vertArray = [],\n        curveVertArray = [],\n        curveVertCount = 0,\n        isCurve = false,\n        isBezier = false,\n        firstVert = true;\n\n    //PShape stuff\n    var curShapeMode = PConstants.CORNER;\n\n    // Stores states for pushStyle() and popStyle().\n    var styleArray = [];\n\n    // The vertices for the box cannot be specified using a triangle strip since each\n    // side of the cube must have its own set of normals.\n    // Vertices are specified in a counter-clockwise order.\n    // Triangles are in this order: back, front, right, bottom, left, top.\n    var boxVerts = new Float32Array([\n       0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,\n       0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5,\n       0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,\n       0.5, -0.5, -0.5,  0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,\n      -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5,\n       0.5,  0.5,  0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5]);\n\n    var boxOutlineVerts = new Float32Array([\n       0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5,\n      -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5,\n       0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5,\n      -0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,\n       0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5,\n      -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5]);\n\n    var boxNorms = new Float32Array([\n       0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,\n       0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,\n       1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,\n       0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,\n      -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0,\n       0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0]);\n\n    // These verts are used for the fill and stroke using TRIANGLE_FAN and LINE_LOOP.\n    var rectVerts = new Float32Array([0,0,0, 0,1,0, 1,1,0, 1,0,0]);\n\n    var rectNorms = new Float32Array([0,0,1, 0,0,1, 0,0,1, 0,0,1]);\n\n    // Shader for points and lines in begin/endShape.\n    var vertexShaderSrcUnlitShape =\n      \"varying vec4 vFrontColor;\" +\n\n      \"attribute vec3 aVertex;\" +\n      \"attribute vec4 aColor;\" +\n\n      \"uniform mat4 uView;\" +\n      \"uniform mat4 uProjection;\" +\n      \"uniform float uPointSize;\" +\n\n      \"void main(void) {\" +\n      \"  vFrontColor = aColor;\" +\n      \"  gl_PointSize = uPointSize;\" +\n      \"  gl_Position = uProjection * uView * vec4(aVertex, 1.0);\" +\n      \"}\";\n\n    var fragmentShaderSrcUnlitShape =\n      \"#ifdef GL_ES\\n\" +\n      \"precision highp float;\\n\" +\n      \"#endif\\n\" +\n\n      \"varying vec4 vFrontColor;\" +\n      \"uniform bool uSmooth;\" +\n\n      \"void main(void){\" +\n      \"  if(uSmooth == true){\" +\n      \"    float dist = distance(gl_PointCoord, vec2(0.5));\" +\n      \"    if(dist > 0.5){\" +\n      \"      discard;\" +\n      \"    }\" +\n      \"  }\" +\n      \"  gl_FragColor = vFrontColor;\" +\n      \"}\";\n\n    // Shader for rect, text, box outlines, sphere outlines, point() and line().\n    var vertexShaderSrc2D =\n      \"varying vec4 vFrontColor;\" +\n\n      \"attribute vec3 aVertex;\" +\n      \"attribute vec2 aTextureCoord;\" +\n      \"uniform vec4 uColor;\" +\n\n      \"uniform mat4 uModel;\" +\n      \"uniform mat4 uView;\" +\n      \"uniform mat4 uProjection;\" +\n      \"uniform float uPointSize;\" +\n      \"varying vec2 vTextureCoord;\"+\n\n      \"void main(void) {\" +\n      \"  gl_PointSize = uPointSize;\" +\n      \"  vFrontColor = uColor;\" +\n      \"  gl_Position = uProjection * uView * uModel * vec4(aVertex, 1.0);\" +\n      \"  vTextureCoord = aTextureCoord;\" +\n      \"}\";\n\n    var fragmentShaderSrc2D =\n      \"#ifdef GL_ES\\n\" +\n      \"precision highp float;\\n\" +\n      \"#endif\\n\" +\n\n      \"varying vec4 vFrontColor;\" +\n      \"varying vec2 vTextureCoord;\"+\n\n      \"uniform sampler2D uSampler;\"+\n      \"uniform int uIsDrawingText;\"+\n      \"uniform bool uSmooth;\" +\n\n      \"void main(void){\" +\n      // WebGL does not support POINT_SMOOTH, so we do it ourselves\n      \"  if(uSmooth == true){\" +\n      \"    float dist = distance(gl_PointCoord, vec2(0.5));\" +\n      \"    if(dist > 0.5){\" +\n      \"      discard;\" +\n      \"    }\" +\n      \"  }\" +\n\n      \"  if(uIsDrawingText == 1){\" +\n      \"    float alpha = texture2D(uSampler, vTextureCoord).a;\"+\n      \"    gl_FragColor = vec4(vFrontColor.rgb * alpha, alpha);\"+\n      \"  }\" +\n      \"  else{\" +\n      \"    gl_FragColor = vFrontColor;\" +\n      \"  }\" +\n      \"}\";\n\n    var webglMaxTempsWorkaround = /Windows/.test(navigator.userAgent);\n\n    // Vertex shader for boxes and spheres.\n    var vertexShaderSrc3D =\n      \"varying vec4 vFrontColor;\" +\n\n      \"attribute vec3 aVertex;\" +\n      \"attribute vec3 aNormal;\" +\n      \"attribute vec4 aColor;\" +\n      \"attribute vec2 aTexture;\" +\n      \"varying   vec2 vTexture;\" +\n\n      \"uniform vec4 uColor;\" +\n\n      \"uniform bool uUsingMat;\" +\n      \"uniform vec3 uSpecular;\" +\n      \"uniform vec3 uMaterialEmissive;\" +\n      \"uniform vec3 uMaterialAmbient;\" +\n      \"uniform vec3 uMaterialSpecular;\" +\n      \"uniform float uShininess;\" +\n\n      \"uniform mat4 uModel;\" +\n      \"uniform mat4 uView;\" +\n      \"uniform mat4 uProjection;\" +\n      \"uniform mat4 uNormalTransform;\" +\n\n      \"uniform int uLightCount;\" +\n      \"uniform vec3 uFalloff;\" +\n\n      // Careful changing the order of these fields. Some cards\n      // have issues with memory alignment.\n      \"struct Light {\" +\n      \"  int type;\" +\n      \"  vec3 color;\" +\n      \"  vec3 position;\" +\n      \"  vec3 direction;\" +\n      \"  float angle;\" +\n      \"  vec3 halfVector;\" +\n      \"  float concentration;\" +\n      \"};\" +\n\n      // nVidia cards have issues with arrays of structures\n      // so instead we create 8 instances of Light.\n      \"uniform Light uLights0;\" +\n      \"uniform Light uLights1;\" +\n      \"uniform Light uLights2;\" +\n      \"uniform Light uLights3;\" +\n      \"uniform Light uLights4;\" +\n      \"uniform Light uLights5;\" +\n      \"uniform Light uLights6;\" +\n      \"uniform Light uLights7;\" +\n\n     // GLSL does not support switch.\n      \"Light getLight(int index){\" +\n      \"  if(index == 0) return uLights0;\" +\n      \"  if(index == 1) return uLights1;\" +\n      \"  if(index == 2) return uLights2;\" +\n      \"  if(index == 3) return uLights3;\" +\n      \"  if(index == 4) return uLights4;\" +\n      \"  if(index == 5) return uLights5;\" +\n      \"  if(index == 6) return uLights6;\" +\n      // Do not use a conditional for the last return statement\n      // because some video cards will fail and complain that\n      // \"not all paths return\".\n      \"  return uLights7;\" +\n      \"}\" +\n\n      \"void AmbientLight( inout vec3 totalAmbient, in vec3 ecPos, in Light light ) {\" +\n      // Get the vector from the light to the vertex and\n      // get the distance from the current vector to the light position.\n      \"  float d = length( light.position - ecPos );\" +\n      \"  float attenuation = 1.0 / ( uFalloff[0] + ( uFalloff[1] * d ) + ( uFalloff[2] * d * d ));\" +\n      \"  totalAmbient += light.color * attenuation;\" +\n      \"}\" +\n\n      /*\n        col - accumulated color\n        spec - accumulated specular highlight\n        vertNormal - Normal of the vertex\n        ecPos - eye coordinate position\n        light - light structure\n      */\n      \"void DirectionalLight( inout vec3 col, inout vec3 spec, in vec3 vertNormal, in vec3 ecPos, in Light light ) {\" +\n      \"  float powerFactor = 0.0;\" +\n      \"  float nDotVP = max(0.0, dot( vertNormal, normalize(-light.position) ));\" +\n      \"  float nDotVH = max(0.0, dot( vertNormal, normalize(-light.position-normalize(ecPos) )));\" +\n\n      \"  if( nDotVP != 0.0 ){\" +\n      \"    powerFactor = pow( nDotVH, uShininess );\" +\n      \"  }\" +\n\n      \"  col += light.color * nDotVP;\" +\n      \"  spec += uSpecular * powerFactor;\" +\n      \"}\" +\n\n      /*\n        col - accumulated color\n        spec - accumulated specular highlight\n        vertNormal - Normal of the vertex\n        ecPos - eye coordinate position\n        light - light structure\n      */\n      \"void PointLight( inout vec3 col, inout vec3 spec, in vec3 vertNormal, in vec3 ecPos, in Light light ) {\" +\n      \"  float powerFactor;\" +\n\n      // Get the vector from the light to the vertex.\n      \"   vec3 VP = light.position - ecPos;\" +\n\n      // Get the distance from the current vector to the light position.\n      \"  float d = length( VP ); \" +\n\n      // Normalize the light ray so it can be used in the dot product operation.\n      \"  VP = normalize( VP );\" +\n\n      \"  float attenuation = 1.0 / ( uFalloff[0] + ( uFalloff[1] * d ) + ( uFalloff[2] * d * d ));\" +\n\n      \"  float nDotVP = max( 0.0, dot( vertNormal, VP ));\" +\n      \"  vec3 halfVector = normalize( VP - normalize(ecPos) );\" +\n      \"  float nDotHV = max( 0.0, dot( vertNormal, halfVector ));\" +\n\n      \"  if( nDotVP == 0.0 ) {\" +\n      \"    powerFactor = 0.0;\" +\n      \"  }\" +\n      \"  else {\" +\n      \"    powerFactor = pow( nDotHV, uShininess );\" +\n      \"  }\" +\n\n      \"  spec += uSpecular * powerFactor * attenuation;\" +\n      \"  col += light.color * nDotVP * attenuation;\" +\n      \"}\" +\n\n      /*\n        col - accumulated color\n        spec - accumulated specular highlight\n        vertNormal - Normal of the vertex\n        ecPos - eye coordinate position\n        light - light structure\n      */\n      \"void SpotLight( inout vec3 col, inout vec3 spec, in vec3 vertNormal, in vec3 ecPos, in Light light ) {\" +\n      \"  float spotAttenuation;\" +\n      \"  float powerFactor = 0.0;\" +\n\n      // Calculate the vector from the current vertex to the light.\n      \"  vec3 VP = light.position - ecPos;\" +\n      \"  vec3 ldir = normalize( -light.direction );\" +\n\n      // Get the distance from the spotlight and the vertex\n      \"  float d = length( VP );\" +\n      \"  VP = normalize( VP );\" +\n\n      \"  float attenuation = 1.0 / ( uFalloff[0] + ( uFalloff[1] * d ) + ( uFalloff[2] * d * d ) );\" +\n\n      // Dot product of the vector from vertex to light and light direction.\n      \"  float spotDot = dot( VP, ldir );\" +\n\n      // If the vertex falls inside the cone\n      (webglMaxTempsWorkaround ? // Windows reports max temps error if light.angle is used\n      \"  spotAttenuation = 1.0; \" :\n      \"  if( spotDot > cos( light.angle ) ) {\" +\n      \"    spotAttenuation = pow( spotDot, light.concentration );\" +\n      \"  }\" +\n      \"  else{\" +\n      \"    spotAttenuation = 0.0;\" +\n      \"  }\" +\n      \"  attenuation *= spotAttenuation;\" +\n      \"\") +\n\n      \"  float nDotVP = max( 0.0, dot( vertNormal, VP ) );\" +\n      \"  vec3 halfVector = normalize( VP - normalize(ecPos) );\" +\n      \"  float nDotHV = max( 0.0, dot( vertNormal, halfVector ) );\" +\n\n      \"  if( nDotVP != 0.0 ) {\" +\n      \"    powerFactor = pow( nDotHV, uShininess );\" +\n      \"  }\" +\n\n      \"  spec += uSpecular * powerFactor * attenuation;\" +\n      \"  col += light.color * nDotVP * attenuation;\" +\n      \"}\" +\n\n      \"void main(void) {\" +\n      \"  vec3 finalAmbient = vec3( 0.0 );\" +\n      \"  vec3 finalDiffuse = vec3( 0.0 );\" +\n      \"  vec3 finalSpecular = vec3( 0.0 );\" +\n\n      \"  vec4 col = uColor;\" +\n\n      \"  if ( uColor[0] == -1.0 ){\" +\n      \"    col = aColor;\" +\n      \"  }\" +\n\n      // We use the sphere vertices as the normals when we create the sphere buffer.\n      // But this only works if the sphere vertices are unit length, so we\n      // have to normalize the normals here. Since this is only required for spheres\n      // we could consider placing this in a conditional later on.\n      \"  vec3 norm = normalize(vec3( uNormalTransform * vec4( aNormal, 0.0 ) ));\" +\n\n      \"  vec4 ecPos4 = uView * uModel * vec4(aVertex, 1.0);\" +\n      \"  vec3 ecPos = (vec3(ecPos4))/ecPos4.w;\" +\n\n      // If there were no lights this draw call, just use the\n      // assigned fill color of the shape and the specular value.\n      \"  if( uLightCount == 0 ) {\" +\n      \"    vFrontColor = col + vec4(uMaterialSpecular, 1.0);\" +\n      \"  }\" +\n      \"  else {\" +\n           // WebGL forces us to iterate over a constant value\n           // so we can't iterate using lightCount.\n      \"    for( int i = 0; i < 8; i++ ) {\" +\n      \"      Light l = getLight(i);\" +\n\n      // We can stop iterating if we know we have gone past\n      // the number of lights which are actually on. This gives us a\n      // significant performance increase with high vertex counts.\n      \"      if( i >= uLightCount ){\" +\n      \"        break;\" +\n      \"      }\" +\n\n      \"      if( l.type == 0 ) {\" +\n      \"        AmbientLight( finalAmbient, ecPos, l );\" +\n      \"      }\" +\n      \"      else if( l.type == 1 ) {\" +\n      \"        DirectionalLight( finalDiffuse, finalSpecular, norm, ecPos, l );\" +\n      \"      }\" +\n      \"      else if( l.type == 2 ) {\" +\n      \"        PointLight( finalDiffuse, finalSpecular, norm, ecPos, l );\" +\n      \"      }\" +\n      \"      else {\" +\n      \"        SpotLight( finalDiffuse, finalSpecular, norm, ecPos, l );\" +\n      \"      }\" +\n      \"    }\" +\n\n      \"   if( uUsingMat == false ) {\" +\n      \"     vFrontColor = vec4(\" +\n      \"       vec3( col ) * finalAmbient +\" +\n      \"       vec3( col ) * finalDiffuse +\" +\n      \"       vec3( col ) * finalSpecular,\" +\n      \"       col[3] );\" +\n      \"   }\" +\n      \"   else{\" +\n      \"     vFrontColor = vec4( \" +\n      \"       uMaterialEmissive + \" +\n      \"       (vec3(col) * uMaterialAmbient * finalAmbient ) + \" +\n      \"       (vec3(col) * finalDiffuse) + \" +\n      \"       (uMaterialSpecular * finalSpecular), \" +\n      \"       col[3] );\" +\n      \"    }\" +\n      \"  }\" +\n\n      \"  vTexture.xy = aTexture.xy;\" +\n      \"  gl_Position = uProjection * uView * uModel * vec4( aVertex, 1.0 );\" +\n      \"}\";\n\n    var fragmentShaderSrc3D =\n      \"#ifdef GL_ES\\n\" +\n      \"precision highp float;\\n\" +\n      \"#endif\\n\" +\n\n      \"varying vec4 vFrontColor;\" +\n\n      \"uniform sampler2D uSampler;\" +\n      \"uniform bool uUsingTexture;\" +\n      \"varying vec2 vTexture;\" +\n\n      // In Processing, when a texture is used, the fill color is ignored\n      // vec4(1.0,1.0,1.0,0.5)\n      \"void main(void){\" +\n      \"  if( uUsingTexture ){\" +\n      \"    gl_FragColor = vec4(texture2D(uSampler, vTexture.xy)) * vFrontColor;\" +\n      \"  }\"+\n      \"  else{\" +\n      \"    gl_FragColor = vFrontColor;\" +\n      \"  }\" +\n      \"}\";\n\n    ////////////////////////////////////////////////////////////////////////////\n    // 3D Functions\n    ////////////////////////////////////////////////////////////////////////////\n\n    /*\n     * Sets a uniform variable in a program object to a particular\n     * value. Before calling this function, ensure the correct\n     * program object has been installed as part of the current\n     * rendering state by calling useProgram.\n     *\n     * On some systems, if the variable exists in the shader but isn't used,\n     * the compiler will optimize it out and this function will fail.\n     *\n     * @param {String} cacheId\n     * @param {WebGLProgram} programObj program object returned from\n     * createProgramObject\n     * @param {String} varName the name of the variable in the shader\n     * @param {float | Array} varValue either a scalar value or an Array\n     *\n     * @returns none\n     *\n     * @see uniformi\n     * @see uniformMatrix\n    */\n    function uniformf(cacheId, programObj, varName, varValue) {\n      var varLocation = curContextCache.locations[cacheId];\n      if(varLocation === undef) {\n        varLocation = curContext.getUniformLocation(programObj, varName);\n        curContextCache.locations[cacheId] = varLocation;\n      }\n      // the variable won't be found if it was optimized out.\n      if (varLocation !== null) {\n        if (varValue.length === 4) {\n          curContext.uniform4fv(varLocation, varValue);\n        } else if (varValue.length === 3) {\n          curContext.uniform3fv(varLocation, varValue);\n        } else if (varValue.length === 2) {\n          curContext.uniform2fv(varLocation, varValue);\n        } else {\n          curContext.uniform1f(varLocation, varValue);\n        }\n      }\n    }\n\n    /**\n     * Sets a uniform int or int array in a program object to a particular\n     * value. Before calling this function, ensure the correct\n     * program object has been installed as part of the current\n     * rendering state.\n     *\n     * On some systems, if the variable exists in the shader but isn't used,\n     * the compiler will optimize it out and this function will fail.\n     *\n     * @param {String} cacheId\n     * @param {WebGLProgram} programObj program object returned from\n     * createProgramObject\n     * @param {String} varName the name of the variable in the shader\n     * @param {int | Array} varValue either a scalar value or an Array\n     *\n     * @returns none\n     *\n     * @see uniformf\n     * @see uniformMatrix\n    */\n    function uniformi(cacheId, programObj, varName, varValue) {\n      var varLocation = curContextCache.locations[cacheId];\n      if(varLocation === undef) {\n        varLocation = curContext.getUniformLocation(programObj, varName);\n        curContextCache.locations[cacheId] = varLocation;\n      }\n      // the variable won't be found if it was optimized out.\n      if (varLocation !== null) {\n        if (varValue.length === 4) {\n          curContext.uniform4iv(varLocation, varValue);\n        } else if (varValue.length === 3) {\n          curContext.uniform3iv(varLocation, varValue);\n        } else if (varValue.length === 2) {\n          curContext.uniform2iv(varLocation, varValue);\n        } else {\n          curContext.uniform1i(varLocation, varValue);\n        }\n      }\n    }\n\n    /**\n     * Sets the value of a uniform matrix variable in a program\n     * object. Before calling this function, ensure the correct\n     * program object has been installed as part of the current\n     * rendering state.\n     *\n     * On some systems, if the variable exists in the shader but\n     * isn't used, the compiler will optimize it out and this\n     * function will fail.\n     *\n     * @param {String} cacheId\n     * @param {WebGLProgram} programObj program object returned from\n     * createProgramObject\n     * @param {String} varName the name of the variable in the shader\n     * @param {boolean} transpose must be false\n     * @param {Array} matrix an array of 4, 9 or 16 values\n     *\n     * @returns none\n     *\n     * @see uniformi\n     * @see uniformf\n    */\n    function uniformMatrix(cacheId, programObj, varName, transpose, matrix) {\n      var varLocation = curContextCache.locations[cacheId];\n      if(varLocation === undef) {\n        varLocation = curContext.getUniformLocation(programObj, varName);\n        curContextCache.locations[cacheId] = varLocation;\n      }\n      // The variable won't be found if it was optimized out.\n      if (varLocation !== -1) {\n        if (matrix.length === 16) {\n          curContext.uniformMatrix4fv(varLocation, transpose, matrix);\n        } else if (matrix.length === 9) {\n          curContext.uniformMatrix3fv(varLocation, transpose, matrix);\n        } else {\n          curContext.uniformMatrix2fv(varLocation, transpose, matrix);\n        }\n      }\n    }\n\n    /**\n     * Binds the VBO, sets the vertex attribute data for the program\n     * object and enables the attribute.\n     *\n     * On some systems, if the attribute exists in the shader but\n     * isn't used, the compiler will optimize it out and this\n     * function will fail.\n     *\n     * @param {String} cacheId\n     * @param {WebGLProgram} programObj program object returned from\n     * createProgramObject\n     * @param {String} varName the name of the variable in the shader\n     * @param {int} size the number of components per vertex attribute\n     * @param {WebGLBuffer} VBO Vertex Buffer Object\n     *\n     * @returns none\n     *\n     * @see disableVertexAttribPointer\n    */\n    function vertexAttribPointer(cacheId, programObj, varName, size, VBO) {\n      var varLocation = curContextCache.attributes[cacheId];\n      if(varLocation === undef) {\n        varLocation = curContext.getAttribLocation(programObj, varName);\n        curContextCache.attributes[cacheId] = varLocation;\n      }\n      if (varLocation !== -1) {\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, VBO);\n        curContext.vertexAttribPointer(varLocation, size, curContext.FLOAT, false, 0, 0);\n        curContext.enableVertexAttribArray(varLocation);\n      }\n    }\n\n    /**\n     * Disables a program object attribute from being sent to WebGL.\n     *\n     * @param {String} cacheId\n     * @param {WebGLProgram} programObj program object returned from\n     * createProgramObject\n     * @param {String} varName name of the attribute\n     *\n     * @returns none\n     *\n     * @see vertexAttribPointer\n    */\n    function disableVertexAttribPointer(cacheId, programObj, varName){\n      var varLocation = curContextCache.attributes[cacheId];\n      if(varLocation === undef) {\n        varLocation = curContext.getAttribLocation(programObj, varName);\n        curContextCache.attributes[cacheId] = varLocation;\n      }\n      if (varLocation !== -1) {\n        curContext.disableVertexAttribArray(varLocation);\n      }\n    }\n\n    /**\n     * Creates a WebGL program object.\n     *\n     * @param {String} vetexShaderSource\n     * @param {String} fragmentShaderSource\n     *\n     * @returns {WebGLProgram} A program object\n    */\n    var createProgramObject = function(curContext, vetexShaderSource, fragmentShaderSource) {\n      var vertexShaderObject = curContext.createShader(curContext.VERTEX_SHADER);\n      curContext.shaderSource(vertexShaderObject, vetexShaderSource);\n      curContext.compileShader(vertexShaderObject);\n      if (!curContext.getShaderParameter(vertexShaderObject, curContext.COMPILE_STATUS)) {\n        throw curContext.getShaderInfoLog(vertexShaderObject);\n      }\n\n      var fragmentShaderObject = curContext.createShader(curContext.FRAGMENT_SHADER);\n      curContext.shaderSource(fragmentShaderObject, fragmentShaderSource);\n      curContext.compileShader(fragmentShaderObject);\n      if (!curContext.getShaderParameter(fragmentShaderObject, curContext.COMPILE_STATUS)) {\n        throw curContext.getShaderInfoLog(fragmentShaderObject);\n      }\n\n      var programObject = curContext.createProgram();\n      curContext.attachShader(programObject, vertexShaderObject);\n      curContext.attachShader(programObject, fragmentShaderObject);\n      curContext.linkProgram(programObject);\n      if (!curContext.getProgramParameter(programObject, curContext.LINK_STATUS)) {\n        throw \"Error linking shaders.\";\n      }\n\n      return programObject;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // 2D/3D drawing handling\n    ////////////////////////////////////////////////////////////////////////////\n    var imageModeCorner = function(x, y, w, h, whAreSizes) {\n      return {\n        x: x,\n        y: y,\n        w: w,\n        h: h\n      };\n    };\n    var imageModeConvert = imageModeCorner;\n\n    var imageModeCorners = function(x, y, w, h, whAreSizes) {\n      return {\n        x: x,\n        y: y,\n        w: whAreSizes ? w : w - x,\n        h: whAreSizes ? h : h - y\n      };\n    };\n\n    var imageModeCenter = function(x, y, w, h, whAreSizes) {\n      return {\n        x: x - w / 2,\n        y: y - h / 2,\n        w: w,\n        h: h\n      };\n    };\n\n    // Objects for shared, 2D and 3D contexts\n    var DrawingShared = function(){};\n    var Drawing2D = function(){};\n    var Drawing3D = function(){};\n    var DrawingPre = function(){};\n\n    // Setup the prototype chain\n    Drawing2D.prototype = new DrawingShared();\n    Drawing2D.prototype.constructor = Drawing2D;\n    Drawing3D.prototype = new DrawingShared();\n    Drawing3D.prototype.constructor = Drawing3D;\n    DrawingPre.prototype = new DrawingShared();\n    DrawingPre.prototype.constructor = DrawingPre;\n\n    // A no-op function for when the user calls 3D functions from a 2D sketch\n    // We can change this to a throw or console.error() later if we want\n    DrawingShared.prototype.a3DOnlyFunction = noop;\n\n    /**\n     * The shape() function displays shapes to the screen.\n     * Processing currently works with SVG shapes only.\n     * The <b>shape</b> parameter specifies the shape to display and the <b>x</b>\n     * and <b>y</b> parameters define the location of the shape from its\n     * upper-left corner.\n     * The shape is displayed at its original size unless the <b>width</b>\n     * and <b>height</b> parameters specify a different size.\n     * The <b>shapeMode()</b> function changes the way the parameters work.\n     * A call to <b>shapeMode(CORNERS)</b>, for example, will change the width\n     * and height parameters to define the x and y values of the opposite corner\n     * of the shape.\n     * <br><br>\n     * Note complex shapes may draw awkwardly with P2D, P3D, and OPENGL. Those\n     * renderers do not yet support shapes that have holes or complicated breaks.\n     *\n     * @param {PShape} shape       the shape to display\n     * @param {int|float} x        x-coordinate of the shape\n     * @param {int|float} y        y-coordinate of the shape\n     * @param {int|float} width    width to display the shape\n     * @param {int|float} height   height to display the shape\n     *\n     * @see PShape\n     * @see loadShape()\n     * @see shapeMode()\n     */\n    p.shape = function(shape, x, y, width, height) {\n      if (arguments.length >= 1 && arguments[0] !== null) {\n        if (shape.isVisible()) {\n          p.pushMatrix();\n          if (curShapeMode === PConstants.CENTER) {\n            if (arguments.length === 5) {\n              p.translate(x - width/2, y - height/2);\n              p.scale(width / shape.getWidth(), height / shape.getHeight());\n            } else if (arguments.length === 3) {\n              p.translate(x - shape.getWidth()/2, - shape.getHeight()/2);\n            } else {\n              p.translate(-shape.getWidth()/2, -shape.getHeight()/2);\n            }\n          } else if (curShapeMode === PConstants.CORNER) {\n            if (arguments.length === 5) {\n              p.translate(x, y);\n              p.scale(width / shape.getWidth(), height / shape.getHeight());\n            } else if (arguments.length === 3) {\n              p.translate(x, y);\n            }\n          } else if (curShapeMode === PConstants.CORNERS) {\n            if (arguments.length === 5) {\n              width  -= x;\n              height -= y;\n              p.translate(x, y);\n              p.scale(width / shape.getWidth(), height / shape.getHeight());\n            } else if (arguments.length === 3) {\n              p.translate(x, y);\n            }\n          }\n          shape.draw(p);\n          if ((arguments.length === 1 && curShapeMode === PConstants.CENTER ) || arguments.length > 1) {\n            p.popMatrix();\n          }\n        }\n      }\n    };\n\n    /**\n     * The shapeMode() function modifies the location from which shapes draw.\n     * The default mode is <b>shapeMode(CORNER)</b>, which specifies the\n     * location to be the upper left corner of the shape and uses the third\n     * and fourth parameters of <b>shape()</b> to specify the width and height.\n     * The syntax <b>shapeMode(CORNERS)</b> uses the first and second parameters\n     * of <b>shape()</b> to set the location of one corner and uses the third\n     * and fourth parameters to set the opposite corner.\n     * The syntax <b>shapeMode(CENTER)</b> draws the shape from its center point\n     * and uses the third and forth parameters of <b>shape()</b> to specify the\n     * width and height.\n     * The parameter must be written in \"ALL CAPS\" because Processing syntax\n     * is case sensitive.\n     *\n     * @param {int} mode One of CORNER, CORNERS, CENTER\n     *\n     * @see shape()\n     * @see rectMode()\n     */\n    p.shapeMode = function (mode) {\n      curShapeMode = mode;\n    };\n\n    /**\n     * The loadShape() function loads vector shapes into a variable of type PShape. Currently, only SVG files may be loaded.\n     * In most cases, <b>loadShape()</b> should be used inside <b>setup()</b> because loading shapes inside <b>draw()</b> will reduce the speed of a sketch.\n     *\n     * @param {String} filename     an SVG file\n     *\n     * @return {PShape} a object of type PShape or null\n     * @see PShape\n     * @see PApplet#shape()\n     * @see PApplet#shapeMode()\n     */\n    p.loadShape = function (filename) {\n      if (arguments.length === 1) {\n        if (filename.indexOf(\".svg\") > -1) {\n          return new PShapeSVG(null, filename);\n        }\n      }\n      return null;\n    };\n\n    /**\n     * Processing 2.0 function for loading XML files.\n     *\n     * @param {String} uri The uri for the xml file to load.\n     *\n     * @return {XML} An XML object representing the xml data.\n     */\n    p.loadXML = function(uri) {\n      return new XML(p, uri);\n    };\n\n    /**\n     * Processing 2.0 function for creating XML elements from string\n     *\n     * @param {String} xml the XML source code\n     *\n     * @return {XML} An XML object representation of the input XML markup.\n     */\n    p.parseXML = function(xmlstring) {\n      var element = new XML();\n      element.parse(xmlstring);\n      return element;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // 2D Matrix\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Helper function for printMatrix(). Finds the largest scalar\n     * in the matrix, then number of digits left of the decimal.\n     * Call from PMatrix2D and PMatrix3D's print() function.\n     */\n    var printMatrixHelper = function(elements) {\n      var big = 0;\n      for (var i = 0; i < elements.length; i++) {\n        if (i !== 0) {\n          big = Math.max(big, Math.abs(elements[i]));\n        } else {\n          big = Math.abs(elements[i]);\n        }\n      }\n\n      var digits = (big + \"\").indexOf(\".\");\n      if (digits === 0) {\n        digits = 1;\n      } else if (digits === -1) {\n        digits = (big + \"\").length;\n      }\n\n      return digits;\n    };\n    /**\n     * PMatrix2D is a 3x2 affine matrix implementation. The constructor accepts another PMatrix2D or a list of six float elements.\n     * If no parameters are provided the matrix is set to the identity matrix.\n     *\n     * @param {PMatrix2D} matrix  the initial matrix to set to\n     * @param {float} m00         the first element of the matrix\n     * @param {float} m01         the second element of the matrix\n     * @param {float} m02         the third element of the matrix\n     * @param {float} m10         the fourth element of the matrix\n     * @param {float} m11         the fifth element of the matrix\n     * @param {float} m12         the sixth element of the matrix\n     */\n    var PMatrix2D = p.PMatrix2D = function() {\n      if (arguments.length === 0) {\n        this.reset();\n      } else if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) {\n        this.set(arguments[0].array());\n      } else if (arguments.length === 6) {\n        this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);\n      }\n    };\n    /**\n     * PMatrix2D methods\n     */\n    PMatrix2D.prototype = {\n      /**\n       * @member PMatrix2D\n       * The set() function sets the matrix elements. The function accepts either another PMatrix2D, an array of elements, or a list of six floats.\n       *\n       * @param {PMatrix2D} matrix    the matrix to set this matrix to\n       * @param {float[]} elements    an array of elements to set this matrix to\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the third element of the matrix\n       * @param {float} m10           the fourth element of the matrix\n       * @param {float} m11           the fith element of the matrix\n       * @param {float} m12           the sixth element of the matrix\n       */\n      set: function() {\n        if (arguments.length === 6) {\n          var a = arguments;\n          this.set([a[0], a[1], a[2],\n                    a[3], a[4], a[5]]);\n        } else if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) {\n          this.elements = arguments[0].array();\n        } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n          this.elements = arguments[0].slice();\n        }\n      },\n      /**\n       * @member PMatrix2D\n       * The get() function returns a copy of this PMatrix2D.\n       *\n       * @return {PMatrix2D} a copy of this PMatrix2D\n       */\n      get: function() {\n        var outgoing = new PMatrix2D();\n        outgoing.set(this.elements);\n        return outgoing;\n      },\n      /**\n       * @member PMatrix2D\n       * The reset() function sets this PMatrix2D to the identity matrix.\n       */\n      reset: function() {\n        this.set([1, 0, 0, 0, 1, 0]);\n      },\n      /**\n       * @member PMatrix2D\n       * The array() function returns a copy of the element values.\n       * @addon\n       *\n       * @return {float[]} returns a copy of the element values\n       */\n      array: function array() {\n        return this.elements.slice();\n      },\n      /**\n       * @member PMatrix2D\n       * The translate() function translates this matrix by moving the current coordinates to the location specified by tx and ty.\n       *\n       * @param {float} tx  the x-axis coordinate to move to\n       * @param {float} ty  the y-axis coordinate to move to\n       */\n      translate: function(tx, ty) {\n        this.elements[2] = tx * this.elements[0] + ty * this.elements[1] + this.elements[2];\n        this.elements[5] = tx * this.elements[3] + ty * this.elements[4] + this.elements[5];\n      },\n      /**\n       * @member PMatrix2D\n       * The invTranslate() function translates this matrix by moving the current coordinates to the negative location specified by tx and ty.\n       *\n       * @param {float} tx  the x-axis coordinate to move to\n       * @param {float} ty  the y-axis coordinate to move to\n       */\n      invTranslate: function(tx, ty) {\n        this.translate(-tx, -ty);\n      },\n       /**\n       * @member PMatrix2D\n       * The transpose() function is not used in processingjs.\n       */\n      transpose: function() {\n        // Does nothing in Processing.\n      },\n      /**\n       * @member PMatrix2D\n       * The mult() function multiplied this matrix.\n       * If two array elements are passed in the function will multiply a two element vector against this matrix.\n       * If target is null or not length four, a new float array will be returned.\n       * The values for vec and target can be the same (though that's less efficient).\n       * If two PVectors are passed in the function multiply the x and y coordinates of a PVector against this matrix.\n       *\n       * @param {PVector} source, target  the PVectors used to multiply this matrix\n       * @param {float[]} source, target  the arrays used to multiply this matrix\n       *\n       * @return {PVector|float[]} returns a PVector or an array representing the new matrix\n       */\n      mult: function(source, target) {\n        var x, y;\n        if (source instanceof PVector) {\n          x = source.x;\n          y = source.y;\n          if (!target) {\n            target = new PVector();\n          }\n        } else if (source instanceof Array) {\n          x = source[0];\n          y = source[1];\n          if (!target) {\n            target = [];\n          }\n        }\n        if (target instanceof Array) {\n          target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2];\n          target[1] = this.elements[3] * x + this.elements[4] * y + this.elements[5];\n        } else if (target instanceof PVector) {\n          target.x = this.elements[0] * x + this.elements[1] * y + this.elements[2];\n          target.y = this.elements[3] * x + this.elements[4] * y + this.elements[5];\n          target.z = 0;\n        }\n        return target;\n      },\n      /**\n       * @member PMatrix2D\n       * The multX() function calculates the x component of a vector from a transformation.\n       *\n       * @param {float} x the x component of the vector being transformed\n       * @param {float} y the y component of the vector being transformed\n       *\n       * @return {float} returnes the result of the calculation\n       */\n      multX: function(x, y) {\n        return (x * this.elements[0] + y * this.elements[1] + this.elements[2]);\n      },\n      /**\n       * @member PMatrix2D\n       * The multY() function calculates the y component of a vector from a transformation.\n       *\n       * @param {float} x the x component of the vector being transformed\n       * @param {float} y the y component of the vector being transformed\n       *\n       * @return {float} returnes the result of the calculation\n       */\n      multY: function(x, y) {\n        return (x * this.elements[3] + y * this.elements[4] + this.elements[5]);\n      },\n      /**\n       * @member PMatrix2D\n       * The skewX() function skews the matrix along the x-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of skew specified in radians\n       */\n      skewX: function(angle) {\n        this.apply(1, 0, 1, angle, 0, 0);\n      },\n      /**\n       * @member PMatrix2D\n       * The skewY() function skews the matrix along the y-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of skew specified in radians\n       */\n      skewY: function(angle) {\n        this.apply(1, 0, 1,  0, angle, 0);\n      },\n      /**\n       * @member PMatrix2D\n       * The shearX() function shears the matrix along the x-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of skew specified in radians\n       */\n      shearX: function(angle) {\n        this.apply(1, 0, 1, Math.tan(angle) , 0, 0);\n      },\n      /**\n       * @member PMatrix2D\n       * The shearY() function shears the matrix along the y-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of skew specified in radians\n       */\n      shearY: function(angle) {\n        this.apply(1, 0, 1,  0, Math.tan(angle), 0);\n      },\n      /**\n       * @member PMatrix2D\n       * The determinant() function calvculates the determinant of this matrix.\n       *\n       * @return {float} the determinant of the matrix\n       */\n      determinant: function() {\n        return (this.elements[0] * this.elements[4] - this.elements[1] * this.elements[3]);\n      },\n      /**\n       * @member PMatrix2D\n       * The invert() function inverts this matrix\n       *\n       * @return {boolean} true if successful\n       */\n      invert: function() {\n        var d = this.determinant();\n        if (Math.abs( d ) > PConstants.MIN_INT) {\n          var old00 = this.elements[0];\n          var old01 = this.elements[1];\n          var old02 = this.elements[2];\n          var old10 = this.elements[3];\n          var old11 = this.elements[4];\n          var old12 = this.elements[5];\n          this.elements[0] =  old11 / d;\n          this.elements[3] = -old10 / d;\n          this.elements[1] = -old01 / d;\n          this.elements[4] =  old00 / d;\n          this.elements[2] = (old01 * old12 - old11 * old02) / d;\n          this.elements[5] = (old10 * old02 - old00 * old12) / d;\n          return true;\n        }\n        return false;\n      },\n      /**\n       * @member PMatrix2D\n       * The scale() function increases or decreases the size of a shape by expanding and contracting vertices. When only one parameter is specified scale will occur in all dimensions.\n       * This is equivalent to a two parameter call.\n       *\n       * @param {float} sx  the amount to scale on the x-axis\n       * @param {float} sy  the amount to scale on the y-axis\n       */\n      scale: function(sx, sy) {\n        if (sx && !sy) {\n          sy = sx;\n        }\n        if (sx && sy) {\n          this.elements[0] *= sx;\n          this.elements[1] *= sy;\n          this.elements[3] *= sx;\n          this.elements[4] *= sy;\n        }\n      },\n       /**\n        * @member PMatrix2D\n        * The invScale() function decreases or increases the size of a shape by contracting and expanding vertices. When only one parameter is specified scale will occur in all dimensions.\n        * This is equivalent to a two parameter call.\n        *\n        * @param {float} sx  the amount to scale on the x-axis\n        * @param {float} sy  the amount to scale on the y-axis\n        */\n      invScale: function(sx, sy) {\n        if (sx && !sy) {\n          sy = sx;\n        }\n        this.scale(1 / sx, 1 / sy);\n      },\n      /**\n       * @member PMatrix2D\n       * The apply() function multiplies the current matrix by the one specified through the parameters. Note that either a PMatrix2D or a list of floats can be passed in.\n       *\n       * @param {PMatrix2D} matrix    the matrix to apply this matrix to\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the third element of the matrix\n       * @param {float} m10           the fourth element of the matrix\n       * @param {float} m11           the fith element of the matrix\n       * @param {float} m12           the sixth element of the matrix\n       */\n      apply: function() {\n        var source;\n        if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) {\n          source = arguments[0].array();\n        } else if (arguments.length === 6) {\n          source = Array.prototype.slice.call(arguments);\n        } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n          source = arguments[0];\n        }\n\n        var result = [0, 0, this.elements[2],\n                      0, 0, this.elements[5]];\n        var e = 0;\n        for (var row = 0; row < 2; row++) {\n          for (var col = 0; col < 3; col++, e++) {\n            result[e] += this.elements[row * 3 + 0] * source[col + 0] +\n                         this.elements[row * 3 + 1] * source[col + 3];\n          }\n        }\n        this.elements = result.slice();\n      },\n      /**\n       * @member PMatrix2D\n       * The preApply() function applies another matrix to the left of this one. Note that either a PMatrix2D or elements of a matrix can be passed in.\n       *\n       * @param {PMatrix2D} matrix    the matrix to apply this matrix to\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the third element of the matrix\n       * @param {float} m10           the fourth element of the matrix\n       * @param {float} m11           the fith element of the matrix\n       * @param {float} m12           the sixth element of the matrix\n       */\n      preApply: function() {\n        var source;\n        if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) {\n          source = arguments[0].array();\n        } else if (arguments.length === 6) {\n          source = Array.prototype.slice.call(arguments);\n        } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n          source = arguments[0];\n        }\n        var result = [0, 0, source[2],\n                      0, 0, source[5]];\n        result[2] = source[2] + this.elements[2] * source[0] + this.elements[5] * source[1];\n        result[5] = source[5] + this.elements[2] * source[3] + this.elements[5] * source[4];\n        result[0] = this.elements[0] * source[0] + this.elements[3] * source[1];\n        result[3] = this.elements[0] * source[3] + this.elements[3] * source[4];\n        result[1] = this.elements[1] * source[0] + this.elements[4] * source[1];\n        result[4] = this.elements[1] * source[3] + this.elements[4] * source[4];\n        this.elements = result.slice();\n      },\n      /**\n       * @member PMatrix2D\n       * The rotate() function rotates the matrix.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */\n      rotate: function(angle) {\n        var c = Math.cos(angle);\n        var s = Math.sin(angle);\n        var temp1 = this.elements[0];\n        var temp2 = this.elements[1];\n        this.elements[0] =  c * temp1 + s * temp2;\n        this.elements[1] = -s * temp1 + c * temp2;\n        temp1 = this.elements[3];\n        temp2 = this.elements[4];\n        this.elements[3] =  c * temp1 + s * temp2;\n        this.elements[4] = -s * temp1 + c * temp2;\n      },\n      /**\n       * @member PMatrix2D\n       * The rotateZ() function rotates the matrix.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */\n      rotateZ: function(angle) {\n        this.rotate(angle);\n      },\n      /**\n       * @member PMatrix2D\n       * The invRotateZ() function rotates the matrix in opposite direction.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */\n      invRotateZ: function(angle) {\n        this.rotateZ(angle - Math.PI);\n      },\n      /**\n       * @member PMatrix2D\n       * The print() function prints out the elements of this matrix\n       */\n      print: function() {\n        var digits = printMatrixHelper(this.elements);\n        var output = \"\" + p.nfs(this.elements[0], digits, 4) + \" \" +\n                     p.nfs(this.elements[1], digits, 4) + \" \" +\n                     p.nfs(this.elements[2], digits, 4) + \"\\n\" +\n                     p.nfs(this.elements[3], digits, 4) + \" \" +\n                     p.nfs(this.elements[4], digits, 4) + \" \" +\n                     p.nfs(this.elements[5], digits, 4) + \"\\n\\n\";\n        p.println(output);\n      }\n    };\n\n    /**\n     * PMatrix3D is a 4x4  matrix implementation. The constructor accepts another PMatrix3D or a list of six or sixteen float elements.\n     * If no parameters are provided the matrix is set to the identity matrix.\n     */\n    var PMatrix3D = p.PMatrix3D = function() {\n      // When a matrix is created, it is set to an identity matrix\n      this.reset();\n    };\n    /**\n     * PMatrix3D methods\n     */\n    PMatrix3D.prototype = {\n      /**\n       * @member PMatrix2D\n       * The set() function sets the matrix elements. The function accepts either another PMatrix3D, an array of elements, or a list of six or sixteen floats.\n       *\n       * @param {PMatrix3D} matrix    the initial matrix to set to\n       * @param {float[]} elements    an array of elements to set this matrix to\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the second element of the matrix\n       * @param {float} m02           the third element of the matrix\n       * @param {float} m03           the fourth element of the matrix\n       * @param {float} m10           the fifth element of the matrix\n       * @param {float} m11           the sixth element of the matrix\n       * @param {float} m12           the seventh element of the matrix\n       * @param {float} m13           the eight element of the matrix\n       * @param {float} m20           the nineth element of the matrix\n       * @param {float} m21           the tenth element of the matrix\n       * @param {float} m22           the eleventh element of the matrix\n       * @param {float} m23           the twelveth element of the matrix\n       * @param {float} m30           the thirteenth element of the matrix\n       * @param {float} m31           the fourtheenth element of the matrix\n       * @param {float} m32           the fivetheenth element of the matrix\n       * @param {float} m33           the sixteenth element of the matrix\n       */\n      set: function() {\n        if (arguments.length === 16) {\n          this.elements = Array.prototype.slice.call(arguments);\n        } else if (arguments.length === 1 && arguments[0] instanceof PMatrix3D) {\n          this.elements = arguments[0].array();\n        } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n          this.elements = arguments[0].slice();\n        }\n      },\n      /**\n       * @member PMatrix3D\n       * The get() function returns a copy of this PMatrix3D.\n       *\n       * @return {PMatrix3D} a copy of this PMatrix3D\n       */\n      get: function() {\n        var outgoing = new PMatrix3D();\n        outgoing.set(this.elements);\n        return outgoing;\n      },\n      /**\n       * @member PMatrix3D\n       * The reset() function sets this PMatrix3D to the identity matrix.\n       */\n      reset: function() {\n        this.elements = [1,0,0,0,\n                         0,1,0,0,\n                         0,0,1,0,\n                         0,0,0,1];\n      },\n      /**\n       * @member PMatrix3D\n       * The array() function returns a copy of the element values.\n       * @addon\n       *\n       * @return {float[]} returns a copy of the element values\n       */\n      array: function array() {\n        return this.elements.slice();\n      },\n      /**\n       * @member PMatrix3D\n       * The translate() function translates this matrix by moving the current coordinates to the location specified by tx, ty, and tz.\n       *\n       * @param {float} tx  the x-axis coordinate to move to\n       * @param {float} ty  the y-axis coordinate to move to\n       * @param {float} tz  the z-axis coordinate to move to\n       */\n      translate: function(tx, ty, tz) {\n        if (tz === undef) {\n          tz = 0;\n        }\n\n        this.elements[3]  += tx * this.elements[0]  + ty * this.elements[1]  + tz * this.elements[2];\n        this.elements[7]  += tx * this.elements[4]  + ty * this.elements[5]  + tz * this.elements[6];\n        this.elements[11] += tx * this.elements[8]  + ty * this.elements[9]  + tz * this.elements[10];\n        this.elements[15] += tx * this.elements[12] + ty * this.elements[13] + tz * this.elements[14];\n      },\n      /**\n       * @member PMatrix3D\n       * The transpose() function transpose this matrix.\n       */\n      transpose: function() {\n        var temp = this.elements[4];\n        this.elements[4] = this.elements[1];\n        this.elements[1] = temp;\n\n        temp = this.elements[8];\n        this.elements[8] = this.elements[2];\n        this.elements[2] = temp;\n\n        temp = this.elements[6];\n        this.elements[6] = this.elements[9];\n        this.elements[9] = temp;\n\n        temp = this.elements[3];\n        this.elements[3] = this.elements[12];\n        this.elements[12] = temp;\n\n        temp = this.elements[7];\n        this.elements[7] = this.elements[13];\n        this.elements[13] = temp;\n\n        temp = this.elements[11];\n        this.elements[11] = this.elements[14];\n        this.elements[14] = temp;\n      },\n      /**\n       * @member PMatrix3D\n       * The mult() function multiplied this matrix.\n       * If two array elements are passed in the function will multiply a two element vector against this matrix.\n       * If target is null or not length four, a new float array will be returned.\n       * The values for vec and target can be the same (though that's less efficient).\n       * If two PVectors are passed in the function multiply the x and y coordinates of a PVector against this matrix.\n       *\n       * @param {PVector} source, target  the PVectors used to multiply this matrix\n       * @param {float[]} source, target  the arrays used to multiply this matrix\n       *\n       * @return {PVector|float[]} returns a PVector or an array representing the new matrix\n       */\n      mult: function(source, target) {\n        var x, y, z, w;\n        if (source instanceof PVector) {\n          x = source.x;\n          y = source.y;\n          z = source.z;\n          w = 1;\n          if (!target) {\n            target = new PVector();\n          }\n        } else if (source instanceof Array) {\n          x = source[0];\n          y = source[1];\n          z = source[2];\n          w = source[3] || 1;\n\n          if ( !target || (target.length !== 3 && target.length !== 4) ) {\n            target = [0, 0, 0];\n          }\n        }\n\n        if (target instanceof Array) {\n          if (target.length === 3) {\n            target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];\n            target[1] = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];\n            target[2] = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];\n          } else if (target.length === 4) {\n            target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3] * w;\n            target[1] = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7] * w;\n            target[2] = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11] * w;\n            target[3] = this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15] * w;\n          }\n        }\n        if (target instanceof PVector) {\n          target.x = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];\n          target.y = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];\n          target.z = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];\n        }\n        return target;\n      },\n      /**\n       * @member PMatrix3D\n       * The preApply() function applies another matrix to the left of this one. Note that either a PMatrix3D or elements of a matrix can be passed in.\n       *\n       * @param {PMatrix3D} matrix    the matrix to apply this matrix to\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the second element of the matrix\n       * @param {float} m02           the third element of the matrix\n       * @param {float} m03           the fourth element of the matrix\n       * @param {float} m10           the fifth element of the matrix\n       * @param {float} m11           the sixth element of the matrix\n       * @param {float} m12           the seventh element of the matrix\n       * @param {float} m13           the eight element of the matrix\n       * @param {float} m20           the nineth element of the matrix\n       * @param {float} m21           the tenth element of the matrix\n       * @param {float} m22           the eleventh element of the matrix\n       * @param {float} m23           the twelveth element of the matrix\n       * @param {float} m30           the thirteenth element of the matrix\n       * @param {float} m31           the fourtheenth element of the matrix\n       * @param {float} m32           the fivetheenth element of the matrix\n       * @param {float} m33           the sixteenth element of the matrix\n       */\n      preApply: function() {\n        var source;\n        if (arguments.length === 1 && arguments[0] instanceof PMatrix3D) {\n          source = arguments[0].array();\n        } else if (arguments.length === 16) {\n          source = Array.prototype.slice.call(arguments);\n        } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n          source = arguments[0];\n        }\n\n        var result = [0, 0, 0, 0,\n                      0, 0, 0, 0,\n                      0, 0, 0, 0,\n                      0, 0, 0, 0];\n        var e = 0;\n        for (var row = 0; row < 4; row++) {\n          for (var col = 0; col < 4; col++, e++) {\n            result[e] += this.elements[col + 0] * source[row * 4 + 0] + this.elements[col + 4] *\n                         source[row * 4 + 1] + this.elements[col + 8] * source[row * 4 + 2] +\n                         this.elements[col + 12] * source[row * 4 + 3];\n          }\n        }\n        this.elements = result.slice();\n      },\n      /**\n       * @member PMatrix3D\n       * The apply() function multiplies the current matrix by the one specified through the parameters. Note that either a PMatrix3D or a list of floats can be passed in.\n       *\n       * @param {PMatrix3D} matrix    the matrix to apply this matrix to\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the second element of the matrix\n       * @param {float} m02           the third element of the matrix\n       * @param {float} m03           the fourth element of the matrix\n       * @param {float} m10           the fifth element of the matrix\n       * @param {float} m11           the sixth element of the matrix\n       * @param {float} m12           the seventh element of the matrix\n       * @param {float} m13           the eight element of the matrix\n       * @param {float} m20           the nineth element of the matrix\n       * @param {float} m21           the tenth element of the matrix\n       * @param {float} m22           the eleventh element of the matrix\n       * @param {float} m23           the twelveth element of the matrix\n       * @param {float} m30           the thirteenth element of the matrix\n       * @param {float} m31           the fourtheenth element of the matrix\n       * @param {float} m32           the fivetheenth element of the matrix\n       * @param {float} m33           the sixteenth element of the matrix\n       */\n      apply: function() {\n        var source;\n        if (arguments.length === 1 && arguments[0] instanceof PMatrix3D) {\n          source = arguments[0].array();\n        } else if (arguments.length === 16) {\n          source = Array.prototype.slice.call(arguments);\n        } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n          source = arguments[0];\n        }\n\n        var result = [0, 0, 0, 0,\n                      0, 0, 0, 0,\n                      0, 0, 0, 0,\n                      0, 0, 0, 0];\n        var e = 0;\n        for (var row = 0; row < 4; row++) {\n          for (var col = 0; col < 4; col++, e++) {\n            result[e] += this.elements[row * 4 + 0] * source[col + 0] + this.elements[row * 4 + 1] *\n                         source[col + 4] + this.elements[row * 4 + 2] * source[col + 8] +\n                         this.elements[row * 4 + 3] * source[col + 12];\n          }\n        }\n        this.elements = result.slice();\n      },\n      /**\n       * @member PMatrix3D\n       * The rotate() function rotates the matrix.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */\n      rotate: function(angle, v0, v1, v2) {\n        if (arguments.length < 4) {\n          this.rotateZ(angle);\n        } else {\n          var v = new PVector(v0, v1, v2);\n          var m = v.mag();\n          if (m === 0) {\n            return;\n          } else if (m != 1) {\n            v.normalize();\n            v0 = v.x;\n            v1 = v.y;\n            v2 = v.z;\n          }\n          var c = p.cos(angle);\n          var s = p.sin(angle);\n          var t = 1.0 - c;\n\n          this.apply((t * v0 * v0) + c,\n                     (t * v0 * v1) - (s * v2),\n                     (t * v0 * v2) + (s * v1),\n                     0,\n                     (t * v0 * v1) + (s * v2),\n                     (t * v1 * v1) + c,\n                     (t * v1 * v2) - (s * v0),\n                     0,\n                     (t * v0 * v2) - (s * v1),\n                     (t * v1 * v2) + (s * v0),\n                     (t * v2 * v2) + c,\n                     0,\n                     0, 0, 0, 1);\n        }\n      },\n      /**\n       * @member PMatrix3D\n       * The invApply() function applies the inverted matrix to this matrix.\n       *\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the second element of the matrix\n       * @param {float} m02           the third element of the matrix\n       * @param {float} m03           the fourth element of the matrix\n       * @param {float} m10           the fifth element of the matrix\n       * @param {float} m11           the sixth element of the matrix\n       * @param {float} m12           the seventh element of the matrix\n       * @param {float} m13           the eight element of the matrix\n       * @param {float} m20           the nineth element of the matrix\n       * @param {float} m21           the tenth element of the matrix\n       * @param {float} m22           the eleventh element of the matrix\n       * @param {float} m23           the twelveth element of the matrix\n       * @param {float} m30           the thirteenth element of the matrix\n       * @param {float} m31           the fourtheenth element of the matrix\n       * @param {float} m32           the fivetheenth element of the matrix\n       * @param {float} m33           the sixteenth element of the matrix\n       *\n       * @return {boolean} returns true if the operation was successful.\n       */\n      invApply: function() {\n        if (inverseCopy === undef) {\n          inverseCopy = new PMatrix3D();\n        }\n        var a = arguments;\n        inverseCopy.set(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8],\n                        a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n\n        if (!inverseCopy.invert()) {\n          return false;\n        }\n        this.preApply(inverseCopy);\n        return true;\n      },\n      /**\n       * @member PMatrix3D\n       * The rotateZ() function rotates the matrix.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */\n      rotateX: function(angle) {\n        var c = p.cos(angle);\n        var s = p.sin(angle);\n        this.apply([1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]);\n      },\n      /**\n       * @member PMatrix3D\n       * The rotateY() function rotates the matrix.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */\n      rotateY: function(angle) {\n        var c = p.cos(angle);\n        var s = p.sin(angle);\n        this.apply([c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1]);\n      },\n      /**\n       * @member PMatrix3D\n       * The rotateZ() function rotates the matrix.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */\n      rotateZ: function(angle) {\n        var c = Math.cos(angle);\n        var s = Math.sin(angle);\n        this.apply([c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n      },\n      /**\n       * @member PMatrix3D\n       * The scale() function increases or decreases the size of a matrix by expanding and contracting vertices. When only one parameter is specified scale will occur in all dimensions.\n       * This is equivalent to a three parameter call.\n       *\n       * @param {float} sx  the amount to scale on the x-axis\n       * @param {float} sy  the amount to scale on the y-axis\n       * @param {float} sz  the amount to scale on the z-axis\n       */\n      scale: function(sx, sy, sz) {\n        if (sx && !sy && !sz) {\n          sy = sz = sx;\n        } else if (sx && sy && !sz) {\n          sz = 1;\n        }\n\n        if (sx && sy && sz) {\n          this.elements[0]  *= sx;\n          this.elements[1]  *= sy;\n          this.elements[2]  *= sz;\n          this.elements[4]  *= sx;\n          this.elements[5]  *= sy;\n          this.elements[6]  *= sz;\n          this.elements[8]  *= sx;\n          this.elements[9]  *= sy;\n          this.elements[10] *= sz;\n          this.elements[12] *= sx;\n          this.elements[13] *= sy;\n          this.elements[14] *= sz;\n        }\n      },\n      /**\n       * @member PMatrix3D\n       * The skewX() function skews the matrix along the x-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of skew specified in radians\n       */\n      skewX: function(angle) {\n        var t = Math.tan(angle);\n        this.apply(1, t, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n      },\n      /**\n       * @member PMatrix3D\n       * The skewY() function skews the matrix along the y-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of skew specified in radians\n       */\n      skewY: function(angle) {\n        var t = Math.tan(angle);\n        this.apply(1, 0, 0, 0, t, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n      },\n      /**\n       * @member PMatrix3D\n       * The shearX() function shears the matrix along the x-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of shear specified in radians\n       */\n      shearX: function(angle) {\n        var t = Math.tan(angle);\n        this.apply(1, t, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n      },\n      /**\n       * @member PMatrix3D\n       * The shearY() function shears the matrix along the y-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of shear specified in radians\n       */\n      shearY: function(angle) {\n        var t = Math.tan(angle);\n        this.apply(1, 0, 0, 0, t, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n      },\n      multX: function(x, y, z, w) {\n        if (!z) {\n          return this.elements[0] * x + this.elements[1] * y + this.elements[3];\n        }\n        if (!w) {\n          return this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];\n        }\n        return this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3] * w;\n      },\n      multY: function(x, y, z, w) {\n        if (!z) {\n          return this.elements[4] * x + this.elements[5] * y + this.elements[7];\n        }\n        if (!w) {\n          return this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];\n        }\n        return this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7] * w;\n      },\n      multZ: function(x, y, z, w) {\n        if (!w) {\n          return this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];\n        }\n        return this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11] * w;\n      },\n      multW: function(x, y, z, w) {\n        if (!w) {\n          return this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15];\n        }\n        return this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15] * w;\n      },\n      /**\n       * @member PMatrix3D\n       * The invert() function inverts this matrix\n       *\n       * @return {boolean} true if successful\n       */\n      invert: function() {\n        var fA0 = this.elements[0] * this.elements[5] - this.elements[1] * this.elements[4];\n        var fA1 = this.elements[0] * this.elements[6] - this.elements[2] * this.elements[4];\n        var fA2 = this.elements[0] * this.elements[7] - this.elements[3] * this.elements[4];\n        var fA3 = this.elements[1] * this.elements[6] - this.elements[2] * this.elements[5];\n        var fA4 = this.elements[1] * this.elements[7] - this.elements[3] * this.elements[5];\n        var fA5 = this.elements[2] * this.elements[7] - this.elements[3] * this.elements[6];\n        var fB0 = this.elements[8] * this.elements[13] - this.elements[9] * this.elements[12];\n        var fB1 = this.elements[8] * this.elements[14] - this.elements[10] * this.elements[12];\n        var fB2 = this.elements[8] * this.elements[15] - this.elements[11] * this.elements[12];\n        var fB3 = this.elements[9] * this.elements[14] - this.elements[10] * this.elements[13];\n        var fB4 = this.elements[9] * this.elements[15] - this.elements[11] * this.elements[13];\n        var fB5 = this.elements[10] * this.elements[15] - this.elements[11] * this.elements[14];\n\n        // Determinant\n        var fDet = fA0 * fB5 - fA1 * fB4 + fA2 * fB3 + fA3 * fB2 - fA4 * fB1 + fA5 * fB0;\n\n        // Account for a very small value\n        // return false if not successful.\n        if (Math.abs(fDet) <= 1e-9) {\n          return false;\n        }\n\n        var kInv = [];\n        kInv[0]  = +this.elements[5] * fB5 - this.elements[6] * fB4 + this.elements[7] * fB3;\n        kInv[4]  = -this.elements[4] * fB5 + this.elements[6] * fB2 - this.elements[7] * fB1;\n        kInv[8]  = +this.elements[4] * fB4 - this.elements[5] * fB2 + this.elements[7] * fB0;\n        kInv[12] = -this.elements[4] * fB3 + this.elements[5] * fB1 - this.elements[6] * fB0;\n        kInv[1]  = -this.elements[1] * fB5 + this.elements[2] * fB4 - this.elements[3] * fB3;\n        kInv[5]  = +this.elements[0] * fB5 - this.elements[2] * fB2 + this.elements[3] * fB1;\n        kInv[9]  = -this.elements[0] * fB4 + this.elements[1] * fB2 - this.elements[3] * fB0;\n        kInv[13] = +this.elements[0] * fB3 - this.elements[1] * fB1 + this.elements[2] * fB0;\n        kInv[2]  = +this.elements[13] * fA5 - this.elements[14] * fA4 + this.elements[15] * fA3;\n        kInv[6]  = -this.elements[12] * fA5 + this.elements[14] * fA2 - this.elements[15] * fA1;\n        kInv[10] = +this.elements[12] * fA4 - this.elements[13] * fA2 + this.elements[15] * fA0;\n        kInv[14] = -this.elements[12] * fA3 + this.elements[13] * fA1 - this.elements[14] * fA0;\n        kInv[3]  = -this.elements[9] * fA5 + this.elements[10] * fA4 - this.elements[11] * fA3;\n        kInv[7]  = +this.elements[8] * fA5 - this.elements[10] * fA2 + this.elements[11] * fA1;\n        kInv[11] = -this.elements[8] * fA4 + this.elements[9] * fA2 - this.elements[11] * fA0;\n        kInv[15] = +this.elements[8] * fA3 - this.elements[9] * fA1 + this.elements[10] * fA0;\n\n        // Inverse using Determinant\n        var fInvDet = 1.0 / fDet;\n        kInv[0]  *= fInvDet;\n        kInv[1]  *= fInvDet;\n        kInv[2]  *= fInvDet;\n        kInv[3]  *= fInvDet;\n        kInv[4]  *= fInvDet;\n        kInv[5]  *= fInvDet;\n        kInv[6]  *= fInvDet;\n        kInv[7]  *= fInvDet;\n        kInv[8]  *= fInvDet;\n        kInv[9]  *= fInvDet;\n        kInv[10] *= fInvDet;\n        kInv[11] *= fInvDet;\n        kInv[12] *= fInvDet;\n        kInv[13] *= fInvDet;\n        kInv[14] *= fInvDet;\n        kInv[15] *= fInvDet;\n\n        this.elements = kInv.slice();\n        return true;\n      },\n      toString: function() {\n        var str = \"\";\n        for (var i = 0; i < 15; i++) {\n          str += this.elements[i] + \", \";\n        }\n        str += this.elements[15];\n        return str;\n      },\n      /**\n       * @member PMatrix3D\n       * The print() function prints out the elements of this matrix\n       */\n      print: function() {\n        var digits = printMatrixHelper(this.elements);\n\n        var output = \"\" + p.nfs(this.elements[0], digits, 4) + \" \" + p.nfs(this.elements[1], digits, 4) +\n                     \" \" + p.nfs(this.elements[2], digits, 4) + \" \" + p.nfs(this.elements[3], digits, 4) +\n                     \"\\n\" + p.nfs(this.elements[4], digits, 4) + \" \" + p.nfs(this.elements[5], digits, 4) +\n                     \" \" + p.nfs(this.elements[6], digits, 4) + \" \" + p.nfs(this.elements[7], digits, 4) +\n                     \"\\n\" + p.nfs(this.elements[8], digits, 4) + \" \" + p.nfs(this.elements[9], digits, 4) +\n                     \" \" + p.nfs(this.elements[10], digits, 4) + \" \" + p.nfs(this.elements[11], digits, 4) +\n                     \"\\n\" + p.nfs(this.elements[12], digits, 4) + \" \" + p.nfs(this.elements[13], digits, 4) +\n                     \" \" + p.nfs(this.elements[14], digits, 4) + \" \" + p.nfs(this.elements[15], digits, 4) + \"\\n\\n\";\n        p.println(output);\n      },\n      invTranslate: function(tx, ty, tz) {\n        this.preApply(1, 0, 0, -tx, 0, 1, 0, -ty, 0, 0, 1, -tz, 0, 0, 0, 1);\n      },\n      invRotateX: function(angle) {\n        var c = Math.cos(-angle);\n        var s = Math.sin(-angle);\n        this.preApply([1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]);\n      },\n      invRotateY: function(angle) {\n        var c = Math.cos(-angle);\n        var s = Math.sin(-angle);\n        this.preApply([c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1]);\n      },\n      invRotateZ: function(angle) {\n        var c = Math.cos(-angle);\n        var s = Math.sin(-angle);\n        this.preApply([c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n      },\n      invScale: function(x, y, z) {\n        this.preApply([1 / x, 0, 0, 0, 0, 1 / y, 0, 0, 0, 0, 1 / z, 0, 0, 0, 0, 1]);\n      }\n    };\n\n    /**\n     * @private\n     * The matrix stack stores the transformations and translations that occur within the space.\n     */\n    var PMatrixStack = p.PMatrixStack = function() {\n      this.matrixStack = [];\n    };\n\n    /**\n     * @member PMatrixStack\n     * load pushes the matrix given in the function into the stack\n     *\n     * @param {Object | Array} matrix the matrix to be pushed into the stack\n     */\n    PMatrixStack.prototype.load = function() {\n      var tmpMatrix = drawing.$newPMatrix();\n\n      if (arguments.length === 1) {\n        tmpMatrix.set(arguments[0]);\n      } else {\n        tmpMatrix.set(arguments);\n      }\n      this.matrixStack.push(tmpMatrix);\n    };\n\n    Drawing2D.prototype.$newPMatrix = function() {\n      return new PMatrix2D();\n    };\n\n    Drawing3D.prototype.$newPMatrix = function() {\n      return new PMatrix3D();\n    };\n\n    /**\n     * @member PMatrixStack\n     * push adds a duplicate of the top of the stack onto the stack - uses the peek function\n     */\n    PMatrixStack.prototype.push = function() {\n      this.matrixStack.push(this.peek());\n    };\n\n    /**\n     * @member PMatrixStack\n     * pop removes returns the matrix at the top of the stack\n     *\n     * @returns {Object} the matrix at the top of the stack\n     */\n    PMatrixStack.prototype.pop = function() {\n      return this.matrixStack.pop();\n    };\n\n    /**\n     * @member PMatrixStack\n     * peek returns but doesn't remove the matrix at the top of the stack\n     *\n     * @returns {Object} the matrix at the top of the stack\n     */\n    PMatrixStack.prototype.peek = function() {\n      var tmpMatrix = drawing.$newPMatrix();\n\n      tmpMatrix.set(this.matrixStack[this.matrixStack.length - 1]);\n      return tmpMatrix;\n    };\n\n    /**\n     * @member PMatrixStack\n     * this function multiplies the matrix at the top of the stack with the matrix given as a parameter\n     *\n     * @param {Object | Array} matrix the matrix to be multiplied into the stack\n     */\n    PMatrixStack.prototype.mult = function(matrix) {\n      this.matrixStack[this.matrixStack.length - 1].apply(matrix);\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Array handling\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n    * The split() function breaks a string into pieces using a character or string\n    * as the divider. The delim  parameter specifies the character or characters that\n    * mark the boundaries between each piece. A String[] array is returned that contains\n    * each of the pieces.\n    * If the result is a set of numbers, you can convert the String[] array to to a float[]\n    * or int[] array using the datatype conversion functions int() and float() (see example above).\n    * The splitTokens() function works in a similar fashion, except that it splits using a range\n    * of characters instead of a specific character or sequence.\n    *\n    * @param {String} str       the String to be split\n    * @param {String} delim     the character or String used to separate the data\n    *\n    * @returns {string[]} The new string array\n    *\n    * @see splitTokens\n    * @see join\n    * @see trim\n    */\n    p.split = function(str, delim) {\n      return str.split(delim);\n    };\n\n    /**\n    * The splitTokens() function splits a String at one or many character \"tokens.\" The tokens\n    * parameter specifies the character or characters to be used as a boundary.\n    * If no tokens character is specified, any whitespace character is used to split.\n    * Whitespace characters include tab (\\t), line feed (\\n), carriage return (\\r), form\n    * feed (\\f), and space. To convert a String to an array of integers or floats, use the\n    * datatype conversion functions int() and float() to convert the array of Strings.\n    *\n    * @param {String} str       the String to be split\n    * @param {Char[]} tokens    list of individual characters that will be used as separators\n    *\n    * @returns {string[]} The new string array\n    *\n    * @see split\n    * @see join\n    * @see trim\n    */\n    p.splitTokens = function(str, tokens) {\n      if (tokens === undef) {\n        return str.split(/\\s+/g);\n      }\n\n      var chars = tokens.split(/()/g),\n          buffer = \"\",\n          len = str.length,\n          i, c,\n          tokenized = [];\n\n      for (i = 0; i < len; i++) {\n        c = str[i];\n        if (chars.indexOf(c) > -1) {\n          if (buffer !== \"\") {\n            tokenized.push(buffer);\n          }\n          buffer = \"\";\n        } else {\n          buffer += c;\n        }\n      }\n\n      if (buffer !== \"\") {\n        tokenized.push(buffer);\n      }\n\n      return tokenized;\n    };\n\n    /**\n    * Expands an array by one element and adds data to the new position. The datatype of\n    * the element parameter must be the same as the datatype of the array.\n    * When using an array of objects, the data returned from the function must be cast to\n    * the object array's data type. For example: SomeClass[] items = (SomeClass[])\n    * append(originalArray, element).\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} array boolean[],\n    * byte[], char[], int[], float[], or String[], or an array of objects\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} element new data for the array\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see shorten\n    * @see expand\n    */\n    p.append = function(array, element) {\n      array[array.length] = element;\n      return array;\n    };\n\n    /**\n    * Concatenates two arrays. For example, concatenating the array { 1, 2, 3 } and the\n    * array { 4, 5, 6 } yields { 1, 2, 3, 4, 5, 6 }. Both parameters must be arrays of the\n    * same datatype.\n    * When using an array of objects, the data returned from the function must be cast to the\n    * object array's data type. For example: SomeClass[] items = (SomeClass[]) concat(array1, array2).\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} array1 boolean[],\n    * byte[], char[], int[], float[], String[], or an array of objects\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} array2 boolean[],\n    * byte[], char[], int[], float[], String[], or an array of objects\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see splice\n    */\n    p.concat = function(array1, array2) {\n      return array1.concat(array2);\n    };\n\n    /**\n     * Sorts an array of numbers from smallest to largest and puts an array of\n     * words in alphabetical order. The original array is not modified, a\n     * re-ordered array is returned. The count parameter states the number of\n     * elements to sort. For example if there are 12 elements in an array and\n     * if count is the value 5, only the first five elements on the array will\n     * be sorted. Alphabetical ordering is case insensitive.\n     *\n     * @param {String[] | int[] | float[]}  array Array of elements to sort\n     * @param {int}                         numElem Number of elements to sort\n     *\n     * @returns {String[] | int[] | float[]} Array (same datatype as the input)\n     *\n     * @see reverse\n    */\n    p.sort = function(array, numElem) {\n      var ret = [];\n\n      // depending on the type used (int, float) or string\n      // we'll need to use a different compare function\n      if (array.length > 0) {\n        // copy since we need to return another array\n        var elemsToCopy = numElem > 0 ? numElem : array.length;\n        for (var i = 0; i < elemsToCopy; i++) {\n          ret.push(array[i]);\n        }\n        if (typeof array[0] === \"string\") {\n          ret.sort();\n        }\n        // int or float\n        else {\n          ret.sort(function(a, b) {\n            return a - b;\n          });\n        }\n\n        // copy on the rest of the elements that were not sorted in case the user\n        // only wanted a subset of an array to be sorted.\n        if (numElem > 0) {\n          for (var j = ret.length; j < array.length; j++) {\n            ret.push(array[j]);\n          }\n        }\n      }\n      return ret;\n    };\n\n    /**\n    * Inserts a value or array of values into an existing array. The first two parameters must\n    * be of the same datatype. The array parameter defines the array which will be modified\n    * and the second parameter defines the data which will be inserted. When using an array\n    * of objects, the data returned from the function must be cast to the object array's data\n    * type. For example: SomeClass[] items = (SomeClass[]) splice(array1, array2, index).\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} array boolean[],\n    * byte[], char[], int[], float[], String[], or an array of objects\n    * @param {boolean|byte|char|int|float|String|boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects}\n    * value boolean, byte, char, int, float, String, boolean[], byte[], char[], int[],\n    * float[], String[], or other Object: value or an array of objects to be spliced in\n    * @param {int} index                position in the array from which to insert data\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see contract\n    * @see subset\n    */\n    p.splice = function(array, value, index) {\n\n      // Trying to splice an empty array into \"array\" in P5 won't do\n      // anything, just return the original.\n      if(value.length === 0)\n      {\n        return array;\n      }\n\n      // If the second argument was an array, we'll need to iterate over all\n      // the \"value\" elements and add one by one because\n      // array.splice(index, 0, value);\n      // would create a multi-dimensional array which isn't what we want.\n      if(value instanceof Array) {\n        for(var i = 0, j = index; i < value.length; j++,i++) {\n          array.splice(j, 0, value[i]);\n        }\n      } else {\n        array.splice(index, 0, value);\n      }\n\n      return array;\n    };\n\n    /**\n    * Extracts an array of elements from an existing array. The array parameter defines the\n    * array from which the elements will be copied and the offset and length parameters determine\n    * which elements to extract. If no length is given, elements will be extracted from the offset\n    * to the end of the array. When specifying the offset remember the first array element is 0.\n    * This function does not change the source array.\n    * When using an array of objects, the data returned from the function must be cast to the\n    * object array's data type.\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} array boolean[],\n    * byte[], char[], int[], float[], String[], or an array of objects\n    * @param {int} offset         position to begin\n    * @param {int} length         number of values to extract\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see splice\n    */\n    p.subset = function(array, offset, length) {\n      var end = (length !== undef) ? offset + length : array.length;\n      return array.slice(offset, end);\n    };\n\n    /**\n    * Combines an array of Strings into one String, each separated by the character(s) used for\n    * the separator parameter. To join arrays of ints or floats, it's necessary to first convert\n    * them to strings using nf() or nfs().\n    *\n    * @param {Array} array              array of Strings\n    * @param {char|String} separator    char or String to be placed between each item\n    *\n    * @returns {String} The combined string\n    *\n    * @see split\n    * @see trim\n    * @see nf\n    * @see nfs\n    */\n    p.join = function(array, seperator) {\n      return array.join(seperator);\n    };\n\n    /**\n    * Decreases an array by one element and returns the shortened array. When using an\n    * array of objects, the data returned from the function must be cast to the object array's\n    * data type. For example: SomeClass[] items = (SomeClass[]) shorten(originalArray).\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} array\n    * boolean[], byte[], char[], int[], float[], or String[], or an array of objects\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see append\n    * @see expand\n    */\n    p.shorten = function(ary) {\n      var newary = [];\n\n      // copy array into new array\n      var len = ary.length;\n      for (var i = 0; i < len; i++) {\n        newary[i] = ary[i];\n      }\n      newary.pop();\n\n      return newary;\n    };\n\n    /**\n    * Increases the size of an array. By default, this function doubles the size of the array,\n    * but the optional newSize parameter provides precise control over the increase in size.\n    * When using an array of objects, the data returned from the function must be cast to the\n    * object array's data type. For example: SomeClass[] items = (SomeClass[]) expand(originalArray).\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} ary\n    * boolean[], byte[], char[], int[], float[], String[], or an array of objects\n    * @param {int} newSize              positive int: new size for the array\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see contract\n    */\n    p.expand = function(ary, targetSize) {\n      var temp = ary.slice(0),\n          newSize = targetSize || ary.length * 2;\n      temp.length = newSize;\n      return temp;\n    };\n\n    /**\n    * Copies an array (or part of an array) to another array. The src array is copied to the\n    * dst array, beginning at the position specified by srcPos and into the position specified\n    * by dstPos. The number of elements to copy is determined by length. The simplified version\n    * with two arguments copies an entire array to another of the same size. It is equivalent\n    * to \"arrayCopy(src, 0, dst, 0, src.length)\". This function is far more efficient for copying\n    * array data than iterating through a for and copying each element.\n    *\n    * @param {Array} src an array of any data type: the source array\n    * @param {Array} dest an array of any data type (as long as it's the same as src): the destination array\n    * @param {int} srcPos     starting position in the source array\n    * @param {int} destPos    starting position in the destination array\n    * @param {int} length     number of array elements to be copied\n    *\n    * @returns none\n    */\n    p.arrayCopy = function() { // src, srcPos, dest, destPos, length) {\n      var src, srcPos = 0, dest, destPos = 0, length;\n\n      if (arguments.length === 2) {\n        // recall itself and copy src to dest from start index 0 to 0 of src.length\n        src = arguments[0];\n        dest = arguments[1];\n        length = src.length;\n      } else if (arguments.length === 3) {\n        // recall itself and copy src to dest from start index 0 to 0 of length\n        src = arguments[0];\n        dest = arguments[1];\n        length = arguments[2];\n      } else if (arguments.length === 5) {\n        src = arguments[0];\n        srcPos = arguments[1];\n        dest = arguments[2];\n        destPos = arguments[3];\n        length = arguments[4];\n      }\n\n      // copy src to dest from index srcPos to index destPos of length recursivly on objects\n      for (var i = srcPos, j = destPos; i < length + srcPos; i++, j++) {\n        if (dest[j] !== undef) {\n          dest[j] = src[i];\n        } else {\n          throw \"array index out of bounds exception\";\n        }\n      }\n    };\n\n    /**\n    * Reverses the order of an array.\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]} array\n    * boolean[], byte[], char[], int[], float[], or String[]\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see sort\n    */\n    p.reverse = function(array) {\n      return array.reverse();\n    };\n\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Color functions\n    ////////////////////////////////////////////////////////////////////////////\n\n    // helper functions for internal blending modes\n    p.mix = function(a, b, f) {\n      return a + (((b - a) * f) >> 8);\n    };\n\n    p.peg = function(n) {\n      return (n < 0) ? 0 : ((n > 255) ? 255 : n);\n    };\n\n    // blending modes\n    /**\n    * These are internal blending modes used for BlendColor()\n    *\n    * @param {Color} c1       First Color to blend\n    * @param {Color} c2       Second Color to blend\n    *\n    * @returns {Color}        The blended Color\n    *\n    * @see BlendColor\n    * @see Blend\n    */\n    p.modes = (function() {\n      var ALPHA_MASK = PConstants.ALPHA_MASK,\n        RED_MASK = PConstants.RED_MASK,\n        GREEN_MASK = PConstants.GREEN_MASK,\n        BLUE_MASK = PConstants.BLUE_MASK,\n        min = Math.min,\n        max = Math.max;\n\n      function applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb) {\n        var a = min(((c1 & 0xff000000) >>> 24) + f, 0xff) << 24;\n\n        var r = (ar + (((cr - ar) * f) >> 8));\n        r = ((r < 0) ? 0 : ((r > 255) ? 255 : r)) << 16;\n\n        var g = (ag + (((cg - ag) * f) >> 8));\n        g = ((g < 0) ? 0 : ((g > 255) ? 255 : g)) << 8;\n\n        var b = ab + (((cb - ab) * f) >> 8);\n        b = (b < 0) ? 0 : ((b > 255) ? 255 : b);\n\n        return (a | r | g | b);\n      }\n\n      return {\n        replace: function(c1, c2) {\n          return c2;\n        },\n        blend: function(c1, c2) {\n          var f = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK),\n            ag = (c1 & GREEN_MASK),\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK),\n            bg = (c2 & GREEN_MASK),\n            bb = (c2 & BLUE_MASK);\n\n          return (min(((c1 & ALPHA_MASK) >>> 24) + f, 0xff) << 24 |\n                  (ar + (((br - ar) * f) >> 8)) & RED_MASK |\n                  (ag + (((bg - ag) * f) >> 8)) & GREEN_MASK |\n                  (ab + (((bb - ab) * f) >> 8)) & BLUE_MASK);\n        },\n        add: function(c1, c2) {\n          var f = (c2 & ALPHA_MASK) >>> 24;\n          return (min(((c1 & ALPHA_MASK) >>> 24) + f, 0xff) << 24 |\n                  min(((c1 & RED_MASK) + ((c2 & RED_MASK) >> 8) * f), RED_MASK) & RED_MASK |\n                  min(((c1 & GREEN_MASK) + ((c2 & GREEN_MASK) >> 8) * f), GREEN_MASK) & GREEN_MASK |\n                  min((c1 & BLUE_MASK) + (((c2 & BLUE_MASK) * f) >> 8), BLUE_MASK));\n        },\n        subtract: function(c1, c2) {\n          var f = (c2 & ALPHA_MASK) >>> 24;\n          return (min(((c1 & ALPHA_MASK) >>> 24) + f, 0xff) << 24 |\n                  max(((c1 & RED_MASK) - ((c2 & RED_MASK) >> 8) * f), GREEN_MASK) & RED_MASK |\n                  max(((c1 & GREEN_MASK) - ((c2 & GREEN_MASK) >> 8) * f), BLUE_MASK) & GREEN_MASK |\n                  max((c1 & BLUE_MASK) - (((c2 & BLUE_MASK) * f) >> 8), 0));\n        },\n        lightest: function(c1, c2) {\n          var f = (c2 & ALPHA_MASK) >>> 24;\n          return (min(((c1 & ALPHA_MASK) >>> 24) + f, 0xff) << 24 |\n                  max(c1 & RED_MASK, ((c2 & RED_MASK) >> 8) * f) & RED_MASK |\n                  max(c1 & GREEN_MASK, ((c2 & GREEN_MASK) >> 8) * f) & GREEN_MASK |\n                  max(c1 & BLUE_MASK, ((c2 & BLUE_MASK) * f) >> 8));\n        },\n        darkest: function(c1, c2) {\n          var f = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK),\n            ag = (c1 & GREEN_MASK),\n            ab = (c1 & BLUE_MASK),\n            br = min(c1 & RED_MASK, ((c2 & RED_MASK) >> 8) * f),\n            bg = min(c1 & GREEN_MASK, ((c2 & GREEN_MASK) >> 8) * f),\n            bb = min(c1 & BLUE_MASK, ((c2 & BLUE_MASK) * f) >> 8);\n\n          return (min(((c1 & ALPHA_MASK) >>> 24) + f, 0xff) << 24 |\n                  (ar + (((br - ar) * f) >> 8)) & RED_MASK |\n                  (ag + (((bg - ag) * f) >> 8)) & GREEN_MASK |\n                  (ab + (((bb - ab) * f) >> 8)) & BLUE_MASK);\n        },\n        difference: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK),\n            cr = (ar > br) ? (ar - br) : (br - ar),\n            cg = (ag > bg) ? (ag - bg) : (bg - ag),\n            cb = (ab > bb) ? (ab - bb) : (bb - ab);\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        },\n        exclusion: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK),\n            cr = ar + br - ((ar * br) >> 7),\n            cg = ag + bg - ((ag * bg) >> 7),\n            cb = ab + bb - ((ab * bb) >> 7);\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        },\n        multiply: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK),\n            cr = (ar * br) >> 8,\n            cg = (ag * bg) >> 8,\n            cb = (ab * bb) >> 8;\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        },\n        screen: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK),\n            cr = 255 - (((255 - ar) * (255 - br)) >> 8),\n            cg = 255 - (((255 - ag) * (255 - bg)) >> 8),\n            cb = 255 - (((255 - ab) * (255 - bb)) >> 8);\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        },\n        hard_light: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK),\n            cr = (br < 128) ? ((ar * br) >> 7) : (255 - (((255 - ar) * (255 - br)) >> 7)),\n            cg = (bg < 128) ? ((ag * bg) >> 7) : (255 - (((255 - ag) * (255 - bg)) >> 7)),\n            cb = (bb < 128) ? ((ab * bb) >> 7) : (255 - (((255 - ab) * (255 - bb)) >> 7));\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        },\n        soft_light: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK),\n            cr = ((ar * br) >> 7) + ((ar * ar) >> 8) - ((ar * ar * br) >> 15),\n            cg = ((ag * bg) >> 7) + ((ag * ag) >> 8) - ((ag * ag * bg) >> 15),\n            cb = ((ab * bb) >> 7) + ((ab * ab) >> 8) - ((ab * ab * bb) >> 15);\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        },\n        overlay: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK),\n            cr = (ar < 128) ? ((ar * br) >> 7) : (255 - (((255 - ar) * (255 - br)) >> 7)),\n            cg = (ag < 128) ? ((ag * bg) >> 7) : (255 - (((255 - ag) * (255 - bg)) >> 7)),\n            cb = (ab < 128) ? ((ab * bb) >> 7) : (255 - (((255 - ab) * (255 - bb)) >> 7));\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        },\n        dodge: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK);\n\n          var cr = 255;\n          if (br !== 255) {\n            cr = (ar << 8) / (255 - br);\n            cr = (cr < 0) ? 0 : ((cr > 255) ? 255 : cr);\n          }\n\n          var cg = 255;\n          if (bg !== 255) {\n            cg = (ag << 8) / (255 - bg);\n            cg = (cg < 0) ? 0 : ((cg > 255) ? 255 : cg);\n          }\n\n          var cb = 255;\n          if (bb !== 255) {\n            cb = (ab << 8) / (255 - bb);\n            cb = (cb < 0) ? 0 : ((cb > 255) ? 255 : cb);\n          }\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        },\n        burn: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK);\n\n          var cr = 0;\n          if (br !== 0) {\n            cr = ((255 - ar) << 8) / br;\n            cr = 255 - ((cr < 0) ? 0 : ((cr > 255) ? 255 : cr));\n          }\n\n          var cg = 0;\n          if (bg !== 0) {\n            cg = ((255 - ag) << 8) / bg;\n            cg = 255 - ((cg < 0) ? 0 : ((cg > 255) ? 255 : cg));\n          }\n\n          var cb = 0;\n          if (bb !== 0) {\n            cb = ((255 - ab) << 8) / bb;\n            cb = 255 - ((cb < 0) ? 0 : ((cb > 255) ? 255 : cb));\n          }\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        }\n      };\n    }());\n\n    function color$4(aValue1, aValue2, aValue3, aValue4) {\n      var r, g, b, a;\n\n      if (curColorMode === PConstants.HSB) {\n        var rgb = p.color.toRGB(aValue1, aValue2, aValue3);\n        r = rgb[0];\n        g = rgb[1];\n        b = rgb[2];\n      } else {\n        r = Math.round(255 * (aValue1 / colorModeX));\n        g = Math.round(255 * (aValue2 / colorModeY));\n        b = Math.round(255 * (aValue3 / colorModeZ));\n      }\n\n      a = Math.round(255 * (aValue4 / colorModeA));\n\n      // Limit values less than 0 and greater than 255\n      r = (r < 0) ? 0 : r;\n      g = (g < 0) ? 0 : g;\n      b = (b < 0) ? 0 : b;\n      a = (a < 0) ? 0 : a;\n      r = (r > 255) ? 255 : r;\n      g = (g > 255) ? 255 : g;\n      b = (b > 255) ? 255 : b;\n      a = (a > 255) ? 255 : a;\n\n      // Create color int\n      return (a << 24) & PConstants.ALPHA_MASK | (r << 16) & PConstants.RED_MASK | (g << 8) & PConstants.GREEN_MASK | b & PConstants.BLUE_MASK;\n    }\n\n    function color$2(aValue1, aValue2) {\n      var a;\n\n      // Color int and alpha\n      if (aValue1 & PConstants.ALPHA_MASK) {\n        a = Math.round(255 * (aValue2 / colorModeA));\n        // Limit values less than 0 and greater than 255\n        a = (a > 255) ? 255 : a;\n        a = (a < 0) ? 0 : a;\n\n        return aValue1 - (aValue1 & PConstants.ALPHA_MASK) + ((a << 24) & PConstants.ALPHA_MASK);\n      }\n      // Grayscale and alpha\n      if (curColorMode === PConstants.RGB) {\n        return color$4(aValue1, aValue1, aValue1, aValue2);\n      }\n      if (curColorMode === PConstants.HSB) {\n        return color$4(0, 0, (aValue1 / colorModeX) * colorModeZ, aValue2);\n      }\n    }\n\n    function color$1(aValue1) {\n      // Grayscale\n      if (aValue1 <= colorModeX && aValue1 >= 0) {\n          if (curColorMode === PConstants.RGB) {\n            return color$4(aValue1, aValue1, aValue1, colorModeA);\n          }\n          if (curColorMode === PConstants.HSB) {\n            return color$4(0, 0, (aValue1 / colorModeX) * colorModeZ, colorModeA);\n          }\n      }\n      // Color int\n      if (aValue1) {\n        if (aValue1 > 2147483647) {\n          // Java Overflow\n          aValue1 -= 4294967296;\n        }\n        return aValue1;\n      }\n    }\n\n    /**\n    * Creates colors for storing in variables of the color datatype. The parameters are\n    * interpreted as RGB or HSB values depending on the current colorMode(). The default\n    * mode is RGB values from 0 to 255 and therefore, the function call color(255, 204, 0)\n    * will return a bright yellow color. More about how colors are stored can be found in\n    * the reference for the color datatype.\n    *\n    * @param {int|float} aValue1        red or hue or grey values relative to the current color range.\n    * Also can be color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)\n    * @param {int|float} aValue2        green or saturation values relative to the current color range\n    * @param {int|float} aValue3        blue or brightness values relative to the current color range\n    * @param {int|float} aValue4        relative to current color range. Represents alpha\n    *\n    * @returns {color} the color\n    *\n    * @see colorMode\n    */\n    p.color = function(aValue1, aValue2, aValue3, aValue4) {\n\n      // 4 arguments: (R, G, B, A) or (H, S, B, A)\n      if (aValue1 !== undef && aValue2 !== undef && aValue3 !== undef && aValue4 !== undef) {\n        return color$4(aValue1, aValue2, aValue3, aValue4);\n      }\n\n      // 3 arguments: (R, G, B) or (H, S, B)\n      if (aValue1 !== undef && aValue2 !== undef && aValue3 !== undef) {\n        return color$4(aValue1, aValue2, aValue3, colorModeA);\n      }\n\n      // 2 arguments: (Color, A) or (Grayscale, A)\n      if (aValue1 !== undef && aValue2 !== undef) {\n        return color$2(aValue1, aValue2);\n      }\n\n      // 1 argument: (Grayscale) or (Color)\n      if (typeof aValue1 === \"number\") {\n        return color$1(aValue1);\n      }\n\n      // Default\n      return color$4(colorModeX, colorModeY, colorModeZ, colorModeA);\n    };\n\n    // Ease of use function to extract the colour bits into a string\n    p.color.toString = function(colorInt) {\n      return \"rgba(\" + ((colorInt & PConstants.RED_MASK) >>> 16) + \",\" + ((colorInt & PConstants.GREEN_MASK) >>> 8) +\n             \",\" + ((colorInt & PConstants.BLUE_MASK)) + \",\" + ((colorInt & PConstants.ALPHA_MASK) >>> 24) / 255 + \")\";\n    };\n\n    // Easy of use function to pack rgba values into a single bit-shifted color int.\n    p.color.toInt = function(r, g, b, a) {\n      return (a << 24) & PConstants.ALPHA_MASK | (r << 16) & PConstants.RED_MASK | (g << 8) & PConstants.GREEN_MASK | b & PConstants.BLUE_MASK;\n    };\n\n    // Creates a simple array in [R, G, B, A] format, [255, 255, 255, 255]\n    p.color.toArray = function(colorInt) {\n      return [(colorInt & PConstants.RED_MASK) >>> 16, (colorInt & PConstants.GREEN_MASK) >>> 8,\n              colorInt & PConstants.BLUE_MASK, (colorInt & PConstants.ALPHA_MASK) >>> 24];\n    };\n\n    // Creates a WebGL color array in [R, G, B, A] format. WebGL wants the color ranges between 0 and 1, [1, 1, 1, 1]\n    p.color.toGLArray = function(colorInt) {\n      return [((colorInt & PConstants.RED_MASK) >>> 16) / 255, ((colorInt & PConstants.GREEN_MASK) >>> 8) / 255,\n              (colorInt & PConstants.BLUE_MASK) / 255, ((colorInt & PConstants.ALPHA_MASK) >>> 24) / 255];\n    };\n\n    // HSB conversion function from Mootools, MIT Licensed\n    p.color.toRGB = function(h, s, b) {\n      // Limit values greater than range\n      h = (h > colorModeX) ? colorModeX : h;\n      s = (s > colorModeY) ? colorModeY : s;\n      b = (b > colorModeZ) ? colorModeZ : b;\n\n      // Limit values smaller than range\n      h = (h < 0) ? 0 : h;\n\n      h = (h / colorModeX) * 360;\n      s = (s / colorModeY) * 100;\n      b = (b / colorModeZ) * 100;\n\n      var br = Math.round(b / 100 * 255);\n\n      if (s === 0) { // Grayscale\n        return [br, br, br];\n      }\n      var hue = h % 360;\n      var f = hue % 60;\n      var p = Math.round((b * (100 - s)) / 10000 * 255);\n      var q = Math.round((b * (6000 - s * f)) / 600000 * 255);\n      var t = Math.round((b * (6000 - s * (60 - f))) / 600000 * 255);\n      switch (Math.floor(hue / 60)) {\n      case 0:\n        return [br, t, p];\n      case 1:\n        return [q, br, p];\n      case 2:\n        return [p, br, t];\n      case 3:\n        return [p, q, br];\n      case 4:\n        return [t, p, br];\n      case 5:\n        return [br, p, q];\n      default:\n        Processing.debug(\"Unexpectedly hit default case in toRGB function.\");\n      }\n    };\n\n    function colorToHSB(colorInt) {\n      var red, green, blue;\n\n      red   = ((colorInt & PConstants.RED_MASK) >>> 16) / 255;\n      green = ((colorInt & PConstants.GREEN_MASK) >>> 8) / 255;\n      blue  = (colorInt & PConstants.BLUE_MASK) / 255;\n\n      var max = p.max(p.max(red,green), blue),\n          min = p.min(p.min(red,green), blue),\n          hue, saturation;\n\n      if (min === max) {\n        return [0, 0, max*colorModeZ];\n      }\n      saturation = (max - min) / max;\n\n      if (red === max) {\n        hue = (green - blue) / (max - min);\n      } else if (green === max) {\n        hue = 2 + ((blue - red) / (max - min));\n      } else {\n        hue = 4 + ((red - green) / (max - min));\n      }\n\n      hue /= 6;\n\n      if (hue < 0) {\n        hue += 1;\n      } else if (hue > 1) {\n        hue -= 1;\n      }\n      return [hue*colorModeX, saturation*colorModeY, max*colorModeZ];\n    }\n\n    /**\n    * Extracts the brightness value from a color.\n    *\n    * @param {color} colInt any value of the color datatype\n    *\n    * @returns {float} The brightness color value.\n    *\n    * @see red\n    * @see green\n    * @see blue\n    * @see hue\n    * @see saturation\n    */\n    p.brightness = function(colInt){\n      return colorToHSB(colInt)[2];\n    };\n\n    /**\n    * Extracts the saturation value from a color.\n    *\n    * @param {color} colInt any value of the color datatype\n    *\n    * @returns {float} The saturation color value.\n    *\n    * @see red\n    * @see green\n    * @see blue\n    * @see hue\n    * @see brightness\n    */\n    p.saturation = function(colInt){\n      return colorToHSB(colInt)[1];\n    };\n\n    /**\n    * Extracts the hue value from a color.\n    *\n    * @param {color} colInt any value of the color datatype\n    *\n    * @returns {float} The hue color value.\n    *\n    * @see red\n    * @see green\n    * @see blue\n    * @see saturation\n    * @see brightness\n    */\n    p.hue = function(colInt){\n      return colorToHSB(colInt)[0];\n    };\n\n    /**\n    * Extracts the red value from a color, scaled to match current colorMode().\n    * This value is always returned as a float so be careful not to assign it to an int value.\n    *\n    * @param {color} aColor any value of the color datatype\n    *\n    * @returns {float} The red color value.\n    *\n    * @see green\n    * @see blue\n    * @see alpha\n    * @see >> right shift\n    * @see hue\n    * @see saturation\n    * @see brightness\n    */\n    p.red = function(aColor) {\n      return ((aColor & PConstants.RED_MASK) >>> 16) / 255 * colorModeX;\n    };\n\n    /**\n    * Extracts the green value from a color, scaled to match current colorMode().\n    * This value is always returned as a float so be careful not to assign it to an int value.\n    *\n    * @param {color} aColor any value of the color datatype\n    *\n    * @returns {float} The green color value.\n    *\n    * @see red\n    * @see blue\n    * @see alpha\n    * @see >> right shift\n    * @see hue\n    * @see saturation\n    * @see brightness\n    */\n    p.green = function(aColor) {\n      return ((aColor & PConstants.GREEN_MASK) >>> 8) / 255 * colorModeY;\n    };\n\n    /**\n    * Extracts the blue value from a color, scaled to match current colorMode().\n    * This value is always returned as a float so be careful not to assign it to an int value.\n    *\n    * @param {color} aColor any value of the color datatype\n    *\n    * @returns {float} The blue color value.\n    *\n    * @see red\n    * @see green\n    * @see alpha\n    * @see >> right shift\n    * @see hue\n    * @see saturation\n    * @see brightness\n    */\n    p.blue = function(aColor) {\n      return (aColor & PConstants.BLUE_MASK) / 255 * colorModeZ;\n    };\n\n    /**\n    * Extracts the alpha value from a color, scaled to match current colorMode().\n    * This value is always returned as a float so be careful not to assign it to an int value.\n    *\n    * @param {color} aColor any value of the color datatype\n    *\n    * @returns {float} The alpha color value.\n    *\n    * @see red\n    * @see green\n    * @see blue\n    * @see >> right shift\n    * @see hue\n    * @see saturation\n    * @see brightness\n    */\n    p.alpha = function(aColor) {\n      return ((aColor & PConstants.ALPHA_MASK) >>> 24) / 255 * colorModeA;\n    };\n\n    /**\n    * Calculates a color or colors between two colors at a specific increment.\n    * The amt parameter is the amount to interpolate between the two values where 0.0\n    * equal to the first point, 0.1 is very near the first point, 0.5 is half-way in between, etc.\n    *\n    * @param {color} c1     interpolate from this color\n    * @param {color} c2     interpolate to this color\n    * @param {float} amt    between 0.0 and 1.0\n    *\n    * @returns {float} The blended color.\n    *\n    * @see blendColor\n    * @see color\n    */\n    p.lerpColor = function(c1, c2, amt) {\n      var r, g, b, a, r1, g1, b1, a1, r2, g2, b2, a2;\n      var hsb1, hsb2, rgb, h, s;\n      var colorBits1 = p.color(c1);\n      var colorBits2 = p.color(c2);\n\n      if (curColorMode === PConstants.HSB) {\n        // Special processing for HSB mode.\n        // Get HSB and Alpha values for Color 1 and 2\n        hsb1 = colorToHSB(colorBits1);\n        a1 = ((colorBits1 & PConstants.ALPHA_MASK) >>> 24) / colorModeA;\n        hsb2 = colorToHSB(colorBits2);\n        a2 = ((colorBits2 & PConstants.ALPHA_MASK) >>> 24) / colorModeA;\n\n        // Return lerp value for each channel, for HSB components\n        h = p.lerp(hsb1[0], hsb2[0], amt);\n        s = p.lerp(hsb1[1], hsb2[1], amt);\n        b = p.lerp(hsb1[2], hsb2[2], amt);\n        rgb = p.color.toRGB(h, s, b);\n        // ... and for Alpha-range\n        a = (p.lerp(a1, a2, amt) * colorModeA + 0.5) | 0;\n\n        return (a << 24) & PConstants.ALPHA_MASK |\n               (rgb[0] << 16) & PConstants.RED_MASK |\n               (rgb[1] << 8) & PConstants.GREEN_MASK |\n               rgb[2] & PConstants.BLUE_MASK;\n      }\n\n      // Get RGBA values for Color 1 to floats\n      r1 = (colorBits1 & PConstants.RED_MASK) >>> 16;\n      g1 = (colorBits1 & PConstants.GREEN_MASK) >>> 8;\n      b1 = (colorBits1 & PConstants.BLUE_MASK);\n      a1 = ((colorBits1 & PConstants.ALPHA_MASK) >>> 24) / colorModeA;\n\n      // Get RGBA values for Color 2 to floats\n      r2 = (colorBits2 & PConstants.RED_MASK) >>> 16;\n      g2 = (colorBits2 & PConstants.GREEN_MASK) >>> 8;\n      b2 = (colorBits2 & PConstants.BLUE_MASK);\n      a2 = ((colorBits2 & PConstants.ALPHA_MASK) >>> 24) / colorModeA;\n\n      // Return lerp value for each channel, INT for color, Float for Alpha-range\n      r = (p.lerp(r1, r2, amt) + 0.5) | 0;\n      g = (p.lerp(g1, g2, amt) + 0.5) | 0;\n      b = (p.lerp(b1, b2, amt) + 0.5) | 0;\n      a = (p.lerp(a1, a2, amt) * colorModeA + 0.5) | 0;\n\n      return (a << 24) & PConstants.ALPHA_MASK |\n             (r << 16) & PConstants.RED_MASK |\n             (g << 8) & PConstants.GREEN_MASK |\n             b & PConstants.BLUE_MASK;\n    };\n\n    /**\n    * Changes the way Processing interprets color data. By default, fill(), stroke(), and background()\n    * colors are set by values between 0 and 255 using the RGB color model. It is possible to change the\n    * numerical range used for specifying colors and to switch color systems. For example, calling colorMode(RGB, 1.0)\n    * will specify that values are specified between 0 and 1. The limits for defining colors are altered by setting the\n    * parameters range1, range2, range3, and range 4.\n    *\n    * @param {MODE} mode Either RGB or HSB, corresponding to Red/Green/Blue and Hue/Saturation/Brightness\n    * @param {int|float} range              range for all color elements\n    * @param {int|float} range1             range for the red or hue depending on the current color mode\n    * @param {int|float} range2             range for the green or saturation depending on the current color mode\n    * @param {int|float} range3             range for the blue or brightness depending on the current color mode\n    * @param {int|float} range4             range for the alpha\n    *\n    * @returns none\n    *\n    * @see background\n    * @see fill\n    * @see stroke\n    */\n    p.colorMode = function() { // mode, range1, range2, range3, range4\n      curColorMode = arguments[0];\n      if (arguments.length > 1) {\n        colorModeX   = arguments[1];\n        colorModeY   = arguments[2] || arguments[1];\n        colorModeZ   = arguments[3] || arguments[1];\n        colorModeA   = arguments[4] || arguments[1];\n      }\n    };\n\n    /**\n    * Blends two color values together based on the blending mode given as the MODE parameter.\n    * The possible modes are described in the reference for the blend() function.\n    *\n    * @param {color} c1 color: the first color to blend\n    * @param {color} c2 color: the second color to blend\n    * @param {MODE} MODE Either BLEND, ADD, SUBTRACT, DARKEST, LIGHTEST, DIFFERENCE, EXCLUSION, MULTIPLY,\n    * SCREEN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, or BURN\n    *\n    * @returns {float} The blended color.\n    *\n    * @see blend\n    * @see color\n    */\n    p.blendColor = function(c1, c2, mode) {\n      if (mode === PConstants.REPLACE) {\n        return p.modes.replace(c1, c2);\n      } else if (mode === PConstants.BLEND) {\n        return p.modes.blend(c1, c2);\n      } else if (mode === PConstants.ADD) {\n        return p.modes.add(c1, c2);\n      } else if (mode === PConstants.SUBTRACT) {\n        return p.modes.subtract(c1, c2);\n      } else if (mode === PConstants.LIGHTEST) {\n        return p.modes.lightest(c1, c2);\n      } else if (mode === PConstants.DARKEST) {\n        return p.modes.darkest(c1, c2);\n      } else if (mode === PConstants.DIFFERENCE) {\n        return p.modes.difference(c1, c2);\n      } else if (mode === PConstants.EXCLUSION) {\n        return p.modes.exclusion(c1, c2);\n      } else if (mode === PConstants.MULTIPLY) {\n        return p.modes.multiply(c1, c2);\n      } else if (mode === PConstants.SCREEN) {\n        return p.modes.screen(c1, c2);\n      } else if (mode === PConstants.HARD_LIGHT) {\n        return p.modes.hard_light(c1, c2);\n      } else if (mode === PConstants.SOFT_LIGHT) {\n        return p.modes.soft_light(c1, c2);\n      } else if (mode === PConstants.OVERLAY) {\n        return p.modes.overlay(c1, c2);\n      } else if (mode === PConstants.DODGE) {\n        return p.modes.dodge(c1, c2);\n      } else if (mode === PConstants.BURN) {\n        return p.modes.burn(c1, c2);\n      }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Canvas-Matrix manipulation\n    ////////////////////////////////////////////////////////////////////////////\n\n    function saveContext() {\n      curContext.save();\n    }\n\n    function restoreContext() {\n      curContext.restore();\n      isStrokeDirty = true;\n      isFillDirty = true;\n    }\n\n    /**\n    * Prints the current matrix to the text window.\n    *\n    * @returns none\n    *\n    * @see pushMatrix\n    * @see popMatrix\n    * @see resetMatrix\n    * @see applyMatrix\n    */\n    p.printMatrix = function() {\n      modelView.print();\n    };\n\n    /**\n    * Specifies an amount to displace objects within the display window. The x parameter specifies left/right translation,\n    * the y parameter specifies up/down translation, and the z parameter specifies translations toward/away from the screen.\n    * Using this function with the z  parameter requires using the P3D or OPENGL parameter in combination with size as shown\n    * in the above example. Transformations apply to everything that happens after and subsequent calls to the function\n    * accumulates the effect. For example, calling translate(50, 0) and then translate(20, 0) is the same as translate(70, 0).\n    * If translate() is called within draw(), the transformation is reset when the loop begins again.\n    * This function can be further controlled by the pushMatrix() and popMatrix().\n    *\n    * @param {int|float} x        left/right translation\n    * @param {int|float} y        up/down translation\n    * @param {int|float} z        forward/back translation\n    *\n    * @returns none\n    *\n    * @see pushMatrix\n    * @see popMatrix\n    * @see scale\n    * @see rotate\n    * @see rotateX\n    * @see rotateY\n    * @see rotateZ\n    */\n    Drawing2D.prototype.translate = function(x, y) {\n      modelView.translate(x, y);\n      modelViewInv.invTranslate(x, y);\n      curContext.translate(x, y);\n    };\n\n    Drawing3D.prototype.translate = function(x, y, z) {\n      modelView.translate(x, y, z);\n      modelViewInv.invTranslate(x, y, z);\n    };\n\n    /**\n    * Increases or decreases the size of a shape by expanding and contracting vertices. Objects always scale from their\n    * relative origin to the coordinate system. Scale values are specified as decimal percentages. For example, the\n    * function call scale(2.0) increases the dimension of a shape by 200%. Transformations apply to everything that\n    * happens after and subsequent calls to the function multiply the effect. For example, calling scale(2.0) and\n    * then scale(1.5) is the same as scale(3.0). If scale() is called within draw(), the transformation is reset when\n    * the loop begins again. Using this fuction with the z  parameter requires passing P3D or OPENGL into the size()\n    * parameter as shown in the example above. This function can be further controlled by pushMatrix() and popMatrix().\n    *\n    * @param {int|float} size     percentage to scale the object\n    * @param {int|float} x        percentage to scale the object in the x-axis\n    * @param {int|float} y        percentage to scale the object in the y-axis\n    * @param {int|float} z        percentage to scale the object in the z-axis\n    *\n    * @returns none\n    *\n    * @see pushMatrix\n    * @see popMatrix\n    * @see translate\n    * @see rotate\n    * @see rotateX\n    * @see rotateY\n    * @see rotateZ\n    */\n    Drawing2D.prototype.scale = function(x, y) {\n      modelView.scale(x, y);\n      modelViewInv.invScale(x, y);\n      curContext.scale(x, y || x);\n    };\n\n    Drawing3D.prototype.scale = function(x, y, z) {\n      modelView.scale(x, y, z);\n      modelViewInv.invScale(x, y, z);\n    };\n\n\n    /**\n     * helper function for applying a transfrom matrix to a 2D context.\n     */\n    Drawing2D.prototype.transform = function(pmatrix) {\n      var e = pmatrix.array();\n      curContext.transform(e[0],e[3],e[1],e[4],e[2],e[5]);\n    };\n\n    /**\n     * helper function for applying a transfrom matrix to a 3D context.\n     * not currently implemented.\n     */\n    Drawing3D.prototype.transformm = function(pmatrix3d) {\n      throw(\"p.transform is currently not supported in 3D mode\");\n    };\n\n\n    /**\n    * Pushes the current transformation matrix onto the matrix stack. Understanding pushMatrix() and popMatrix()\n    * requires understanding the concept of a matrix stack. The pushMatrix() function saves the current coordinate\n    * system to the stack and popMatrix() restores the prior coordinate system. pushMatrix() and popMatrix() are\n    * used in conjuction with the other transformation methods and may be embedded to control the scope of\n    * the transformations.\n    *\n    * @returns none\n    *\n    * @see popMatrix\n    * @see translate\n    * @see rotate\n    * @see rotateX\n    * @see rotateY\n    * @see rotateZ\n    */\n    Drawing2D.prototype.pushMatrix = function() {\n      userMatrixStack.load(modelView);\n      userReverseMatrixStack.load(modelViewInv);\n      saveContext();\n    };\n\n    Drawing3D.prototype.pushMatrix = function() {\n      userMatrixStack.load(modelView);\n      userReverseMatrixStack.load(modelViewInv);\n    };\n\n    /**\n    * Pops the current transformation matrix off the matrix stack. Understanding pushing and popping requires\n    * understanding the concept of a matrix stack. The pushMatrix() function saves the current coordinate system to\n    * the stack and popMatrix() restores the prior coordinate system. pushMatrix() and popMatrix() are used in\n    * conjuction with the other transformation methods and may be embedded to control the scope of the transformations.\n    *\n    * @returns none\n    *\n    * @see popMatrix\n    * @see pushMatrix\n    */\n    Drawing2D.prototype.popMatrix = function() {\n      modelView.set(userMatrixStack.pop());\n      modelViewInv.set(userReverseMatrixStack.pop());\n      restoreContext();\n    };\n\n    Drawing3D.prototype.popMatrix = function() {\n      modelView.set(userMatrixStack.pop());\n      modelViewInv.set(userReverseMatrixStack.pop());\n    };\n\n    /**\n    * Replaces the current matrix with the identity matrix. The equivalent function in OpenGL is glLoadIdentity().\n    *\n    * @returns none\n    *\n    * @see popMatrix\n    * @see pushMatrix\n    * @see applyMatrix\n    * @see printMatrix\n    */\n    Drawing2D.prototype.resetMatrix = function() {\n      modelView.reset();\n      modelViewInv.reset();\n      curContext.setTransform(1,0,0,1,0,0);\n    };\n\n    Drawing3D.prototype.resetMatrix = function() {\n      modelView.reset();\n      modelViewInv.reset();\n    };\n\n    /**\n    * Multiplies the current matrix by the one specified through the parameters. This is very slow because it will\n    * try to calculate the inverse of the transform, so avoid it whenever possible. The equivalent function\n    * in OpenGL is glMultMatrix().\n    *\n    * @param {int|float} n00-n15      numbers which define the 4x4 matrix to be multiplied\n    *\n    * @returns none\n    *\n    * @see popMatrix\n    * @see pushMatrix\n    * @see resetMatrix\n    * @see printMatrix\n    */\n    DrawingShared.prototype.applyMatrix = function() {\n      var a = arguments;\n      modelView.apply(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n      modelViewInv.invApply(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n    };\n\n    Drawing2D.prototype.applyMatrix = function() {\n      var a = arguments;\n      for (var cnt = a.length; cnt < 16; cnt++) {\n        a[cnt] = 0;\n      }\n      a[10] = a[15] = 1;\n      DrawingShared.prototype.applyMatrix.apply(this, a);\n    };\n\n    /**\n    * Rotates a shape around the x-axis the amount specified by the angle parameter. Angles should be\n    * specified in radians (values from 0 to PI*2) or converted to radians with the radians()  function.\n    * Objects are always rotated around their relative position to the origin and positive numbers\n    * rotate objects in a counterclockwise direction. Transformations apply to everything that happens\n    * after and subsequent calls to the function accumulates the effect. For example, calling rotateX(PI/2)\n    * and then rotateX(PI/2) is the same as rotateX(PI). If rotateX() is called within the draw(), the\n    * transformation is reset when the loop begins again. This function requires passing P3D or OPENGL\n    * into the size() parameter as shown in the example above.\n    *\n    * @param {int|float} angleInRadians     angle of rotation specified in radians\n    *\n    * @returns none\n    *\n    * @see rotateY\n    * @see rotateZ\n    * @see rotate\n    * @see translate\n    * @see scale\n    * @see popMatrix\n    * @see pushMatrix\n    */\n    p.rotateX = function(angleInRadians) {\n      modelView.rotateX(angleInRadians);\n      modelViewInv.invRotateX(angleInRadians);\n    };\n\n    /**\n    * Rotates a shape around the z-axis the amount specified by the angle parameter. Angles should be\n    * specified in radians (values from 0 to PI*2) or converted to radians with the radians()  function.\n    * Objects are always rotated around their relative position to the origin and positive numbers\n    * rotate objects in a counterclockwise direction. Transformations apply to everything that happens\n    * after and subsequent calls to the function accumulates the effect. For example, calling rotateZ(PI/2)\n    * and then rotateZ(PI/2) is the same as rotateZ(PI). If rotateZ() is called within the draw(), the\n    * transformation is reset when the loop begins again. This function requires passing P3D or OPENGL\n    * into the size() parameter as shown in the example above.\n    *\n    * @param {int|float} angleInRadians     angle of rotation specified in radians\n    *\n    * @returns none\n    *\n    * @see rotateX\n    * @see rotateY\n    * @see rotate\n    * @see translate\n    * @see scale\n    * @see popMatrix\n    * @see pushMatrix\n    */\n    Drawing2D.prototype.rotateZ = function() {\n      throw \"rotateZ() is not supported in 2D mode. Use rotate(float) instead.\";\n    };\n\n    Drawing3D.prototype.rotateZ = function(angleInRadians) {\n      modelView.rotateZ(angleInRadians);\n      modelViewInv.invRotateZ(angleInRadians);\n    };\n\n    /**\n    * Rotates a shape around the y-axis the amount specified by the angle parameter. Angles should be\n    * specified in radians (values from 0 to PI*2) or converted to radians with the radians()  function.\n    * Objects are always rotated around their relative position to the origin and positive numbers\n    * rotate objects in a counterclockwise direction. Transformations apply to everything that happens\n    * after and subsequent calls to the function accumulates the effect. For example, calling rotateY(PI/2)\n    * and then rotateY(PI/2) is the same as rotateY(PI). If rotateY() is called within the draw(), the\n    * transformation is reset when the loop begins again. This function requires passing P3D or OPENGL\n    * into the size() parameter as shown in the example above.\n    *\n    * @param {int|float} angleInRadians     angle of rotation specified in radians\n    *\n    * @returns none\n    *\n    * @see rotateX\n    * @see rotateZ\n    * @see rotate\n    * @see translate\n    * @see scale\n    * @see popMatrix\n    * @see pushMatrix\n    */\n    p.rotateY = function(angleInRadians) {\n      modelView.rotateY(angleInRadians);\n      modelViewInv.invRotateY(angleInRadians);\n    };\n\n    /**\n    * Rotates a shape the amount specified by the angle parameter. Angles should be specified in radians\n    * (values from 0 to TWO_PI) or converted to radians with the radians() function. Objects are always\n    * rotated around their relative position to the origin and positive numbers rotate objects in a\n    * clockwise direction. Transformations apply to everything that happens after and subsequent calls\n    * to the function accumulates the effect. For example, calling rotate(HALF_PI) and then rotate(HALF_PI)\n    * is the same as rotate(PI). All tranformations are reset when draw() begins again. Technically,\n    * rotate() multiplies the current transformation matrix by a rotation matrix. This function can be\n    * further controlled by the pushMatrix() and popMatrix().\n    *\n    * @param {int|float} angleInRadians     angle of rotation specified in radians\n    *\n    * @returns none\n    *\n    * @see rotateX\n    * @see rotateY\n    * @see rotateZ\n    * @see rotate\n    * @see translate\n    * @see scale\n    * @see popMatrix\n    * @see pushMatrix\n    */\n    Drawing2D.prototype.rotate = function(angleInRadians) {\n      modelView.rotateZ(angleInRadians);\n      modelViewInv.invRotateZ(angleInRadians);\n      curContext.rotate(angleInRadians);\n    };\n\n    Drawing3D.prototype.rotate = function(angleInRadians) {\n      if (arguments.length < 4) {\n        p.rotateZ(angleInRadians);\n      } else {\n        modelView.rotate(angleInRadians, arguments[1], arguments[2], arguments[3]);\n        modelViewInv.rotate((-angleInRadians), arguments[1], arguments[2], arguments[3]);\n      }\n    };\n\n    /**\n    * Shears a shape around the x-axis the amount specified by the angle parameter.\n    * Angles should be specified in radians (values from 0 to PI*2) or converted to radians\n    * with the radians() function. Objects are always sheared around their relative position\n    * to the origin and positive numbers shear objects in a clockwise direction. Transformations\n    * apply to everything that happens after and subsequent calls to the function accumulates the\n    * effect. For example, calling shearX(PI/2) and then shearX(PI/2) is the same as shearX(PI)\n    *\n    * @param {int|float} angleInRadians     angle of rotation specified in radians\n    *\n    * @returns none\n    *\n    * @see rotateX\n    * @see rotateY\n    * @see rotateZ\n    * @see rotate\n    * @see translate\n    * @see scale\n    * @see popMatrix\n    * @see pushMatrix\n    */\n\n    Drawing2D.prototype.shearX = function(angleInRadians) {\n      modelView.shearX(angleInRadians);\n      curContext.transform(1,0,angleInRadians,1,0,0);\n    };\n\n    Drawing3D.prototype.shearX = function(angleInRadians) {\n      modelView.shearX(angleInRadians);\n    };\n\n    /**\n    * Shears a shape around the y-axis the amount specified by the angle parameter.\n    * Angles should be specified in radians (values from 0 to PI*2) or converted to\n    * radians with the radians() function. Objects are always sheared around their\n    * relative position to the origin and positive numbers shear objects in a\n    * clockwise direction. Transformations apply to everything that happens after\n    * and subsequent calls to the function accumulates the effect. For example,\n    * calling shearY(PI/2) and then shearY(PI/2) is the same as shearY(PI).\n    *\n    * @param {int|float} angleInRadians     angle of rotation specified in radians\n    *\n    * @returns none\n    *\n    * @see rotateX\n    * @see rotateY\n    * @see rotateZ\n    * @see rotate\n    * @see translate\n    * @see scale\n    * @see popMatrix\n    * @see pushMatrix\n    * @see shearX\n    */\n\n   Drawing2D.prototype.shearY = function(angleInRadians) {\n      modelView.shearY(angleInRadians);\n      curContext.transform(1,angleInRadians,0,1,0,0);\n    };\n\n    Drawing3D.prototype.shearY = function(angleInRadians) {\n      modelView.shearY(angleInRadians);\n    };\n\n    /**\n    * The pushStyle() function saves the current style settings and popStyle()  restores the prior settings.\n    * Note that these functions are always used together. They allow you to change the style settings and later\n    * return to what you had. When a new style is started with pushStyle(), it builds on the current style information.\n    * The pushStyle() and popStyle() functions can be embedded to provide more control (see the second example\n    * above for a demonstration.)\n    * The style information controlled by the following functions are included in the style: fill(), stroke(), tint(),\n    * strokeWeight(), strokeCap(), strokeJoin(), imageMode(), rectMode(), ellipseMode(), shapeMode(), colorMode(),\n    * textAlign(), textFont(), textMode(), textSize(), textLeading(), emissive(), specular(), shininess(), ambient()\n    *\n    * @returns none\n    *\n    * @see popStyle\n    */\n    p.pushStyle = function() {\n      // Save the canvas state.\n      saveContext();\n\n      p.pushMatrix();\n\n      var newState = {\n        'doFill': doFill,\n        'currentFillColor': currentFillColor,\n        'doStroke': doStroke,\n        'currentStrokeColor': currentStrokeColor,\n        'curTint': curTint,\n        'curRectMode': curRectMode,\n        'curColorMode': curColorMode,\n        'colorModeX': colorModeX,\n        'colorModeZ': colorModeZ,\n        'colorModeY': colorModeY,\n        'colorModeA': colorModeA,\n        'curTextFont': curTextFont,\n        'horizontalTextAlignment': horizontalTextAlignment,\n        'verticalTextAlignment': verticalTextAlignment,\n        'textMode': textMode,\n        'curFontName': curFontName,\n        'curTextSize': curTextSize,\n        'curTextAscent': curTextAscent,\n        'curTextDescent': curTextDescent,\n        'curTextLeading': curTextLeading\n      };\n\n      styleArray.push(newState);\n    };\n\n    /**\n    * The pushStyle() function saves the current style settings and popStyle()  restores the prior settings; these\n    * functions are always used together. They allow you to change the style settings and later return to what you had.\n    * When a new style is started with pushStyle(), it builds on the current style information. The pushStyle() and\n    * popStyle() functions can be embedded to provide more control (see the second example above for a demonstration.)\n    *\n    * @returns none\n    *\n    * @see pushStyle\n    */\n    p.popStyle = function() {\n      var oldState = styleArray.pop();\n\n      if (oldState) {\n        restoreContext();\n\n        p.popMatrix();\n\n        doFill = oldState.doFill;\n        currentFillColor = oldState.currentFillColor;\n        doStroke = oldState.doStroke;\n        currentStrokeColor = oldState.currentStrokeColor;\n        curTint = oldState.curTint;\n        curRectMode = oldState.curRectMode;\n        curColorMode = oldState.curColorMode;\n        colorModeX = oldState.colorModeX;\n        colorModeZ = oldState.colorModeZ;\n        colorModeY = oldState.colorModeY;\n        colorModeA = oldState.colorModeA;\n        curTextFont = oldState.curTextFont;\n        curFontName = oldState.curFontName;\n        curTextSize = oldState.curTextSize;\n        horizontalTextAlignment = oldState.horizontalTextAlignment;\n        verticalTextAlignment = oldState.verticalTextAlignment;\n        textMode = oldState.textMode;\n        curTextAscent = oldState.curTextAscent;\n        curTextDescent = oldState.curTextDescent;\n        curTextLeading = oldState.curTextLeading;\n      } else {\n        throw \"Too many popStyle() without enough pushStyle()\";\n      }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Time based functions\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n    * Processing communicates with the clock on your computer.\n    * The year() function returns the current year as an integer (2003, 2004, 2005, etc).\n    *\n    * @returns {float} The current year.\n    *\n    * @see millis\n    * @see second\n    * @see minute\n    * @see hour\n    * @see day\n    * @see month\n    */\n    p.year = function() {\n      return new Date().getFullYear();\n    };\n    /**\n    * Processing communicates with the clock on your computer.\n    * The month() function returns the current month as a value from 1 - 12.\n    *\n    * @returns {float} The current month.\n    *\n    * @see millis\n    * @see second\n    * @see minute\n    * @see hour\n    * @see day\n    * @see year\n    */\n    p.month = function() {\n      return new Date().getMonth() + 1;\n    };\n    /**\n    * Processing communicates with the clock on your computer.\n    * The day() function returns the current day as a value from 1 - 31.\n    *\n    * @returns {float} The current day.\n    *\n    * @see millis\n    * @see second\n    * @see minute\n    * @see hour\n    * @see month\n    * @see year\n    */\n    p.day = function() {\n      return new Date().getDate();\n    };\n    /**\n    * Processing communicates with the clock on your computer.\n    * The hour() function returns the current hour as a value from 0 - 23.\n    *\n    * @returns {float} The current hour.\n    *\n    * @see millis\n    * @see second\n    * @see minute\n    * @see month\n    * @see day\n    * @see year\n    */\n    p.hour = function() {\n      return new Date().getHours();\n    };\n    /**\n    * Processing communicates with the clock on your computer.\n    * The minute() function returns the current minute as a value from 0 - 59.\n    *\n    * @returns {float} The current minute.\n    *\n    * @see millis\n    * @see second\n    * @see month\n    * @see hour\n    * @see day\n    * @see year\n    */\n    p.minute = function() {\n      return new Date().getMinutes();\n    };\n    /**\n    * Processing communicates with the clock on your computer.\n    * The second() function returns the current second as a value from 0 - 59.\n    *\n    * @returns {float} The current minute.\n    *\n    * @see millis\n    * @see month\n    * @see minute\n    * @see hour\n    * @see day\n    * @see year\n    */\n    p.second = function() {\n      return new Date().getSeconds();\n    };\n    /**\n    * Returns the number of milliseconds (thousandths of a second) since starting a sketch.\n    * This information is often used for timing animation sequences.\n    *\n    * @returns {long} The number of milliseconds since starting the sketch.\n    *\n    * @see month\n    * @see second\n    * @see minute\n    * @see hour\n    * @see day\n    * @see year\n    */\n    p.millis = function() {\n      return Date.now() - start;\n    };\n\n    /**\n    * Executes the code within draw() one time. This functions allows the program to update\n    * the display window only when necessary, for example when an event registered by\n    * mousePressed() or keyPressed() occurs.\n    * In structuring a program, it only makes sense to call redraw() within events such as\n    * mousePressed(). This is because redraw() does not run draw() immediately (it only sets\n    * a flag that indicates an update is needed).\n    * Calling redraw() within draw() has no effect because draw() is continuously called anyway.\n    *\n    * @returns none\n    *\n    * @see noLoop\n    * @see loop\n    */\n    function redrawHelper() {\n      var sec = (Date.now() - timeSinceLastFPS) / 1000;\n      framesSinceLastFPS++;\n      var fps = framesSinceLastFPS / sec;\n\n      // recalculate FPS every half second for better accuracy.\n      if (sec > 0.5) {\n        timeSinceLastFPS = Date.now();\n        framesSinceLastFPS = 0;\n        p.__frameRate = fps;\n      }\n\n      p.frameCount++;\n    }\n\n    Drawing2D.prototype.redraw = function() {\n      redrawHelper();\n\n      curContext.lineWidth = lineWidth;\n      var pmouseXLastEvent = p.pmouseX,\n          pmouseYLastEvent = p.pmouseY;\n      p.pmouseX = pmouseXLastFrame;\n      p.pmouseY = pmouseYLastFrame;\n\n      saveContext();\n      p.draw();\n      restoreContext();\n\n      pmouseXLastFrame = p.mouseX;\n      pmouseYLastFrame = p.mouseY;\n      p.pmouseX = pmouseXLastEvent;\n      p.pmouseY = pmouseYLastEvent;\n    };\n\n    Drawing3D.prototype.redraw = function() {\n      redrawHelper();\n\n      var pmouseXLastEvent = p.pmouseX,\n          pmouseYLastEvent = p.pmouseY;\n      p.pmouseX = pmouseXLastFrame;\n      p.pmouseY = pmouseYLastFrame;\n      // even if the color buffer isn't cleared with background(),\n      // the depth buffer needs to be cleared regardless.\n      curContext.clear(curContext.DEPTH_BUFFER_BIT);\n      curContextCache = { attributes: {}, locations: {} };\n      // Delete all the lighting states and the materials the\n      // user set in the last draw() call.\n      p.noLights();\n      p.lightFalloff(1, 0, 0);\n      p.shininess(1);\n      p.ambient(255, 255, 255);\n      p.specular(0, 0, 0);\n      p.emissive(0, 0, 0);\n      p.camera();\n      p.draw();\n\n      pmouseXLastFrame = p.mouseX;\n      pmouseYLastFrame = p.mouseY;\n      p.pmouseX = pmouseXLastEvent;\n      p.pmouseY = pmouseYLastEvent;\n    };\n\n    /**\n    * Stops Processing from continuously executing the code within draw(). If loop() is\n    * called, the code in draw() begin to run continuously again. If using noLoop() in\n    * setup(), it should be the last line inside the block.\n    * When noLoop() is used, it's not possible to manipulate or access the screen inside event\n    * handling functions such as mousePressed() or keyPressed(). Instead, use those functions\n    * to call redraw() or loop(), which will run draw(), which can update the screen properly.\n    * This means that when noLoop() has been called, no drawing can happen, and functions like\n    * saveFrame() or loadPixels() may not be used.\n    * Note that if the sketch is resized, redraw() will be called to update the sketch, even\n    * after noLoop() has been specified. Otherwise, the sketch would enter an odd state until\n    * loop() was called.\n    *\n    * @returns none\n    *\n    * @see redraw\n    * @see draw\n    * @see loop\n    */\n    p.noLoop = function() {\n      doLoop = false;\n      loopStarted = false;\n      clearInterval(looping);\n      curSketch.onPause();\n    };\n\n    /**\n    * Causes Processing to continuously execute the code within draw(). If noLoop() is called,\n    * the code in draw() stops executing.\n    *\n    * @returns none\n    *\n    * @see noLoop\n    */\n    p.loop = function() {\n      if (loopStarted) {\n        return;\n      }\n\n      timeSinceLastFPS = Date.now();\n      framesSinceLastFPS = 0;\n\n      looping = window.setInterval(function() {\n        try {\n          curSketch.onFrameStart();\n          p.redraw();\n          curSketch.onFrameEnd();\n        } catch(e_loop) {\n          window.clearInterval(looping);\n          throw e_loop;\n        }\n      }, curMsPerFrame);\n      doLoop = true;\n      loopStarted = true;\n      curSketch.onLoop();\n    };\n\n    /**\n    * Specifies the number of frames to be displayed every second. If the processor is not\n    * fast enough to maintain the specified rate, it will not be achieved. For example, the\n    * function call frameRate(30) will attempt to refresh 30 times a second. It is recommended\n    * to set the frame rate within setup(). The default rate is 60 frames per second.\n    *\n    * @param {int} aRate        number of frames per second.\n    *\n    * @returns none\n    *\n    * @see delay\n    */\n    p.frameRate = function(aRate) {\n      curFrameRate = aRate;\n      curMsPerFrame = 1000 / curFrameRate;\n\n      // clear and reset interval\n      if (doLoop) {\n        p.noLoop();\n        p.loop();\n      }\n    };\n\n    /**\n    * Quits/stops/exits the program.\n    * Rather than terminating immediately, exit() will cause the sketch to exit after draw()\n    * has completed (or after setup() completes if called during the setup() method).\n    *\n    * @returns none\n    */\n    p.exit = function() {\n      // cleanup\n      window.clearInterval(looping);\n      removeInstance(p.externals.canvas.id);\n      delete(curElement.onmousedown);\n\n      // Step through the libraries to detach them\n      for (var lib in Processing.lib) {\n        if (Processing.lib.hasOwnProperty(lib)) {\n          if (Processing.lib[lib].hasOwnProperty(\"detach\")) {\n            Processing.lib[lib].detach(p);\n          }\n        }\n      }\n\n      // clean up all event handling\n      var i = eventHandlers.length;\n      while (i--) {\n        detachEventHandler(eventHandlers[i]);\n      }\n      curSketch.onExit();\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // MISC functions\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n    * Sets the cursor to a predefined symbol, an image, or turns it on if already hidden.\n    * If you are trying to set an image as the cursor, it is recommended to make the size\n    * 16x16 or 32x32 pixels. It is not possible to load an image as the cursor if you are\n    * exporting your program for the Web. The values for parameters x and y must be less\n    * than the dimensions of the image.\n    *\n    * @param {MODE} MODE either ARROW, CROSS, HAND, MOVE, TEXT, WAIT\n    * @param {PImage} image       any variable of type PImage\n    * @param {int}    x           the horizonal active spot of the cursor\n    * @param {int}    y           the vertical active spot of the cursor\n    *\n    * @returns none\n    *\n    * @see noCursor\n    */\n    p.cursor = function() {\n      if (arguments.length > 1 || (arguments.length === 1 && arguments[0] instanceof p.PImage)) {\n        var image = arguments[0],\n          x, y;\n        if (arguments.length >= 3) {\n          x = arguments[1];\n          y = arguments[2];\n          if (x < 0 || y < 0 || y >= image.height || x >= image.width) {\n            throw \"x and y must be non-negative and less than the dimensions of the image\";\n          }\n        } else {\n          x = image.width >>> 1;\n          y = image.height >>> 1;\n        }\n\n        // see https://developer.mozilla.org/en/Using_URL_values_for_the_cursor_property\n        var imageDataURL = image.toDataURL();\n        var style = \"url(\\\"\" + imageDataURL + \"\\\") \" + x + \" \" + y + \", default\";\n        curCursor = curElement.style.cursor = style;\n      } else if (arguments.length === 1) {\n        var mode = arguments[0];\n        curCursor = curElement.style.cursor = mode;\n      } else {\n        curCursor = curElement.style.cursor = oldCursor;\n      }\n    };\n\n    /**\n    * Hides the cursor from view.\n    *\n    * @returns none\n    *\n    * @see cursor\n    */\n    p.noCursor = function() {\n      curCursor = curElement.style.cursor = PConstants.NOCURSOR;\n    };\n\n    /**\n    * Links to a webpage either in the same window or in a new window. The complete URL\n    * must be specified.\n    *\n    * @param {String} href      complete url as a String in quotes\n    * @param {String} target    name of the window to load the URL as a string in quotes\n    *\n    * @returns none\n    */\n    p.link = function(href, target) {\n      if (target !== undef) {\n        window.open(href, target);\n      } else {\n        window.location = href;\n      }\n    };\n\n    // PGraphics methods\n    // These functions exist only for compatibility with P5\n    p.beginDraw = noop;\n    p.endDraw = noop;\n\n    /**\n     * This function takes content from a canvas and turns it into an ImageData object to be used with a PImage\n     *\n     * @returns {ImageData}        ImageData object to attach to a PImage (1D array of pixel data)\n     *\n     * @see PImage\n     */\n    Drawing2D.prototype.toImageData = function(x, y, w, h) {\n      x = x !== undef ? x : 0;\n      y = y !== undef ? y : 0;\n      w = w !== undef ? w : p.width;\n      h = h !== undef ? h : p.height;\n      return curContext.getImageData(x, y, w, h);\n    };\n\n    Drawing3D.prototype.toImageData = function(x, y, w, h) {\n      x = x !== undef ? x : 0;\n      y = y !== undef ? y : 0;\n      w = w !== undef ? w : p.width;\n      h = h !== undef ? h : p.height;\n      var c = document.createElement(\"canvas\"),\n          ctx = c.getContext(\"2d\"),\n          obj = ctx.createImageData(w, h),\n          uBuff = new Uint8Array(w * h * 4);\n      curContext.readPixels(x, y, w, h, curContext.RGBA, curContext.UNSIGNED_BYTE, uBuff);\n      for (var i=0, ul=uBuff.length, obj_data=obj.data; i < ul; i++) {\n        obj_data[i] = uBuff[(h - 1 - Math.floor(i / 4 / w)) * w * 4 + (i % (w * 4))];\n      }\n      return obj;\n    };\n\n    /**\n    * Displays message in the browser's status area. This is the text area in the lower\n    * left corner of the browser. The status() function will only work when the\n    * Processing program is running in a web browser.\n    *\n    * @param {String} text      any valid String\n    *\n    * @returns none\n    */\n    p.status = function(text) {\n      window.status = text;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Binary Functions\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n    * Converts a byte, char, int, or color to a String containing the equivalent binary\n    * notation. For example color(0, 102, 153, 255) will convert to the String\n    * \"11111111000000000110011010011001\". This function can help make your geeky debugging\n    * sessions much happier.\n    *\n    * @param {byte|char|int|color} num          byte, char, int, color: value to convert\n    * @param {int} numBits                      number of digits to return\n    *\n    * @returns {String}\n    *\n    * @see unhex\n    * @see hex\n    * @see unbinary\n    */\n    p.binary = function(num, numBits) {\n      var bit;\n      if (numBits > 0) {\n        bit = numBits;\n      } else if(num instanceof Char) {\n        bit = 16;\n        num |= 0; // making it int\n      } else {\n        // autodetect, skipping zeros\n        bit = 32;\n        while (bit > 1 && !((num >>> (bit - 1)) & 1)) {\n          bit--;\n        }\n      }\n      var result = \"\";\n      while (bit > 0) {\n        result += ((num >>> (--bit)) & 1) ? \"1\" : \"0\";\n      }\n      return result;\n    };\n\n    /**\n    * Converts a String representation of a binary number to its equivalent integer value.\n    * For example, unbinary(\"00001000\") will return 8.\n    *\n    * @param {String} binaryString String\n    *\n    * @returns {Int}\n    *\n    * @see hex\n    * @see binary\n    * @see unbinary\n    */\n    p.unbinary = function(binaryString) {\n      var i = binaryString.length - 1, mask = 1, result = 0;\n      while (i >= 0) {\n        var ch = binaryString[i--];\n        if (ch !== '0' && ch !== '1') {\n          throw \"the value passed into unbinary was not an 8 bit binary number\";\n        }\n        if (ch === '1') {\n          result += mask;\n        }\n        mask <<= 1;\n      }\n      return result;\n    };\n\n    var decimalToHex = function(d, padding) {\n      //if there is no padding value added, default padding to 8 else go into while statement.\n      padding = (padding === undef || padding === null) ? padding = 8 : padding;\n      if (d < 0) {\n        d = 0xFFFFFFFF + d + 1;\n      }\n      var hex = Number(d).toString(16).toUpperCase();\n      while (hex.length < padding) {\n        hex = \"0\" + hex;\n      }\n      if (hex.length >= padding) {\n        hex = hex.substring(hex.length - padding, hex.length);\n      }\n      return hex;\n    };\n\n    // note: since we cannot keep track of byte, int types by default the returned string is 8 chars long\n    // if no 2nd argument is passed.  closest compromise we can use to match java implementation Feb 5 2010\n    // also the char parser has issues with chars that are not digits or letters IE: !@#$%^&*\n    /**\n    * Converts a byte, char, int, or color to a String containing the equivalent hexadecimal notation.\n    * For example color(0, 102, 153, 255) will convert to the String \"FF006699\". This function can help\n    * make your geeky debugging sessions much happier.\n    *\n    * @param {byte|char|int|Color} value   the value to turn into a hex string\n    * @param {int} digits                 the number of digits to return\n    *\n    * @returns {String}\n    *\n    * @see unhex\n    * @see binary\n    * @see unbinary\n    */\n    p.hex = function(value, len) {\n      if (arguments.length === 1) {\n        if (value instanceof Char) {\n          len = 4;\n        } else { // int or byte, indistinguishable at the moment, default to 8\n          len = 8;\n        }\n      }\n      return decimalToHex(value, len);\n    };\n\n    function unhexScalar(hex) {\n      var value = parseInt(\"0x\" + hex, 16);\n\n      // correct for int overflow java expectation\n      if (value > 2147483647) {\n        value -= 4294967296;\n      }\n      return value;\n    }\n\n    /**\n    * Converts a String representation of a hexadecimal number to its equivalent integer value.\n    *\n    * @param {String} hex   the hex string to convert to an int\n    *\n    * @returns {int}\n    *\n    * @see hex\n    * @see binary\n    * @see unbinary\n    */\n    p.unhex = function(hex) {\n      if (hex instanceof Array) {\n        var arr = [];\n        for (var i = 0; i < hex.length; i++) {\n          arr.push(unhexScalar(hex[i]));\n        }\n        return arr;\n      }\n      return unhexScalar(hex);\n    };\n\n    // Load a file or URL into strings\n    /**\n    * Reads the contents of a file or url and creates a String array of its individual lines.\n    * The filename parameter can also be a URL to a file found online.  If the file is not available or an error occurs,\n    * null will be returned and an error message will be printed to the console. The error message does not halt\n    * the program.\n    *\n    * @param {String} filename    name of the file or url to load\n    *\n    * @returns {String[]}\n    *\n    * @see loadBytes\n    * @see saveStrings\n    * @see saveBytes\n    */\n    p.loadStrings = function(filename) {\n      if (localStorage[filename]) {\n        return localStorage[filename].split(\"\\n\");\n      }\n\n      var filecontent = ajax(filename);\n      if(typeof filecontent !== \"string\" || filecontent === \"\") {\n        return [];\n      }\n\n      // deal with the fact that Windows uses \\r\\n, Unix uses \\n,\n      // Mac uses \\r, and we actually expect \\n\n      filecontent = filecontent.replace(/(\\r\\n?)/g,\"\\n\").replace(/\\n$/,\"\");\n\n      return filecontent.split(\"\\n\");\n    };\n\n    // Writes an array of strings to a file, one line per string\n    /**\n    * Writes an array of strings to a file, one line per string. This file is saved to the localStorage.\n    *\n    * @param {String} filename    name of the file to save to localStorage\n    * @param {String[]} strings   string array to be written\n    *\n    * @see loadBytes\n    * @see loadStrings\n    * @see saveBytes\n    */\n    p.saveStrings = function(filename, strings) {\n      localStorage[filename] = strings.join('\\n');\n    };\n\n    /**\n    * Reads the contents of a file or url and places it in a byte array. If a file is specified, it must be located in the localStorage.\n    * The filename parameter can also be a URL to a file found online.\n    *\n    * @param {String} filename   name of a file in the localStorage or a URL.\n    *\n    * @returns {byte[]}\n    *\n    * @see loadStrings\n    * @see saveStrings\n    * @see saveBytes\n    */\n    p.loadBytes = function(url) {\n      var string = ajax(url);\n      var ret = [];\n\n      for (var i = 0; i < string.length; i++) {\n        ret.push(string.charCodeAt(i));\n      }\n\n      return ret;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // String Functions\n    ////////////////////////////////////////////////////////////////////////////\n    /**\n     * The matchAll() function is identical to match(), except that it returns an array of all matches in\n     * the specified String, rather than just the first.\n     *\n     * @param {String} aString  the String to search inside\n     * @param {String} aRegExp  the regexp to be used for matching\n     *\n     * @return {String[]} returns an array of matches\n     *\n     * @see #match\n     */\n    p.matchAll = function(aString, aRegExp) {\n      var results = [],\n          latest;\n      var regexp = new RegExp(aRegExp, \"g\");\n      while ((latest = regexp.exec(aString)) !== null) {\n        results.push(latest);\n        if (latest[0].length === 0) {\n          ++regexp.lastIndex;\n        }\n      }\n      return results.length > 0 ? results : null;\n    };\n    /**\n     * The match() function matches a string with a regular expression, and returns the match as an\n     * array. The first index is the matching expression, and array elements\n     * [1] and higher represent each of the groups (sequences found in parens).\n     *\n     * @param {String} str      the String to be searched\n     * @param {String} regexp   the regexp to be used for matching\n     *\n     * @return {String[]} an array of matching strings\n     */\n    p.match = function(str, regexp) {\n      return str.match(regexp);\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Other java specific functions\n    ////////////////////////////////////////////////////////////////////////////\n\n\n    var logBuffer = [];\n\n    /**\n     * The println() function writes to the console area of the Processing environment.\n     * Each call to this function creates a new line of output. Individual elements can be separated with quotes (\"\") and joined with the string concatenation operator (+).\n     *\n     * @param {String} message the string to write to the console\n     *\n     * @see #join\n     * @see #print\n     */\n    p.println = function() {\n      Processing.logger.println.apply(Processing.logger, arguments);\n    };\n    /**\n     * The print() function writes to the console area of the Processing environment.\n     *\n     * @param {String} message the string to write to the console\n     *\n     * @see #join\n     */\n    p.print = function() {\n      Processing.logger.print.apply(Processing.logger, arguments);\n    };\n\n    // Alphanumeric chars arguments automatically converted to numbers when\n    // passed in, and will come out as numbers.\n    p.str = function(val) {\n      if (val instanceof Array) {\n        var arr = [];\n        for (var i = 0; i < val.length; i++) {\n          arr.push(val[i].toString() + \"\");\n        }\n        return arr;\n      }\n      return (val.toString() + \"\");\n    };\n\n\n    // Conversion\n    function booleanScalar(val) {\n      if (typeof val === 'number') {\n        return val !== 0;\n      }\n      if (typeof val === 'boolean') {\n        return val;\n      }\n      if (typeof val === 'string') {\n        return val.toLowerCase() === 'true';\n      }\n      if (val instanceof Char) {\n        // 1, T or t\n        return val.code === 49 || val.code === 84 || val.code === 116;\n      }\n    }\n\n    /**\n     * Converts the passed parameter to the function to its boolean value.\n     * It will return an array of booleans if an array is passed in.\n     *\n     * @param {int, byte, string} val          the parameter to be converted to boolean\n     * @param {int[], byte[], string[]} val    the array to be converted to boolean[]\n     *\n     * @return {boolean|boolean[]} returns a boolean or an array of booleans\n     */\n    p.parseBoolean = function (val) {\n      if (val instanceof Array) {\n        var ret = [];\n        for (var i = 0; i < val.length; i++) {\n          ret.push(booleanScalar(val[i]));\n        }\n        return ret;\n      }\n      return booleanScalar(val);\n    };\n\n    /**\n     * Converts the passed parameter to the function to its byte value.\n     * A byte is a number between -128 and 127.\n     * It will return an array of bytes if an array is passed in.\n     *\n     * @param {int, char} what        the parameter to be conveted to byte\n     * @param {int[], char[]} what    the array to be converted to byte[]\n     *\n     * @return {byte|byte[]} returns a byte or an array of bytes\n     */\n    p.parseByte = function(what) {\n      if (what instanceof Array) {\n        var bytes = [];\n        for (var i = 0; i < what.length; i++) {\n          bytes.push((0 - (what[i] & 0x80)) | (what[i] & 0x7F));\n        }\n        return bytes;\n      }\n      return (0 - (what & 0x80)) | (what & 0x7F);\n    };\n\n    /**\n     * Converts the passed parameter to the function to its char value.\n     * It will return an array of chars if an array is passed in.\n     *\n     * @param {int, byte} key        the parameter to be conveted to char\n     * @param {int[], byte[]} key    the array to be converted to char[]\n     *\n     * @return {char|char[]} returns a char or an array of chars\n     */\n    p.parseChar = function(key) {\n      if (typeof key === \"number\") {\n        return new Char(String.fromCharCode(key & 0xFFFF));\n      }\n      if (key instanceof Array) {\n        var ret = [];\n        for (var i = 0; i < key.length; i++) {\n          ret.push(new Char(String.fromCharCode(key[i] & 0xFFFF)));\n        }\n        return ret;\n      }\n      throw \"char() may receive only one argument of type int, byte, int[], or byte[].\";\n    };\n\n    // Processing doc claims good argument types are: int, char, byte, boolean,\n    // String, int[], char[], byte[], boolean[], String[].\n    // floats should not work. However, floats with only zeroes right of the\n    // decimal will work because JS converts those to int.\n    function floatScalar(val) {\n      if (typeof val === 'number') {\n        return val;\n      }\n      if (typeof val === 'boolean') {\n        return val ? 1 : 0;\n      }\n      if (typeof val === 'string') {\n        return parseFloat(val);\n      }\n      if (val instanceof Char) {\n        return val.code;\n      }\n    }\n\n    /**\n     * Converts the passed parameter to the function to its float value.\n     * It will return an array of floats if an array is passed in.\n     *\n     * @param {int, char, boolean, string} val            the parameter to be conveted to float\n     * @param {int[], char[], boolean[], string[]} val    the array to be converted to float[]\n     *\n     * @return {float|float[]} returns a float or an array of floats\n     */\n    p.parseFloat = function(val) {\n      if (val instanceof Array) {\n        var ret = [];\n        for (var i = 0; i < val.length; i++) {\n          ret.push(floatScalar(val[i]));\n        }\n        return ret;\n      }\n      return floatScalar(val);\n    };\n\n    function intScalar(val, radix) {\n      if (typeof val === 'number') {\n        return val & 0xFFFFFFFF;\n      }\n      if (typeof val === 'boolean') {\n        return val ? 1 : 0;\n      }\n      if (typeof val === 'string') {\n        var number = parseInt(val, radix || 10); // Default to decimal radix.\n        return number & 0xFFFFFFFF;\n      }\n      if (val instanceof Char) {\n        return val.code;\n      }\n    }\n\n    /**\n     * Converts the passed parameter to the function to its int value.\n     * It will return an array of ints if an array is passed in.\n     *\n     * @param {string, char, boolean, float} val            the parameter to be conveted to int\n     * @param {string[], char[], boolean[], float[]} val    the array to be converted to int[]\n     * @param {int} radix                                   optional the radix of the number (for js compatibility)\n     *\n     * @return {int|int[]} returns a int or an array of ints\n     */\n    p.parseInt = function(val, radix) {\n      if (val instanceof Array) {\n        var ret = [];\n        for (var i = 0; i < val.length; i++) {\n          if (typeof val[i] === 'string' && !/^\\s*[+\\-]?\\d+\\s*$/.test(val[i])) {\n            ret.push(0);\n          } else {\n            ret.push(intScalar(val[i], radix));\n          }\n        }\n        return ret;\n      }\n      return intScalar(val, radix);\n    };\n\n    p.__int_cast = function(val) {\n      return 0|val;\n    };\n\n    p.__instanceof = function(obj, type) {\n      if (typeof type !== \"function\") {\n        throw \"Function is expected as type argument for instanceof operator\";\n      }\n\n      if (typeof obj === \"string\") {\n        // special case for strings\n        return type === Object || type === String;\n      }\n\n      if (obj instanceof type) {\n        // fast check if obj is already of type instance\n        return true;\n      }\n\n      if (typeof obj !== \"object\" || obj === null) {\n        return false; // not an object or null\n      }\n\n      var objType = obj.constructor;\n      if (type.$isInterface) {\n        // expecting the interface\n        // queueing interfaces from type and its base classes\n        var interfaces = [];\n        while (objType) {\n          if (objType.$interfaces) {\n            interfaces = interfaces.concat(objType.$interfaces);\n          }\n          objType = objType.$base;\n        }\n        while (interfaces.length > 0) {\n          var i = interfaces.shift();\n          if (i === type) {\n            return true;\n          }\n          // wide search in base interfaces\n          if (i.$interfaces) {\n            interfaces = interfaces.concat(i.$interfaces);\n          }\n        }\n        return false;\n      }\n\n      while (objType.hasOwnProperty(\"$base\")) {\n        objType = objType.$base;\n        if (objType === type) {\n          return true; // object was found\n        }\n      }\n\n      return false;\n    };\n\n    /**\n    * Defines the dimension of the display window in units of pixels. The size() function must\n    * be the first line in setup(). If size() is not called, the default size of the window is\n    * 100x100 pixels. The system variables width and height are set by the parameters passed to\n    * the size() function.\n    *\n    * @param {int} aWidth     width of the display window in units of pixels\n    * @param {int} aHeight    height of the display window in units of pixels\n    * @param {MODE} aMode     Either P2D, P3D, JAVA2D, or OPENGL\n    *\n    * @see createGraphics\n    * @see screen\n    */\n    DrawingShared.prototype.size = function(aWidth, aHeight, aMode) {\n      if (doStroke) {\n        p.stroke(0);\n      }\n\n      if (doFill) {\n        p.fill(255);\n      }\n\n      // The default 2d context has already been created in the p.init() stage if\n      // a 3d context was not specified. This is so that a 2d context will be\n      // available if size() was not called.\n      var savedProperties = {\n        fillStyle: curContext.fillStyle,\n        strokeStyle: curContext.strokeStyle,\n        lineCap: curContext.lineCap,\n        lineJoin: curContext.lineJoin\n      };\n      // remove the style width and height properties to ensure that the canvas gets set to\n      // aWidth and aHeight coming in\n      if (curElement.style.length > 0 ) {\n        curElement.style.removeProperty(\"width\");\n        curElement.style.removeProperty(\"height\");\n      }\n\n      curElement.width = p.width = aWidth || 100;\n      curElement.height = p.height = aHeight || 100;\n\n      for (var prop in savedProperties) {\n        if (savedProperties.hasOwnProperty(prop)) {\n          curContext[prop] = savedProperties[prop];\n        }\n      }\n\n      // make sure to set the default font the first time round.\n      p.textFont(curTextFont);\n\n      // Set the background to whatever it was called last as if background() was called before size()\n      // If background() hasn't been called before, set background() to a light gray\n      p.background();\n\n      // set 5% for pixels to cache (or 1000)\n      maxPixelsCached = Math.max(1000, aWidth * aHeight * 0.05);\n\n      // Externalize the context\n      p.externals.context = curContext;\n\n      for (var i = 0; i < PConstants.SINCOS_LENGTH; i++) {\n        sinLUT[i] = p.sin(i * (PConstants.PI / 180) * 0.5);\n        cosLUT[i] = p.cos(i * (PConstants.PI / 180) * 0.5);\n      }\n    };\n\n    Drawing2D.prototype.size = function(aWidth, aHeight, aMode) {\n      if (curContext === undef) {\n        // size() was called without p.init() default context, i.e. p.createGraphics()\n        curContext = curElement.getContext(\"2d\");\n        userMatrixStack = new PMatrixStack();\n        userReverseMatrixStack = new PMatrixStack();\n        modelView = new PMatrix2D();\n        modelViewInv = new PMatrix2D();\n      }\n\n      DrawingShared.prototype.size.apply(this, arguments);\n    };\n\n    Drawing3D.prototype.size = (function() {\n      var size3DCalled = false;\n\n      return function size(aWidth, aHeight, aMode) {\n        if (size3DCalled) {\n          throw \"Multiple calls to size() for 3D renders are not allowed.\";\n        }\n        size3DCalled = true;\n\n        function getGLContext(canvas) {\n          var ctxNames = ['experimental-webgl', 'webgl', 'webkit-3d'],\n              gl;\n\n          for (var i=0, l=ctxNames.length; i<l; i++) {\n            gl = canvas.getContext(ctxNames[i], {antialias: false, preserveDrawingBuffer: true});\n            if (gl) {\n              break;\n            }\n          }\n\n          return gl;\n        }\n\n        // Get the 3D rendering context.\n        try {\n          // If the HTML <canvas> dimensions differ from the\n          // dimensions specified in the size() call in the sketch, for\n          // 3D sketches, browsers will either not render or render the\n          // scene incorrectly. To fix this, we need to adjust the\n          // width and height attributes of the canvas.\n          curElement.width = p.width = aWidth || 100;\n          curElement.height = p.height = aHeight || 100;\n          curContext = getGLContext(curElement);\n          canTex = curContext.createTexture();\n          textTex = curContext.createTexture();\n        } catch(e_size) {\n          Processing.debug(e_size);\n        }\n\n        if (!curContext) {\n          throw \"WebGL context is not supported on this browser.\";\n        }\n\n        // Set defaults\n        curContext.viewport(0, 0, curElement.width, curElement.height);\n        curContext.enable(curContext.DEPTH_TEST);\n        curContext.enable(curContext.BLEND);\n        curContext.blendFunc(curContext.SRC_ALPHA, curContext.ONE_MINUS_SRC_ALPHA);\n\n        // Create the program objects to render 2D (points, lines) and\n        // 3D (spheres, boxes) shapes. Because 2D shapes are not lit,\n        // lighting calculations are ommitted from this program object.\n        programObject2D = createProgramObject(curContext, vertexShaderSrc2D, fragmentShaderSrc2D);\n\n        programObjectUnlitShape = createProgramObject(curContext, vertexShaderSrcUnlitShape, fragmentShaderSrcUnlitShape);\n\n        // Set the default point and line width for the 2D and unlit shapes.\n        p.strokeWeight(1);\n\n        // Now that the programs have been compiled, we can set the default\n        // states for the lights.\n        programObject3D = createProgramObject(curContext, vertexShaderSrc3D, fragmentShaderSrc3D);\n        curContext.useProgram(programObject3D);\n\n        // Assume we aren't using textures by default.\n        uniformi(\"usingTexture3d\", programObject3D, \"usingTexture\", usingTexture);\n\n        // Set some defaults.\n        p.lightFalloff(1, 0, 0);\n        p.shininess(1);\n        p.ambient(255, 255, 255);\n        p.specular(0, 0, 0);\n        p.emissive(0, 0, 0);\n\n        // Create buffers for 3D primitives\n        boxBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, boxBuffer);\n        curContext.bufferData(curContext.ARRAY_BUFFER, boxVerts, curContext.STATIC_DRAW);\n\n        boxNormBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, boxNormBuffer);\n        curContext.bufferData(curContext.ARRAY_BUFFER, boxNorms, curContext.STATIC_DRAW);\n\n        boxOutlineBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, boxOutlineBuffer);\n        curContext.bufferData(curContext.ARRAY_BUFFER, boxOutlineVerts, curContext.STATIC_DRAW);\n\n        // used to draw the rectangle and the outline\n        rectBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, rectBuffer);\n        curContext.bufferData(curContext.ARRAY_BUFFER, rectVerts, curContext.STATIC_DRAW);\n\n        rectNormBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, rectNormBuffer);\n        curContext.bufferData(curContext.ARRAY_BUFFER, rectNorms, curContext.STATIC_DRAW);\n\n        // The sphere vertices are specified dynamically since the user\n        // can change the level of detail. Everytime the user does that\n        // using sphereDetail(), the new vertices are calculated.\n        sphereBuffer = curContext.createBuffer();\n\n        lineBuffer = curContext.createBuffer();\n\n        // Shape buffers\n        fillBuffer = curContext.createBuffer();\n        fillColorBuffer = curContext.createBuffer();\n        strokeColorBuffer = curContext.createBuffer();\n        shapeTexVBO = curContext.createBuffer();\n\n        pointBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, pointBuffer);\n        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array([0, 0, 0]), curContext.STATIC_DRAW);\n\n        textBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, textBuffer );\n        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array([1,1,0,-1,1,0,-1,-1,0,1,-1,0]), curContext.STATIC_DRAW);\n\n        textureBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, textureBuffer);\n        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array([0,0,1,0,1,1,0,1]), curContext.STATIC_DRAW);\n\n        indexBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ELEMENT_ARRAY_BUFFER, indexBuffer);\n        curContext.bufferData(curContext.ELEMENT_ARRAY_BUFFER, new Uint16Array([0,1,2,2,3,0]), curContext.STATIC_DRAW);\n\n        cam = new PMatrix3D();\n        cameraInv = new PMatrix3D();\n        modelView = new PMatrix3D();\n        modelViewInv = new PMatrix3D();\n        projection = new PMatrix3D();\n        p.camera();\n        p.perspective();\n\n        userMatrixStack = new PMatrixStack();\n        userReverseMatrixStack = new PMatrixStack();\n        // used by both curve and bezier, so just init here\n        curveBasisMatrix = new PMatrix3D();\n        curveToBezierMatrix = new PMatrix3D();\n        curveDrawMatrix = new PMatrix3D();\n        bezierDrawMatrix = new PMatrix3D();\n        bezierBasisInverse = new PMatrix3D();\n        bezierBasisMatrix = new PMatrix3D();\n        bezierBasisMatrix.set(-1, 3, -3, 1, 3, -6, 3, 0, -3, 3, 0, 0, 1, 0, 0, 0);\n\n        DrawingShared.prototype.size.apply(this, arguments);\n      };\n    }());\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Lights\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Adds an ambient light. Ambient light doesn't come from a specific direction,\n     * the rays have light have bounced around so much that objects are evenly lit\n     * from all sides. Ambient lights are almost always used in combination with\n     * other types of lights. Lights need to be included in the <b>draw()</b> to\n     * remain persistent in a looping program. Placing them in the <b>setup()</b>\n     * of a looping program will cause them to only have an effect the first time\n     * through the loop. The effect of the parameters is determined by the current\n     * color mode.\n     *\n     * @param {int | float} r red or hue value\n     * @param {int | float} g green or hue value\n     * @param {int | float} b blue or hue value\n     *\n     * @param {int | float} x x position of light (used for falloff)\n     * @param {int | float} y y position of light (used for falloff)\n     * @param {int | float} z z position of light (used for falloff)\n     *\n     * @returns none\n     *\n     * @see lights\n     * @see directionalLight\n     * @see pointLight\n     * @see spotLight\n    */\n    Drawing2D.prototype.ambientLight = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.ambientLight = function(r, g, b, x, y, z) {\n      if (lightCount === PConstants.MAX_LIGHTS) {\n        throw \"can only create \" + PConstants.MAX_LIGHTS + \" lights\";\n      }\n\n      var pos = new PVector(x, y, z);\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.mult(pos, pos);\n\n      // Instead of calling p.color, we do the calculations ourselves to\n      // reduce property lookups.\n      var col = color$4(r, g, b, 0);\n      var normalizedCol = [ ((col & PConstants.RED_MASK) >>> 16) / 255,\n                            ((col & PConstants.GREEN_MASK) >>> 8) / 255,\n                             (col & PConstants.BLUE_MASK) / 255 ];\n\n      curContext.useProgram(programObject3D);\n      uniformf(\"uLights.color.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".color\", normalizedCol);\n      uniformf(\"uLights.position.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".position\", pos.array());\n      uniformi(\"uLights.type.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".type\", 0);\n      uniformi(\"uLightCount3d\", programObject3D, \"uLightCount\", ++lightCount);\n    };\n\n    /**\n     * Adds a directional light. Directional light comes from one direction and\n     * is stronger when hitting a surface squarely and weaker if it hits at a\n     * gentle angle. After hitting a surface, a directional lights scatters in\n     * all directions. Lights need to be included in the <b>draw()</b> to remain\n     * persistent in a looping program. Placing them in the <b>setup()</b> of a\n     * looping program will cause them to only have an effect the first time\n     * through the loop. The affect of the <br>r</b>, <br>g</b>, and <br>b</b>\n     * parameters is determined by the current color mode. The <b>nx</b>,\n     * <b>ny</b>, and <b>nz</b> parameters specify the direction the light is\n     * facing. For example, setting <b>ny</b> to -1 will cause the geometry to be\n     * lit from below (the light is facing directly upward).\n     *\n     * @param {int | float} r red or hue value\n     * @param {int | float} g green or hue value\n     * @param {int | float} b blue or hue value\n     *\n     * @param {int | float} nx direction along the x axis\n     * @param {int | float} ny direction along the y axis\n     * @param {int | float} nz direction along the z axis\n     *\n     * @returns none\n     *\n     * @see lights\n     * @see ambientLight\n     * @see pointLight\n     * @see spotLight\n    */\n    Drawing2D.prototype.directionalLight = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.directionalLight = function(r, g, b, nx, ny, nz) {\n      if (lightCount === PConstants.MAX_LIGHTS) {\n        throw \"can only create \" + PConstants.MAX_LIGHTS + \" lights\";\n      }\n\n      curContext.useProgram(programObject3D);\n\n      var mvm = new PMatrix3D();\n      mvm.scale(1, -1, 1);\n      mvm.apply(modelView.array());\n      mvm = mvm.array();\n\n      // We need to multiply the direction by the model view matrix, but\n      // the mult function checks the w component of the vector, if it isn't\n      // present, it uses 1, so we manually multiply.\n      var dir = [\n        mvm[0] * nx + mvm[4] * ny + mvm[8] * nz,\n        mvm[1] * nx + mvm[5] * ny + mvm[9] * nz,\n        mvm[2] * nx + mvm[6] * ny + mvm[10] * nz\n      ];\n\n      // Instead of calling p.color, we do the calculations ourselves to\n      // reduce property lookups.\n      var col = color$4(r, g, b, 0);\n      var normalizedCol = [ ((col & PConstants.RED_MASK) >>> 16) / 255,\n                            ((col & PConstants.GREEN_MASK) >>> 8) / 255,\n                             (col & PConstants.BLUE_MASK) / 255 ];\n\n      uniformf(\"uLights.color.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".color\", normalizedCol);\n      uniformf(\"uLights.position.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".position\", dir);\n      uniformi(\"uLights.type.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".type\", 1);\n      uniformi(\"uLightCount3d\", programObject3D, \"uLightCount\", ++lightCount);\n    };\n\n    /**\n     * Sets the falloff rates for point lights, spot lights, and ambient lights.\n     * The parameters are used to determine the falloff with the following equation:\n     *\n     * d = distance from light position to vertex position\n     * falloff = 1 / (CONSTANT + d * LINEAR + (d*d) * QUADRATIC)\n     *\n     * Like <b>fill()</b>, it affects only the elements which are created after it in the\n     * code. The default value if <b>LightFalloff(1.0, 0.0, 0.0)</b>. Thinking about an\n     * ambient light with a falloff can be tricky. It is used, for example, if you\n     * wanted a region of your scene to be lit ambiently one color and another region\n     * to be lit ambiently by another color, you would use an ambient light with location\n     * and falloff. You can think of it as a point light that doesn't care which direction\n     * a surface is facing.\n     *\n     * @param {int | float} constant constant value for determining falloff\n     * @param {int | float} linear linear value for determining falloff\n     * @param {int | float} quadratic quadratic value for determining falloff\n     *\n     * @returns none\n     *\n     * @see lights\n     * @see ambientLight\n     * @see pointLight\n     * @see spotLight\n     * @see lightSpecular\n    */\n    Drawing2D.prototype.lightFalloff = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.lightFalloff = function(constant, linear, quadratic) {\n      curContext.useProgram(programObject3D);\n      uniformf(\"uFalloff3d\", programObject3D, \"uFalloff\", [constant, linear, quadratic]);\n    };\n\n    /**\n     * Sets the specular color for lights. Like <b>fill()</b>, it affects only the\n     * elements which are created after it in the code. Specular refers to light\n     * which bounces off a surface in a perferred direction (rather than bouncing\n     * in all directions like a diffuse light) and is used for creating highlights.\n     * The specular quality of a light interacts with the specular material qualities\n     * set through the <b>specular()</b> and <b>shininess()</b> functions.\n     *\n     * @param {int | float} r red or hue value\n     * @param {int | float} g green or hue value\n     * @param {int | float} b blue or hue value\n     *\n     * @returns none\n     *\n     * @see lights\n     * @see ambientLight\n     * @see pointLight\n     * @see spotLight\n    */\n    Drawing2D.prototype.lightSpecular = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.lightSpecular = function(r, g, b) {\n\n      // Instead of calling p.color, we do the calculations ourselves to\n      // reduce property lookups.\n      var col = color$4(r, g, b, 0);\n      var normalizedCol = [ ((col & PConstants.RED_MASK) >>> 16) / 255,\n                            ((col & PConstants.GREEN_MASK) >>> 8) / 255,\n                             (col & PConstants.BLUE_MASK) / 255 ];\n\n      curContext.useProgram(programObject3D);\n      uniformf(\"uSpecular3d\", programObject3D, \"uSpecular\", normalizedCol);\n    };\n\n    /**\n     * Sets the default ambient light, directional light, falloff, and specular\n     * values. The defaults are ambientLight(128, 128, 128) and\n     * directionalLight(128, 128, 128, 0, 0, -1), lightFalloff(1, 0, 0), and\n     * lightSpecular(0, 0, 0). Lights need to be included in the draw() to remain\n     * persistent in a looping program. Placing them in the setup() of a looping\n     * program will cause them to only have an effect the first time through the\n     * loop.\n     *\n     * @returns none\n     *\n     * @see ambientLight\n     * @see directionalLight\n     * @see pointLight\n     * @see spotLight\n     * @see noLights\n     *\n    */\n    p.lights = function() {\n      p.ambientLight(128, 128, 128);\n      p.directionalLight(128, 128, 128, 0, 0, -1);\n      p.lightFalloff(1, 0, 0);\n      p.lightSpecular(0, 0, 0);\n    };\n\n    /**\n     * Adds a point light. Lights need to be included in the <b>draw()</b> to remain\n     * persistent in a looping program. Placing them in the <b>setup()</b> of a\n     * looping program will cause them to only have an effect the first time through\n     * the loop. The affect of the <b>r</b>, <b>g</b>, and <b>b</b> parameters\n     * is determined by the current color mode. The <b>x</b>, <b>y</b>, and <b>z</b>\n     * parameters set the position of the light.\n     *\n     * @param {int | float} r red or hue value\n     * @param {int | float} g green or hue value\n     * @param {int | float} b blue or hue value\n     * @param {int | float} x x coordinate of the light\n     * @param {int | float} y y coordinate of the light\n     * @param {int | float} z z coordinate of the light\n     *\n     * @returns none\n     *\n     * @see lights\n     * @see directionalLight\n     * @see ambientLight\n     * @see spotLight\n    */\n    Drawing2D.prototype.pointLight = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.pointLight = function(r, g, b, x, y, z) {\n      if (lightCount === PConstants.MAX_LIGHTS) {\n        throw \"can only create \" + PConstants.MAX_LIGHTS + \" lights\";\n      }\n\n      // Place the point in view space once instead of once per vertex\n      // in the shader.\n      var pos = new PVector(x, y, z);\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.mult(pos, pos);\n\n      // Instead of calling p.color, we do the calculations ourselves to\n      // reduce property lookups.\n      var col = color$4(r, g, b, 0);\n      var normalizedCol = [ ((col & PConstants.RED_MASK) >>> 16) / 255,\n                            ((col & PConstants.GREEN_MASK) >>> 8) / 255,\n                             (col & PConstants.BLUE_MASK) / 255 ];\n\n      curContext.useProgram(programObject3D);\n      uniformf(\"uLights.color.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".color\", normalizedCol);\n      uniformf(\"uLights.position.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".position\", pos.array());\n      uniformi(\"uLights.type.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".type\", 2);\n      uniformi(\"uLightCount3d\", programObject3D, \"uLightCount\", ++lightCount);\n    };\n\n    /**\n     * Disable all lighting. Lighting is turned off by default and enabled with\n     * the lights() method. This function can be used to disable lighting so\n     * that 2D geometry (which does not require lighting) can be drawn after a\n     * set of lighted 3D geometry.\n     *\n     * @returns none\n     *\n     * @see lights\n    */\n    Drawing2D.prototype.noLights = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.noLights = function() {\n      lightCount = 0;\n      curContext.useProgram(programObject3D);\n      uniformi(\"uLightCount3d\", programObject3D, \"uLightCount\", lightCount);\n    };\n\n    /**\n     * Adds a spot light. Lights need to be included in the <b>draw()</b> to\n     * remain persistent in a looping program. Placing them in the <b>setup()</b>\n     * of a looping program will cause them to only have an effect the first time\n     * through the loop. The affect of the <b>r</b>, <b>g</b>, and <b>b</b> parameters\n     * is determined by the current color mode. The <b>x</b>, <b>y</b>, and <b>z</b>\n     * parameters specify the position of the light and <b>nx</b>, <b>ny</b>, <b>nz</b>\n     * specify the direction or light. The angle parameter affects <b>angle</b> of the\n     * spotlight cone.\n     *\n     * @param {int | float} r red or hue value\n     * @param {int | float} g green or hue value\n     * @param {int | float} b blue or hue value\n     * @param {int | float} x coordinate of the light\n     * @param {int | float} y coordinate of the light\n     * @param {int | float} z coordinate of the light\n     * @param {int | float} nx direction along the x axis\n     * @param {int | float} ny direction along the y axis\n     * @param {int | float} nz direction along the z axis\n     * @param {float} angle angle of the spotlight cone\n     * @param {float} concentration exponent determining the center bias of the cone\n     *\n     * @returns none\n     *\n     * @see lights\n     * @see directionalLight\n     * @see ambientLight\n     * @see pointLight\n    */\n    Drawing2D.prototype.spotLight = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.spotLight = function(r, g, b, x, y, z, nx, ny, nz, angle, concentration) {\n      if (lightCount === PConstants.MAX_LIGHTS) {\n        throw \"can only create \" + PConstants.MAX_LIGHTS + \" lights\";\n      }\n\n      curContext.useProgram(programObject3D);\n\n      // multiply the position and direction by the model view matrix\n      // once per object rather than once per vertex.\n      var pos = new PVector(x, y, z);\n      var mvm = new PMatrix3D();\n      mvm.scale(1, -1, 1);\n      mvm.apply(modelView.array());\n      mvm.mult(pos, pos);\n\n      // Convert to array since we need to directly access the elements.\n      mvm = mvm.array();\n\n      // We need to multiply the direction by the model view matrix, but\n      // the mult function checks the w component of the vector, if it isn't\n      // present, it uses 1, so we use a very small value as a work around.\n      var dir = [\n          mvm[0] * nx + mvm[4] * ny + mvm[8] * nz,\n          mvm[1] * nx + mvm[5] * ny + mvm[9] * nz,\n          mvm[2] * nx + mvm[6] * ny + mvm[10] * nz\n      ];\n\n      // Instead of calling p.color, we do the calculations ourselves to\n      // reduce property lookups.\n      var col = color$4(r, g, b, 0);\n      var normalizedCol = [ ((col & PConstants.RED_MASK) >>> 16) / 255,\n                            ((col & PConstants.GREEN_MASK) >>> 8) / 255,\n                             (col & PConstants.BLUE_MASK) / 255 ];\n\n      uniformf(\"uLights.color.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".color\", normalizedCol);\n      uniformf(\"uLights.position.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".position\", pos.array());\n      uniformf(\"uLights.direction.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".direction\", dir);\n      uniformf(\"uLights.concentration.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".concentration\", concentration);\n      uniformf(\"uLights.angle.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".angle\", angle);\n      uniformi(\"uLights.type.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".type\", 3);\n      uniformi(\"uLightCount3d\", programObject3D, \"uLightCount\", ++lightCount);\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Camera functions\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * The <b>beginCamera()</b> and <b>endCamera()</b> functions enable advanced customization of the camera space.\n     * The functions are useful if you want to more control over camera movement, however for most users, the <b>camera()</b>\n     * function will be sufficient.<br /><br />The camera functions will replace any transformations (such as <b>rotate()</b>\n     * or <b>translate()</b>) that occur before them in <b>draw()</b>, but they will not automatically replace the camera\n     * transform itself. For this reason, camera functions should be placed at the beginning of <b>draw()</b> (so that\n     * transformations happen afterwards), and the <b>camera()</b> function can be used after <b>beginCamera()</b> if\n     * you want to reset the camera before applying transformations.<br /><br />This function sets the matrix mode to the\n     * camera matrix so calls such as <b>translate()</b>, <b>rotate()</b>, applyMatrix() and resetMatrix() affect the camera.\n     * <b>beginCamera()</b> should always be used with a following <b>endCamera()</b> and pairs of <b>beginCamera()</b> and\n     * <b>endCamera()</b> cannot be nested.\n     *\n     * @see camera\n     * @see endCamera\n     * @see applyMatrix\n     * @see resetMatrix\n     * @see translate\n     * @see rotate\n     * @see scale\n     */\n    Drawing2D.prototype.beginCamera = function() {\n      throw (\"beginCamera() is not available in 2D mode\");\n    };\n\n    Drawing3D.prototype.beginCamera = function() {\n      if (manipulatingCamera) {\n        throw (\"You cannot call beginCamera() again before calling endCamera()\");\n      }\n      manipulatingCamera = true;\n      modelView = cameraInv;\n      modelViewInv = cam;\n    };\n\n    /**\n     * The <b>beginCamera()</b> and <b>endCamera()</b> functions enable advanced customization of the camera space.\n     * Please see the reference for <b>beginCamera()</b> for a description of how the functions are used.\n     *\n     * @see beginCamera\n     */\n    Drawing2D.prototype.endCamera = function() {\n      throw (\"endCamera() is not available in 2D mode\");\n    };\n\n    Drawing3D.prototype.endCamera = function() {\n      if (!manipulatingCamera) {\n        throw (\"You cannot call endCamera() before calling beginCamera()\");\n      }\n      modelView.set(cam);\n      modelViewInv.set(cameraInv);\n      manipulatingCamera = false;\n    };\n\n    /**\n     * Sets the position of the camera through setting the eye position, the center of the scene, and which axis is facing\n     * upward. Moving the eye position and the direction it is pointing (the center of the scene) allows the images to be\n     * seen from different angles. The version without any parameters sets the camera to the default position, pointing to\n     * the center of the display window with the Y axis as up. The default values are camera(width/2.0, height/2.0,\n     * (height/2.0) / tan(PI*60.0 / 360.0), width/2.0, height/2.0, 0, 0, 1, 0). This function is similar to gluLookAt()\n     * in OpenGL, but it first clears the current camera settings.\n     *\n     * @param {float} eyeX    x-coordinate for the eye\n     * @param {float} eyeY    y-coordinate for the eye\n     * @param {float} eyeZ    z-coordinate for the eye\n     * @param {float} centerX x-coordinate for the center of the scene\n     * @param {float} centerY y-coordinate for the center of the scene\n     * @param {float} centerZ z-coordinate for the center of the scene\n     * @param {float} upX     usually 0.0, 1.0, -1.0\n     * @param {float} upY     usually 0.0, 1.0, -1.0\n     * @param {float} upZ     usually 0.0, 1.0, -1.0\n     *\n     * @see beginCamera\n     * @see endCamera\n     * @see frustum\n     */\n    p.camera = function(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {\n      if (eyeX === undef) {\n        // Workaround if createGraphics is used.\n        cameraX = p.width / 2;\n        cameraY = p.height / 2;\n        cameraZ = cameraY / Math.tan(cameraFOV / 2);\n        eyeX = cameraX;\n        eyeY = cameraY;\n        eyeZ = cameraZ;\n        centerX = cameraX;\n        centerY = cameraY;\n        centerZ = 0;\n        upX = 0;\n        upY = 1;\n        upZ = 0;\n      }\n\n      var z = new PVector(eyeX - centerX, eyeY - centerY, eyeZ - centerZ);\n      var y = new PVector(upX, upY, upZ);\n      z.normalize();\n      var x = PVector.cross(y, z);\n      y = PVector.cross(z, x);\n      x.normalize();\n      y.normalize();\n\n      var xX = x.x,\n          xY = x.y,\n          xZ = x.z;\n\n      var yX = y.x,\n          yY = y.y,\n          yZ = y.z;\n\n      var zX = z.x,\n          zY = z.y,\n          zZ = z.z;\n\n      cam.set(xX, xY, xZ, 0, yX, yY, yZ, 0, zX, zY, zZ, 0, 0, 0, 0, 1);\n\n      cam.translate(-eyeX, -eyeY, -eyeZ);\n\n      cameraInv.reset();\n      cameraInv.invApply(xX, xY, xZ, 0, yX, yY, yZ, 0, zX, zY, zZ, 0, 0, 0, 0, 1);\n\n      cameraInv.translate(eyeX, eyeY, eyeZ);\n\n      modelView.set(cam);\n      modelViewInv.set(cameraInv);\n    };\n\n    /**\n     * Sets a perspective projection applying foreshortening, making distant objects appear smaller than closer ones. The\n     * parameters define a viewing volume with the shape of truncated pyramid. Objects near to the front of the volume appear\n     * their actual size, while farther objects appear smaller. This projection simulates the perspective of the world more\n     * accurately than orthographic projection. The version of perspective without parameters sets the default perspective and\n     * the version with four parameters allows the programmer to set the area precisely. The default values are:\n     * perspective(PI/3.0, width/height, cameraZ/10.0, cameraZ*10.0) where cameraZ is ((height/2.0) / tan(PI*60.0/360.0));\n     *\n     * @param {float} fov     field-of-view angle (in radians) for vertical direction\n     * @param {float} aspect  ratio of width to height\n     * @param {float} zNear   z-position of nearest clipping plane\n     * @param {float} zFar    z-positions of farthest clipping plane\n     */\n    p.perspective = function(fov, aspect, near, far) {\n      if (arguments.length === 0) {\n        //in case canvas is resized\n        cameraY = curElement.height / 2;\n        cameraZ = cameraY / Math.tan(cameraFOV / 2);\n        cameraNear = cameraZ / 10;\n        cameraFar = cameraZ * 10;\n        cameraAspect = p.width / p.height;\n        fov = cameraFOV;\n        aspect = cameraAspect;\n        near = cameraNear;\n        far = cameraFar;\n      }\n\n      var yMax, yMin, xMax, xMin;\n      yMax = near * Math.tan(fov / 2);\n      yMin = -yMax;\n      xMax = yMax * aspect;\n      xMin = yMin * aspect;\n      p.frustum(xMin, xMax, yMin, yMax, near, far);\n    };\n\n    /**\n     * Sets a perspective matrix defined through the parameters. Works like glFrustum, except it wipes out the current\n     * perspective matrix rather than muliplying itself with it.\n     *\n     * @param {float} left   left coordinate of the clipping plane\n     * @param {float} right  right coordinate of the clipping plane\n     * @param {float} bottom bottom coordinate of the clipping plane\n     * @param {float} top    top coordinate of the clipping plane\n     * @param {float} near   near coordinate of the clipping plane\n     * @param {float} far    far coordinate of the clipping plane\n     *\n     * @see beginCamera\n     * @see camera\n     * @see endCamera\n     * @see perspective\n     */\n    Drawing2D.prototype.frustum = function() {\n      throw(\"Processing.js: frustum() is not supported in 2D mode\");\n    };\n\n    Drawing3D.prototype.frustum = function(left, right, bottom, top, near, far) {\n      frustumMode = true;\n      projection = new PMatrix3D();\n      projection.set((2 * near) / (right - left), 0, (right + left) / (right - left),\n                     0, 0, (2 * near) / (top - bottom), (top + bottom) / (top - bottom),\n                     0, 0, 0, -(far + near) / (far - near), -(2 * far * near) / (far - near),\n                     0, 0, -1, 0);\n      var proj = new PMatrix3D();\n      proj.set(projection);\n      proj.transpose();\n      curContext.useProgram(programObject2D);\n      uniformMatrix(\"projection2d\", programObject2D, \"uProjection\", false, proj.array());\n      curContext.useProgram(programObject3D);\n      uniformMatrix(\"projection3d\", programObject3D, \"uProjection\", false, proj.array());\n      curContext.useProgram(programObjectUnlitShape);\n      uniformMatrix(\"uProjectionUS\", programObjectUnlitShape, \"uProjection\", false, proj.array());\n    };\n\n    /**\n     * Sets an orthographic projection and defines a parallel clipping volume. All objects with the same dimension appear\n     * the same size, regardless of whether they are near or far from the camera. The parameters to this function specify\n     * the clipping volume where left and right are the minimum and maximum x values, top and bottom are the minimum and\n     * maximum y values, and near and far are the minimum and maximum z values. If no parameters are given, the default\n     * is used: ortho(0, width, 0, height, -10, 10).\n     *\n     * @param {float} left   left plane of the clipping volume\n     * @param {float} right  right plane of the clipping volume\n     * @param {float} bottom bottom plane of the clipping volume\n     * @param {float} top    top plane of the clipping volume\n     * @param {float} near   maximum distance from the origin to the viewer\n     * @param {float} far    maximum distance from the origin away from the viewer\n     */\n    p.ortho = function(left, right, bottom, top, near, far) {\n      if (arguments.length === 0) {\n        left = 0;\n        right = p.width;\n        bottom = 0;\n        top = p.height;\n        near = -10;\n        far = 10;\n      }\n\n      var x = 2 / (right - left);\n      var y = 2 / (top - bottom);\n      var z = -2 / (far - near);\n\n      var tx = -(right + left) / (right - left);\n      var ty = -(top + bottom) / (top - bottom);\n      var tz = -(far + near) / (far - near);\n\n      projection = new PMatrix3D();\n      projection.set(x, 0, 0, tx, 0, y, 0, ty, 0, 0, z, tz, 0, 0, 0, 1);\n\n      var proj = new PMatrix3D();\n      proj.set(projection);\n      proj.transpose();\n      curContext.useProgram(programObject2D);\n      uniformMatrix(\"projection2d\", programObject2D, \"uProjection\", false, proj.array());\n      curContext.useProgram(programObject3D);\n      uniformMatrix(\"projection3d\", programObject3D, \"uProjection\", false, proj.array());\n      curContext.useProgram(programObjectUnlitShape);\n      uniformMatrix(\"uProjectionUS\", programObjectUnlitShape, \"uProjection\", false, proj.array());\n      frustumMode = false;\n    };\n    /**\n     * The printProjection() prints the current projection matrix to the text window.\n     */\n    p.printProjection = function() {\n      projection.print();\n    };\n    /**\n     * The printCamera() function prints the current camera matrix.\n     */\n    p.printCamera = function() {\n      cam.print();\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Shapes\n    ////////////////////////////////////////////////////////////////////////////\n    /**\n     * The box() function renders a box. A box is an extruded rectangle. A box with equal dimension on all sides is a cube.\n     * Calling this function with only one parameter will create a cube.\n     *\n     * @param {int|float} w  dimension of the box in the x-dimension\n     * @param {int|float} h  dimension of the box in the y-dimension\n     * @param {int|float} d  dimension of the box in the z-dimension\n     */\n    Drawing2D.prototype.box = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.box = function(w, h, d) {\n      // user can uniformly scale the box by\n      // passing in only one argument.\n      if (!h || !d) {\n        h = d = w;\n      }\n\n      // Modeling transformation\n      var model = new PMatrix3D();\n      model.scale(w, h, d);\n\n      // Viewing transformation needs to have Y flipped\n      // becuase that's what Processing does.\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.transpose();\n\n      if (doFill) {\n        curContext.useProgram(programObject3D);\n        uniformMatrix(\"model3d\", programObject3D, \"uModel\", false, model.array());\n        uniformMatrix(\"view3d\", programObject3D, \"uView\", false, view.array());\n        // Fix stitching problems. (lines get occluded by triangles\n        // since they share the same depth values). This is not entirely\n        // working, but it's a start for drawing the outline. So\n        // developers can start playing around with styles.\n        curContext.enable(curContext.POLYGON_OFFSET_FILL);\n        curContext.polygonOffset(1, 1);\n        uniformf(\"color3d\", programObject3D, \"uColor\", fillStyle);\n\n        // Calculating the normal matrix can be expensive, so only\n        // do it if it's necessary.\n        if(lightCount > 0){\n          // Create the normal transformation matrix.\n          var v = new PMatrix3D();\n          v.set(view);\n\n          var m = new PMatrix3D();\n          m.set(model);\n\n          v.mult(m);\n\n          var normalMatrix = new PMatrix3D();\n          normalMatrix.set(v);\n          normalMatrix.invert();\n          normalMatrix.transpose();\n\n          uniformMatrix(\"uNormalTransform3d\", programObject3D, \"uNormalTransform\", false, normalMatrix.array());\n          vertexAttribPointer(\"aNormal3d\", programObject3D, \"aNormal\", 3, boxNormBuffer);\n        }\n        else{\n          disableVertexAttribPointer(\"aNormal3d\", programObject3D, \"aNormal\");\n        }\n\n        vertexAttribPointer(\"aVertex3d\", programObject3D, \"aVertex\", 3, boxBuffer);\n\n        // Turn off per vertex colors.\n        disableVertexAttribPointer(\"aColor3d\", programObject3D, \"aColor\");\n        disableVertexAttribPointer(\"aTexture3d\", programObject3D, \"aTexture\");\n\n        curContext.drawArrays(curContext.TRIANGLES, 0, boxVerts.length / 3);\n        curContext.disable(curContext.POLYGON_OFFSET_FILL);\n      }\n\n      // Draw the box outline.\n      if (lineWidth > 0 && doStroke) {\n        curContext.useProgram(programObject2D);\n        uniformMatrix(\"uModel2d\", programObject2D, \"uModel\", false, model.array());\n        uniformMatrix(\"uView2d\", programObject2D, \"uView\", false, view.array());\n        uniformf(\"uColor2d\", programObject2D, \"uColor\", strokeStyle);\n        uniformi(\"uIsDrawingText2d\", programObject2D, \"uIsDrawingText\", false);\n        vertexAttribPointer(\"vertex2d\", programObject2D, \"aVertex\", 3, boxOutlineBuffer);\n        disableVertexAttribPointer(\"aTextureCoord2d\", programObject2D, \"aTextureCoord\");\n        curContext.drawArrays(curContext.LINES, 0, boxOutlineVerts.length / 3);\n      }\n    };\n\n    /**\n     * The initSphere() function is a helper function used by <b>sphereDetail()</b>\n     * This function creates and stores sphere vertices every time the user changes sphere detail.\n     *\n     * @see #sphereDetail\n     */\n    var initSphere = function() {\n      var i;\n      sphereVerts = [];\n\n      for (i = 0; i < sphereDetailU; i++) {\n        sphereVerts.push(0);\n        sphereVerts.push(-1);\n        sphereVerts.push(0);\n        sphereVerts.push(sphereX[i]);\n        sphereVerts.push(sphereY[i]);\n        sphereVerts.push(sphereZ[i]);\n      }\n      sphereVerts.push(0);\n      sphereVerts.push(-1);\n      sphereVerts.push(0);\n      sphereVerts.push(sphereX[0]);\n      sphereVerts.push(sphereY[0]);\n      sphereVerts.push(sphereZ[0]);\n\n      var v1, v11, v2;\n\n      // middle rings\n      var voff = 0;\n      for (i = 2; i < sphereDetailV; i++) {\n        v1 = v11 = voff;\n        voff += sphereDetailU;\n        v2 = voff;\n        for (var j = 0; j < sphereDetailU; j++) {\n          sphereVerts.push(sphereX[v1]);\n          sphereVerts.push(sphereY[v1]);\n          sphereVerts.push(sphereZ[v1++]);\n          sphereVerts.push(sphereX[v2]);\n          sphereVerts.push(sphereY[v2]);\n          sphereVerts.push(sphereZ[v2++]);\n        }\n\n        // close each ring\n        v1 = v11;\n        v2 = voff;\n\n        sphereVerts.push(sphereX[v1]);\n        sphereVerts.push(sphereY[v1]);\n        sphereVerts.push(sphereZ[v1]);\n        sphereVerts.push(sphereX[v2]);\n        sphereVerts.push(sphereY[v2]);\n        sphereVerts.push(sphereZ[v2]);\n      }\n\n      // add the northern cap\n      for (i = 0; i < sphereDetailU; i++) {\n        v2 = voff + i;\n\n        sphereVerts.push(sphereX[v2]);\n        sphereVerts.push(sphereY[v2]);\n        sphereVerts.push(sphereZ[v2]);\n        sphereVerts.push(0);\n        sphereVerts.push(1);\n        sphereVerts.push(0);\n      }\n\n      sphereVerts.push(sphereX[voff]);\n      sphereVerts.push(sphereY[voff]);\n      sphereVerts.push(sphereZ[voff]);\n      sphereVerts.push(0);\n      sphereVerts.push(1);\n      sphereVerts.push(0);\n\n      //set the buffer data\n      curContext.bindBuffer(curContext.ARRAY_BUFFER, sphereBuffer);\n      curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(sphereVerts), curContext.STATIC_DRAW);\n    };\n\n    /**\n     * The sphereDetail() function controls the detail used to render a sphere by adjusting the number of\n     * vertices of the sphere mesh. The default resolution is 30, which creates\n     * a fairly detailed sphere definition with vertices every 360/30 = 12\n     * degrees. If you're going to render a great number of spheres per frame,\n     * it is advised to reduce the level of detail using this function.\n     * The setting stays active until <b>sphereDetail()</b> is called again with\n     * a new parameter and so should <i>not</i> be called prior to every\n     * <b>sphere()</b> statement, unless you wish to render spheres with\n     * different settings, e.g. using less detail for smaller spheres or ones\n     * further away from the camera. To control the detail of the horizontal\n     * and vertical resolution independently, use the version of the functions\n     * with two parameters. Calling this function with one parameter sets the number of segments\n     *(minimum of 3) used per full circle revolution. This is equivalent to calling the function with\n     * two identical values.\n     *\n     * @param {int} ures    number of segments used horizontally (longitudinally) per full circle revolution\n     * @param {int} vres    number of segments used vertically (latitudinally) from top to bottom\n     *\n     * @see #sphere()\n     */\n    p.sphereDetail = function(ures, vres) {\n      var i;\n\n      if (arguments.length === 1) {\n        ures = vres = arguments[0];\n      }\n\n      if (ures < 3) {\n        ures = 3;\n      } // force a minimum res\n      if (vres < 2) {\n        vres = 2;\n      } // force a minimum res\n      // if it hasn't changed do nothing\n      if ((ures === sphereDetailU) && (vres === sphereDetailV)) {\n        return;\n      }\n\n      var delta = PConstants.SINCOS_LENGTH / ures;\n      var cx = new Float32Array(ures);\n      var cz = new Float32Array(ures);\n      // calc unit circle in XZ plane\n      for (i = 0; i < ures; i++) {\n        cx[i] = cosLUT[((i * delta) % PConstants.SINCOS_LENGTH) | 0];\n        cz[i] = sinLUT[((i * delta) % PConstants.SINCOS_LENGTH) | 0];\n      }\n\n      // computing vertexlist\n      // vertexlist starts at south pole\n      var vertCount = ures * (vres - 1) + 2;\n      var currVert = 0;\n\n      // re-init arrays to store vertices\n      sphereX = new Float32Array(vertCount);\n      sphereY = new Float32Array(vertCount);\n      sphereZ = new Float32Array(vertCount);\n\n      var angle_step = (PConstants.SINCOS_LENGTH * 0.5) / vres;\n      var angle = angle_step;\n\n      // step along Y axis\n      for (i = 1; i < vres; i++) {\n        var curradius = sinLUT[(angle % PConstants.SINCOS_LENGTH) | 0];\n        var currY = -cosLUT[(angle % PConstants.SINCOS_LENGTH) | 0];\n        for (var j = 0; j < ures; j++) {\n          sphereX[currVert] = cx[j] * curradius;\n          sphereY[currVert] = currY;\n          sphereZ[currVert++] = cz[j] * curradius;\n        }\n        angle += angle_step;\n      }\n      sphereDetailU = ures;\n      sphereDetailV = vres;\n\n      // make the sphere verts and norms\n      initSphere();\n    };\n\n    /**\n     * The sphere() function draws a sphere with radius r centered at coordinate 0, 0, 0.\n     * A sphere is a hollow ball made from tessellated triangles.\n     *\n     * @param {int|float} r the radius of the sphere\n     */\n    Drawing2D.prototype.sphere = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.sphere = function() {\n      var sRad = arguments[0];\n\n      if ((sphereDetailU < 3) || (sphereDetailV < 2)) {\n        p.sphereDetail(30);\n      }\n\n      // Modeling transformation.\n      var model = new PMatrix3D();\n      model.scale(sRad, sRad, sRad);\n\n      // viewing transformation needs to have Y flipped\n      // becuase that's what Processing does.\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.transpose();\n\n      if (doFill) {\n        // Calculating the normal matrix can be expensive, so only\n        // do it if it's necessary.\n        if(lightCount > 0){\n          // Create a normal transformation matrix.\n          var v = new PMatrix3D();\n          v.set(view);\n\n          var m = new PMatrix3D();\n          m.set(model);\n\n          v.mult(m);\n\n          var normalMatrix = new PMatrix3D();\n          normalMatrix.set(v);\n          normalMatrix.invert();\n          normalMatrix.transpose();\n\n          uniformMatrix(\"uNormalTransform3d\", programObject3D, \"uNormalTransform\", false, normalMatrix.array());\n          vertexAttribPointer(\"aNormal3d\", programObject3D, \"aNormal\", 3, sphereBuffer);\n        }\n        else{\n          disableVertexAttribPointer(\"aNormal3d\", programObject3D, \"aNormal\");\n        }\n\n        curContext.useProgram(programObject3D);\n        disableVertexAttribPointer(\"aTexture3d\", programObject3D, \"aTexture\");\n\n        uniformMatrix(\"uModel3d\", programObject3D, \"uModel\", false, model.array());\n        uniformMatrix(\"uView3d\", programObject3D, \"uView\", false, view.array());\n        vertexAttribPointer(\"aVertex3d\", programObject3D, \"aVertex\", 3, sphereBuffer);\n\n        // Turn off per vertex colors.\n        disableVertexAttribPointer(\"aColor3d\", programObject3D, \"aColor\");\n\n        // fix stitching problems. (lines get occluded by triangles\n        // since they share the same depth values). This is not entirely\n        // working, but it's a start for drawing the outline. So\n        // developers can start playing around with styles.\n        curContext.enable(curContext.POLYGON_OFFSET_FILL);\n        curContext.polygonOffset(1, 1);\n        uniformf(\"uColor3d\", programObject3D, \"uColor\", fillStyle);\n        curContext.drawArrays(curContext.TRIANGLE_STRIP, 0, sphereVerts.length / 3);\n        curContext.disable(curContext.POLYGON_OFFSET_FILL);\n      }\n\n      // Draw the sphere outline.\n      if (lineWidth > 0 && doStroke) {\n        curContext.useProgram(programObject2D);\n        uniformMatrix(\"uModel2d\", programObject2D, \"uModel\", false, model.array());\n        uniformMatrix(\"uView2d\", programObject2D, \"uView\", false, view.array());\n        vertexAttribPointer(\"aVertex2d\", programObject2D, \"aVertex\", 3, sphereBuffer);\n        disableVertexAttribPointer(\"aTextureCoord2d\", programObject2D, \"aTextureCoord\");\n        uniformf(\"uColor2d\", programObject2D, \"uColor\", strokeStyle);\n        uniformi(\"uIsDrawingText\", programObject2D, \"uIsDrawingText\", false);\n        curContext.drawArrays(curContext.LINE_STRIP, 0, sphereVerts.length / 3);\n      }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Coordinates\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Returns the three-dimensional X, Y, Z position in model space. This returns\n     * the X value for a given coordinate based on the current set of transformations\n     * (scale, rotate, translate, etc.) The X value can be used to place an object\n     * in space relative to the location of the original point once the transformations\n     * are no longer in use.<br />\n     * <br />\n     *\n     * @param {int | float} x 3D x coordinate to be mapped\n     * @param {int | float} y 3D y coordinate to be mapped\n     * @param {int | float} z 3D z coordinate to be mapped\n     *\n     * @returns {float}\n     *\n     * @see modelY\n     * @see modelZ\n    */\n    p.modelX = function(x, y, z) {\n      var mv = modelView.array();\n      var ci = cameraInv.array();\n\n      var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];\n      var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];\n      var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];\n      var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];\n\n      var ox = ci[0] * ax + ci[1] * ay + ci[2] * az + ci[3] * aw;\n      var ow = ci[12] * ax + ci[13] * ay + ci[14] * az + ci[15] * aw;\n\n      return (ow !== 0) ? ox / ow : ox;\n    };\n\n    /**\n     * Returns the three-dimensional X, Y, Z position in model space. This returns\n     * the Y value for a given coordinate based on the current set of transformations\n     * (scale, rotate, translate, etc.) The Y value can be used to place an object in\n     * space relative to the location of the original point once the transformations\n     * are no longer in use.<br />\n     * <br />\n     *\n     * @param {int | float} x 3D x coordinate to be mapped\n     * @param {int | float} y 3D y coordinate to be mapped\n     * @param {int | float} z 3D z coordinate to be mapped\n     *\n     * @returns {float}\n     *\n     * @see modelX\n     * @see modelZ\n    */\n    p.modelY = function(x, y, z) {\n      var mv = modelView.array();\n      var ci = cameraInv.array();\n\n      var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];\n      var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];\n      var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];\n      var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];\n\n      var oy = ci[4] * ax + ci[5] * ay + ci[6] * az + ci[7] * aw;\n      var ow = ci[12] * ax + ci[13] * ay + ci[14] * az + ci[15] * aw;\n\n      return (ow !== 0) ? oy / ow : oy;\n    };\n\n    /**\n     * Returns the three-dimensional X, Y, Z position in model space. This returns\n     * the Z value for a given coordinate based on the current set of transformations\n     * (scale, rotate, translate, etc.) The Z value can be used to place an object in\n     * space relative to the location of the original point once the transformations\n     * are no longer in use.\n     *\n     * @param {int | float} x 3D x coordinate to be mapped\n     * @param {int | float} y 3D y coordinate to be mapped\n     * @param {int | float} z 3D z coordinate to be mapped\n     *\n     * @returns {float}\n     *\n     * @see modelX\n     * @see modelY\n    */\n    p.modelZ = function(x, y, z) {\n      var mv = modelView.array();\n      var ci = cameraInv.array();\n\n      var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];\n      var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];\n      var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];\n      var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];\n\n      var oz = ci[8] * ax + ci[9] * ay + ci[10] * az + ci[11] * aw;\n      var ow = ci[12] * ax + ci[13] * ay + ci[14] * az + ci[15] * aw;\n\n      return (ow !== 0) ? oz / ow : oz;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Material Properties\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Sets the ambient reflectance for shapes drawn to the screen. This is\n     * combined with the ambient light component of environment. The color\n     * components set through the parameters define the reflectance. For example in\n     * the default color mode, setting v1=255, v2=126, v3=0, would cause all the\n     * red light to reflect and half of the green light to reflect. Used in combination\n     * with <b>emissive()</b>, <b>specular()</b>, and <b>shininess()</b> in setting\n     * the materal properties of shapes.\n     *\n     * @param {int | float} gray\n     *\n     * @returns none\n     *\n     * @see emissive\n     * @see specular\n     * @see shininess\n    */\n    Drawing2D.prototype.ambient = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.ambient = function(v1, v2, v3) {\n      curContext.useProgram(programObject3D);\n      uniformi(\"uUsingMat3d\", programObject3D, \"uUsingMat\", true);\n      var col = p.color(v1, v2, v3);\n      uniformf(\"uMaterialAmbient3d\", programObject3D, \"uMaterialAmbient\", p.color.toGLArray(col).slice(0, 3));\n    };\n\n    /**\n     * Sets the emissive color of the material used for drawing shapes\n     * drawn to the screen. Used in combination with ambient(), specular(),\n     * and shininess() in setting the material properties of shapes.\n     *\n     * Can be called in the following ways:\n     *\n     * emissive(gray)\n     * @param {int | float} gray number specifying value between white and black\n     *\n     * emissive(color)\n     * @param {color} color any value of the color datatype\n     *\n     * emissive(v1, v2, v3)\n     * @param {int | float} v1 red or hue value\n     * @param {int | float} v2 green or saturation value\n     * @param {int | float} v3 blue or brightness value\n     *\n     * @returns none\n     *\n     * @see ambient\n     * @see specular\n     * @see shininess\n    */\n    Drawing2D.prototype.emissive = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.emissive = function(v1, v2, v3) {\n      curContext.useProgram(programObject3D);\n      uniformi(\"uUsingMat3d\", programObject3D, \"uUsingMat\", true);\n      var col = p.color(v1, v2, v3);\n      uniformf(\"uMaterialEmissive3d\", programObject3D, \"uMaterialEmissive\", p.color.toGLArray(col).slice(0, 3));\n    };\n\n    /**\n     * Sets the amount of gloss in the surface of shapes. Used in combination with\n     * <b>ambient()</b>, <b>specular()</b>, and <b>emissive()</b> in setting the\n     * material properties of shapes.\n     *\n     * @param {float} shine degree of shininess\n     *\n     * @returns none\n    */\n    Drawing2D.prototype.shininess = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.shininess = function(shine) {\n      curContext.useProgram(programObject3D);\n      uniformi(\"uUsingMat3d\", programObject3D, \"uUsingMat\", true);\n      uniformf(\"uShininess3d\", programObject3D, \"uShininess\", shine);\n    };\n\n    /**\n     * Sets the specular color of the materials used for shapes drawn to the screen,\n     * which sets the color of hightlights. Specular refers to light which bounces\n     * off a surface in a perferred direction (rather than bouncing in all directions\n     * like a diffuse light). Used in combination with emissive(), ambient(), and\n     * shininess() in setting the material properties of shapes.\n     *\n     * Can be called in the following ways:\n     *\n     * specular(gray)\n     * @param {int | float} gray number specifying value between white and black\n     *\n     * specular(gray, alpha)\n     * @param {int | float} gray number specifying value between white and black\n     * @param {int | float} alpha opacity\n     *\n     * specular(color)\n     * @param {color} color any value of the color datatype\n     *\n     * specular(v1, v2, v3)\n     * @param {int | float} v1 red or hue value\n     * @param {int | float} v2 green or saturation value\n     * @param {int | float} v3 blue or brightness value\n     *\n     * specular(v1, v2, v3, alpha)\n     * @param {int | float} v1 red or hue value\n     * @param {int | float} v2 green or saturation value\n     * @param {int | float} v3 blue or brightness value\n     * @param {int | float} alpha opacity\n     *\n     * @returns none\n     *\n     * @see ambient\n     * @see emissive\n     * @see shininess\n    */\n    Drawing2D.prototype.specular = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.specular = function(v1, v2, v3) {\n      curContext.useProgram(programObject3D);\n      uniformi(\"uUsingMat3d\", programObject3D, \"uUsingMat\", true);\n      var col = p.color(v1, v2, v3);\n      uniformf(\"uMaterialSpecular3d\", programObject3D, \"uMaterialSpecular\", p.color.toGLArray(col).slice(0, 3));\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Coordinates\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Takes a three-dimensional X, Y, Z position and returns the X value for\n     * where it will appear on a (two-dimensional) screen.\n     *\n     * @param {int | float} x 3D x coordinate to be mapped\n     * @param {int | float} y 3D y coordinate to be mapped\n     * @param {int | float} z 3D z optional coordinate to be mapped\n     *\n     * @returns {float}\n     *\n     * @see screenY\n     * @see screenZ\n    */\n    p.screenX = function( x, y, z ) {\n      var mv = modelView.array();\n      if( mv.length === 16 )\n      {\n        var ax = mv[ 0]*x + mv[ 1]*y + mv[ 2]*z + mv[ 3];\n        var ay = mv[ 4]*x + mv[ 5]*y + mv[ 6]*z + mv[ 7];\n        var az = mv[ 8]*x + mv[ 9]*y + mv[10]*z + mv[11];\n        var aw = mv[12]*x + mv[13]*y + mv[14]*z + mv[15];\n\n        var pj = projection.array();\n\n        var ox = pj[ 0]*ax + pj[ 1]*ay + pj[ 2]*az + pj[ 3]*aw;\n        var ow = pj[12]*ax + pj[13]*ay + pj[14]*az + pj[15]*aw;\n\n        if ( ow !== 0 ){\n          ox /= ow;\n        }\n        return p.width * ( 1 + ox ) / 2.0;\n      }\n      // We assume that we're in 2D\n      return modelView.multX(x, y);\n    };\n\n    /**\n     * Takes a three-dimensional X, Y, Z position and returns the Y value for\n     * where it will appear on a (two-dimensional) screen.\n     *\n     * @param {int | float} x 3D x coordinate to be mapped\n     * @param {int | float} y 3D y coordinate to be mapped\n     * @param {int | float} z 3D z optional coordinate to be mapped\n     *\n     * @returns {float}\n     *\n     * @see screenX\n     * @see screenZ\n    */\n    p.screenY = function screenY( x, y, z ) {\n      var mv = modelView.array();\n      if( mv.length === 16 ) {\n        var ax = mv[ 0]*x + mv[ 1]*y + mv[ 2]*z + mv[ 3];\n        var ay = mv[ 4]*x + mv[ 5]*y + mv[ 6]*z + mv[ 7];\n        var az = mv[ 8]*x + mv[ 9]*y + mv[10]*z + mv[11];\n        var aw = mv[12]*x + mv[13]*y + mv[14]*z + mv[15];\n\n        var pj = projection.array();\n\n        var oy = pj[ 4]*ax + pj[ 5]*ay + pj[ 6]*az + pj[ 7]*aw;\n        var ow = pj[12]*ax + pj[13]*ay + pj[14]*az + pj[15]*aw;\n\n        if ( ow !== 0 ){\n          oy /= ow;\n        }\n        return p.height * ( 1 + oy ) / 2.0;\n      }\n      // We assume that we're in 2D\n      return modelView.multY(x, y);\n    };\n\n    /**\n     * Takes a three-dimensional X, Y, Z position and returns the Z value for\n     * where it will appear on a (two-dimensional) screen.\n     *\n     * @param {int | float} x 3D x coordinate to be mapped\n     * @param {int | float} y 3D y coordinate to be mapped\n     * @param {int | float} z 3D z coordinate to be mapped\n     *\n     * @returns {float}\n     *\n     * @see screenX\n     * @see screenY\n    */\n    p.screenZ = function screenZ( x, y, z ) {\n      var mv = modelView.array();\n      if( mv.length !== 16 ) {\n        return 0;\n      }\n\n      var pj = projection.array();\n\n      var ax = mv[ 0]*x + mv[ 1]*y + mv[ 2]*z + mv[ 3];\n      var ay = mv[ 4]*x + mv[ 5]*y + mv[ 6]*z + mv[ 7];\n      var az = mv[ 8]*x + mv[ 9]*y + mv[10]*z + mv[11];\n      var aw = mv[12]*x + mv[13]*y + mv[14]*z + mv[15];\n\n      var oz = pj[ 8]*ax + pj[ 9]*ay + pj[10]*az + pj[11]*aw;\n      var ow = pj[12]*ax + pj[13]*ay + pj[14]*az + pj[15]*aw;\n\n      if ( ow !== 0 ) {\n        oz /= ow;\n      }\n      return ( oz + 1 ) / 2.0;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Style functions\n    ////////////////////////////////////////////////////////////////////////////\n    /**\n     * The fill() function sets the color used to fill shapes. For example, if you run <b>fill(204, 102, 0)</b>, all subsequent shapes will be filled with orange.\n     * This color is either specified in terms of the RGB or HSB color depending on the current <b>colorMode()</b>\n     *(the default color space is RGB, with each value in the range from 0 to 255).\n     * <br><br>When using hexadecimal notation to specify a color, use \"#\" or \"0x\" before the values (e.g. #CCFFAA, 0xFFCCFFAA).\n     * The # syntax uses six digits to specify a color (the way colors are specified in HTML and CSS). When using the hexadecimal notation starting with \"0x\",\n     * the hexadecimal value must be specified with eight characters; the first two characters define the alpha component and the remainder the red, green, and blue components.\n     * <br><br>The value for the parameter \"gray\" must be less than or equal to the current maximum value as specified by <b>colorMode()</b>. The default maximum value is 255.\n     * <br><br>To change the color of an image (or a texture), use tint().\n     *\n     * @param {int|float} gray    number specifying value between white and black\n     * @param {int|float} value1  red or hue value\n     * @param {int|float} value2  green or saturation value\n     * @param {int|float} value3  blue or brightness value\n     * @param {int|float} alpha   opacity of the fill\n     * @param {Color} color       any value of the color datatype\n     * @param {int} hex           color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)\n     *\n     * @see #noFill()\n     * @see #stroke()\n     * @see #tint()\n     * @see #background()\n     * @see #colorMode()\n     */\n    DrawingShared.prototype.fill = function() {\n      var color = p.color.apply(this, arguments);\n      if(color === currentFillColor && doFill) {\n        return;\n      }\n      doFill = true;\n      currentFillColor = color;\n    };\n\n    Drawing2D.prototype.fill = function() {\n      DrawingShared.prototype.fill.apply(this, arguments);\n      isFillDirty = true;\n    };\n\n    Drawing3D.prototype.fill = function() {\n      DrawingShared.prototype.fill.apply(this, arguments);\n      fillStyle = p.color.toGLArray(currentFillColor);\n    };\n\n    function executeContextFill() {\n      if(doFill) {\n        if(isFillDirty) {\n          curContext.fillStyle = p.color.toString(currentFillColor);\n          isFillDirty = false;\n        }\n        curContext.fill();\n      }\n    }\n\n    /**\n     * The noFill() function disables filling geometry. If both <b>noStroke()</b> and <b>noFill()</b>\n     * are called, no shapes will be drawn to the screen.\n     *\n     * @see #fill()\n     *\n     */\n    p.noFill = function() {\n      doFill = false;\n    };\n\n    /**\n     * The stroke() function sets the color used to draw lines and borders around shapes. This color\n     * is either specified in terms of the RGB or HSB color depending on the\n     * current <b>colorMode()</b> (the default color space is RGB, with each\n     * value in the range from 0 to 255).\n     * <br><br>When using hexadecimal notation to specify a color, use \"#\" or\n     * \"0x\" before the values (e.g. #CCFFAA, 0xFFCCFFAA). The # syntax uses six\n     * digits to specify a color (the way colors are specified in HTML and CSS).\n     * When using the hexadecimal notation starting with \"0x\", the hexadecimal\n     * value must be specified with eight characters; the first two characters\n     * define the alpha component and the remainder the red, green, and blue\n     * components.\n     * <br><br>The value for the parameter \"gray\" must be less than or equal\n     * to the current maximum value as specified by <b>colorMode()</b>.\n     * The default maximum value is 255.\n     *\n     * @param {int|float} gray    number specifying value between white and black\n     * @param {int|float} value1  red or hue value\n     * @param {int|float} value2  green or saturation value\n     * @param {int|float} value3  blue or brightness value\n     * @param {int|float} alpha   opacity of the stroke\n     * @param {Color} color       any value of the color datatype\n     * @param {int} hex           color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)\n     *\n     * @see #fill()\n     * @see #noStroke()\n     * @see #tint()\n     * @see #background()\n     * @see #colorMode()\n     */\n    DrawingShared.prototype.stroke = function() {\n      var color = p.color.apply(this, arguments);\n      if(color === currentStrokeColor && doStroke) {\n        return;\n      }\n      doStroke = true;\n      currentStrokeColor = color;\n    };\n\n    Drawing2D.prototype.stroke = function() {\n      DrawingShared.prototype.stroke.apply(this, arguments);\n      isStrokeDirty = true;\n    };\n\n    Drawing3D.prototype.stroke = function() {\n      DrawingShared.prototype.stroke.apply(this, arguments);\n      strokeStyle = p.color.toGLArray(currentStrokeColor);\n    };\n\n    function executeContextStroke() {\n      if(doStroke) {\n        if(isStrokeDirty) {\n          curContext.strokeStyle = p.color.toString(currentStrokeColor);\n          isStrokeDirty = false;\n        }\n        curContext.stroke();\n      }\n    }\n\n    /**\n     * The noStroke() function disables drawing the stroke (outline). If both <b>noStroke()</b> and\n     * <b>noFill()</b> are called, no shapes will be drawn to the screen.\n     *\n     * @see #stroke()\n     */\n    p.noStroke = function() {\n      doStroke = false;\n    };\n\n    /**\n     * The strokeWeight() function sets the width of the stroke used for lines, points, and the border around shapes.\n     * All widths are set in units of pixels.\n     *\n     * @param {int|float} w the weight (in pixels) of the stroke\n     */\n    DrawingShared.prototype.strokeWeight = function(w) {\n      lineWidth = w;\n    };\n\n    Drawing2D.prototype.strokeWeight = function(w) {\n      DrawingShared.prototype.strokeWeight.apply(this, arguments);\n      curContext.lineWidth = w;\n    };\n\n    Drawing3D.prototype.strokeWeight = function(w) {\n      DrawingShared.prototype.strokeWeight.apply(this, arguments);\n\n      // Processing groups the weight of points and lines under this one function,\n      // but for WebGL, we need to set a uniform for points and call a function for line.\n\n      curContext.useProgram(programObject2D);\n      uniformf(\"pointSize2d\", programObject2D, \"uPointSize\", w);\n\n      curContext.useProgram(programObjectUnlitShape);\n      uniformf(\"pointSizeUnlitShape\", programObjectUnlitShape, \"uPointSize\", w);\n\n      curContext.lineWidth(w);\n    };\n\n    /**\n     * The strokeCap() function sets the style for rendering line endings. These ends are either squared, extended, or rounded and\n     * specified with the corresponding parameters SQUARE, PROJECT, and ROUND. The default cap is ROUND.\n     * This function is not available with the P2D, P3D, or OPENGL renderers\n     *\n     * @param {int} value Either SQUARE, PROJECT, or ROUND\n     */\n    p.strokeCap = function(value) {\n      drawing.$ensureContext().lineCap = value;\n    };\n\n    /**\n     * The strokeJoin() function sets the style of the joints which connect line segments.\n     * These joints are either mitered, beveled, or rounded and specified with the corresponding parameters MITER, BEVEL, and ROUND. The default joint is MITER.\n     * This function is not available with the P2D, P3D, or OPENGL renderers\n     *\n     * @param {int} value Either SQUARE, PROJECT, or ROUND\n     */\n    p.strokeJoin = function(value) {\n      drawing.$ensureContext().lineJoin = value;\n    };\n\n    /**\n     * The smooth() function draws all geometry with smooth (anti-aliased) edges. This will slow down the frame rate of the application,\n     * but will enhance the visual refinement. <br/><br/>\n     * Note that smooth() will also improve image quality of resized images, and noSmooth() will disable image (and font) smoothing altogether.\n     * When working with a 3D sketch, smooth will draw points as circles rather than squares.\n     *\n     * @see #noSmooth()\n     * @see #hint()\n     * @see #size()\n     */\n\n    Drawing2D.prototype.smooth = function() {\n      renderSmooth = true;\n      var style = curElement.style;\n      style.setProperty(\"image-rendering\", \"optimizeQuality\", \"important\");\n      style.setProperty(\"-ms-interpolation-mode\", \"bicubic\", \"important\");\n      if (curContext.hasOwnProperty(\"mozImageSmoothingEnabled\")) {\n        curContext.mozImageSmoothingEnabled = true;\n      }\n    };\n\n    Drawing3D.prototype.smooth = function(){\n      renderSmooth = true;\n    };\n\n    /**\n     * The noSmooth() function draws all geometry with jagged (aliased) edges.\n     *\n     * @see #smooth()\n     */\n\n    Drawing2D.prototype.noSmooth = function() {\n      renderSmooth = false;\n      var style = curElement.style;\n      style.setProperty(\"image-rendering\", \"optimizeSpeed\", \"important\");\n      style.setProperty(\"image-rendering\", \"-moz-crisp-edges\", \"important\");\n      style.setProperty(\"image-rendering\", \"-webkit-optimize-contrast\", \"important\");\n      style.setProperty(\"image-rendering\", \"optimize-contrast\", \"important\");\n      style.setProperty(\"-ms-interpolation-mode\", \"nearest-neighbor\", \"important\");\n      if (curContext.hasOwnProperty(\"mozImageSmoothingEnabled\")) {\n        curContext.mozImageSmoothingEnabled = false;\n      }\n    };\n\n    Drawing3D.prototype.noSmooth = function(){\n      renderSmooth = false;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Vector drawing functions\n    ////////////////////////////////////////////////////////////////////////////\n    /**\n     * The point() function draws a point, a coordinate in space at the dimension of one pixel.\n     * The first parameter is the horizontal value for the point, the second\n     * value is the vertical value for the point, and the optional third value\n     * is the depth value. Drawing this shape in 3D using the <b>z</b>\n     * parameter requires the P3D or OPENGL parameter in combination with\n     * size as shown in the above example.\n     *\n     * @param {int|float} x x-coordinate of the point\n     * @param {int|float} y y-coordinate of the point\n     * @param {int|float} z z-coordinate of the point\n     *\n     * @see #beginShape()\n     */\n    Drawing2D.prototype.point = function(x, y) {\n      if (!doStroke) {\n        return;\n      }\n      if (!renderSmooth) {\n        x = Math.round(x);\n        y = Math.round(y);\n      }\n      curContext.fillStyle = p.color.toString(currentStrokeColor);\n      isFillDirty = true;\n      // Draw a circle for any point larger than 1px\n      if (lineWidth > 1) {\n        curContext.beginPath();\n        curContext.arc(x, y, lineWidth / 2, 0, PConstants.TWO_PI, false);\n        curContext.fill();\n      } else {\n        curContext.fillRect(x, y, 1, 1);\n      }\n    };\n\n    Drawing3D.prototype.point = function(x, y, z) {\n      var model = new PMatrix3D();\n\n      // move point to position\n      model.translate(x, y, z || 0);\n      model.transpose();\n\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.transpose();\n\n      curContext.useProgram(programObject2D);\n      uniformMatrix(\"uModel2d\", programObject2D, \"uModel\", false, model.array());\n      uniformMatrix(\"uView2d\", programObject2D, \"uView\", false, view.array());\n\n      if (lineWidth > 0 && doStroke) {\n        // this will be replaced with the new bit shifting color code\n        uniformf(\"uColor2d\", programObject2D, \"uColor\", strokeStyle);\n        uniformi(\"uIsDrawingText2d\", programObject2D, \"uIsDrawingText\", false);\n        uniformi(\"uSmooth2d\", programObject2D, \"uSmooth\", renderSmooth);\n        vertexAttribPointer(\"aVertex2d\", programObject2D, \"aVertex\", 3, pointBuffer);\n        disableVertexAttribPointer(\"aTextureCoord2d\", programObject2D, \"aTextureCoord\");\n        curContext.drawArrays(curContext.POINTS, 0, 1);\n      }\n    };\n\n    /**\n     * Using the <b>beginShape()</b> and <b>endShape()</b> functions allow creating more complex forms.\n     * <b>beginShape()</b> begins recording vertices for a shape and <b>endShape()</b> stops recording.\n     * The value of the <b>MODE</b> parameter tells it which types of shapes to create from the provided vertices.\n     * With no mode specified, the shape can be any irregular polygon. After calling the <b>beginShape()</b> function,\n     * a series of <b>vertex()</b> commands must follow. To stop drawing the shape, call <b>endShape()</b>.\n     * The <b>vertex()</b> function with two parameters specifies a position in 2D and the <b>vertex()</b>\n     * function with three parameters specifies a position in 3D. Each shape will be outlined with the current\n     * stroke color and filled with the fill color.\n     *\n     * @param {int} MODE either POINTS, LINES, TRIANGLES, TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, and QUAD_STRIP.\n     *\n     * @see endShape\n     * @see vertex\n     * @see curveVertex\n     * @see bezierVertex\n     */\n    p.beginShape = function(type) {\n      curShape = type;\n      curvePoints = [];\n      vertArray = [];\n    };\n\n    /**\n     * All shapes are constructed by connecting a series of vertices. <b>vertex()</b> is used to specify the vertex\n     * coordinates for points, lines, triangles, quads, and polygons and is used exclusively within the <b>beginShape()</b>\n     * and <b>endShape()</b> function. <br /><br />Drawing a vertex in 3D using the <b>z</b> parameter requires the P3D or\n     * OPENGL parameter in combination with size as shown in the above example.<br /><br />This function is also used to map a\n     * texture onto the geometry. The <b>texture()</b> function declares the texture to apply to the geometry and the <b>u</b>\n     * and <b>v</b> coordinates set define the mapping of this texture to the form. By default, the coordinates used for\n     * <b>u</b> and <b>v</b> are specified in relation to the image's size in pixels, but this relation can be changed with\n     * <b>textureMode()</b>.\n     *\n     * @param {int | float} x x-coordinate of the vertex\n     * @param {int | float} y y-coordinate of the vertex\n     * @param {boolean} moveto flag to indicate whether this is a new subpath\n     *\n     * @see beginShape\n     * @see endShape\n     * @see bezierVertex\n     * @see curveVertex\n     * @see texture\n     */\n\n    Drawing2D.prototype.vertex = function(x, y, moveTo) {\n      var vert = [];\n\n      if (firstVert) { firstVert = false; }\n      vert.isVert = true;\n\n      vert[0] = x;\n      vert[1] = y;\n      vert[2] = 0;\n      vert[3] = 0;\n      vert[4] = 0;\n\n      // fill and stroke color\n      vert[5] = currentFillColor;\n      vert[6] = currentStrokeColor;\n\n      vertArray.push(vert);\n      if (moveTo) {\n        vertArray[vertArray.length-1].moveTo = moveTo;\n      }\n    };\n\n    Drawing3D.prototype.vertex = function(x, y, z, u, v) {\n      var vert = [];\n\n      if (firstVert) { firstVert = false; }\n      vert.isVert = true;\n\n      if (v === undef && usingTexture) {\n        v = u;\n        u = z;\n        z = 0;\n      }\n\n      // Convert u and v to normalized coordinates\n      if (u !== undef && v !== undef) {\n        if (curTextureMode === PConstants.IMAGE) {\n          u /= curTexture.width;\n          v /= curTexture.height;\n        }\n        u = u > 1 ? 1 : u;\n        u = u < 0 ? 0 : u;\n        v = v > 1 ? 1 : v;\n        v = v < 0 ? 0 : v;\n      }\n\n      vert[0] = x;\n      vert[1] = y;\n      vert[2] = z || 0;\n      vert[3] = u || 0;\n      vert[4] = v || 0;\n\n      // fill rgba\n      vert[5] = fillStyle[0];\n      vert[6] = fillStyle[1];\n      vert[7] = fillStyle[2];\n      vert[8] = fillStyle[3];\n      // stroke rgba\n      vert[9] = strokeStyle[0];\n      vert[10] = strokeStyle[1];\n      vert[11] = strokeStyle[2];\n      vert[12] = strokeStyle[3];\n      //normals\n      vert[13] = normalX;\n      vert[14] = normalY;\n      vert[15] = normalZ;\n\n      vertArray.push(vert);\n    };\n\n    /**\n     * @private\n     * Renders 3D points created from calls to vertex and beginShape/endShape\n     *\n     * @param {Array} vArray an array of vertex coordinate\n     * @param {Array} cArray an array of colours used for the vertices\n     *\n     * @see beginShape\n     * @see endShape\n     * @see vertex\n     */\n    var point3D = function(vArray, cArray){\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.transpose();\n\n      curContext.useProgram(programObjectUnlitShape);\n\n      uniformMatrix(\"uViewUS\", programObjectUnlitShape, \"uView\", false, view.array());\n      uniformi(\"uSmoothUS\", programObjectUnlitShape, \"uSmooth\", renderSmooth);\n\n      vertexAttribPointer(\"aVertexUS\", programObjectUnlitShape, \"aVertex\", 3, pointBuffer);\n      curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(vArray), curContext.STREAM_DRAW);\n\n      vertexAttribPointer(\"aColorUS\", programObjectUnlitShape, \"aColor\", 4, fillColorBuffer);\n      curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(cArray), curContext.STREAM_DRAW);\n\n      curContext.drawArrays(curContext.POINTS, 0, vArray.length/3);\n    };\n\n    /**\n     * @private\n     * Renders 3D lines created from calls to beginShape/vertex/endShape - based on the mode specified LINES, LINE_LOOP, etc.\n     *\n     * @param {Array} vArray an array of vertex coordinate\n     * @param {String} mode  either LINES, LINE_LOOP, or LINE_STRIP\n     * @param {Array} cArray an array of colours used for the vertices\n     *\n     * @see beginShape\n     * @see endShape\n     * @see vertex\n     */\n    var line3D = function(vArray, mode, cArray){\n      var ctxMode;\n      if (mode === \"LINES\"){\n        ctxMode = curContext.LINES;\n      }\n      else if(mode === \"LINE_LOOP\"){\n        ctxMode = curContext.LINE_LOOP;\n      }\n      else{\n        ctxMode = curContext.LINE_STRIP;\n      }\n\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.transpose();\n\n      curContext.useProgram(programObjectUnlitShape);\n      uniformMatrix(\"uViewUS\", programObjectUnlitShape, \"uView\", false, view.array());\n      vertexAttribPointer(\"aVertexUS\", programObjectUnlitShape, \"aVertex\", 3, lineBuffer);\n      curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(vArray), curContext.STREAM_DRAW);\n      vertexAttribPointer(\"aColorUS\", programObjectUnlitShape, \"aColor\", 4, strokeColorBuffer);\n      curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(cArray), curContext.STREAM_DRAW);\n      curContext.drawArrays(ctxMode, 0, vArray.length/3);\n    };\n\n    /**\n     * @private\n     * Render filled shapes created from calls to beginShape/vertex/endShape - based on the mode specified TRIANGLES, etc.\n     *\n     * @param {Array} vArray an array of vertex coordinate\n     * @param {String} mode  either LINES, LINE_LOOP, or LINE_STRIP\n     * @param {Array} cArray an array of colours used for the vertices\n     * @param {Array} tArray an array of u,v coordinates for textures\n     *\n     * @see beginShape\n     * @see endShape\n     * @see vertex\n     */\n    var fill3D = function(vArray, mode, cArray, tArray){\n      var ctxMode;\n      if (mode === \"TRIANGLES\") {\n        ctxMode = curContext.TRIANGLES;\n      } else if(mode === \"TRIANGLE_FAN\") {\n        ctxMode = curContext.TRIANGLE_FAN;\n      } else {\n        ctxMode = curContext.TRIANGLE_STRIP;\n      }\n\n      var view = new PMatrix3D();\n      view.scale( 1, -1, 1 );\n      view.apply( modelView.array() );\n      view.transpose();\n\n      curContext.useProgram( programObject3D );\n      uniformMatrix( \"model3d\", programObject3D, \"uModel\", false,  [1,0,0,0,  0,1,0,0,   0,0,1,0,   0,0,0,1] );\n      uniformMatrix( \"view3d\", programObject3D, \"uView\", false, view.array() );\n      curContext.enable( curContext.POLYGON_OFFSET_FILL );\n      curContext.polygonOffset( 1, 1 );\n      uniformf( \"color3d\", programObject3D, \"uColor\", [-1,0,0,0] );\n      vertexAttribPointer( \"vertex3d\", programObject3D, \"aVertex\", 3, fillBuffer );\n      curContext.bufferData( curContext.ARRAY_BUFFER, new Float32Array(vArray), curContext.STREAM_DRAW );\n\n      // if we are using a texture and a tint, then overwrite the\n      // contents of the color buffer with the current tint\n      if ( usingTexture && curTint !== null ){\n        curTint3d( cArray );\n      }\n\n      vertexAttribPointer( \"aColor3d\", programObject3D, \"aColor\", 4, fillColorBuffer );\n      curContext.bufferData( curContext.ARRAY_BUFFER, new Float32Array(cArray), curContext.STREAM_DRAW );\n\n      // No support for lights....yet\n      disableVertexAttribPointer( \"aNormal3d\", programObject3D, \"aNormal\" );\n\n      if ( usingTexture ) {\n        uniformi( \"uUsingTexture3d\", programObject3D, \"uUsingTexture\", usingTexture );\n        vertexAttribPointer( \"aTexture3d\", programObject3D, \"aTexture\", 2, shapeTexVBO );\n        curContext.bufferData( curContext.ARRAY_BUFFER, new Float32Array(tArray), curContext.STREAM_DRAW );\n      }\n\n      curContext.drawArrays( ctxMode, 0, vArray.length/3 );\n      curContext.disable( curContext.POLYGON_OFFSET_FILL );\n    };\n\n    /**\n     * this series of three operations is used a lot in Drawing2D.prototype.endShape\n     * and has been split off as its own function, to tighten the code and allow for\n     * fewer bugs.\n     */\n    function fillStrokeClose() {\n      executeContextFill();\n      executeContextStroke();\n      curContext.closePath();\n    }\n\n    /**\n     * The endShape() function is the companion to beginShape() and may only be called after beginShape().\n     * When endshape() is called, all of image data defined since the previous call to beginShape() is written\n     * into the image buffer.\n     *\n     * @param {int} MODE Use CLOSE to close the shape\n     *\n     * @see beginShape\n     */\n    Drawing2D.prototype.endShape = function(mode) {\n      // Duplicated in Drawing3D; too many variables used\n      if (vertArray.length === 0) { return; }\n\n      var closeShape = mode === PConstants.CLOSE;\n\n      // if the shape is closed, the first element is also the last element\n      if (closeShape) {\n        vertArray.push(vertArray[0]);\n      }\n\n      var lineVertArray = [];\n      var fillVertArray = [];\n      var colorVertArray = [];\n      var strokeVertArray = [];\n      var texVertArray = [];\n      var cachedVertArray;\n\n      firstVert = true;\n      var i, j, k;\n      var vertArrayLength = vertArray.length;\n\n      for (i = 0; i < vertArrayLength; i++) {\n        cachedVertArray = vertArray[i];\n        for (j = 0; j < 3; j++) {\n          fillVertArray.push(cachedVertArray[j]);\n        }\n      }\n\n      // 5,6,7,8\n      // R,G,B,A - fill colour\n      for (i = 0; i < vertArrayLength; i++) {\n        cachedVertArray = vertArray[i];\n        for (j = 5; j < 9; j++) {\n          colorVertArray.push(cachedVertArray[j]);\n        }\n      }\n\n      // 9,10,11,12\n      // R, G, B, A - stroke colour\n      for (i = 0; i < vertArrayLength; i++) {\n        cachedVertArray = vertArray[i];\n        for (j = 9; j < 13; j++) {\n          strokeVertArray.push(cachedVertArray[j]);\n        }\n      }\n\n      // texture u,v\n      for (i = 0; i < vertArrayLength; i++) {\n        cachedVertArray = vertArray[i];\n        texVertArray.push(cachedVertArray[3]);\n        texVertArray.push(cachedVertArray[4]);\n      }\n\n      // curveVertex\n      if ( isCurve && (curShape === PConstants.POLYGON || curShape === undef) ) {\n        if (vertArrayLength > 3) {\n          var b = [],\n              s = 1 - curTightness;\n          curContext.beginPath();\n          curContext.moveTo(vertArray[1][0], vertArray[1][1]);\n            /*\n            * Matrix to convert from Catmull-Rom to cubic Bezier\n            * where t = curTightness\n            * |0         1          0         0       |\n            * |(t-1)/6   1          (1-t)/6   0       |\n            * |0         (1-t)/6    1         (t-1)/6 |\n            * |0         0          0         0       |\n            */\n          for (i = 1; (i+2) < vertArrayLength; i++) {\n            cachedVertArray = vertArray[i];\n            b[0] = [cachedVertArray[0], cachedVertArray[1]];\n            b[1] = [cachedVertArray[0] + (s * vertArray[i+1][0] - s * vertArray[i-1][0]) / 6,\n                   cachedVertArray[1] + (s * vertArray[i+1][1] - s * vertArray[i-1][1]) / 6];\n            b[2] = [vertArray[i+1][0] + (s * vertArray[i][0] - s * vertArray[i+2][0]) / 6,\n                   vertArray[i+1][1] + (s * vertArray[i][1] - s * vertArray[i+2][1]) / 6];\n            b[3] = [vertArray[i+1][0], vertArray[i+1][1]];\n            curContext.bezierCurveTo(b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]);\n          }\n          fillStrokeClose();\n        }\n      }\n\n      // bezierVertex\n      else if ( isBezier && (curShape === PConstants.POLYGON || curShape === undef) ) {\n        curContext.beginPath();\n        for (i = 0; i < vertArrayLength; i++) {\n          cachedVertArray = vertArray[i];\n          if (vertArray[i].isVert) { //if it is a vertex move to the position\n            if (vertArray[i].moveTo) {\n              curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);\n            } else {\n              curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n            }\n          } else { //otherwise continue drawing bezier\n            curContext.bezierCurveTo(vertArray[i][0], vertArray[i][1], vertArray[i][2], vertArray[i][3], vertArray[i][4], vertArray[i][5]);\n          }\n        }\n        fillStrokeClose();\n      }\n\n      // render the vertices provided\n      else {\n        if (curShape === PConstants.POINTS) {\n          for (i = 0; i < vertArrayLength; i++) {\n            cachedVertArray = vertArray[i];\n            if (doStroke) {\n              p.stroke(cachedVertArray[6]);\n            }\n            p.point(cachedVertArray[0], cachedVertArray[1]);\n          }\n        } else if (curShape === PConstants.LINES) {\n          for (i = 0; (i + 1) < vertArrayLength; i+=2) {\n            cachedVertArray = vertArray[i];\n            if (doStroke) {\n              p.stroke(vertArray[i+1][6]);\n            }\n            p.line(cachedVertArray[0], cachedVertArray[1], vertArray[i+1][0], vertArray[i+1][1]);\n          }\n        } else if (curShape === PConstants.TRIANGLES) {\n          for (i = 0; (i + 2) < vertArrayLength; i+=3) {\n            cachedVertArray = vertArray[i];\n            curContext.beginPath();\n            curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);\n            curContext.lineTo(vertArray[i+1][0], vertArray[i+1][1]);\n            curContext.lineTo(vertArray[i+2][0], vertArray[i+2][1]);\n            curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n\n            if (doFill) {\n              p.fill(vertArray[i+2][5]);\n              executeContextFill();\n            }\n            if (doStroke) {\n              p.stroke(vertArray[i+2][6]);\n              executeContextStroke();\n            }\n\n            curContext.closePath();\n          }\n        } else if (curShape === PConstants.TRIANGLE_STRIP) {\n          for (i = 0; (i+1) < vertArrayLength; i++) {\n            cachedVertArray = vertArray[i];\n            curContext.beginPath();\n            curContext.moveTo(vertArray[i+1][0], vertArray[i+1][1]);\n            curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n\n            if (doStroke) {\n              p.stroke(vertArray[i+1][6]);\n            }\n            if (doFill) {\n              p.fill(vertArray[i+1][5]);\n            }\n\n            if (i + 2 < vertArrayLength) {\n              curContext.lineTo(vertArray[i+2][0], vertArray[i+2][1]);\n              if (doStroke) {\n                p.stroke(vertArray[i+2][6]);\n              }\n              if (doFill) {\n                p.fill(vertArray[i+2][5]);\n              }\n            }\n            fillStrokeClose();\n          }\n        } else if (curShape === PConstants.TRIANGLE_FAN) {\n          if (vertArrayLength > 2) {\n            curContext.beginPath();\n            curContext.moveTo(vertArray[0][0], vertArray[0][1]);\n            curContext.lineTo(vertArray[1][0], vertArray[1][1]);\n            curContext.lineTo(vertArray[2][0], vertArray[2][1]);\n\n            if (doFill) {\n              p.fill(vertArray[2][5]);\n              executeContextFill();\n            }\n            if (doStroke) {\n              p.stroke(vertArray[2][6]);\n              executeContextStroke();\n            }\n\n            curContext.closePath();\n            for (i = 3; i < vertArrayLength; i++) {\n              cachedVertArray = vertArray[i];\n              curContext.beginPath();\n              curContext.moveTo(vertArray[0][0], vertArray[0][1]);\n              curContext.lineTo(vertArray[i-1][0], vertArray[i-1][1]);\n              curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n\n              if (doFill) {\n                p.fill(cachedVertArray[5]);\n                executeContextFill();\n              }\n              if (doStroke) {\n                p.stroke(cachedVertArray[6]);\n                executeContextStroke();\n              }\n\n              curContext.closePath();\n            }\n          }\n        } else if (curShape === PConstants.QUADS) {\n          for (i = 0; (i + 3) < vertArrayLength; i+=4) {\n            cachedVertArray = vertArray[i];\n            curContext.beginPath();\n            curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);\n            for (j = 1; j < 4; j++) {\n              curContext.lineTo(vertArray[i+j][0], vertArray[i+j][1]);\n            }\n            curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n\n            if (doFill) {\n              p.fill(vertArray[i+3][5]);\n              executeContextFill();\n            }\n            if (doStroke) {\n              p.stroke(vertArray[i+3][6]);\n              executeContextStroke();\n            }\n\n            curContext.closePath();\n          }\n        } else if (curShape === PConstants.QUAD_STRIP) {\n          if (vertArrayLength > 3) {\n            for (i = 0; (i+1) < vertArrayLength; i+=2) {\n              cachedVertArray = vertArray[i];\n              curContext.beginPath();\n              if (i+3 < vertArrayLength) {\n                curContext.moveTo(vertArray[i+2][0], vertArray[i+2][1]);\n                curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n                curContext.lineTo(vertArray[i+1][0], vertArray[i+1][1]);\n                curContext.lineTo(vertArray[i+3][0], vertArray[i+3][1]);\n\n                if (doFill) {\n                  p.fill(vertArray[i+3][5]);\n                }\n                if (doStroke) {\n                  p.stroke(vertArray[i+3][6]);\n                }\n              } else {\n                curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);\n                curContext.lineTo(vertArray[i+1][0], vertArray[i+1][1]);\n              }\n              fillStrokeClose();\n            }\n          }\n        } else {\n          curContext.beginPath();\n          curContext.moveTo(vertArray[0][0], vertArray[0][1]);\n          for (i = 1; i < vertArrayLength; i++) {\n            cachedVertArray = vertArray[i];\n            if (cachedVertArray.isVert) { //if it is a vertex move to the position\n              if (cachedVertArray.moveTo) {\n                curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);\n              } else {\n                curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n              }\n            }\n          }\n          fillStrokeClose();\n        }\n      }\n\n      // Reset some settings\n      isCurve = false;\n      isBezier = false;\n      curveVertArray = [];\n      curveVertCount = 0;\n\n      // If the shape is closed, the first element was added as last element.\n      // We must remove it again to prevent the list of vertices from growing\n      // over successive calls to endShape(CLOSE)\n      if (closeShape) {\n        vertArray.pop();\n      }\n    };\n\n    Drawing3D.prototype.endShape = function(mode) {\n      // Duplicated in Drawing3D; too many variables used\n      if (vertArray.length === 0) { return; }\n\n      var closeShape = mode === PConstants.CLOSE;\n      var lineVertArray = [];\n      var fillVertArray = [];\n      var colorVertArray = [];\n      var strokeVertArray = [];\n      var texVertArray = [];\n      var cachedVertArray;\n\n      firstVert = true;\n      var i, j, k;\n      var vertArrayLength = vertArray.length;\n\n      for (i = 0; i < vertArrayLength; i++) {\n        cachedVertArray = vertArray[i];\n        for (j = 0; j < 3; j++) {\n          fillVertArray.push(cachedVertArray[j]);\n        }\n      }\n\n      // 5,6,7,8\n      // R,G,B,A - fill colour\n      for (i = 0; i < vertArrayLength; i++) {\n        cachedVertArray = vertArray[i];\n        for (j = 5; j < 9; j++) {\n          colorVertArray.push(cachedVertArray[j]);\n        }\n      }\n\n      // 9,10,11,12\n      // R, G, B, A - stroke colour\n      for (i = 0; i < vertArrayLength; i++) {\n        cachedVertArray = vertArray[i];\n        for (j = 9; j < 13; j++) {\n          strokeVertArray.push(cachedVertArray[j]);\n        }\n      }\n\n      // texture u,v\n      for (i = 0; i < vertArrayLength; i++) {\n        cachedVertArray = vertArray[i];\n        texVertArray.push(cachedVertArray[3]);\n        texVertArray.push(cachedVertArray[4]);\n      }\n\n      // if shape is closed, push the first point into the last point (including colours)\n      if (closeShape) {\n        fillVertArray.push(vertArray[0][0]);\n        fillVertArray.push(vertArray[0][1]);\n        fillVertArray.push(vertArray[0][2]);\n\n        for (i = 5; i < 9; i++) {\n          colorVertArray.push(vertArray[0][i]);\n        }\n\n        for (i = 9; i < 13; i++) {\n          strokeVertArray.push(vertArray[0][i]);\n        }\n\n        texVertArray.push(vertArray[0][3]);\n        texVertArray.push(vertArray[0][4]);\n      }\n      // End duplication\n\n      // curveVertex\n      if ( isCurve && (curShape === PConstants.POLYGON || curShape === undef) ) {\n        lineVertArray = fillVertArray;\n        if (doStroke) {\n          line3D(lineVertArray, null, strokeVertArray);\n        }\n        if (doFill) {\n          fill3D(fillVertArray, null, colorVertArray);\n        }\n      }\n      // bezierVertex\n      else if ( isBezier && (curShape === PConstants.POLYGON || curShape === undef) ) {\n        lineVertArray = fillVertArray;\n        lineVertArray.splice(lineVertArray.length - 3);\n        strokeVertArray.splice(strokeVertArray.length - 4);\n        if (doStroke) {\n          line3D(lineVertArray, null, strokeVertArray);\n        }\n        if (doFill) {\n          fill3D(fillVertArray, \"TRIANGLES\", colorVertArray);\n        }\n      }\n\n      // render the vertices provided\n      else {\n        if (curShape === PConstants.POINTS) {       // if POINTS was the specified parameter in beginShape\n          for (i = 0; i < vertArrayLength; i++) {  // loop through and push the point location information to the array\n            cachedVertArray = vertArray[i];\n            for (j = 0; j < 3; j++) {\n              lineVertArray.push(cachedVertArray[j]);\n            }\n          }\n          point3D(lineVertArray, strokeVertArray);  // render function for points\n        } else if (curShape === PConstants.LINES) { // if LINES was the specified parameter in beginShape\n          for (i = 0; i < vertArrayLength; i++) {  // loop through and push the point location information to the array\n            cachedVertArray = vertArray[i];\n            for (j = 0; j < 3; j++) {\n              lineVertArray.push(cachedVertArray[j]);\n            }\n          }\n          for (i = 0; i < vertArrayLength; i++) {  // loop through and push the color information to the array\n            cachedVertArray = vertArray[i];\n            for (j = 5; j < 9; j++) {\n              colorVertArray.push(cachedVertArray[j]);\n            }\n          }\n          line3D(lineVertArray, \"LINES\", strokeVertArray);  // render function for lines\n        } else if (curShape === PConstants.TRIANGLES) {     // if TRIANGLES was the specified parameter in beginShape\n          if (vertArrayLength > 2) {\n            for (i = 0; (i+2) < vertArrayLength; i+=3) {   // loop through the array per triangle\n              fillVertArray = [];\n              texVertArray = [];\n              lineVertArray = [];\n              colorVertArray = [];\n              strokeVertArray = [];\n              for (j = 0; j < 3; j++) {\n                for (k = 0; k < 3; k++) {                   // loop through and push\n                  lineVertArray.push(vertArray[i+j][k]);    // the line point location information\n                  fillVertArray.push(vertArray[i+j][k]);    // and fill point location information\n                }\n              }\n              for (j = 0; j < 3; j++) {                     // loop through and push the texture information\n                for (k = 3; k < 5; k++) {\n                  texVertArray.push(vertArray[i+j][k]);\n                }\n              }\n              for (j = 0; j < 3; j++) {\n                for (k = 5; k < 9; k++) {                   // loop through and push\n                  colorVertArray.push(vertArray[i+j][k]);   // the colour information\n                  strokeVertArray.push(vertArray[i+j][k+4]);// and the stroke information\n                }\n              }\n              if (doStroke) {\n                line3D(lineVertArray, \"LINE_LOOP\", strokeVertArray );               // line render function\n              }\n              if (doFill || usingTexture) {\n                fill3D(fillVertArray, \"TRIANGLES\", colorVertArray, texVertArray);   // fill shape render function\n              }\n            }\n          }\n        } else if (curShape === PConstants.TRIANGLE_STRIP) {    // if TRIANGLE_STRIP was the specified parameter in beginShape\n          if (vertArrayLength > 2) {\n            for (i = 0; (i+2) < vertArrayLength; i++) {\n              lineVertArray = [];\n              fillVertArray = [];\n              strokeVertArray = [];\n              colorVertArray = [];\n              texVertArray = [];\n              for (j = 0; j < 3; j++) {\n                for (k = 0; k < 3; k++) {\n                  lineVertArray.push(vertArray[i+j][k]);\n                  fillVertArray.push(vertArray[i+j][k]);\n                }\n              }\n              for (j = 0; j < 3; j++) {\n                for (k = 3; k < 5; k++) {\n                  texVertArray.push(vertArray[i+j][k]);\n                }\n              }\n              for (j = 0; j < 3; j++) {\n                for (k = 5; k < 9; k++) {\n                  strokeVertArray.push(vertArray[i+j][k+4]);\n                  colorVertArray.push(vertArray[i+j][k]);\n                }\n              }\n\n              if (doFill || usingTexture) {\n                fill3D(fillVertArray, \"TRIANGLE_STRIP\", colorVertArray, texVertArray);\n              }\n              if (doStroke) {\n                line3D(lineVertArray, \"LINE_LOOP\", strokeVertArray);\n              }\n            }\n          }\n        } else if (curShape === PConstants.TRIANGLE_FAN) {\n          if (vertArrayLength > 2) {\n            for (i = 0; i < 3; i++) {\n              cachedVertArray = vertArray[i];\n              for (j = 0; j < 3; j++) {\n                lineVertArray.push(cachedVertArray[j]);\n              }\n            }\n            for (i = 0; i < 3; i++) {\n              cachedVertArray = vertArray[i];\n              for (j = 9; j < 13; j++) {\n                strokeVertArray.push(cachedVertArray[j]);\n              }\n            }\n            if (doStroke) {\n              line3D(lineVertArray, \"LINE_LOOP\", strokeVertArray);\n            }\n\n            for (i = 2; (i+1) < vertArrayLength; i++) {\n              lineVertArray = [];\n              strokeVertArray = [];\n              lineVertArray.push(vertArray[0][0]);\n              lineVertArray.push(vertArray[0][1]);\n              lineVertArray.push(vertArray[0][2]);\n\n              strokeVertArray.push(vertArray[0][9]);\n              strokeVertArray.push(vertArray[0][10]);\n              strokeVertArray.push(vertArray[0][11]);\n              strokeVertArray.push(vertArray[0][12]);\n\n              for (j = 0; j < 2; j++) {\n                for (k = 0; k < 3; k++) {\n                  lineVertArray.push(vertArray[i+j][k]);\n                }\n              }\n              for (j = 0; j < 2; j++) {\n                for (k = 9; k < 13; k++) {\n                  strokeVertArray.push(vertArray[i+j][k]);\n                }\n              }\n              if (doStroke) {\n                line3D(lineVertArray, \"LINE_STRIP\",strokeVertArray);\n              }\n            }\n            if (doFill || usingTexture) {\n              fill3D(fillVertArray, \"TRIANGLE_FAN\", colorVertArray, texVertArray);\n            }\n          }\n        } else if (curShape === PConstants.QUADS) {\n          for (i = 0; (i + 3) < vertArrayLength; i+=4) {\n            lineVertArray = [];\n            for (j = 0; j < 4; j++) {\n              cachedVertArray = vertArray[i+j];\n              for (k = 0; k < 3; k++) {\n                lineVertArray.push(cachedVertArray[k]);\n              }\n            }\n            if (doStroke) {\n              line3D(lineVertArray, \"LINE_LOOP\",strokeVertArray);\n            }\n\n            if (doFill) {\n              fillVertArray = [];\n              colorVertArray = [];\n              texVertArray = [];\n              for (j = 0; j < 3; j++) {\n                fillVertArray.push(vertArray[i][j]);\n              }\n              for (j = 5; j < 9; j++) {\n                colorVertArray.push(vertArray[i][j]);\n              }\n\n              for (j = 0; j < 3; j++) {\n                fillVertArray.push(vertArray[i+1][j]);\n              }\n              for (j = 5; j < 9; j++) {\n                colorVertArray.push(vertArray[i+1][j]);\n              }\n\n              for (j = 0; j < 3; j++) {\n                fillVertArray.push(vertArray[i+3][j]);\n              }\n              for (j = 5; j < 9; j++) {\n                colorVertArray.push(vertArray[i+3][j]);\n              }\n\n              for (j = 0; j < 3; j++) {\n                fillVertArray.push(vertArray[i+2][j]);\n              }\n              for (j = 5; j < 9; j++) {\n                colorVertArray.push(vertArray[i+2][j]);\n              }\n\n              if (usingTexture) {\n                texVertArray.push(vertArray[i+0][3]);\n                texVertArray.push(vertArray[i+0][4]);\n                texVertArray.push(vertArray[i+1][3]);\n                texVertArray.push(vertArray[i+1][4]);\n                texVertArray.push(vertArray[i+3][3]);\n                texVertArray.push(vertArray[i+3][4]);\n                texVertArray.push(vertArray[i+2][3]);\n                texVertArray.push(vertArray[i+2][4]);\n              }\n\n              fill3D(fillVertArray, \"TRIANGLE_STRIP\", colorVertArray, texVertArray);\n            }\n          }\n        } else if (curShape === PConstants.QUAD_STRIP) {\n          var tempArray = [];\n          if (vertArrayLength > 3) {\n            for (i = 0; i < 2; i++) {\n              cachedVertArray = vertArray[i];\n              for (j = 0; j < 3; j++) {\n                lineVertArray.push(cachedVertArray[j]);\n              }\n            }\n\n            for (i = 0; i < 2; i++) {\n              cachedVertArray = vertArray[i];\n              for (j = 9; j < 13; j++) {\n                strokeVertArray.push(cachedVertArray[j]);\n              }\n            }\n\n            line3D(lineVertArray, \"LINE_STRIP\", strokeVertArray);\n            if (vertArrayLength > 4 && vertArrayLength % 2 > 0) {\n              tempArray = fillVertArray.splice(fillVertArray.length - 3);\n              vertArray.pop();\n            }\n            for (i = 0; (i+3) < vertArrayLength; i+=2) {\n              lineVertArray = [];\n              strokeVertArray = [];\n              for (j = 0; j < 3; j++) {\n                lineVertArray.push(vertArray[i+1][j]);\n              }\n              for (j = 0; j < 3; j++) {\n                lineVertArray.push(vertArray[i+3][j]);\n              }\n              for (j = 0; j < 3; j++) {\n                lineVertArray.push(vertArray[i+2][j]);\n              }\n              for (j = 0; j < 3; j++) {\n                lineVertArray.push(vertArray[i+0][j]);\n              }\n              for (j = 9; j < 13; j++) {\n                strokeVertArray.push(vertArray[i+1][j]);\n              }\n              for (j = 9; j < 13; j++) {\n                strokeVertArray.push(vertArray[i+3][j]);\n              }\n              for (j = 9; j < 13; j++) {\n                strokeVertArray.push(vertArray[i+2][j]);\n              }\n              for (j = 9; j < 13; j++) {\n                strokeVertArray.push(vertArray[i+0][j]);\n              }\n              if (doStroke) {\n                line3D(lineVertArray, \"LINE_STRIP\", strokeVertArray);\n              }\n            }\n\n            if (doFill || usingTexture) {\n              fill3D(fillVertArray, \"TRIANGLE_LIST\", colorVertArray, texVertArray);\n            }\n          }\n        }\n        // If the user didn't specify a type (LINES, TRIANGLES, etc)\n        else {\n          // If only one vertex was specified, it must be a point\n          if (vertArrayLength === 1) {\n            for (j = 0; j < 3; j++) {\n              lineVertArray.push(vertArray[0][j]);\n            }\n            for (j = 9; j < 13; j++) {\n              strokeVertArray.push(vertArray[0][j]);\n            }\n            point3D(lineVertArray,strokeVertArray);\n          } else {\n            for (i = 0; i < vertArrayLength; i++) {\n              cachedVertArray = vertArray[i];\n              for (j = 0; j < 3; j++) {\n                lineVertArray.push(cachedVertArray[j]);\n              }\n              for (j = 5; j < 9; j++) {\n                strokeVertArray.push(cachedVertArray[j]);\n              }\n            }\n            if (doStroke && closeShape) {\n              line3D(lineVertArray, \"LINE_LOOP\", strokeVertArray);\n            } else if (doStroke && !closeShape) {\n              line3D(lineVertArray, \"LINE_STRIP\", strokeVertArray);\n            }\n\n            // fill is ignored if textures are used\n            if (doFill || usingTexture) {\n              fill3D(fillVertArray, \"TRIANGLE_FAN\", colorVertArray, texVertArray);\n            }\n          }\n        }\n        // everytime beginShape is followed by a call to\n        // texture(), texturing it turned back on. We do this to\n        // figure out if the shape should be textured or filled\n        // with a color.\n        usingTexture = false;\n        curContext.useProgram(programObject3D);\n        uniformi(\"usingTexture3d\", programObject3D, \"uUsingTexture\", usingTexture);\n      }\n\n      // Reset some settings\n      isCurve = false;\n      isBezier = false;\n      curveVertArray = [];\n      curveVertCount = 0;\n    };\n\n    /**\n     * The function splineForward() setup forward-differencing matrix to be used for speedy\n     * curve rendering. It's based on using a specific number\n     * of curve segments and just doing incremental adds for each\n     * vertex of the segment, rather than running the mathematically\n     * expensive cubic equation. This function is used by both curveDetail and bezierDetail.\n     *\n     * @param {int} segments      number of curve segments to use when drawing\n     * @param {PMatrix3D} matrix  target object for the new matrix\n     */\n    var splineForward = function(segments, matrix) {\n      var f = 1.0 / segments;\n      var ff = f * f;\n      var fff = ff * f;\n\n      matrix.set(0, 0, 0, 1, fff, ff, f, 0, 6 * fff, 2 * ff, 0, 0, 6 * fff, 0, 0, 0);\n    };\n\n    /**\n     * The curveInit() function set the number of segments to use when drawing a Catmull-Rom\n     * curve, and setting the s parameter, which defines how tightly\n     * the curve fits to each vertex. Catmull-Rom curves are actually\n     * a subset of this curve type where the s is set to zero.\n     * This in an internal function used by curveDetail() and curveTightness().\n     */\n    var curveInit = function() {\n      // allocate only if/when used to save startup time\n      if (!curveDrawMatrix) {\n        curveBasisMatrix = new PMatrix3D();\n        curveDrawMatrix = new PMatrix3D();\n        curveInited = true;\n      }\n\n      var s = curTightness;\n      curveBasisMatrix.set((s - 1) / 2, (s + 3) / 2, (-3 - s) / 2, (1 - s) / 2,\n                           (1 - s), (-5 - s) / 2, (s + 2), (s - 1) / 2,\n                           (s - 1) / 2, 0, (1 - s) / 2, 0, 0, 1, 0, 0);\n\n      splineForward(curveDet, curveDrawMatrix);\n\n      if (!bezierBasisInverse) {\n        //bezierBasisInverse = bezierBasisMatrix.get();\n        //bezierBasisInverse.invert();\n        curveToBezierMatrix = new PMatrix3D();\n      }\n\n      // TODO only needed for PGraphicsJava2D? if so, move it there\n      // actually, it's generally useful for other renderers, so keep it\n      // or hide the implementation elsewhere.\n      curveToBezierMatrix.set(curveBasisMatrix);\n      curveToBezierMatrix.preApply(bezierBasisInverse);\n\n      // multiply the basis and forward diff matrices together\n      // saves much time since this needn't be done for each curve\n      curveDrawMatrix.apply(curveBasisMatrix);\n    };\n\n    /**\n     * Specifies vertex coordinates for Bezier curves. Each call to <b>bezierVertex()</b> defines the position of two control\n     * points and one anchor point of a Bezier curve, adding a new segment to a line or shape. The first time\n     * <b>bezierVertex()</b> is used within a <b>beginShape()</b> call, it must be prefaced with a call to <b>vertex()</b>\n     * to set the first anchor point. This function must be used between <b>beginShape()</b> and <b>endShape()</b> and only\n     * when there is no MODE parameter specified to <b>beginShape()</b>. Using the 3D version of requires rendering with P3D\n     * or OPENGL (see the Environment reference for more information). <br /> <br /> <b>NOTE: </b> Fill does not work properly yet.\n     *\n     * @param {float | int} cx1 The x-coordinate of 1st control point\n     * @param {float | int} cy1 The y-coordinate of 1st control point\n     * @param {float | int} cz1 The z-coordinate of 1st control point\n     * @param {float | int} cx2 The x-coordinate of 2nd control point\n     * @param {float | int} cy2 The y-coordinate of 2nd control point\n     * @param {float | int} cz2 The z-coordinate of 2nd control point\n     * @param {float | int} x   The x-coordinate of the anchor point\n     * @param {float | int} y   The y-coordinate of the anchor point\n     * @param {float | int} z   The z-coordinate of the anchor point\n     *\n     * @see curveVertex\n     * @see vertex\n     * @see bezier\n     */\n    Drawing2D.prototype.bezierVertex = function() {\n      isBezier = true;\n      var vert = [];\n      if (firstVert) {\n        throw (\"vertex() must be used at least once before calling bezierVertex()\");\n      }\n\n      for (var i = 0; i < arguments.length; i++) {\n        vert[i] = arguments[i];\n      }\n      vertArray.push(vert);\n      vertArray[vertArray.length -1].isVert = false;\n    };\n\n    Drawing3D.prototype.bezierVertex = function() {\n      isBezier = true;\n      var vert = [];\n      if (firstVert) {\n        throw (\"vertex() must be used at least once before calling bezierVertex()\");\n      }\n\n      if (arguments.length === 9) {\n        if (bezierDrawMatrix === undef) {\n          bezierDrawMatrix = new PMatrix3D();\n        }\n        // setup matrix for forward differencing to speed up drawing\n        var lastPoint = vertArray.length - 1;\n        splineForward( bezDetail, bezierDrawMatrix );\n        bezierDrawMatrix.apply( bezierBasisMatrix );\n        var draw = bezierDrawMatrix.array();\n        var x1 = vertArray[lastPoint][0],\n            y1 = vertArray[lastPoint][1],\n            z1 = vertArray[lastPoint][2];\n        var xplot1 = draw[4] * x1 + draw[5] * arguments[0] + draw[6] * arguments[3] + draw[7] * arguments[6];\n        var xplot2 = draw[8] * x1 + draw[9] * arguments[0] + draw[10]* arguments[3] + draw[11]* arguments[6];\n        var xplot3 = draw[12]* x1 + draw[13]* arguments[0] + draw[14]* arguments[3] + draw[15]* arguments[6];\n\n        var yplot1 = draw[4] * y1 + draw[5] * arguments[1] + draw[6] * arguments[4] + draw[7] * arguments[7];\n        var yplot2 = draw[8] * y1 + draw[9] * arguments[1] + draw[10]* arguments[4] + draw[11]* arguments[7];\n        var yplot3 = draw[12]* y1 + draw[13]* arguments[1] + draw[14]* arguments[4] + draw[15]* arguments[7];\n\n        var zplot1 = draw[4] * z1 + draw[5] * arguments[2] + draw[6] * arguments[5] + draw[7] * arguments[8];\n        var zplot2 = draw[8] * z1 + draw[9] * arguments[2] + draw[10]* arguments[5] + draw[11]* arguments[8];\n        var zplot3 = draw[12]* z1 + draw[13]* arguments[2] + draw[14]* arguments[5] + draw[15]* arguments[8];\n        for (var j = 0; j < bezDetail; j++) {\n          x1 += xplot1; xplot1 += xplot2; xplot2 += xplot3;\n          y1 += yplot1; yplot1 += yplot2; yplot2 += yplot3;\n          z1 += zplot1; zplot1 += zplot2; zplot2 += zplot3;\n          p.vertex(x1, y1, z1);\n        }\n        p.vertex(arguments[6], arguments[7], arguments[8]);\n      }\n    };\n\n    /**\n     * Sets a texture to be applied to vertex points. The <b>texture()</b> function\n     * must be called between <b>beginShape()</b> and <b>endShape()</b> and before\n     * any calls to vertex().\n     *\n     * When textures are in use, the fill color is ignored. Instead, use tint() to\n     * specify the color of the texture as it is applied to the shape.\n     *\n     * @param {PImage} pimage the texture to apply\n     *\n     * @returns none\n     *\n     * @see textureMode\n     * @see beginShape\n     * @see endShape\n     * @see vertex\n    */\n    p.texture = function(pimage) {\n      var curContext = drawing.$ensureContext();\n\n      if (pimage.__texture) {\n        curContext.bindTexture(curContext.TEXTURE_2D, pimage.__texture);\n      } else if (pimage.localName === \"canvas\") {\n        curContext.bindTexture(curContext.TEXTURE_2D, canTex);\n        curContext.texImage2D(curContext.TEXTURE_2D, 0, curContext.RGBA, curContext.RGBA, curContext.UNSIGNED_BYTE, pimage);\n        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MAG_FILTER, curContext.LINEAR);\n        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MIN_FILTER, curContext.LINEAR);\n        curContext.generateMipmap(curContext.TEXTURE_2D);\n        curTexture.width = pimage.width;\n        curTexture.height = pimage.height;\n      } else {\n        var texture = curContext.createTexture(),\n            cvs = document.createElement('canvas'),\n            cvsTextureCtx = cvs.getContext('2d'),\n            pot;\n\n        // WebGL requires power of two textures\n        if (pimage.width & (pimage.width-1) === 0) {\n          cvs.width = pimage.width;\n        } else {\n          pot = 1;\n          while (pot < pimage.width) {\n            pot *= 2;\n          }\n          cvs.width = pot;\n        }\n\n        if (pimage.height & (pimage.height-1) === 0) {\n          cvs.height = pimage.height;\n        } else {\n          pot = 1;\n          while (pot < pimage.height) {\n            pot *= 2;\n          }\n          cvs.height = pot;\n        }\n\n        cvsTextureCtx.drawImage(pimage.sourceImg, 0, 0, pimage.width, pimage.height, 0, 0, cvs.width, cvs.height);\n\n        curContext.bindTexture(curContext.TEXTURE_2D, texture);\n        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MIN_FILTER, curContext.LINEAR_MIPMAP_LINEAR);\n        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MAG_FILTER, curContext.LINEAR);\n        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_WRAP_T, curContext.CLAMP_TO_EDGE);\n        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_WRAP_S, curContext.CLAMP_TO_EDGE);\n        curContext.texImage2D(curContext.TEXTURE_2D, 0, curContext.RGBA, curContext.RGBA, curContext.UNSIGNED_BYTE, cvs);\n        curContext.generateMipmap(curContext.TEXTURE_2D);\n\n        pimage.__texture = texture;\n        curTexture.width = pimage.width;\n        curTexture.height = pimage.height;\n      }\n\n      usingTexture = true;\n      curContext.useProgram(programObject3D);\n      uniformi(\"usingTexture3d\", programObject3D, \"uUsingTexture\", usingTexture);\n    };\n\n    /**\n     * Sets the coordinate space for texture mapping. There are two options, IMAGE,\n     * which refers to the actual coordinates of the image, and NORMALIZED, which\n     * refers to a normalized space of values ranging from 0 to 1. The default mode\n     * is IMAGE. In IMAGE, if an image is 100 x 200 pixels, mapping the image onto\n     * the entire size of a quad would require the points (0,0) (0,100) (100,200) (0,200).\n     * The same mapping in NORMAL_SPACE is (0,0) (0,1) (1,1) (0,1).\n     *\n     * @param MODE either IMAGE or NORMALIZED\n     *\n     * @returns none\n     *\n     * @see texture\n    */\n    p.textureMode = function(mode){\n      curTextureMode = mode;\n    };\n    /**\n     * The curveVertexSegment() function handle emitting a specific segment of Catmull-Rom curve. Internal helper function used by <b>curveVertex()</b>.\n     */\n    var curveVertexSegment = function(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {\n      var x0 = x2;\n      var y0 = y2;\n      var z0 = z2;\n\n      var draw = curveDrawMatrix.array();\n\n      var xplot1 = draw[4] * x1 + draw[5] * x2 + draw[6] * x3 + draw[7] * x4;\n      var xplot2 = draw[8] * x1 + draw[9] * x2 + draw[10] * x3 + draw[11] * x4;\n      var xplot3 = draw[12] * x1 + draw[13] * x2 + draw[14] * x3 + draw[15] * x4;\n\n      var yplot1 = draw[4] * y1 + draw[5] * y2 + draw[6] * y3 + draw[7] * y4;\n      var yplot2 = draw[8] * y1 + draw[9] * y2 + draw[10] * y3 + draw[11] * y4;\n      var yplot3 = draw[12] * y1 + draw[13] * y2 + draw[14] * y3 + draw[15] * y4;\n\n      var zplot1 = draw[4] * z1 + draw[5] * z2 + draw[6] * z3 + draw[7] * z4;\n      var zplot2 = draw[8] * z1 + draw[9] * z2 + draw[10] * z3 + draw[11] * z4;\n      var zplot3 = draw[12] * z1 + draw[13] * z2 + draw[14] * z3 + draw[15] * z4;\n\n      p.vertex(x0, y0, z0);\n      for (var j = 0; j < curveDet; j++) {\n        x0 += xplot1; xplot1 += xplot2; xplot2 += xplot3;\n        y0 += yplot1; yplot1 += yplot2; yplot2 += yplot3;\n        z0 += zplot1; zplot1 += zplot2; zplot2 += zplot3;\n        p.vertex(x0, y0, z0);\n      }\n    };\n\n    /**\n     * Specifies vertex coordinates for curves. This function may only be used between <b>beginShape()</b> and\n     * <b>endShape()</b> and only when there is no MODE parameter specified to <b>beginShape()</b>. The first and last points\n     * in a series of <b>curveVertex()</b> lines will be used to guide the beginning and end of a the curve. A minimum of four\n     * points is required to draw a tiny curve between the second and third points. Adding a fifth point with\n     * <b>curveVertex()</b> will draw the curve between the second, third, and fourth points. The <b>curveVertex()</b> function\n     * is an implementation of Catmull-Rom splines. Using the 3D version of requires rendering with P3D or OPENGL (see the\n     * Environment reference for more information). <br /> <br /><b>NOTE: </b> Fill does not work properly yet.\n     *\n     * @param {float | int} x The x-coordinate of the vertex\n     * @param {float | int} y The y-coordinate of the vertex\n     * @param {float | int} z The z-coordinate of the vertex\n     *\n     * @see curve\n     * @see beginShape\n     * @see endShape\n     * @see vertex\n     * @see bezierVertex\n     */\n    Drawing2D.prototype.curveVertex = function(x, y) {\n      isCurve = true;\n\n      p.vertex(x, y);\n    };\n\n    Drawing3D.prototype.curveVertex = function(x, y, z) {\n      isCurve = true;\n\n      if (!curveInited) {\n        curveInit();\n      }\n      var vert = [];\n      vert[0] = x;\n      vert[1] = y;\n      vert[2] = z;\n      curveVertArray.push(vert);\n      curveVertCount++;\n\n      if (curveVertCount > 3) {\n        curveVertexSegment( curveVertArray[curveVertCount-4][0],\n                            curveVertArray[curveVertCount-4][1],\n                            curveVertArray[curveVertCount-4][2],\n                            curveVertArray[curveVertCount-3][0],\n                            curveVertArray[curveVertCount-3][1],\n                            curveVertArray[curveVertCount-3][2],\n                            curveVertArray[curveVertCount-2][0],\n                            curveVertArray[curveVertCount-2][1],\n                            curveVertArray[curveVertCount-2][2],\n                            curveVertArray[curveVertCount-1][0],\n                            curveVertArray[curveVertCount-1][1],\n                            curveVertArray[curveVertCount-1][2] );\n      }\n    };\n\n    /**\n     * The curve() function draws a curved line on the screen. The first and second parameters\n     * specify the beginning control point and the last two parameters specify\n     * the ending control point. The middle parameters specify the start and\n     * stop of the curve. Longer curves can be created by putting a series of\n     * <b>curve()</b> functions together or using <b>curveVertex()</b>.\n     * An additional function called <b>curveTightness()</b> provides control\n     * for the visual quality of the curve. The <b>curve()</b> function is an\n     * implementation of Catmull-Rom splines. Using the 3D version of requires\n     * rendering with P3D or OPENGL (see the Environment reference for more\n     * information).\n     *\n     * @param {int|float} x1 coordinates for the beginning control point\n     * @param {int|float} y1 coordinates for the beginning control point\n     * @param {int|float} z1 coordinates for the beginning control point\n     * @param {int|float} x2 coordinates for the first point\n     * @param {int|float} y2 coordinates for the first point\n     * @param {int|float} z2 coordinates for the first point\n     * @param {int|float} x3 coordinates for the second point\n     * @param {int|float} y3 coordinates for the second point\n     * @param {int|float} z3 coordinates for the second point\n     * @param {int|float} x4 coordinates for the ending control point\n     * @param {int|float} y4 coordinates for the ending control point\n     * @param {int|float} z4 coordinates for the ending control point\n     *\n     * @see #curveVertex()\n     * @see #curveTightness()\n     * @see #bezier()\n     */\n    Drawing2D.prototype.curve = function(x1, y1, x2, y2, x3, y3, x4, y4) {\n      p.beginShape();\n      p.curveVertex(x1, y1);\n      p.curveVertex(x2, y2);\n      p.curveVertex(x3, y3);\n      p.curveVertex(x4, y4);\n      p.endShape();\n    };\n\n    Drawing3D.prototype.curve = function(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {\n      if (z4 !== undef) {\n        p.beginShape();\n        p.curveVertex(x1, y1, z1);\n        p.curveVertex(x2, y2, z2);\n        p.curveVertex(x3, y3, z3);\n        p.curveVertex(x4, y4, z4);\n        p.endShape();\n        return;\n      }\n      p.beginShape();\n      p.curveVertex(x1, y1);\n      p.curveVertex(z1, x2);\n      p.curveVertex(y2, z2);\n      p.curveVertex(x3, y3);\n      p.endShape();\n    };\n\n    /**\n     * The curveTightness() function modifies the quality of forms created with <b>curve()</b> and\n     * <b>curveVertex()</b>. The parameter <b>squishy</b> determines how the\n     * curve fits to the vertex points. The value 0.0 is the default value for\n     * <b>squishy</b> (this value defines the curves to be Catmull-Rom splines)\n     * and the value 1.0 connects all the points with straight lines.\n     * Values within the range -5.0 and 5.0 will deform the curves but\n     * will leave them recognizable and as values increase in magnitude,\n     * they will continue to deform.\n     *\n     * @param {float} tightness amount of deformation from the original vertices\n     *\n     * @see #curve()\n     * @see #curveVertex()\n     *\n     */\n    p.curveTightness = function(tightness) {\n      curTightness = tightness;\n    };\n\n    /**\n     * The curveDetail() function sets the resolution at which curves display. The default value is 20.\n     * This function is only useful when using the P3D or OPENGL renderer.\n     *\n     * @param {int} detail resolution of the curves\n     *\n     * @see curve()\n     * @see curveVertex()\n     * @see curveTightness()\n     */\n    p.curveDetail = function(detail) {\n      curveDet = detail;\n      curveInit();\n    };\n\n    /**\n    * Modifies the location from which rectangles draw. The default mode is rectMode(CORNER), which\n    * specifies the location to be the upper left corner of the shape and uses the third and fourth\n    * parameters of rect() to specify the width and height. The syntax rectMode(CORNERS) uses the\n    * first and second parameters of rect() to set the location of one corner and uses the third and\n    * fourth parameters to set the opposite corner. The syntax rectMode(CENTER) draws the image from\n    * its center point and uses the third and forth parameters of rect() to specify the image's width\n    * and height. The syntax rectMode(RADIUS) draws the image from its center point and uses the third\n    * and forth parameters of rect()  to specify half of the image's width and height. The parameter must\n    * be written in ALL CAPS because Processing is a case sensitive language. Note: In version 125, the\n    * mode named CENTER_RADIUS was shortened to RADIUS.\n    *\n    * @param {MODE} MODE      Either CORNER, CORNERS, CENTER, or RADIUS\n    *\n    * @see rect\n    */\n    p.rectMode = function(aRectMode) {\n      curRectMode = aRectMode;\n    };\n\n    /**\n    * Modifies the location from which images draw. The default mode is imageMode(CORNER), which specifies\n    * the location to be the upper left corner and uses the fourth and fifth parameters of image() to set\n    * the image's width and height. The syntax imageMode(CORNERS) uses the second and third parameters of\n    * image() to set the location of one corner of the image and uses the fourth and fifth parameters to\n    * set the opposite corner. Use imageMode(CENTER) to draw images centered at the given x and y position.\n    * The parameter to imageMode() must be written in ALL CAPS because Processing is a case sensitive language.\n    *\n    * @param {MODE} MODE      Either CORNER, CORNERS, or CENTER\n    *\n    * @see loadImage\n    * @see PImage\n    * @see image\n    * @see background\n    */\n    p.imageMode = function(mode) {\n      switch (mode) {\n      case PConstants.CORNER:\n        imageModeConvert = imageModeCorner;\n        break;\n      case PConstants.CORNERS:\n        imageModeConvert = imageModeCorners;\n        break;\n      case PConstants.CENTER:\n        imageModeConvert = imageModeCenter;\n        break;\n      default:\n        throw \"Invalid imageMode\";\n      }\n    };\n\n    /**\n    * The origin of the ellipse is modified by the ellipseMode() function. The default configuration is\n    * ellipseMode(CENTER), which specifies the location of the ellipse as the center of the shape. The RADIUS\n    * mode is the same, but the width and height parameters to ellipse()  specify the radius of the ellipse,\n    * rather than the diameter. The CORNER mode draws the shape from the upper-left corner of its bounding box.\n    * The CORNERS mode uses the four parameters to ellipse() to set two opposing corners of the ellipse's bounding\n    * box. The parameter must be written in \"ALL CAPS\" because Processing is a case sensitive language.\n    *\n    * @param {MODE} MODE      Either CENTER, RADIUS, CORNER, or CORNERS.\n    *\n    * @see ellipse\n    */\n    p.ellipseMode = function(aEllipseMode) {\n      curEllipseMode = aEllipseMode;\n    };\n\n    /**\n     * The arc() function draws an arc in the display window.\n     * Arcs are drawn along the outer edge of an ellipse defined by the\n     * <b>x</b>, <b>y</b>, <b>width</b> and <b>height</b> parameters.\n     * The origin or the arc's ellipse may be changed with the\n     * <b>ellipseMode()</b> function.\n     * The <b>start</b> and <b>stop</b> parameters specify the angles\n     * at which to draw the arc.\n     *\n     * @param {float} a       x-coordinate of the arc's ellipse\n     * @param {float} b       y-coordinate of the arc's ellipse\n     * @param {float} c       width of the arc's ellipse\n     * @param {float} d       height of the arc's ellipse\n     * @param {float} start   angle to start the arc, specified in radians\n     * @param {float} stop    angle to stop the arc, specified in radians\n     * @param {enum}  mode    drawing mode (OPEN, CHORD, PIE)\n     *\n     * @see #ellipseMode()\n     * @see #ellipse()\n     */\n    p.arc = function(x, y, width, height, start, stop, mode) {\n      if (width <= 0 || stop < start) { return; }\n\n      if (curEllipseMode === PConstants.CORNERS) {\n        width = width - x;\n        height = height - y;\n      } else if (curEllipseMode === PConstants.RADIUS) {\n        x = x - width;\n        y = y - height;\n        width = width * 2;\n        height = height * 2;\n      } else if (curEllipseMode === PConstants.CENTER) {\n        x = x - width/2;\n        y = y - height/2;\n      }\n      // make sure that we're starting at a useful point\n      while (start < 0) {\n        start += PConstants.TWO_PI;\n        stop += PConstants.TWO_PI;\n      }\n      if (stop - start > PConstants.TWO_PI) {\n        // don't change start, it is visible in PIE mode\n        stop = start + PConstants.TWO_PI;\n      }\n      var hr = width / 2,\n          vr = height / 2,\n          centerX = x + hr,\n          centerY = y + vr,\n          step = 1/(hr+vr);\n\n      var drawSlice = (function(x, y, start, step, stop) {\n        return function(p, closed, i, a, e) {\n          i = 0;\n          a = start;\n          e = stop + step;\n          p.beginShape();\n          if(closed) { p.vertex(x-0.5, y-0.5); }\n          for (; a < e; i++, a = i*step + start) {\n            p.vertex(\n              (x + Math.cos(a) * hr)|0,\n              (y + Math.sin(a) * vr)|0\n            );\n          }\n\n          if (mode === PConstants.OPEN && doFill) {\n            p.vertex(centerX + Math.cos(start) * hr, centerY + Math.sin(start) * vr);\n          } else if (mode === PConstants.CHORD) {\n            p.vertex(centerX + Math.cos(start) * hr, centerY + Math.sin(start) * vr);\n          } else if (mode === PConstants.PIE) {\n            p.line(centerX + Math.cos(start) * hr, centerY + Math.sin(start) * vr, centerX, centerY);\n            p.line(centerX, centerY, centerX + Math.cos(stop) * hr, centerY + Math.sin(stop) * vr);\n          }\n\n          p.endShape(closed ? PConstants.CLOSE : undefined);\n        };\n      }(centerX+0.5, centerY+0.5, start, step, stop));\n\n      if (doFill) {\n        var savedStroke = doStroke;\n        doStroke = false;\n        drawSlice(p, true);\n        doStroke = savedStroke;\n      }\n\n      if (doStroke) {\n        var savedFill = doFill;\n        doFill = false;\n        drawSlice(p);\n        doFill = savedFill;\n      }\n    };\n\n    /**\n    * Draws a line (a direct path between two points) to the screen. The version of line() with four parameters\n    * draws the line in 2D. To color a line, use the stroke() function. A line cannot be filled, therefore the\n    * fill()  method will not affect the color of a line. 2D lines are drawn with a width of one pixel by default,\n    * but this can be changed with the strokeWeight()  function. The version with six parameters allows the line\n    * to be placed anywhere within XYZ space. Drawing this shape in 3D using the z parameter requires the P3D or\n    * OPENGL parameter in combination with size.\n    *\n    * @param {int|float} x1       x-coordinate of the first point\n    * @param {int|float} y1       y-coordinate of the first point\n    * @param {int|float} z1       z-coordinate of the first point\n    * @param {int|float} x2       x-coordinate of the second point\n    * @param {int|float} y2       y-coordinate of the second point\n    * @param {int|float} z2       z-coordinate of the second point\n    *\n    * @see strokeWeight\n    * @see strokeJoin\n    * @see strokeCap\n    * @see beginShape\n    */\n    Drawing2D.prototype.line = function(x1, y1, x2, y2) {\n      if (!doStroke) {\n        return;\n      }\n      if (!renderSmooth) {\n        x1 = Math.round(x1);\n        x2 = Math.round(x2);\n        y1 = Math.round(y1);\n        y2 = Math.round(y2);\n      }\n\n      // A line is only defined if it has different start and end coordinates.\n      // If they are the same, we call point instead.\n      if (x1 === x2 && y1 === y2) {\n        p.point(x1, y1);\n        return;\n      }\n\n      var swap = undef,\n          lineCap = undef,\n          drawCrisp = true,\n          currentModelView = modelView.array(),\n          identityMatrix = [1, 0, 0, 0, 1, 0];\n      // Test if any transformations have been applied to the sketch\n      for (var i = 0; i < 6 && drawCrisp; i++) {\n        drawCrisp = currentModelView[i] === identityMatrix[i];\n      }\n      /* Draw crisp lines if the line is vertical or horizontal with the following method\n       * If any transformations have been applied to the sketch, don't make the line crisp\n       * If the line is directed up or to the left, reverse it by swapping x1/x2 or y1/y2\n       * Make the line 1 pixel longer to work around cross-platform canvas implementations\n       * If the lineWidth is odd, translate the line by 0.5 in the perpendicular direction\n       * Even lineWidths do not need to be translated because the canvas will draw them on pixel boundaries\n       * Change the cap to butt-end to work around cross-platform canvas implementations\n       * Reverse the translate and lineCap canvas state changes after drawing the line\n       */\n      if (drawCrisp) {\n        if (x1 === x2) {\n          if (y1 > y2) {\n            swap = y1;\n            y1 = y2;\n            y2 = swap;\n          }\n          y2++;\n          if (lineWidth % 2 === 1) {\n            curContext.translate(0.5, 0.0);\n          }\n        } else if (y1 === y2) {\n          if (x1 > x2) {\n            swap = x1;\n            x1 = x2;\n            x2 = swap;\n          }\n          x2++;\n          if (lineWidth % 2 === 1) {\n            curContext.translate(0.0, 0.5);\n          }\n        }\n        if (lineWidth === 1) {\n          lineCap = curContext.lineCap;\n          curContext.lineCap = 'butt';\n        }\n      }\n      curContext.beginPath();\n      curContext.moveTo(x1 || 0, y1 || 0);\n      curContext.lineTo(x2 || 0, y2 || 0);\n      executeContextStroke();\n      if (drawCrisp) {\n        if (x1 === x2 && lineWidth % 2 === 1) {\n          curContext.translate(-0.5, 0.0);\n        } else if (y1 === y2 && lineWidth % 2 === 1) {\n          curContext.translate(0.0, -0.5);\n        }\n        if (lineWidth === 1) {\n          curContext.lineCap = lineCap;\n        }\n      }\n    };\n\n    Drawing3D.prototype.line = function(x1, y1, z1, x2, y2, z2) {\n      if (y2 === undef || z2 === undef) { // 2D line called in 3D context\n        z2 = 0;\n        y2 = x2;\n        x2 = z1;\n        z1 = 0;\n      }\n\n      // a line is only defined if it has different start and end coordinates.\n      // If they are the same, we call point instead.\n      if (x1===x2 && y1===y2 && z1===z2) {\n        p.point(x1,y1,z1);\n        return;\n      }\n\n      var lineVerts = [x1, y1, z1, x2, y2, z2];\n\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.transpose();\n\n      if (lineWidth > 0 && doStroke) {\n        curContext.useProgram(programObject2D);\n\n        uniformMatrix(\"uModel2d\", programObject2D, \"uModel\", false, [1,0,0,0,  0,1,0,0,  0,0,1,0,  0,0,0,1]);\n        uniformMatrix(\"uView2d\", programObject2D, \"uView\", false, view.array());\n\n        uniformf(\"uColor2d\", programObject2D, \"uColor\", strokeStyle);\n        uniformi(\"uIsDrawingText\", programObject2D, \"uIsDrawingText\", false);\n\n        vertexAttribPointer(\"aVertex2d\", programObject2D, \"aVertex\", 3, lineBuffer);\n        disableVertexAttribPointer(\"aTextureCoord2d\", programObject2D, \"aTextureCoord\");\n\n        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(lineVerts), curContext.STREAM_DRAW);\n        curContext.drawArrays(curContext.LINES, 0, 2);\n      }\n    };\n\n    /**\n     * Draws a Bezier curve on the screen. These curves are defined by a series of anchor and control points. The first\n     * two parameters specify the first anchor point and the last two parameters specify the other anchor point. The\n     * middle parameters specify the control points which define the shape of the curve. Bezier curves were developed\n     * by French engineer Pierre Bezier. Using the 3D version of requires rendering with P3D or OPENGL (see the\n     * Environment reference for more information).\n     *\n     * @param {int | float} x1,y1,z1    coordinates for the first anchor point\n     * @param {int | float} cx1,cy1,cz1 coordinates for the first control point\n     * @param {int | float} cx2,cy2,cz2 coordinates for the second control point\n     * @param {int | float} x2,y2,z2    coordinates for the second anchor point\n     *\n     * @see bezierVertex\n     * @see curve\n     */\n    Drawing2D.prototype.bezier = function() {\n      if (arguments.length !== 8) {\n        throw(\"You must use 8 parameters for bezier() in 2D mode\");\n      }\n\n      p.beginShape();\n      p.vertex( arguments[0], arguments[1] );\n      p.bezierVertex( arguments[2], arguments[3],\n                      arguments[4], arguments[5],\n                      arguments[6], arguments[7] );\n      p.endShape();\n    };\n\n    Drawing3D.prototype.bezier = function() {\n      if (arguments.length !== 12) {\n        throw(\"You must use 12 parameters for bezier() in 3D mode\");\n      }\n\n      p.beginShape();\n      p.vertex( arguments[0], arguments[1], arguments[2] );\n      p.bezierVertex( arguments[3], arguments[4], arguments[5],\n                      arguments[6], arguments[7], arguments[8],\n                      arguments[9], arguments[10], arguments[11] );\n      p.endShape();\n    };\n\n    /**\n     * Sets the resolution at which Beziers display. The default value is 20. This function is only useful when using the P3D\n     * or OPENGL renderer as the default (JAVA2D) renderer does not use this information.\n     *\n     * @param {int} detail resolution of the curves\n     *\n     * @see curve\n     * @see curveVertex\n     * @see curveTightness\n     */\n    p.bezierDetail = function( detail ){\n      bezDetail = detail;\n    };\n\n    /**\n     * The bezierPoint() function evalutes quadratic bezier at point t for points a, b, c, d.\n     * The parameter t varies between 0 and 1. The a and d parameters are the\n     * on-curve points, b and c are the control points. To make a two-dimensional\n     * curve, call this function once with the x coordinates and a second time\n     * with the y coordinates to get the location of a bezier curve at t.\n     *\n     * @param {float} a   coordinate of first point on the curve\n     * @param {float} b   coordinate of first control point\n     * @param {float} c   coordinate of second control point\n     * @param {float} d   coordinate of second point on the curve\n     * @param {float} t   value between 0 and 1\n     *\n     * @see #bezier()\n     * @see #bezierVertex()\n     * @see #curvePoint()\n     */\n    p.bezierPoint = function(a, b, c, d, t) {\n      return (1 - t) * (1 - t) * (1 - t) * a + 3 * (1 - t) * (1 - t) * t * b + 3 * (1 - t) * t * t * c + t * t * t * d;\n    };\n\n    /**\n     * The bezierTangent() function calculates the tangent of a point on a Bezier curve. There is a good\n     * definition of \"tangent\" at Wikipedia: <a href=\"http://en.wikipedia.org/wiki/Tangent\" target=\"new\">http://en.wikipedia.org/wiki/Tangent</a>\n     *\n     * @param {float} a   coordinate of first point on the curve\n     * @param {float} b   coordinate of first control point\n     * @param {float} c   coordinate of second control point\n     * @param {float} d   coordinate of second point on the curve\n     * @param {float} t   value between 0 and 1\n     *\n     * @see #bezier()\n     * @see #bezierVertex()\n     * @see #curvePoint()\n     */\n    p.bezierTangent = function(a, b, c, d, t) {\n      return (3 * t * t * (-a + 3 * b - 3 * c + d) + 6 * t * (a - 2 * b + c) + 3 * (-a + b));\n    };\n\n    /**\n     * The curvePoint() function evalutes the Catmull-Rom curve at point t for points a, b, c, d. The\n     * parameter t varies between 0 and 1, a and d are points on the curve,\n     * and b and c are the control points. This can be done once with the x\n     * coordinates and a second time with the y coordinates to get the\n     * location of a curve at t.\n     *\n     * @param {int|float} a   coordinate of first point on the curve\n     * @param {int|float} b   coordinate of second point on the curve\n     * @param {int|float} c   coordinate of third point on the curve\n     * @param {int|float} d   coordinate of fourth point on the curve\n     * @param {float} t       value between 0 and 1\n     *\n     * @see #curve()\n     * @see #curveVertex()\n     * @see #bezierPoint()\n     */\n    p.curvePoint = function(a, b, c, d, t) {\n      return 0.5 * ((2 * b) + (-a + c) * t + (2 * a - 5 * b + 4 * c - d) * t * t + (-a + 3 * b - 3 * c + d) * t * t * t);\n    };\n\n    /**\n     * The curveTangent() function calculates the tangent of a point on a Catmull-Rom curve.\n     * There is a good definition of \"tangent\" at Wikipedia: <a href=\"http://en.wikipedia.org/wiki/Tangent\" target=\"new\">http://en.wikipedia.org/wiki/Tangent</a>.\n     *\n     * @param {int|float} a   coordinate of first point on the curve\n     * @param {int|float} b   coordinate of first control point\n     * @param {int|float} c   coordinate of second control point\n     * @param {int|float} d   coordinate of second point on the curve\n     * @param {float} t       value between 0 and 1\n     *\n     * @see #curve()\n     * @see #curveVertex()\n     * @see #curvePoint()\n     * @see #bezierTangent()\n     */\n    p.curveTangent = function(a, b, c, d, t) {\n      return 0.5 * ((-a + c) + 2 * (2 * a - 5 * b + 4 * c - d) * t + 3 * (-a + 3 * b - 3 * c + d) * t * t);\n    };\n\n    /**\n     * A triangle is a plane created by connecting three points. The first two arguments specify the first point,\n     * the middle two arguments specify the second point, and the last two arguments specify the third point.\n     *\n     * @param {int | float} x1 x-coordinate of the first point\n     * @param {int | float} y1 y-coordinate of the first point\n     * @param {int | float} x2 x-coordinate of the second point\n     * @param {int | float} y2 y-coordinate of the second point\n     * @param {int | float} x3 x-coordinate of the third point\n     * @param {int | float} y3 y-coordinate of the third point\n     */\n    p.triangle = function(x1, y1, x2, y2, x3, y3) {\n      p.beginShape(PConstants.TRIANGLES);\n      p.vertex(x1, y1, 0);\n      p.vertex(x2, y2, 0);\n      p.vertex(x3, y3, 0);\n      p.endShape();\n    };\n\n    /**\n     * A quad is a quadrilateral, a four sided polygon. It is similar to a rectangle, but the angles between its\n     * edges are not constrained to ninety degrees. The first pair of parameters (x1,y1) sets the first vertex\n     * and the subsequent pairs should proceed clockwise or counter-clockwise around the defined shape.\n     *\n     * @param {float | int} x1 x-coordinate of the first corner\n     * @param {float | int} y1 y-coordinate of the first corner\n     * @param {float | int} x2 x-coordinate of the second corner\n     * @param {float | int} y2 y-coordinate of the second corner\n     * @param {float | int} x3 x-coordinate of the third corner\n     * @param {float | int} y3 y-coordinate of the third corner\n     * @param {float | int} x4 x-coordinate of the fourth corner\n     * @param {float | int} y4 y-coordinate of the fourth corner\n     */\n    p.quad = function(x1, y1, x2, y2, x3, y3, x4, y4) {\n      p.beginShape(PConstants.QUADS);\n      p.vertex(x1, y1, 0);\n      p.vertex(x2, y2, 0);\n      p.vertex(x3, y3, 0);\n      p.vertex(x4, y4, 0);\n      p.endShape();\n    };\n\n    var roundedRect$2d = function(x, y, width, height, tl, tr, br, bl) {\n      if (bl === undef) {\n        tr = tl;\n        br = tl;\n        bl = tl;\n      }\n      var halfWidth = width / 2,\n          halfHeight = height / 2;\n      if (tl > halfWidth || tl > halfHeight) {\n        tl = Math.min(halfWidth, halfHeight);\n      }\n      if (tr > halfWidth || tr > halfHeight) {\n        tr = Math.min(halfWidth, halfHeight);\n      }\n      if (br > halfWidth || br > halfHeight) {\n        br = Math.min(halfWidth, halfHeight);\n      }\n      if (bl > halfWidth || bl > halfHeight) {\n        bl = Math.min(halfWidth, halfHeight);\n      }\n      // Translate the stroke by (0.5, 0.5) to draw a crisp border\n      if (!doFill || doStroke) {\n        curContext.translate(0.5, 0.5);\n      }\n      curContext.beginPath();\n      curContext.moveTo(x + tl, y);\n      curContext.lineTo(x + width - tr, y);\n      curContext.quadraticCurveTo(x + width, y, x + width, y + tr);\n      curContext.lineTo(x + width, y + height - br);\n      curContext.quadraticCurveTo(x + width, y + height, x + width - br, y + height);\n      curContext.lineTo(x + bl, y + height);\n      curContext.quadraticCurveTo(x, y + height, x, y + height - bl);\n      curContext.lineTo(x, y + tl);\n      curContext.quadraticCurveTo(x, y, x + tl, y);\n      if (!doFill || doStroke) {\n        curContext.translate(-0.5, -0.5);\n      }\n      executeContextFill();\n      executeContextStroke();\n    };\n\n    /**\n    * Draws a rectangle to the screen. A rectangle is a four-sided shape with every angle at ninety\n    * degrees. The first two parameters set the location, the third sets the width, and the fourth\n    * sets the height. The origin is changed with the rectMode() function.\n    *\n    * @param {int|float} x        x-coordinate of the rectangle\n    * @param {int|float} y        y-coordinate of the rectangle\n    * @param {int|float} width    width of the rectangle\n    * @param {int|float} height   height of the rectangle\n    *\n    * @see rectMode\n    * @see quad\n    */\n    Drawing2D.prototype.rect = function(x, y, width, height, tl, tr, br, bl) {\n      // width and height need to be defined, numerical values\n      if (width!=''+width && height!=''+height) {\n        return;\n      }\n\n      if (curRectMode === PConstants.CORNERS) {\n        width -= x;\n        height -= y;\n      } else if (curRectMode === PConstants.RADIUS) {\n        width *= 2;\n        height *= 2;\n        x -= width / 2;\n        y -= height / 2;\n      } else if (curRectMode === PConstants.CENTER) {\n        x -= width / 2;\n        y -= height / 2;\n      }\n\n      if (!renderSmooth) {\n        x = Math.round(x);\n        y = Math.round(y);\n        width = Math.round(width);\n        height = Math.round(height);\n      }\n      if (tl !== undef) {\n        roundedRect$2d(x, y, width, height, tl, tr, br, bl);\n        return;\n      }\n\n      // Translate the line by (0.5, 0.5) to draw a crisp rectangle border\n      if (doStroke && lineWidth % 2 === 1) {\n        curContext.translate(0.5, 0.5);\n      }\n      curContext.beginPath();\n      curContext.rect(x, y, width, height);\n      executeContextFill();\n      executeContextStroke();\n      if (doStroke && lineWidth % 2 === 1) {\n        curContext.translate(-0.5, -0.5);\n      }\n    };\n\n    Drawing3D.prototype.rect = function(x, y, width, height, tl, tr, br, bl) {\n      if (tl !== undef) {\n        throw \"rect() with rounded corners is not supported in 3D mode\";\n      }\n\n      if (curRectMode === PConstants.CORNERS) {\n        width -= x;\n        height -= y;\n      } else if (curRectMode === PConstants.RADIUS) {\n        width *= 2;\n        height *= 2;\n        x -= width / 2;\n        y -= height / 2;\n      } else if (curRectMode === PConstants.CENTER) {\n        x -= width / 2;\n        y -= height / 2;\n      }\n\n      // Modeling transformation\n      var model = new PMatrix3D();\n      model.translate(x, y, 0);\n      model.scale(width, height, 1);\n      model.transpose();\n\n      // viewing transformation needs to have Y flipped\n      // becuase that's what Processing does.\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.transpose();\n\n      if (lineWidth > 0 && doStroke) {\n        curContext.useProgram(programObject2D);\n        uniformMatrix(\"uModel2d\", programObject2D, \"uModel\", false, model.array());\n        uniformMatrix(\"uView2d\", programObject2D, \"uView\", false, view.array());\n        uniformf(\"uColor2d\", programObject2D, \"uColor\", strokeStyle);\n        uniformi(\"uIsDrawingText2d\", programObject2D, \"uIsDrawingText\", false);\n        vertexAttribPointer(\"aVertex2d\", programObject2D, \"aVertex\", 3, rectBuffer);\n        disableVertexAttribPointer(\"aTextureCoord2d\", programObject2D, \"aTextureCoord\");\n        curContext.drawArrays(curContext.LINE_LOOP, 0, rectVerts.length / 3);\n      }\n\n      if (doFill) {\n        curContext.useProgram(programObject3D);\n        uniformMatrix(\"uModel3d\", programObject3D, \"uModel\", false, model.array());\n        uniformMatrix(\"uView3d\", programObject3D, \"uView\", false, view.array());\n\n        // fix stitching problems. (lines get occluded by triangles\n        // since they share the same depth values). This is not entirely\n        // working, but it's a start for drawing the outline. So\n        // developers can start playing around with styles.\n        curContext.enable(curContext.POLYGON_OFFSET_FILL);\n        curContext.polygonOffset(1, 1);\n\n        uniformf(\"color3d\", programObject3D, \"uColor\", fillStyle);\n\n        if(lightCount > 0){\n          var v = new PMatrix3D();\n          v.set(view);\n\n          var m = new PMatrix3D();\n          m.set(model);\n\n          v.mult(m);\n\n          var normalMatrix = new PMatrix3D();\n          normalMatrix.set(v);\n          normalMatrix.invert();\n          normalMatrix.transpose();\n\n          uniformMatrix(\"uNormalTransform3d\", programObject3D, \"uNormalTransform\", false, normalMatrix.array());\n          vertexAttribPointer(\"aNormal3d\", programObject3D, \"aNormal\", 3, rectNormBuffer);\n        }\n        else{\n          disableVertexAttribPointer(\"normal3d\", programObject3D, \"aNormal\");\n        }\n\n        vertexAttribPointer(\"vertex3d\", programObject3D, \"aVertex\", 3, rectBuffer);\n\n        curContext.drawArrays(curContext.TRIANGLE_FAN, 0, rectVerts.length / 3);\n        curContext.disable(curContext.POLYGON_OFFSET_FILL);\n      }\n    };\n\n    /**\n     * Draws an ellipse (oval) in the display window. An ellipse with an equal <b>width</b> and <b>height</b> is a circle.\n     * The first two parameters set the location, the third sets the width, and the fourth sets the height. The origin may be\n     * changed with the <b>ellipseMode()</b> function.\n     *\n     * @param {float|int} x      x-coordinate of the ellipse\n     * @param {float|int} y      y-coordinate of the ellipse\n     * @param {float|int} width  width of the ellipse\n     * @param {float|int} height height of the ellipse\n     *\n     * @see ellipseMode\n     */\n    Drawing2D.prototype.ellipse = function(x, y, width, height) {\n      x = x || 0;\n      y = y || 0;\n\n      if (width <= 0 && height <= 0) {\n        return;\n      }\n\n      if (curEllipseMode === PConstants.RADIUS) {\n        width *= 2;\n        height *= 2;\n      } else if (curEllipseMode === PConstants.CORNERS) {\n        width = width - x;\n        height = height - y;\n        x += width / 2;\n        y += height / 2;\n      } else if (curEllipseMode === PConstants.CORNER) {\n        x += width / 2;\n        y += height / 2;\n      }\n\n      // Shortcut for drawing a 2D circle\n      if (width === height) {\n        curContext.beginPath();\n        curContext.arc(x, y, width / 2, 0, PConstants.TWO_PI, false);\n        executeContextFill();\n        executeContextStroke();\n      } else {\n        var w = width / 2,\n            h = height / 2,\n            C = 0.5522847498307933,\n            c_x = C * w,\n            c_y = C * h;\n\n        p.beginShape();\n        p.vertex(x + w, y);\n        p.bezierVertex(x + w, y - c_y, x + c_x, y - h, x, y - h);\n        p.bezierVertex(x - c_x, y - h, x - w, y - c_y, x - w, y);\n        p.bezierVertex(x - w, y + c_y, x - c_x, y + h, x, y + h);\n        p.bezierVertex(x + c_x, y + h, x + w, y + c_y, x + w, y);\n        p.endShape();\n      }\n    };\n\n    Drawing3D.prototype.ellipse = function(x, y, width, height) {\n      x = x || 0;\n      y = y || 0;\n\n      if (width <= 0 && height <= 0) {\n        return;\n      }\n\n      if (curEllipseMode === PConstants.RADIUS) {\n        width *= 2;\n        height *= 2;\n      } else if (curEllipseMode === PConstants.CORNERS) {\n        width = width - x;\n        height = height - y;\n        x += width / 2;\n        y += height / 2;\n      } else if (curEllipseMode === PConstants.CORNER) {\n        x += width / 2;\n        y += height / 2;\n      }\n\n      var w = width / 2,\n          h = height / 2,\n          C = 0.5522847498307933,\n          c_x = C * w,\n          c_y = C * h;\n\n      p.beginShape();\n      p.vertex(x + w, y);\n      p.bezierVertex(x + w, y - c_y, 0, x + c_x, y - h, 0, x, y - h, 0);\n      p.bezierVertex(x - c_x, y - h, 0, x - w, y - c_y, 0, x - w, y, 0);\n      p.bezierVertex(x - w, y + c_y, 0, x - c_x, y + h, 0, x, y + h, 0);\n      p.bezierVertex(x + c_x, y + h, 0, x + w, y + c_y, 0, x + w, y, 0);\n      p.endShape();\n\n      if (doFill) {\n        //temporary workaround to not working fills for bezier -- will fix later\n        var xAv = 0, yAv = 0, i, j;\n        for (i = 0; i < vertArray.length; i++) {\n          xAv += vertArray[i][0];\n          yAv += vertArray[i][1];\n        }\n        xAv /= vertArray.length;\n        yAv /= vertArray.length;\n        var vert = [],\n            fillVertArray = [],\n            colorVertArray = [];\n        vert[0] = xAv;\n        vert[1] = yAv;\n        vert[2] = 0;\n        vert[3] = 0;\n        vert[4] = 0;\n        vert[5] = fillStyle[0];\n        vert[6] = fillStyle[1];\n        vert[7] = fillStyle[2];\n        vert[8] = fillStyle[3];\n        vert[9] = strokeStyle[0];\n        vert[10] = strokeStyle[1];\n        vert[11] = strokeStyle[2];\n        vert[12] = strokeStyle[3];\n        vert[13] = normalX;\n        vert[14] = normalY;\n        vert[15] = normalZ;\n        vertArray.unshift(vert);\n        for (i = 0; i < vertArray.length; i++) {\n          for (j = 0; j < 3; j++) {\n            fillVertArray.push(vertArray[i][j]);\n          }\n          for (j = 5; j < 9; j++) {\n            colorVertArray.push(vertArray[i][j]);\n          }\n        }\n        fill3D(fillVertArray, \"TRIANGLE_FAN\", colorVertArray);\n      }\n    };\n\n    /**\n    * Sets the current normal vector. This is for drawing three dimensional shapes and surfaces and\n    * specifies a vector perpendicular to the surface of the shape which determines how lighting affects\n    * it. Processing attempts to automatically assign normals to shapes, but since that's imperfect,\n    * this is a better option when you want more control. This function is identical to glNormal3f() in OpenGL.\n    *\n    * @param {float} nx       x direction\n    * @param {float} ny       y direction\n    * @param {float} nz       z direction\n    *\n    * @see beginShape\n    * @see endShape\n    * @see lights\n    */\n    p.normal = function(nx, ny, nz) {\n      if (arguments.length !== 3 || !(typeof nx === \"number\" && typeof ny === \"number\" && typeof nz === \"number\")) {\n        throw \"normal() requires three numeric arguments.\";\n      }\n\n      normalX = nx;\n      normalY = ny;\n      normalZ = nz;\n\n      if (curShape !== 0) {\n        if (normalMode === PConstants.NORMAL_MODE_AUTO) {\n          normalMode = PConstants.NORMAL_MODE_SHAPE;\n        } else if (normalMode === PConstants.NORMAL_MODE_SHAPE) {\n          normalMode = PConstants.NORMAL_MODE_VERTEX;\n        }\n      }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Raster drawing functions\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n    * Saves an image from the display window. Images are saved in TIFF, TARGA, JPEG, and PNG format\n    * depending on the extension within the filename  parameter. For example, \"image.tif\" will have\n    * a TIFF image and \"image.png\" will save a PNG image. If no extension is included in the filename,\n    * the image will save in TIFF format and .tif will be added to the name. These files are saved to\n    * the sketch's folder, which may be opened by selecting \"Show sketch folder\" from the \"Sketch\" menu.\n    * It is not possible to use save() while running the program in a web browser.  All images saved\n    * from the main drawing window will be opaque. To save images without a background, use createGraphics().\n    *\n    * @param {String} filename      any sequence of letters and numbers\n    *\n    * @see saveFrame\n    * @see createGraphics\n    */\n    p.save = function(file, img) {\n      // file is unused at the moment\n      // may implement this differently in later release\n      if (img !== undef) {\n        return window.open(img.toDataURL(),\"_blank\");\n      }\n      return window.open(p.externals.canvas.toDataURL(),\"_blank\");\n    };\n\n    var saveNumber = 0;\n\n    p.saveFrame = function(file) {\n      if(file === undef) {\n        // use default name template if parameter is not specified\n        file = \"screen-####.png\";\n      }\n      // Increment changeable part: screen-0000.png, screen-0001.png, ...\n      var frameFilename = file.replace(/#+/, function(all) {\n        var s = \"\" + (saveNumber++);\n        while(s.length < all.length) {\n          s = \"0\" + s;\n        }\n        return s;\n      });\n      p.save(frameFilename);\n    };\n\n    var utilityContext2d = document.createElement(\"canvas\").getContext(\"2d\");\n\n    var canvasDataCache = [undef, undef, undef]; // we need three for now\n\n    function getCanvasData(obj, w, h) {\n      var canvasData = canvasDataCache.shift();\n\n      if (canvasData === undef) {\n        canvasData = {};\n        canvasData.canvas = document.createElement(\"canvas\");\n        canvasData.context = canvasData.canvas.getContext('2d');\n      }\n\n      canvasDataCache.push(canvasData);\n\n      var canvas = canvasData.canvas, context = canvasData.context,\n          width = w || obj.width, height = h || obj.height;\n\n      canvas.width = width;\n      canvas.height = height;\n\n      if (!obj) {\n        context.clearRect(0, 0, width, height);\n      } else if (\"data\" in obj) { // ImageData\n        context.putImageData(obj, 0, 0);\n      } else {\n        context.clearRect(0, 0, width, height);\n        context.drawImage(obj, 0, 0, width, height);\n      }\n      return canvasData;\n    }\n\n    /**\n     * Handle the sketch code for pixels[] and pixels.length\n     * parser code converts pixels[] to getPixels()\n     * or setPixels(), .length becomes getLength()\n     */\n    function buildPixelsObject(pImage) {\n      return {\n\n        getLength: (function(aImg) {\n          return function() {\n            if (aImg.isRemote) {\n              throw \"Image is loaded remotely. Cannot get length.\";\n            } else {\n              return aImg.imageData.data.length ? aImg.imageData.data.length/4 : 0;\n            }\n          };\n        }(pImage)),\n\n        getPixel: (function(aImg) {\n          return function(i) {\n            var offset = i*4,\n              data = aImg.imageData.data;\n\n            if (aImg.isRemote) {\n              throw \"Image is loaded remotely. Cannot get pixels.\";\n            }\n\n            return (data[offset+3] << 24) & PConstants.ALPHA_MASK |\n                   (data[offset] << 16) & PConstants.RED_MASK |\n                   (data[offset+1] << 8) & PConstants.GREEN_MASK |\n                   data[offset+2] & PConstants.BLUE_MASK;\n          };\n        }(pImage)),\n\n        setPixel: (function(aImg) {\n          return function(i, c) {\n            var offset = i*4,\n              data = aImg.imageData.data;\n\n            if (aImg.isRemote) {\n              throw \"Image is loaded remotely. Cannot set pixel.\";\n            }\n\n            data[offset+0] = (c & PConstants.RED_MASK) >>> 16;\n            data[offset+1] = (c & PConstants.GREEN_MASK) >>> 8;\n            data[offset+2] = (c & PConstants.BLUE_MASK);\n            data[offset+3] = (c & PConstants.ALPHA_MASK) >>> 24;\n            aImg.__isDirty = true;\n          };\n        }(pImage)),\n\n        toArray: (function(aImg) {\n          return function() {\n            var arr = [],\n              data = aImg.imageData.data,\n              length = aImg.width * aImg.height;\n\n            if (aImg.isRemote) {\n              throw \"Image is loaded remotely. Cannot get pixels.\";\n            }\n\n            for (var i = 0, offset = 0; i < length; i++, offset += 4) {\n              arr.push( (data[offset+3] << 24) & PConstants.ALPHA_MASK |\n                        (data[offset] << 16) & PConstants.RED_MASK |\n                        (data[offset+1] << 8) & PConstants.GREEN_MASK |\n                        data[offset+2] & PConstants.BLUE_MASK );\n            }\n            return arr;\n          };\n        }(pImage)),\n\n        set: (function(aImg) {\n          return function(arr) {\n            var offset,\n              data,\n              c;\n            if (this.isRemote) {\n              throw \"Image is loaded remotely. Cannot set pixels.\";\n            }\n\n            data = aImg.imageData.data;\n            for (var i = 0, aL = arr.length; i < aL; i++) {\n              c = arr[i];\n              offset = i*4;\n\n              data[offset+0] = (c & PConstants.RED_MASK) >>> 16;\n              data[offset+1] = (c & PConstants.GREEN_MASK) >>> 8;\n              data[offset+2] = (c & PConstants.BLUE_MASK);\n              data[offset+3] = (c & PConstants.ALPHA_MASK) >>> 24;\n            }\n            aImg.__isDirty = true;\n          };\n        }(pImage))\n\n      };\n    }\n\n    /**\n    * Datatype for storing images. Processing can display .gif, .jpg, .tga, and .png images. Images may be\n    * displayed in 2D and 3D space. Before an image is used, it must be loaded with the loadImage() function.\n    * The PImage object contains fields for the width and height of the image, as well as an array called\n    * pixels[]  which contains the values for every pixel in the image. A group of methods, described below,\n    * allow easy access to the image's pixels and alpha channel and simplify the process of compositing.\n    * Before using the pixels[] array, be sure to use the loadPixels() method on the image to make sure that the\n    * pixel data is properly loaded. To create a new image, use the createImage() function (do not use new PImage()).\n    *\n    * @param {int} width                image width\n    * @param {int} height               image height\n    * @param {MODE} format              Either RGB, ARGB, ALPHA (grayscale alpha channel)\n    *\n    * @returns {PImage}\n    *\n    * @see loadImage\n    * @see imageMode\n    * @see createImage\n    */\n    var PImage = function(aWidth, aHeight, aFormat) {\n\n      // Keep track of whether or not the cached imageData has been touched.\n      this.__isDirty = false;\n\n      if (aWidth instanceof HTMLImageElement) {\n        // convert an <img> to a PImage\n        this.fromHTMLImageData(aWidth);\n      } else if (aHeight || aFormat) {\n        this.width = aWidth || 1;\n        this.height = aHeight || 1;\n\n        // Stuff a canvas into sourceImg so image() calls can use drawImage like an <img>\n        var canvas = this.sourceImg = document.createElement(\"canvas\");\n        canvas.width = this.width;\n        canvas.height = this.height;\n\n        var imageData = this.imageData = canvas.getContext('2d').createImageData(this.width, this.height);\n        this.format = (aFormat === PConstants.ARGB || aFormat === PConstants.ALPHA) ? aFormat : PConstants.RGB;\n        if (this.format === PConstants.RGB) {\n          // Set the alpha channel of an RGB image to opaque.\n          for (var i = 3, data = this.imageData.data, len = data.length; i < len; i += 4) {\n            data[i] = 255;\n          }\n        }\n\n        this.__isDirty = true;\n        this.updatePixels();\n      } else {\n        this.width = 0;\n        this.height = 0;\n        this.imageData = utilityContext2d.createImageData(1, 1);\n        this.format = PConstants.ARGB;\n      }\n\n      this.pixels = buildPixelsObject(this);\n    };\n    PImage.prototype = {\n\n      /**\n       * Temporary hack to deal with cross-Processing-instance created PImage.  See\n       * tickets #1623 and #1644.\n       */\n      __isPImage: true,\n\n      /**\n      * @member PImage\n      * Updates the image with the data in its pixels[] array. Use in conjunction with loadPixels(). If\n      * you're only reading pixels from the array, there's no need to call updatePixels().\n      * Certain renderers may or may not seem to require loadPixels() or updatePixels(). However, the rule\n      * is that any time you want to manipulate the pixels[] array, you must first call loadPixels(), and\n      * after changes have been made, call updatePixels(). Even if the renderer may not seem to use this\n      * function in the current Processing release, this will always be subject to change.\n      * Currently, none of the renderers use the additional parameters to updatePixels().\n      */\n      updatePixels: function() {\n        var canvas = this.sourceImg;\n        if (canvas && canvas instanceof HTMLCanvasElement && this.__isDirty) {\n          canvas.getContext('2d').putImageData(this.imageData, 0, 0);\n        }\n        this.__isDirty = false;\n      },\n\n      fromHTMLImageData: function(htmlImg) {\n        // convert an <img> to a PImage\n        var canvasData = getCanvasData(htmlImg);\n        try {\n          var imageData = canvasData.context.getImageData(0, 0, htmlImg.width, htmlImg.height);\n          this.fromImageData(imageData);\n        } catch(e) {\n          if (htmlImg.width && htmlImg.height) {\n            this.isRemote = true;\n            this.width = htmlImg.width;\n            this.height = htmlImg.height;\n          }\n        }\n        this.sourceImg = htmlImg;\n      },\n\n      'get': function(x, y, w, h) {\n        if (!arguments.length) {\n          return p.get(this);\n        }\n        if (arguments.length === 2) {\n          return p.get(x, y, this);\n        }\n        if (arguments.length === 4) {\n          return p.get(x, y, w, h, this);\n        }\n      },\n\n      /**\n      * @member PImage\n      * Changes the color of any pixel or writes an image directly into the image. The x and y parameter\n      * specify the pixel or the upper-left corner of the image. The color parameter specifies the color value.\n      * Setting the color of a single pixel with set(x, y) is easy, but not as fast as putting the data\n      * directly into pixels[]. The equivalent statement to \"set(x, y, #000000)\" using pixels[] is\n      * \"pixels[y*width+x] = #000000\". Processing requires calling loadPixels() to load the display window\n      * data into the pixels[] array before getting the values and calling updatePixels() to update the window.\n      *\n      * @param {int} x        x-coordinate of the pixel or upper-left corner of the image\n      * @param {int} y        y-coordinate of the pixel or upper-left corner of the image\n      * @param {color} color  any value of the color datatype\n      *\n      * @see get\n      * @see pixels[]\n      * @see copy\n      */\n      'set': function(x, y, c) {\n        p.set(x, y, c, this);\n        this.__isDirty = true;\n      },\n\n      /**\n      * @member PImage\n      * Blends a region of pixels into the image specified by the img parameter. These copies utilize full\n      * alpha channel support and a choice of the following modes to blend the colors of source pixels (A)\n      * with the ones of pixels in the destination image (B):\n      * BLEND - linear interpolation of colours: C = A*factor + B\n      * ADD - additive blending with white clip: C = min(A*factor + B, 255)\n      * SUBTRACT - subtractive blending with black clip: C = max(B - A*factor, 0)\n      * DARKEST - only the darkest colour succeeds: C = min(A*factor, B)\n      * LIGHTEST - only the lightest colour succeeds: C = max(A*factor, B)\n      * DIFFERENCE - subtract colors from underlying image.\n      * EXCLUSION - similar to DIFFERENCE, but less extreme.\n      * MULTIPLY - Multiply the colors, result will always be darker.\n      * SCREEN - Opposite multiply, uses inverse values of the colors.\n      * OVERLAY - A mix of MULTIPLY and SCREEN. Multiplies dark values, and screens light values.\n      * HARD_LIGHT - SCREEN when greater than 50% gray, MULTIPLY when lower.\n      * SOFT_LIGHT - Mix of DARKEST and LIGHTEST. Works like OVERLAY, but not as harsh.\n      * DODGE - Lightens light tones and increases contrast, ignores darks. Called \"Color Dodge\" in Illustrator and Photoshop.\n      * BURN - Darker areas are applied, increasing contrast, ignores lights. Called \"Color Burn\" in Illustrator and Photoshop.\n      * All modes use the alpha information (highest byte) of source image pixels as the blending factor.\n      * If the source and destination regions are different sizes, the image will be automatically resized to\n      * match the destination size. If the srcImg parameter is not used, the display window is used as the source image.\n      * This function ignores imageMode().\n      *\n      * @param {int} x              X coordinate of the source's upper left corner\n      * @param {int} y              Y coordinate of the source's upper left corner\n      * @param {int} width          source image width\n      * @param {int} height         source image height\n      * @param {int} dx             X coordinate of the destinations's upper left corner\n      * @param {int} dy             Y coordinate of the destinations's upper left corner\n      * @param {int} dwidth         destination image width\n      * @param {int} dheight        destination image height\n      * @param {PImage} srcImg      an image variable referring to the source image\n      * @param {MODE} MODE          Either BLEND, ADD, SUBTRACT, LIGHTEST, DARKEST, DIFFERENCE, EXCLUSION,\n      * MULTIPLY, SCREEN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, BURN\n      *\n      * @see alpha\n      * @see copy\n      */\n      blend: function(srcImg, x, y, width, height, dx, dy, dwidth, dheight, MODE) {\n        if (arguments.length === 9) {\n          p.blend(this, srcImg, x, y, width, height, dx, dy, dwidth, dheight, this);\n        } else if (arguments.length === 10) {\n          p.blend(srcImg, x, y, width, height, dx, dy, dwidth, dheight, MODE, this);\n        }\n        delete this.sourceImg;\n      },\n\n      /**\n      * @member PImage\n      * Copies a region of pixels from one image into another. If the source and destination regions\n      * aren't the same size, it will automatically resize source pixels to fit the specified target region.\n      * No alpha information is used in the process, however if the source image has an alpha channel set,\n      * it will be copied as well. This function ignores imageMode().\n      *\n      * @param {int} sx             X coordinate of the source's upper left corner\n      * @param {int} sy             Y coordinate of the source's upper left corner\n      * @param {int} swidth         source image width\n      * @param {int} sheight        source image height\n      * @param {int} dx             X coordinate of the destinations's upper left corner\n      * @param {int} dy             Y coordinate of the destinations's upper left corner\n      * @param {int} dwidth         destination image width\n      * @param {int} dheight        destination image height\n      * @param {PImage} srcImg      an image variable referring to the source image\n      *\n      * @see alpha\n      * @see blend\n      */\n      copy: function(srcImg, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {\n        if (arguments.length === 8) {\n          p.blend(this, srcImg, sx, sy, swidth, sheight, dx, dy, dwidth, PConstants.REPLACE, this);\n        } else if (arguments.length === 9) {\n          p.blend(srcImg, sx, sy, swidth, sheight, dx, dy, dwidth, dheight, PConstants.REPLACE, this);\n        }\n        delete this.sourceImg;\n      },\n\n      /**\n      * @member PImage\n      * Filters an image as defined by one of the following modes:\n      * THRESHOLD - converts the image to black and white pixels depending if they are above or below\n      * the threshold defined by the level parameter. The level must be between 0.0 (black) and 1.0(white).\n      * If no level is specified, 0.5 is used.\n      * GRAY - converts any colors in the image to grayscale equivalents\n      * INVERT - sets each pixel to its inverse value\n      * POSTERIZE - limits each channel of the image to the number of colors specified as the level parameter\n      * BLUR - executes a Guassian blur with the level parameter specifying the extent of the blurring.\n      * If no level parameter is used, the blur is equivalent to Guassian blur of radius 1.\n      * OPAQUE - sets the alpha channel to entirely opaque.\n      * ERODE - reduces the light areas with the amount defined by the level parameter.\n      * DILATE - increases the light areas with the amount defined by the level parameter\n      *\n      * @param {MODE} MODE        Either THRESHOLD, GRAY, INVERT, POSTERIZE, BLUR, OPAQUE, ERODE, or DILATE\n      * @param {int|float} param  in the range from 0 to 1\n      */\n      filter: function(mode, param) {\n        if (arguments.length === 2) {\n          p.filter(mode, param, this);\n        } else if (arguments.length === 1) {\n          // no param specified, send null to show its invalid\n          p.filter(mode, null, this);\n        }\n        delete this.sourceImg;\n      },\n\n      /**\n      * @member PImage\n      * Saves the image into a file. Images are saved in TIFF, TARGA, JPEG, and PNG format depending on\n      * the extension within the filename  parameter. For example, \"image.tif\" will have a TIFF image and\n      * \"image.png\" will save a PNG image. If no extension is included in the filename, the image will save\n      * in TIFF format and .tif will be added to the name. These files are saved to the sketch's folder,\n      * which may be opened by selecting \"Show sketch folder\" from the \"Sketch\" menu. It is not possible to\n      * use save() while running the program in a web browser.\n      * To save an image created within the code, rather than through loading, it's necessary to make the\n      * image with the createImage() function so it is aware of the location of the program and can therefore\n      * save the file to the right place. See the createImage() reference for more information.\n      *\n      * @param {String} filename        a sequence of letters and numbers\n      */\n      save: function(file){\n        p.save(file,this);\n      },\n\n      /**\n      * @member PImage\n      * Resize the image to a new width and height. To make the image scale proportionally, use 0 as the\n      * value for the wide or high parameter.\n      *\n      * @param {int} wide         the resized image width\n      * @param {int} high         the resized image height\n      *\n      * @see get\n      */\n      resize: function(w, h) {\n        if (this.isRemote) { // Remote images cannot access imageData\n          throw \"Image is loaded remotely. Cannot resize.\";\n        }\n        if (this.width !== 0 || this.height !== 0) {\n          // make aspect ratio if w or h is 0\n          if (w === 0 && h !== 0) {\n            w = Math.floor(this.width / this.height * h);\n          } else if (h === 0 && w !== 0) {\n            h = Math.floor(this.height / this.width * w);\n          }\n          // put 'this.imageData' into a new canvas\n          var canvas = getCanvasData(this.imageData).canvas;\n          // pull imageData object out of canvas into ImageData object\n          var imageData = getCanvasData(canvas, w, h).context.getImageData(0, 0, w, h);\n          // set this as new pimage\n          this.fromImageData(imageData);\n        }\n      },\n\n      /**\n      * @member PImage\n      * Masks part of an image from displaying by loading another image and using it as an alpha channel.\n      * This mask image should only contain grayscale data, but only the blue color channel is used. The\n      * mask image needs to be the same size as the image to which it is applied.\n      * In addition to using a mask image, an integer array containing the alpha channel data can be\n      * specified directly. This method is useful for creating dynamically generated alpha masks. This\n      * array must be of the same length as the target image's pixels array and should contain only grayscale\n      * data of values between 0-255.\n      *\n      * @param {PImage} maskImg         any PImage object used as the alpha channel for \"img\", needs to be same\n      *                                 size as \"img\"\n      * @param {int[]} maskArray        any array of Integer numbers used as the alpha channel, needs to be same\n      *                                 length as the image's pixel array\n      */\n      mask: function(mask) {\n        var obj = this.toImageData(),\n            i,\n            size;\n\n        if (mask instanceof PImage || mask.__isPImage) {\n          if (mask.width === this.width && mask.height === this.height) {\n            mask = mask.toImageData();\n\n            for (i = 2, size = this.width * this.height * 4; i < size; i += 4) {\n              // using it as an alpha channel\n              obj.data[i + 1] = mask.data[i];\n              // but only the blue color channel\n            }\n          } else {\n            throw \"mask must have the same dimensions as PImage.\";\n          }\n        } else if (mask instanceof Array) {\n          if (this.width * this.height === mask.length) {\n            for (i = 0, size = mask.length; i < size; ++i) {\n              obj.data[i * 4 + 3] = mask[i];\n            }\n          } else {\n            throw \"mask array must be the same length as PImage pixels array.\";\n          }\n        }\n\n        this.fromImageData(obj);\n      },\n\n      // These are intentionally left blank for PImages, we work live with pixels and draw as necessary\n      /**\n      * @member PImage\n      * Loads the pixel data for the image into its pixels[] array. This function must always be called\n      * before reading from or writing to pixels[].\n      * Certain renderers may or may not seem to require loadPixels() or updatePixels(). However, the\n      * rule is that any time you want to manipulate the pixels[] array, you must first call loadPixels(),\n      * and after changes have been made, call updatePixels(). Even if the renderer may not seem to use\n      * this function in the current Processing release, this will always be subject to change.\n      */\n      loadPixels: noop,\n\n      toImageData: function() {\n        if (this.isRemote) {\n          return this.sourceImg;\n        }\n\n        if (!this.__isDirty) {\n          return this.imageData;\n        }\n\n        var canvasData = getCanvasData(this.sourceImg);\n        return canvasData.context.getImageData(0, 0, this.width, this.height);\n      },\n\n      toDataURL: function() {\n        if (this.isRemote) { // Remote images cannot access imageData\n          throw \"Image is loaded remotely. Cannot create dataURI.\";\n        }\n        var canvasData = getCanvasData(this.imageData);\n        return canvasData.canvas.toDataURL();\n      },\n\n      fromImageData: function(canvasImg) {\n        var w = canvasImg.width,\n          h = canvasImg.height,\n          canvas = document.createElement('canvas'),\n          ctx = canvas.getContext('2d');\n\n        this.width = canvas.width = w;\n        this.height = canvas.height = h;\n\n        ctx.putImageData(canvasImg, 0, 0);\n\n        // changed for 0.9\n        this.format = PConstants.ARGB;\n\n        this.imageData = canvasImg;\n        this.sourceImg = canvas;\n      }\n    };\n\n    p.PImage = PImage;\n\n    /**\n    * Creates a new PImage (the datatype for storing images). This provides a fresh buffer of pixels to play\n    * with. Set the size of the buffer with the width and height parameters. The format parameter defines how\n    * the pixels are stored. See the PImage reference for more information.\n    * Be sure to include all three parameters, specifying only the width and height (but no format) will\n    * produce a strange error.\n    * Advanced users please note that createImage() should be used instead of the syntax new PImage().\n    *\n    * @param {int} width                image width\n    * @param {int} height               image height\n    * @param {MODE} format              Either RGB, ARGB, ALPHA (grayscale alpha channel)\n    *\n    * @returns {PImage}\n    *\n    * @see PImage\n    * @see PGraphics\n    */\n    p.createImage = function(w, h, mode) {\n      return new PImage(w,h,mode);\n    };\n\n    // Loads an image for display. Type is an extension. Callback is fired on load.\n    /**\n    * Loads an image into a variable of type PImage. Four types of images ( .gif, .jpg, .tga, .png) images may\n    * be loaded. To load correctly, images must be located in the data directory of the current sketch. In most\n    * cases, load all images in setup() to preload them at the start of the program. Loading images inside draw()\n    * will reduce the speed of a program.\n    * The filename parameter can also be a URL to a file found online. For security reasons, a Processing sketch\n    * found online can only download files from the same server from which it came. Getting around this restriction\n    * requires a signed applet.\n    * The extension parameter is used to determine the image type in cases where the image filename does not end\n    * with a proper extension. Specify the extension as the second parameter to loadImage(), as shown in the\n    * third example on this page.\n    * If an image is not loaded successfully, the null value is returned and an error message will be printed to\n    * the console. The error message does not halt the program, however the null value may cause a NullPointerException\n    * if your code does not check whether the value returned from loadImage() is null.\n    * Depending on the type of error, a PImage object may still be returned, but the width and height of the image\n    * will be set to -1. This happens if bad image data is returned or cannot be decoded properly. Sometimes this happens\n    * with image URLs that produce a 403 error or that redirect to a password prompt, because loadImage() will attempt\n    * to interpret the HTML as image data.\n    *\n    * @param {String} filename        name of file to load, can be .gif, .jpg, .tga, or a handful of other image\n    *                                 types depending on your platform.\n    * @param {String} extension       the type of image to load, for example \"png\", \"gif\", \"jpg\"\n    *\n    * @returns {PImage}\n    *\n    * @see PImage\n    * @see image\n    * @see imageMode\n    * @see background\n    */\n    p.loadImage = function(file, type, callback) {\n      // if type is specified, we just ignore it\n\n      var pimg;\n      // if image is in the preloader cache return a new PImage\n      if (curSketch.imageCache.images[file]) {\n        pimg = new PImage(curSketch.imageCache.images[file]);\n        pimg.loaded = true;\n        return pimg;\n      }\n      // else async load it\n      pimg = new PImage();\n      var img = document.createElement('img');\n\n      pimg.sourceImg = img;\n\n      img.onload = (function(aImage, aPImage, aCallback) {\n        var image = aImage;\n        var pimg = aPImage;\n        var callback = aCallback;\n        return function() {\n          // change the <img> object into a PImage now that its loaded\n          pimg.fromHTMLImageData(image);\n          pimg.loaded = true;\n          if (callback) {\n            callback();\n          }\n        };\n      }(img, pimg, callback));\n\n      img.src = file; // needs to be called after the img.onload function is declared or it wont work in opera\n      return pimg;\n    };\n\n    // async loading of large images, same functionality as loadImage above\n    /**\n    * This function load images on a separate thread so that your sketch does not freeze while images load during\n    * setup(). While the image is loading, its width and height will be 0. If an error occurs while loading the image,\n    * its width and height will be set to -1. You'll know when the image has loaded properly because its width and\n    * height will be greater than 0. Asynchronous image loading (particularly when downloading from a server) can\n    * dramatically improve performance.\n    * The extension parameter is used to determine the image type in cases where the image filename does not end\n    * with a proper extension. Specify the extension as the second parameter to requestImage().\n    *\n    * @param {String} filename        name of file to load, can be .gif, .jpg, .tga, or a handful of other image\n    *                                 types depending on your platform.\n    * @param {String} extension       the type of image to load, for example \"png\", \"gif\", \"jpg\"\n    *\n    * @returns {PImage}\n    *\n    * @see PImage\n    * @see loadImage\n    */\n    p.requestImage = p.loadImage;\n\n    function get$2(x,y) {\n      var data;\n      // return the color at x,y (int) of curContext\n      if (x >= p.width || x < 0 || y < 0 || y >= p.height) {\n        // x,y is outside image return transparent black\n        return 0;\n      }\n\n      // loadPixels() has been called\n      if (isContextReplaced) {\n        var offset = ((0|x) + p.width * (0|y)) * 4;\n        data = p.imageData.data;\n        return (data[offset + 3] << 24) & PConstants.ALPHA_MASK |\n               (data[offset] << 16) & PConstants.RED_MASK |\n               (data[offset + 1] << 8) & PConstants.GREEN_MASK |\n               data[offset + 2] & PConstants.BLUE_MASK;\n      }\n\n      // x,y is inside canvas space\n      data = p.toImageData(0|x, 0|y, 1, 1).data;\n      return (data[3] << 24) & PConstants.ALPHA_MASK |\n             (data[0] << 16) & PConstants.RED_MASK |\n             (data[1] << 8) & PConstants.GREEN_MASK |\n             data[2] & PConstants.BLUE_MASK;\n    }\n    function get$3(x,y,img) {\n      if (img.isRemote) { // Remote images cannot access imageData\n        throw \"Image is loaded remotely. Cannot get x,y.\";\n      }\n      // PImage.get(x,y) was called, return the color (int) at x,y of img\n      var offset = y * img.width * 4 + (x * 4),\n          data = img.imageData.data;\n      return (data[offset + 3] << 24) & PConstants.ALPHA_MASK |\n             (data[offset] << 16) & PConstants.RED_MASK |\n             (data[offset + 1] << 8) & PConstants.GREEN_MASK |\n             data[offset + 2] & PConstants.BLUE_MASK;\n    }\n    function get$4(x, y, w, h) {\n      // return a PImage of w and h from cood x,y of curContext\n      var c = new PImage(w, h, PConstants.ARGB);\n      c.fromImageData(p.toImageData(x, y, w, h));\n      return c;\n    }\n    function get$5(x, y, w, h, img) {\n      if (img.isRemote) { // Remote images cannot access imageData\n        throw \"Image is loaded remotely. Cannot get x,y,w,h.\";\n      }\n      // PImage.get(x,y,w,h) was called, return x,y,w,h PImage of img\n      // offset start point needs to be *4\n      var c = new PImage(w, h, PConstants.ARGB), cData = c.imageData.data,\n        imgWidth = img.width, imgHeight = img.height, imgData = img.imageData.data;\n      // Don't need to copy pixels from the image outside ranges.\n      var startRow = Math.max(0, -y), startColumn = Math.max(0, -x),\n        stopRow = Math.min(h, imgHeight - y), stopColumn = Math.min(w, imgWidth - x);\n      for (var i = startRow; i < stopRow; ++i) {\n        var sourceOffset = ((y + i) * imgWidth + (x + startColumn)) * 4;\n        var targetOffset = (i * w + startColumn) * 4;\n        for (var j = startColumn; j < stopColumn; ++j) {\n          cData[targetOffset++] = imgData[sourceOffset++];\n          cData[targetOffset++] = imgData[sourceOffset++];\n          cData[targetOffset++] = imgData[sourceOffset++];\n          cData[targetOffset++] = imgData[sourceOffset++];\n        }\n      }\n      c.__isDirty = true;\n      return c;\n    }\n\n    // Gets a single pixel or block of pixels from the current Canvas Context or a PImage\n    /**\n    * Reads the color of any pixel or grabs a section of an image. If no parameters are specified, the entire\n    * image is returned. Get the value of one pixel by specifying an x,y coordinate. Get a section of the display\n    * window by specifying an additional width and height parameter. If the pixel requested is outside of the image\n    * window, black is returned. The numbers returned are scaled according to the current color ranges, but only RGB\n    * values are returned by this function. For example, even though you may have drawn a shape with colorMode(HSB),\n    * the numbers returned will be in RGB.\n    * Getting the color of a single pixel with get(x, y) is easy, but not as fast as grabbing the data directly\n    * from pixels[]. The equivalent statement to \"get(x, y)\" using pixels[] is \"pixels[y*width+x]\". Processing\n    * requires calling loadPixels() to load the display window data into the pixels[] array before getting the values.\n    * This function ignores imageMode().\n    *\n    * @param {int} x            x-coordinate of the pixel\n    * @param {int} y            y-coordinate of the pixel\n    * @param {int} width        width of pixel rectangle to get\n    * @param {int} height       height of pixel rectangle to get\n    *\n    * @returns {Color|PImage}\n    *\n    * @see set\n    * @see pixels[]\n    * @see imageMode\n    */\n    p.get = function(x, y, w, h, img) {\n      // for 0 2 and 4 arguments use curContext, otherwise PImage.get was called\n      if (img !== undefined) {\n        return get$5(x, y, w, h, img);\n      }\n      if (h !== undefined) {\n        return get$4(x, y, w, h);\n      }\n      if (w !== undefined) {\n        return get$3(x, y, w);\n      }\n      if (y !== undefined) {\n        return get$2(x, y);\n      }\n      if (x !== undefined) {\n        // PImage.get() was called, return a new PImage\n        return get$5(0, 0, x.width, x.height, x);\n      }\n\n      return get$4(0, 0, p.width, p.height);\n    };\n\n    /**\n     * Creates and returns a new <b>PGraphics</b> object of the types P2D, P3D, and JAVA2D. Use this class if you need to draw\n     * into an off-screen graphics buffer. It's not possible to use <b>createGraphics()</b> with OPENGL, because it doesn't\n     * allow offscreen use. The DXF and PDF renderers require the filename parameter. <br /><br /> It's important to call\n     * any drawing commands between beginDraw() and endDraw() statements. This is also true for any commands that affect\n     * drawing, such as smooth() or colorMode().<br /><br /> Unlike the main drawing surface which is completely opaque,\n     * surfaces created with createGraphics() can have transparency. This makes it possible to draw into a graphics and\n     * maintain the alpha channel.\n     *\n     * @param {int} width       width in pixels\n     * @param {int} height      height in pixels\n     * @param {int} renderer    Either P2D, P3D, JAVA2D, PDF, DXF\n     * @param {String} filename the name of the file (not supported yet)\n     */\n    p.createGraphics = function(w, h, render) {\n      var pg = new Processing();\n      pg.size(w, h, render);\n      pg.background(0,0);\n      return pg;\n    };\n\n    // pixels caching\n    function resetContext() {\n      if(isContextReplaced) {\n        curContext = originalContext;\n        isContextReplaced = false;\n\n        p.updatePixels();\n      }\n    }\n    function SetPixelContextWrapper() {\n      function wrapFunction(newContext, name) {\n        function wrapper() {\n          resetContext();\n          curContext[name].apply(curContext, arguments);\n        }\n        newContext[name] = wrapper;\n      }\n      function wrapProperty(newContext, name) {\n        function getter() {\n          resetContext();\n          return curContext[name];\n        }\n        function setter(value) {\n          resetContext();\n          curContext[name] = value;\n        }\n        p.defineProperty(newContext, name, { get: getter, set: setter });\n      }\n      for(var n in curContext) {\n        if(typeof curContext[n] === 'function') {\n          wrapFunction(this, n);\n        } else {\n          wrapProperty(this, n);\n        }\n      }\n    }\n    function replaceContext() {\n      if(isContextReplaced) {\n        return;\n      }\n      p.loadPixels();\n      if(proxyContext === null) {\n        originalContext = curContext;\n        proxyContext = new SetPixelContextWrapper();\n      }\n      isContextReplaced = true;\n      curContext = proxyContext;\n      setPixelsCached = 0;\n    }\n\n    function set$3(x, y, c) {\n      if (x < p.width && x >= 0 && y >= 0 && y < p.height) {\n        replaceContext();\n        p.pixels.setPixel((0|x)+p.width*(0|y), c);\n        if(++setPixelsCached > maxPixelsCached) {\n          resetContext();\n        }\n      }\n    }\n    function set$4(x, y, obj, img) {\n      if (img.isRemote) { // Remote images cannot access imageData\n        throw \"Image is loaded remotely. Cannot set x,y.\";\n      }\n      var c = p.color.toArray(obj);\n      var offset = y * img.width * 4 + (x*4);\n      var data = img.imageData.data;\n      data[offset] = c[0];\n      data[offset+1] = c[1];\n      data[offset+2] = c[2];\n      data[offset+3] = c[3];\n    }\n\n    // Paints a pixel array into the canvas\n    /**\n    * Changes the color of any pixel or writes an image directly into the display window. The x and y parameters\n    * specify the pixel to change and the color  parameter specifies the color value. The color parameter is affected\n    * by the current color mode (the default is RGB values from 0 to 255). When setting an image, the x and y\n    * parameters define the coordinates for the upper-left corner of the image.\n    * Setting the color of a single pixel with set(x, y) is easy, but not as fast as putting the data directly\n    * into pixels[]. The equivalent statement to \"set(x, y, #000000)\" using pixels[] is \"pixels[y*width+x] = #000000\".\n    * You must call loadPixels() to load the display window data into the pixels[] array before setting the values\n    * and calling updatePixels() to update the window with any changes. This function ignores imageMode().\n    *\n    * @param {int} x            x-coordinate of the pixel\n    * @param {int} y            y-coordinate of the pixel\n    * @param {Color} obj        any value of the color datatype\n    * @param {PImage} img       any valid variable of type PImage\n    *\n    * @see get\n    * @see pixels[]\n    * @see imageMode\n    */\n    p.set = function(x, y, obj, img) {\n      var color, oldFill;\n      if (arguments.length === 3) {\n        // called p.set(), was it with a color or a img ?\n        if (typeof obj === \"number\") {\n          set$3(x, y, obj);\n        } else if (obj instanceof PImage || obj.__isPImage) {\n          p.image(obj, x, y);\n        }\n      } else if (arguments.length === 4) {\n        // PImage.set(x,y,c) was called, set coordinate x,y color to c of img\n        set$4(x, y, obj, img);\n      }\n    };\n    p.imageData = {};\n\n    // handle the sketch code for pixels[]\n    // parser code converts pixels[] to getPixels() or setPixels(),\n    // .length becomes getLength()\n    /**\n    * Array containing the values for all the pixels in the display window. These values are of the color datatype.\n    * This array is the size of the display window. For example, if the image is 100x100 pixels, there will be 10000\n    * values and if the window is 200x300 pixels, there will be 60000 values. The index value defines the position\n    * of a value within the array. For example, the statment color b = pixels[230] will set the variable b to be\n    * equal to the value at that location in the array.\n    * Before accessing this array, the data must loaded with the loadPixels() function. After the array data has\n    * been modified, the updatePixels() function must be run to update the changes.\n    *\n    * @param {int} index      must not exceed the size of the array\n    *\n    * @see loadPixels\n    * @see updatePixels\n    * @see get\n    * @see set\n    * @see PImage\n    */\n    p.pixels = {\n      getLength: function() { return p.imageData.data.length ? p.imageData.data.length/4 : 0; },\n      getPixel: function(i) {\n        var offset = i*4, data = p.imageData.data;\n        return (data[offset+3] << 24) & 0xff000000 |\n               (data[offset+0] << 16) & 0x00ff0000 |\n               (data[offset+1] << 8) & 0x0000ff00 |\n               data[offset+2] & 0x000000ff;\n      },\n      setPixel: function(i,c) {\n        var offset = i*4, data = p.imageData.data;\n        data[offset+0] = (c & 0x00ff0000) >>> 16; // RED_MASK\n        data[offset+1] = (c & 0x0000ff00) >>> 8;  // GREEN_MASK\n        data[offset+2] = (c & 0x000000ff);        // BLUE_MASK\n        data[offset+3] = (c & 0xff000000) >>> 24; // ALPHA_MASK\n      },\n      toArray: function() {\n        var arr = [], length = p.imageData.width * p.imageData.height, data = p.imageData.data;\n        for (var i = 0, offset = 0; i < length; i++, offset += 4) {\n          arr.push((data[offset+3] << 24) & 0xff000000 |\n                   (data[offset+0] << 16) & 0x00ff0000 |\n                   (data[offset+1] << 8) & 0x0000ff00 |\n                   data[offset+2] & 0x000000ff);\n        }\n        return arr;\n      },\n      set: function(arr) {\n        for (var i = 0, aL = arr.length; i < aL; i++) {\n          this.setPixel(i, arr[i]);\n        }\n      }\n    };\n\n    // Gets a 1-Dimensional pixel array from Canvas\n    /**\n    * Loads the pixel data for the display window into the pixels[] array. This function must always be called\n    * before reading from or writing to pixels[].\n    * Certain renderers may or may not seem to require loadPixels() or updatePixels(). However, the rule is that\n    * any time you want to manipulate the pixels[] array, you must first call loadPixels(), and after changes\n    * have been made, call updatePixels(). Even if the renderer may not seem to use this function in the current\n    * Processing release, this will always be subject to change.\n    *\n    * @see pixels[]\n    * @see updatePixels\n    */\n    p.loadPixels = function() {\n      p.imageData = drawing.$ensureContext().getImageData(0, 0, p.width, p.height);\n    };\n\n    // Draws a 1-Dimensional pixel array to Canvas\n    /**\n    * Updates the display window with the data in the pixels[] array. Use in conjunction with loadPixels(). If\n    * you're only reading pixels from the array, there's no need to call updatePixels() unless there are changes.\n    * Certain renderers may or may not seem to require loadPixels() or updatePixels(). However, the rule is that\n    * any time you want to manipulate the pixels[] array, you must first call loadPixels(), and after changes\n    * have been made, call updatePixels(). Even if the renderer may not seem to use this function in the current\n    * Processing release, this will always be subject to change.\n    * Currently, none of the renderers use the additional parameters to updatePixels(), however this may be\n    * implemented in the future.\n    *\n    * @see loadPixels\n    * @see pixels[]\n    */\n    p.updatePixels = function() {\n      if (p.imageData) {\n        drawing.$ensureContext().putImageData(p.imageData, 0, 0);\n      }\n    };\n\n    /**\n    * Set various hints and hacks for the renderer. This is used to handle obscure rendering features that cannot be\n    * implemented in a consistent manner across renderers. Many options will often graduate to standard features\n    * instead of hints over time.\n    * hint(ENABLE_OPENGL_4X_SMOOTH) - Enable 4x anti-aliasing for OpenGL. This can help force anti-aliasing if\n    * it has not been enabled by the user. On some graphics cards, this can also be set by the graphics driver's\n    * control panel, however not all cards make this available. This hint must be called immediately after the\n    * size() command because it resets the renderer, obliterating any settings and anything drawn (and like size(),\n    * re-running the code that came before it again).\n    * hint(DISABLE_OPENGL_2X_SMOOTH) - In Processing 1.0, Processing always enables 2x smoothing when the OpenGL\n    * renderer is used. This hint disables the default 2x smoothing and returns the smoothing behavior found in\n    * earlier releases, where smooth() and noSmooth() could be used to enable and disable smoothing, though the\n    * quality was inferior.\n    * hint(ENABLE_NATIVE_FONTS) - Use the native version fonts when they are installed, rather than the bitmapped\n    * version from a .vlw file. This is useful with the JAVA2D renderer setting, as it will improve font rendering\n    * speed. This is not enabled by default, because it can be misleading while testing because the type will look\n    * great on your machine (because you have the font installed) but lousy on others' machines if the identical\n    * font is unavailable. This option can only be set per-sketch, and must be called before any use of textFont().\n    * hint(DISABLE_DEPTH_TEST) - Disable the zbuffer, allowing you to draw on top of everything at will. When depth\n    * testing is disabled, items will be drawn to the screen sequentially, like a painting. This hint is most often\n    * used to draw in 3D, then draw in 2D on top of it (for instance, to draw GUI controls in 2D on top of a 3D\n    * interface). Starting in release 0149, this will also clear the depth buffer. Restore the default with\n    * hint(ENABLE_DEPTH_TEST), but note that with the depth buffer cleared, any 3D drawing that happens later in\n    * draw() will ignore existing shapes on the screen.\n    * hint(ENABLE_DEPTH_SORT) - Enable primitive z-sorting of triangles and lines in P3D and OPENGL. This can slow\n    * performance considerably, and the algorithm is not yet perfect. Restore the default with hint(DISABLE_DEPTH_SORT).\n    * hint(DISABLE_OPENGL_ERROR_REPORT) - Speeds up the OPENGL renderer setting by not checking for errors while\n    * running. Undo with hint(ENABLE_OPENGL_ERROR_REPORT).\n    * As of release 0149, unhint() has been removed in favor of adding additional ENABLE/DISABLE constants to reset\n    * the default behavior. This prevents the double negatives, and also reinforces which hints can be enabled or disabled.\n    *\n    * @param {MODE} item          constant: name of the hint to be enabled or disabled\n    *\n    * @see PGraphics\n    * @see createGraphics\n    * @see size\n    */\n    p.hint = function(which) {\n      var curContext = drawing.$ensureContext();\n      if (which === PConstants.DISABLE_DEPTH_TEST) {\n         curContext.disable(curContext.DEPTH_TEST);\n         curContext.depthMask(false);\n         curContext.clear(curContext.DEPTH_BUFFER_BIT);\n      }\n      else if (which === PConstants.ENABLE_DEPTH_TEST) {\n         curContext.enable(curContext.DEPTH_TEST);\n         curContext.depthMask(true);\n      }\n      else if (which === PConstants.ENABLE_OPENGL_2X_SMOOTH ||\n               which === PConstants.ENABLE_OPENGL_4X_SMOOTH){\n        renderSmooth = true;\n      }\n      else if (which === PConstants.DISABLE_OPENGL_2X_SMOOTH){\n        renderSmooth = false;\n      }\n    };\n\n    /**\n     * The background() function sets the color used for the background of the Processing window.\n     * The default background is light gray. In the <b>draw()</b> function, the background color is used to clear the display window at the beginning of each frame.\n     * An image can also be used as the background for a sketch, however its width and height must be the same size as the sketch window.\n     * To resize an image 'b' to the size of the sketch window, use b.resize(width, height).\n     * Images used as background will ignore the current <b>tint()</b> setting.\n     * For the main drawing surface, the alpha value will be ignored. However,\n     * alpha can be used on PGraphics objects from <b>createGraphics()</b>. This is\n     * the only way to set all the pixels partially transparent, for instance.\n     * If the 'gray' parameter is passed in the function sets the background to a grayscale value, based on the\n     * current colorMode.\n     * <p>\n     * Note that background() should be called before any transformations occur,\n     * because some implementations may require the current transformation matrix\n     * to be identity before drawing.\n     *\n     * @param {int|float} gray    specifies a value between white and black\n     * @param {int|float} value1  red or hue value (depending on the current color mode)\n     * @param {int|float} value2  green or saturation value (depending on the current color mode)\n     * @param {int|float} value3  blue or brightness value (depending on the current color mode)\n     * @param {int|float} alpha   opacity of the background\n     * @param {Color} color       any value of the color datatype\n     * @param {int} hex           color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)\n     * @param {PImage} image      an instance of a PImage to use as a background\n     *\n     * @see #stroke()\n     * @see #fill()\n     * @see #tint()\n     * @see #colorMode()\n     */\n    var backgroundHelper = function(arg1, arg2, arg3, arg4) {\n      var obj;\n\n      if (arg1 instanceof PImage || arg1.__isPImage) {\n        obj = arg1;\n\n        if (!obj.loaded) {\n          throw \"Error using image in background(): PImage not loaded.\";\n        }\n        if(obj.width !== p.width || obj.height !== p.height){\n          throw \"Background image must be the same dimensions as the canvas.\";\n        }\n      } else {\n        obj = p.color(arg1, arg2, arg3, arg4);\n      }\n\n      backgroundObj = obj;\n    };\n\n    Drawing2D.prototype.background = function(arg1, arg2, arg3, arg4) {\n      if (arg1 !== undef) {\n        backgroundHelper(arg1, arg2, arg3, arg4);\n      }\n\n      if (backgroundObj instanceof PImage || backgroundObj.__isPImage) {\n        saveContext();\n        curContext.setTransform(1, 0, 0, 1, 0, 0);\n        p.image(backgroundObj, 0, 0);\n        restoreContext();\n      } else {\n        saveContext();\n        curContext.setTransform(1, 0, 0, 1, 0, 0);\n\n        // If the background is transparent\n        if (p.alpha(backgroundObj) !== colorModeA) {\n          curContext.clearRect(0,0, p.width, p.height);\n        }\n        curContext.fillStyle = p.color.toString(backgroundObj);\n        curContext.fillRect(0, 0, p.width, p.height);\n        isFillDirty = true;\n        restoreContext();\n      }\n    };\n\n    Drawing3D.prototype.background = function(arg1, arg2, arg3, arg4) {\n      if (arguments.length > 0) {\n        backgroundHelper(arg1, arg2, arg3, arg4);\n      }\n\n      var c = p.color.toGLArray(backgroundObj);\n      curContext.clearColor(c[0], c[1], c[2], c[3]);\n      curContext.clear(curContext.COLOR_BUFFER_BIT | curContext.DEPTH_BUFFER_BIT);\n\n      // An image as a background in 3D is not implemented yet\n    };\n\n    // Draws an image to the Canvas\n    /**\n    * Displays images to the screen. The images must be in the sketch's \"data\" directory to load correctly. Select \"Add\n    * file...\" from the \"Sketch\" menu to add the image. Processing currently works with GIF, JPEG, and Targa images. The\n    * color of an image may be modified with the tint() function and if a GIF has transparency, it will maintain its\n    * transparency. The img parameter specifies the image to display and the x and y parameters define the location of\n    * the image from its upper-left corner. The image is displayed at its original size unless the width and height\n    * parameters specify a different size. The imageMode() function changes the way the parameters work. A call to\n    * imageMode(CORNERS) will change the width and height parameters to define the x and y values of the opposite\n    * corner of the image.\n    *\n    * @param {PImage} img            the image to display\n    * @param {int|float} x           x-coordinate of the image\n    * @param {int|float} y           y-coordinate of the image\n    * @param {int|float} width       width to display the image\n    * @param {int|float} height      height to display the image\n    *\n    * @see loadImage\n    * @see PImage\n    * @see imageMode\n    * @see tint\n    * @see background\n    * @see alpha\n    */\n    Drawing2D.prototype.image = function(img, x, y, w, h) {\n      // Fix fractional positions\n      x = Math.round(x);\n      y = Math.round(y);\n\n      if (img.width > 0) {\n        var wid = w || img.width;\n        var hgt = h || img.height;\n\n        var bounds = imageModeConvert(x || 0, y || 0, w || img.width, h || img.height, arguments.length < 4);\n        var fastImage = !!img.sourceImg && curTint === null;\n        if (fastImage) {\n          var htmlElement = img.sourceImg;\n          if (img.__isDirty) {\n            img.updatePixels();\n          }\n          // Using HTML element's width and height in case if the image was resized.\n          curContext.drawImage(htmlElement, 0, 0,\n            htmlElement.width, htmlElement.height, bounds.x, bounds.y, bounds.w, bounds.h);\n        } else {\n          var obj = img.toImageData();\n\n          // Tint the image\n          if (curTint !== null) {\n            curTint(obj);\n            img.__isDirty = true;\n          }\n\n          curContext.drawImage(getCanvasData(obj).canvas, 0, 0,\n            img.width, img.height, bounds.x, bounds.y, bounds.w, bounds.h);\n        }\n      }\n    };\n\n    Drawing3D.prototype.image = function(img, x, y, w, h) {\n      if (img.width > 0) {\n        // Fix fractional positions\n        x = Math.round(x);\n        y = Math.round(y);\n        w = w || img.width;\n        h = h || img.height;\n\n        p.beginShape(p.QUADS);\n        p.texture(img);\n        p.vertex(x, y, 0, 0, 0);\n        p.vertex(x, y+h, 0, 0, h);\n        p.vertex(x+w, y+h, 0, w, h);\n        p.vertex(x+w, y, 0, w, 0);\n        p.endShape();\n      }\n    };\n\n    /**\n     * The tint() function sets the fill value for displaying images. Images can be tinted to\n     * specified colors or made transparent by setting the alpha.\n     * <br><br>To make an image transparent, but not change it's color,\n     * use white as the tint color and specify an alpha value. For instance,\n     * tint(255, 128) will make an image 50% transparent (unless\n     * <b>colorMode()</b> has been used).\n     *\n     * <br><br>When using hexadecimal notation to specify a color, use \"#\" or\n     * \"0x\" before the values (e.g. #CCFFAA, 0xFFCCFFAA). The # syntax uses six\n     * digits to specify a color (the way colors are specified in HTML and CSS).\n     * When using the hexadecimal notation starting with \"0x\", the hexadecimal\n     * value must be specified with eight characters; the first two characters\n     * define the alpha component and the remainder the red, green, and blue\n     * components.\n     * <br><br>The value for the parameter \"gray\" must be less than or equal\n     * to the current maximum value as specified by <b>colorMode()</b>.\n     * The default maximum value is 255.\n     * <br><br>The tint() method is also used to control the coloring of\n     * textures in 3D.\n     *\n     * @param {int|float} gray    any valid number\n     * @param {int|float} alpha    opacity of the image\n     * @param {int|float} value1  red or hue value\n     * @param {int|float} value2  green or saturation value\n     * @param {int|float} value3  blue or brightness value\n     * @param {int|float} color    any value of the color datatype\n     * @param {int} hex            color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)\n     *\n     * @see #noTint()\n     * @see #image()\n     */\n    p.tint = function(a1, a2, a3, a4) {\n      var tintColor = p.color(a1, a2, a3, a4);\n      var r = p.red(tintColor) / colorModeX;\n      var g = p.green(tintColor) / colorModeY;\n      var b = p.blue(tintColor) / colorModeZ;\n      var a = p.alpha(tintColor) / colorModeA;\n      curTint = function(obj) {\n        var data = obj.data,\n            length = 4 * obj.width * obj.height;\n        for (var i = 0; i < length;) {\n          data[i++] *= r;\n          data[i++] *= g;\n          data[i++] *= b;\n          data[i++] *= a;\n        }\n      };\n      // for overriding the color buffer when 3d rendering\n      curTint3d = function(data){\n        for (var i = 0; i < data.length;) {\n          data[i++] = r;\n          data[i++] = g;\n          data[i++] = b;\n          data[i++] = a;\n        }\n      };\n    };\n\n    /**\n     * The noTint() function removes the current fill value for displaying images and reverts to displaying images with their original hues.\n     *\n     * @see #tint()\n     * @see #image()\n     */\n    p.noTint = function() {\n      curTint = null;\n      curTint3d = null;\n    };\n\n    /**\n    * Copies a region of pixels from the display window to another area of the display window and copies a region of pixels from an\n    * image used as the srcImg  parameter into the display window. If the source and destination regions aren't the same size, it will\n    * automatically resize the source pixels to fit the specified target region. No alpha information is used in the process, however\n    * if the source image has an alpha channel set, it will be copied as well. This function ignores imageMode().\n    *\n    * @param {int} x            X coordinate of the source's upper left corner\n    * @param {int} y            Y coordinate of the source's upper left corner\n    * @param {int} width        source image width\n    * @param {int} height       source image height\n    * @param {int} dx           X coordinate of the destination's upper left corner\n    * @param {int} dy           Y coordinate of the destination's upper left corner\n    * @param {int} dwidth       destination image width\n    * @param {int} dheight      destination image height\n    * @param {PImage} srcImg    image variable referring to the source image\n    *\n    * @see blend\n    * @see get\n    */\n    p.copy = function(src, sx, sy, sw, sh, dx, dy, dw, dh) {\n      if (dh === undef) {\n        // shift everything, and introduce p\n        dh = dw;\n        dw = dy;\n        dy = dx;\n        dx = sh;\n        sh = sw;\n        sw = sy;\n        sy = sx;\n        sx = src;\n        src = p;\n      }\n      p.blend(src, sx, sy, sw, sh, dx, dy, dw, dh, PConstants.REPLACE);\n    };\n\n    /**\n    * Blends a region of pixels from one image into another (or in itself again) with full alpha channel support. There\n    * is a choice of the following modes to blend the source pixels (A) with the ones of pixels in the destination image (B):\n    * BLEND - linear interpolation of colours: C = A*factor + B\n    * ADD - additive blending with white clip: C = min(A*factor + B, 255)\n    * SUBTRACT - subtractive blending with black clip: C = max(B - A*factor, 0)\n    * DARKEST - only the darkest colour succeeds: C = min(A*factor, B)\n    * LIGHTEST - only the lightest colour succeeds: C = max(A*factor, B)\n    * DIFFERENCE - subtract colors from underlying image.\n    * EXCLUSION - similar to DIFFERENCE, but less extreme.\n    * MULTIPLY - Multiply the colors, result will always be darker.\n    * SCREEN - Opposite multiply, uses inverse values of the colors.\n    * OVERLAY - A mix of MULTIPLY and SCREEN. Multiplies dark values, and screens light values.\n    * HARD_LIGHT - SCREEN when greater than 50% gray, MULTIPLY when lower.\n    * SOFT_LIGHT - Mix of DARKEST and LIGHTEST. Works like OVERLAY, but not as harsh.\n    * DODGE - Lightens light tones and increases contrast, ignores darks. Called \"Color Dodge\" in Illustrator and Photoshop.\n    * BURN - Darker areas are applied, increasing contrast, ignores lights. Called \"Color Burn\" in Illustrator and Photoshop.\n    * All modes use the alpha information (highest byte) of source image pixels as the blending factor. If the source and\n    * destination regions are different sizes, the image will be automatically resized to match the destination size. If the\n    * srcImg parameter is not used, the display window is used as the source image.  This function ignores imageMode().\n    *\n    * @param {int} x            X coordinate of the source's upper left corner\n    * @param {int} y            Y coordinate of the source's upper left corner\n    * @param {int} width        source image width\n    * @param {int} height       source image height\n    * @param {int} dx           X coordinate of the destination's upper left corner\n    * @param {int} dy           Y coordinate of the destination's upper left corner\n    * @param {int} dwidth       destination image width\n    * @param {int} dheight      destination image height\n    * @param {PImage} srcImg    image variable referring to the source image\n    * @param {PImage} MODE      Either BLEND, ADD, SUBTRACT, LIGHTEST, DARKEST, DIFFERENCE, EXCLUSION, MULTIPLY, SCREEN,\n    *                           OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, BURN\n    * @see filter\n    */\n    p.blend = function(src, sx, sy, sw, sh, dx, dy, dw, dh, mode, pimgdest) {\n      if (src.isRemote) {\n        throw \"Image is loaded remotely. Cannot blend image.\";\n      }\n\n      if (mode === undef) {\n        // shift everything, and introduce p\n        mode = dh;\n        dh = dw;\n        dw = dy;\n        dy = dx;\n        dx = sh;\n        sh = sw;\n        sw = sy;\n        sy = sx;\n        sx = src;\n        src = p;\n      }\n\n      var sx2 = sx + sw,\n        sy2 = sy + sh,\n        dx2 = dx + dw,\n        dy2 = dy + dh,\n        dest = pimgdest || p;\n\n      // check if pimgdest is there and pixels, if so this was a call from pimg.blend\n      if (pimgdest === undef || mode === undef) {\n        p.loadPixels();\n      }\n\n      src.loadPixels();\n\n      if (src === p && p.intersect(sx, sy, sx2, sy2, dx, dy, dx2, dy2)) {\n        p.blit_resize(p.get(sx, sy, sx2 - sx, sy2 - sy), 0, 0, sx2 - sx - 1, sy2 - sy - 1,\n                      dest.imageData.data, dest.width, dest.height, dx, dy, dx2, dy2, mode);\n      } else {\n        p.blit_resize(src, sx, sy, sx2, sy2, dest.imageData.data, dest.width, dest.height, dx, dy, dx2, dy2, mode);\n      }\n\n      if (pimgdest === undef) {\n        p.updatePixels();\n      }\n    };\n\n    // helper function for filter()\n    var buildBlurKernel = function(r) {\n      var radius = p.floor(r * 3.5), i;\n      radius = (radius < 1) ? 1 : ((radius < 248) ? radius : 248);\n      if (p.shared.blurRadius !== radius) {\n        p.shared.blurRadius = radius;\n        p.shared.blurKernelSize = 1 + (p.shared.blurRadius<<1);\n        p.shared.blurKernel = new Float32Array(p.shared.blurKernelSize);\n        var sharedBlurKernal = p.shared.blurKernel;\n        var sharedBlurKernelSize = p.shared.blurKernelSize;\n        var sharedBlurRadius = p.shared.blurRadius;\n        // init blurKernel\n        for (i = 0; i < sharedBlurKernelSize; i++) {\n          sharedBlurKernal[i] = 0;\n        }\n        var radiusiSquared = (radius - 1) * (radius - 1);\n        for (i = 1; i < radius; i++) {\n          sharedBlurKernal[radius + i] = sharedBlurKernal[radius-i] = radiusiSquared;\n        }\n        sharedBlurKernal[radius] = radius * radius;\n      }\n    };\n\n    var blurARGB = function(r, aImg) {\n      var sum, cr, cg, cb, ca, c, m;\n      var read, ri, ym, ymi, bk0;\n      var wh = aImg.pixels.getLength();\n      var r2 = new Float32Array(wh);\n      var g2 = new Float32Array(wh);\n      var b2 = new Float32Array(wh);\n      var a2 = new Float32Array(wh);\n      var yi = 0;\n      var x, y, i, offset;\n\n      buildBlurKernel(r);\n\n      var aImgHeight = aImg.height;\n      var aImgWidth = aImg.width;\n      var sharedBlurKernelSize = p.shared.blurKernelSize;\n      var sharedBlurRadius = p.shared.blurRadius;\n      var sharedBlurKernal = p.shared.blurKernel;\n      var pix = aImg.imageData.data;\n\n      for (y = 0; y < aImgHeight; y++) {\n        for (x = 0; x < aImgWidth; x++) {\n          cb = cg = cr = ca = sum = 0;\n          read = x - sharedBlurRadius;\n          if (read<0) {\n            bk0 = -read;\n            read = 0;\n          } else {\n            if (read >= aImgWidth) {\n              break;\n            }\n            bk0=0;\n          }\n          for (i = bk0; i < sharedBlurKernelSize; i++) {\n            if (read >= aImgWidth) {\n              break;\n            }\n            offset = (read + yi) *4;\n            m = sharedBlurKernal[i];\n            ca += m * pix[offset + 3];\n            cr += m * pix[offset];\n            cg += m * pix[offset + 1];\n            cb += m * pix[offset + 2];\n            sum += m;\n            read++;\n          }\n          ri = yi + x;\n          a2[ri] = ca / sum;\n          r2[ri] = cr / sum;\n          g2[ri] = cg / sum;\n          b2[ri] = cb / sum;\n        }\n        yi += aImgWidth;\n      }\n\n      yi = 0;\n      ym = -sharedBlurRadius;\n      ymi = ym*aImgWidth;\n\n      for (y = 0; y < aImgHeight; y++) {\n        for (x = 0; x < aImgWidth; x++) {\n          cb = cg = cr = ca = sum = 0;\n          if (ym<0) {\n            bk0 = ri = -ym;\n            read = x;\n          } else {\n            if (ym >= aImgHeight) {\n              break;\n            }\n            bk0 = 0;\n            ri = ym;\n            read = x + ymi;\n          }\n          for (i = bk0; i < sharedBlurKernelSize; i++) {\n            if (ri >= aImgHeight) {\n              break;\n            }\n            m = sharedBlurKernal[i];\n            ca += m * a2[read];\n            cr += m * r2[read];\n            cg += m * g2[read];\n            cb += m * b2[read];\n            sum += m;\n            ri++;\n            read += aImgWidth;\n          }\n          offset = (x + yi) *4;\n          pix[offset] = cr / sum;\n          pix[offset + 1] = cg / sum;\n          pix[offset + 2] = cb / sum;\n          pix[offset + 3] = ca / sum;\n        }\n        yi += aImgWidth;\n        ymi += aImgWidth;\n        ym++;\n      }\n    };\n\n    // helper funtion for ERODE and DILATE modes of filter()\n    var dilate = function(isInverted, aImg) {\n      var currIdx = 0;\n      var maxIdx = aImg.pixels.getLength();\n      var out = new Int32Array(maxIdx);\n      var currRowIdx, maxRowIdx, colOrig, colOut, currLum;\n      var idxRight, idxLeft, idxUp, idxDown,\n          colRight, colLeft, colUp, colDown,\n          lumRight, lumLeft, lumUp, lumDown;\n\n      if (!isInverted) {\n        // erosion (grow light areas)\n        while (currIdx<maxIdx) {\n          currRowIdx = currIdx;\n          maxRowIdx = currIdx + aImg.width;\n          while (currIdx < maxRowIdx) {\n            colOrig = colOut = aImg.pixels.getPixel(currIdx);\n            idxLeft = currIdx - 1;\n            idxRight = currIdx + 1;\n            idxUp = currIdx - aImg.width;\n            idxDown = currIdx + aImg.width;\n            if (idxLeft < currRowIdx) {\n              idxLeft = currIdx;\n            }\n            if (idxRight >= maxRowIdx) {\n              idxRight = currIdx;\n            }\n            if (idxUp < 0) {\n              idxUp = 0;\n            }\n            if (idxDown >= maxIdx) {\n              idxDown = currIdx;\n            }\n            colUp = aImg.pixels.getPixel(idxUp);\n            colLeft = aImg.pixels.getPixel(idxLeft);\n            colDown = aImg.pixels.getPixel(idxDown);\n            colRight = aImg.pixels.getPixel(idxRight);\n\n            // compute luminance\n            currLum = 77*(colOrig>>16&0xff) + 151*(colOrig>>8&0xff) + 28*(colOrig&0xff);\n            lumLeft = 77*(colLeft>>16&0xff) + 151*(colLeft>>8&0xff) + 28*(colLeft&0xff);\n            lumRight = 77*(colRight>>16&0xff) + 151*(colRight>>8&0xff) + 28*(colRight&0xff);\n            lumUp = 77*(colUp>>16&0xff) + 151*(colUp>>8&0xff) + 28*(colUp&0xff);\n            lumDown = 77*(colDown>>16&0xff) + 151*(colDown>>8&0xff) + 28*(colDown&0xff);\n\n            if (lumLeft > currLum) {\n              colOut = colLeft;\n              currLum = lumLeft;\n            }\n            if (lumRight > currLum) {\n              colOut = colRight;\n              currLum = lumRight;\n            }\n            if (lumUp > currLum) {\n              colOut = colUp;\n              currLum = lumUp;\n            }\n            if (lumDown > currLum) {\n              colOut = colDown;\n              currLum = lumDown;\n            }\n            out[currIdx++] = colOut;\n          }\n        }\n      } else {\n        // dilate (grow dark areas)\n        while (currIdx < maxIdx) {\n          currRowIdx = currIdx;\n          maxRowIdx = currIdx + aImg.width;\n          while (currIdx < maxRowIdx) {\n            colOrig = colOut = aImg.pixels.getPixel(currIdx);\n            idxLeft = currIdx - 1;\n            idxRight = currIdx + 1;\n            idxUp = currIdx - aImg.width;\n            idxDown = currIdx + aImg.width;\n            if (idxLeft < currRowIdx) {\n              idxLeft = currIdx;\n            }\n            if (idxRight >= maxRowIdx) {\n              idxRight = currIdx;\n            }\n            if (idxUp < 0) {\n              idxUp = 0;\n            }\n            if (idxDown >= maxIdx) {\n              idxDown = currIdx;\n            }\n            colUp = aImg.pixels.getPixel(idxUp);\n            colLeft = aImg.pixels.getPixel(idxLeft);\n            colDown = aImg.pixels.getPixel(idxDown);\n            colRight = aImg.pixels.getPixel(idxRight);\n\n            // compute luminance\n            currLum = 77*(colOrig>>16&0xff) + 151*(colOrig>>8&0xff) + 28*(colOrig&0xff);\n            lumLeft = 77*(colLeft>>16&0xff) + 151*(colLeft>>8&0xff) + 28*(colLeft&0xff);\n            lumRight = 77*(colRight>>16&0xff) + 151*(colRight>>8&0xff) + 28*(colRight&0xff);\n            lumUp = 77*(colUp>>16&0xff) + 151*(colUp>>8&0xff) + 28*(colUp&0xff);\n            lumDown = 77*(colDown>>16&0xff) + 151*(colDown>>8&0xff) + 28*(colDown&0xff);\n\n            if (lumLeft < currLum) {\n              colOut = colLeft;\n              currLum = lumLeft;\n            }\n            if (lumRight < currLum) {\n              colOut = colRight;\n              currLum = lumRight;\n            }\n            if (lumUp < currLum) {\n              colOut = colUp;\n              currLum = lumUp;\n            }\n            if (lumDown < currLum) {\n              colOut = colDown;\n              currLum = lumDown;\n            }\n            out[currIdx++]=colOut;\n          }\n        }\n      }\n      aImg.pixels.set(out);\n      //p.arraycopy(out,0,pixels,0,maxIdx);\n    };\n\n    /**\n    * Filters the display window as defined by one of the following modes:\n    * THRESHOLD - converts the image to black and white pixels depending if they are above or below the threshold\n    * defined by the level parameter. The level must be between 0.0 (black) and 1.0(white). If no level is specified, 0.5 is used.\n    * GRAY - converts any colors in the image to grayscale equivalents\n    * INVERT - sets each pixel to its inverse value\n    * POSTERIZE - limits each channel of the image to the number of colors specified as the level parameter\n    * BLUR - executes a Guassian blur with the level parameter specifying the extent of the blurring. If no level parameter is\n    * used, the blur is equivalent to Guassian blur of radius 1.\n    * OPAQUE - sets the alpha channel to entirely opaque.\n    * ERODE - reduces the light areas with the amount defined by the level parameter.\n    * DILATE - increases the light areas with the amount defined by the level parameter.\n    *\n    * @param {MODE} MODE          Either THRESHOLD, GRAY, INVERT, POSTERIZE, BLUR, OPAQUE, ERODE, or DILATE\n    * @param {int|float} level    defines the quality of the filter\n    *\n    * @see blend\n    */\n    p.filter = function(kind, param, aImg){\n      var img, col, lum, i;\n\n      if (arguments.length === 3) {\n        aImg.loadPixels();\n        img = aImg;\n      } else {\n        p.loadPixels();\n        img = p;\n      }\n\n      if (param === undef) {\n        param = null;\n      }\n      if (img.isRemote) { // Remote images cannot access imageData\n        throw \"Image is loaded remotely. Cannot filter image.\";\n      }\n      // begin filter process\n      var imglen = img.pixels.getLength();\n      switch (kind) {\n        case PConstants.BLUR:\n          var radius = param || 1; // if no param specified, use 1 (default for p5)\n          blurARGB(radius, img);\n          break;\n\n        case PConstants.GRAY:\n          if (img.format === PConstants.ALPHA) { //trouble\n            // for an alpha image, convert it to an opaque grayscale\n            for (i = 0; i < imglen; i++) {\n              col = 255 - img.pixels.getPixel(i);\n              img.pixels.setPixel(i,(0xff000000 | (col << 16) | (col << 8) | col));\n            }\n            img.format = PConstants.RGB; //trouble\n          } else {\n            for (i = 0; i < imglen; i++) {\n              col = img.pixels.getPixel(i);\n              lum = (77*(col>>16&0xff) + 151*(col>>8&0xff) + 28*(col&0xff))>>8;\n              img.pixels.setPixel(i,((col & PConstants.ALPHA_MASK) | lum<<16 | lum<<8 | lum));\n            }\n          }\n          break;\n\n        case PConstants.INVERT:\n          for (i = 0; i < imglen; i++) {\n            img.pixels.setPixel(i, (img.pixels.getPixel(i) ^ 0xffffff));\n          }\n          break;\n\n        case PConstants.POSTERIZE:\n          if (param === null) {\n            throw \"Use filter(POSTERIZE, int levels) instead of filter(POSTERIZE)\";\n          }\n          var levels = p.floor(param);\n          if ((levels < 2) || (levels > 255)) {\n            throw \"Levels must be between 2 and 255 for filter(POSTERIZE, levels)\";\n          }\n          var levels1 = levels - 1;\n          for (i = 0; i < imglen; i++) {\n            var rlevel = (img.pixels.getPixel(i) >> 16) & 0xff;\n            var glevel = (img.pixels.getPixel(i) >> 8) & 0xff;\n            var blevel = img.pixels.getPixel(i) & 0xff;\n            rlevel = (((rlevel * levels) >> 8) * 255) / levels1;\n            glevel = (((glevel * levels) >> 8) * 255) / levels1;\n            blevel = (((blevel * levels) >> 8) * 255) / levels1;\n            img.pixels.setPixel(i, ((0xff000000 & img.pixels.getPixel(i)) | (rlevel << 16) | (glevel << 8) | blevel));\n          }\n          break;\n\n        case PConstants.OPAQUE:\n          for (i = 0; i < imglen; i++) {\n            img.pixels.setPixel(i, (img.pixels.getPixel(i) | 0xff000000));\n          }\n          img.format = PConstants.RGB; //trouble\n          break;\n\n        case PConstants.THRESHOLD:\n          if (param === null) {\n            param = 0.5;\n          }\n          if ((param < 0) || (param > 1)) {\n            throw \"Level must be between 0 and 1 for filter(THRESHOLD, level)\";\n          }\n          var thresh = p.floor(param * 255);\n          for (i = 0; i < imglen; i++) {\n            var max = p.max((img.pixels.getPixel(i) & PConstants.RED_MASK) >> 16, p.max((img.pixels.getPixel(i) & PConstants.GREEN_MASK) >> 8, (img.pixels.getPixel(i) & PConstants.BLUE_MASK)));\n            img.pixels.setPixel(i, ((img.pixels.getPixel(i) & PConstants.ALPHA_MASK) | ((max < thresh) ? 0x000000 : 0xffffff)));\n          }\n          break;\n\n        case PConstants.ERODE:\n          dilate(true, img);\n          break;\n\n        case PConstants.DILATE:\n          dilate(false, img);\n          break;\n      }\n      img.updatePixels();\n    };\n\n\n    // shared variables for blit_resize(), filter_new_scanline(), filter_bilinear(), filter()\n    // change this in the future to not be exposed to p\n    p.shared = {\n      fracU: 0,\n      ifU: 0,\n      fracV: 0,\n      ifV: 0,\n      u1: 0,\n      u2: 0,\n      v1: 0,\n      v2: 0,\n      sX: 0,\n      sY: 0,\n      iw: 0,\n      iw1: 0,\n      ih1: 0,\n      ul: 0,\n      ll: 0,\n      ur: 0,\n      lr: 0,\n      cUL: 0,\n      cLL: 0,\n      cUR: 0,\n      cLR: 0,\n      srcXOffset: 0,\n      srcYOffset: 0,\n      r: 0,\n      g: 0,\n      b: 0,\n      a: 0,\n      srcBuffer: null,\n      blurRadius: 0,\n      blurKernelSize: 0,\n      blurKernel: null\n    };\n\n    p.intersect = function(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2) {\n      var sw = sx2 - sx1 + 1;\n      var sh = sy2 - sy1 + 1;\n      var dw = dx2 - dx1 + 1;\n      var dh = dy2 - dy1 + 1;\n      if (dx1 < sx1) {\n        dw += dx1 - sx1;\n        if (dw > sw) {\n          dw = sw;\n        }\n      } else {\n        var w = sw + sx1 - dx1;\n        if (dw > w) {\n          dw = w;\n        }\n      }\n      if (dy1 < sy1) {\n        dh += dy1 - sy1;\n        if (dh > sh) {\n          dh = sh;\n        }\n      } else {\n        var h = sh + sy1 - dy1;\n        if (dh > h) {\n          dh = h;\n        }\n      }\n      return ! (dw <= 0 || dh <= 0);\n    };\n\n    var blendFuncs = {};\n    blendFuncs[PConstants.BLEND] = p.modes.blend;\n    blendFuncs[PConstants.ADD] = p.modes.add;\n    blendFuncs[PConstants.SUBTRACT] = p.modes.subtract;\n    blendFuncs[PConstants.LIGHTEST] = p.modes.lightest;\n    blendFuncs[PConstants.DARKEST] = p.modes.darkest;\n    blendFuncs[PConstants.REPLACE] = p.modes.replace;\n    blendFuncs[PConstants.DIFFERENCE] = p.modes.difference;\n    blendFuncs[PConstants.EXCLUSION] = p.modes.exclusion;\n    blendFuncs[PConstants.MULTIPLY] = p.modes.multiply;\n    blendFuncs[PConstants.SCREEN] = p.modes.screen;\n    blendFuncs[PConstants.OVERLAY] = p.modes.overlay;\n    blendFuncs[PConstants.HARD_LIGHT] = p.modes.hard_light;\n    blendFuncs[PConstants.SOFT_LIGHT] = p.modes.soft_light;\n    blendFuncs[PConstants.DODGE] = p.modes.dodge;\n    blendFuncs[PConstants.BURN] = p.modes.burn;\n\n    p.blit_resize = function(img, srcX1, srcY1, srcX2, srcY2, destPixels,\n                             screenW, screenH, destX1, destY1, destX2, destY2, mode) {\n      var x, y;\n      if (srcX1 < 0) {\n        srcX1 = 0;\n      }\n      if (srcY1 < 0) {\n        srcY1 = 0;\n      }\n      if (srcX2 >= img.width) {\n        srcX2 = img.width - 1;\n      }\n      if (srcY2 >= img.height) {\n        srcY2 = img.height - 1;\n      }\n      var srcW = srcX2 - srcX1;\n      var srcH = srcY2 - srcY1;\n      var destW = destX2 - destX1;\n      var destH = destY2 - destY1;\n\n      if (destW <= 0 || destH <= 0 || srcW <= 0 || srcH <= 0 || destX1 >= screenW ||\n          destY1 >= screenH || srcX1 >= img.width || srcY1 >= img.height) {\n        return;\n      }\n\n      var dx = Math.floor(srcW / destW * PConstants.PRECISIONF);\n      var dy = Math.floor(srcH / destH * PConstants.PRECISIONF);\n\n      var pshared = p.shared;\n\n      pshared.srcXOffset = Math.floor(destX1 < 0 ? -destX1 * dx : srcX1 * PConstants.PRECISIONF);\n      pshared.srcYOffset = Math.floor(destY1 < 0 ? -destY1 * dy : srcY1 * PConstants.PRECISIONF);\n      if (destX1 < 0) {\n        destW += destX1;\n        destX1 = 0;\n      }\n      if (destY1 < 0) {\n        destH += destY1;\n        destY1 = 0;\n      }\n      destW = Math.min(destW, screenW - destX1);\n      destH = Math.min(destH, screenH - destY1);\n\n      var destOffset = destY1 * screenW + destX1;\n      var destColor;\n\n      pshared.srcBuffer = img.imageData.data;\n      pshared.iw = img.width;\n      pshared.iw1 = img.width - 1;\n      pshared.ih1 = img.height - 1;\n\n      // cache for speed\n      var filterBilinear = p.filter_bilinear,\n        filterNewScanline = p.filter_new_scanline,\n        blendFunc = blendFuncs[mode],\n        blendedColor,\n        idx,\n        cULoffset,\n        cURoffset,\n        cLLoffset,\n        cLRoffset,\n        ALPHA_MASK = PConstants.ALPHA_MASK,\n        RED_MASK = PConstants.RED_MASK,\n        GREEN_MASK = PConstants.GREEN_MASK,\n        BLUE_MASK = PConstants.BLUE_MASK,\n        PREC_MAXVAL = PConstants.PREC_MAXVAL,\n        PRECISIONB = PConstants.PRECISIONB,\n        PREC_RED_SHIFT = PConstants.PREC_RED_SHIFT,\n        PREC_ALPHA_SHIFT = PConstants.PREC_ALPHA_SHIFT,\n        srcBuffer = pshared.srcBuffer,\n        min = Math.min;\n\n      for (y = 0; y < destH; y++) {\n\n        pshared.sX = pshared.srcXOffset;\n        pshared.fracV = pshared.srcYOffset & PREC_MAXVAL;\n        pshared.ifV = PREC_MAXVAL - pshared.fracV;\n        pshared.v1 = (pshared.srcYOffset >> PRECISIONB) * pshared.iw;\n        pshared.v2 = min((pshared.srcYOffset >> PRECISIONB) + 1, pshared.ih1) * pshared.iw;\n\n        for (x = 0; x < destW; x++) {\n          idx = (destOffset + x) * 4;\n\n          destColor = (destPixels[idx + 3] << 24) &\n                      ALPHA_MASK | (destPixels[idx] << 16) &\n                      RED_MASK   | (destPixels[idx + 1] << 8) &\n                      GREEN_MASK |  destPixels[idx + 2] & BLUE_MASK;\n\n          pshared.fracU = pshared.sX & PREC_MAXVAL;\n          pshared.ifU = PREC_MAXVAL - pshared.fracU;\n          pshared.ul = (pshared.ifU * pshared.ifV) >> PRECISIONB;\n          pshared.ll = (pshared.ifU * pshared.fracV) >> PRECISIONB;\n          pshared.ur = (pshared.fracU * pshared.ifV) >> PRECISIONB;\n          pshared.lr = (pshared.fracU * pshared.fracV) >> PRECISIONB;\n          pshared.u1 = (pshared.sX >> PRECISIONB);\n          pshared.u2 = min(pshared.u1 + 1, pshared.iw1);\n\n          cULoffset = (pshared.v1 + pshared.u1) * 4;\n          cURoffset = (pshared.v1 + pshared.u2) * 4;\n          cLLoffset = (pshared.v2 + pshared.u1) * 4;\n          cLRoffset = (pshared.v2 + pshared.u2) * 4;\n\n          pshared.cUL = (srcBuffer[cULoffset + 3] << 24) &\n                        ALPHA_MASK | (srcBuffer[cULoffset] << 16) &\n                        RED_MASK   | (srcBuffer[cULoffset + 1] << 8) &\n                        GREEN_MASK |  srcBuffer[cULoffset + 2] & BLUE_MASK;\n\n          pshared.cUR = (srcBuffer[cURoffset + 3] << 24) &\n                        ALPHA_MASK | (srcBuffer[cURoffset] << 16) &\n                        RED_MASK   | (srcBuffer[cURoffset + 1] << 8) &\n                        GREEN_MASK |  srcBuffer[cURoffset + 2] & BLUE_MASK;\n\n          pshared.cLL = (srcBuffer[cLLoffset + 3] << 24) &\n                        ALPHA_MASK | (srcBuffer[cLLoffset] << 16) &\n                        RED_MASK   | (srcBuffer[cLLoffset + 1] << 8) &\n                        GREEN_MASK |  srcBuffer[cLLoffset + 2] & BLUE_MASK;\n\n          pshared.cLR = (srcBuffer[cLRoffset + 3] << 24) &\n                        ALPHA_MASK | (srcBuffer[cLRoffset] << 16) &\n                        RED_MASK   | (srcBuffer[cLRoffset + 1] << 8) &\n                        GREEN_MASK |  srcBuffer[cLRoffset + 2] & BLUE_MASK;\n\n          pshared.r = ((pshared.ul * ((pshared.cUL & RED_MASK) >> 16) +\n                       pshared.ll * ((pshared.cLL & RED_MASK) >> 16) +\n                       pshared.ur * ((pshared.cUR & RED_MASK) >> 16) +\n                       pshared.lr * ((pshared.cLR & RED_MASK) >> 16)) << PREC_RED_SHIFT) & RED_MASK;\n          pshared.g = ((pshared.ul * (pshared.cUL & GREEN_MASK) +\n                       pshared.ll * (pshared.cLL & GREEN_MASK) +\n                       pshared.ur * (pshared.cUR & GREEN_MASK) +\n                       pshared.lr * (pshared.cLR & GREEN_MASK)) >>> PRECISIONB) & GREEN_MASK;\n          pshared.b = (pshared.ul * (pshared.cUL & BLUE_MASK) +\n                       pshared.ll * (pshared.cLL & BLUE_MASK) +\n                       pshared.ur * (pshared.cUR & BLUE_MASK) +\n                       pshared.lr * (pshared.cLR & BLUE_MASK)) >>> PRECISIONB;\n          pshared.a = ((pshared.ul * ((pshared.cUL & ALPHA_MASK) >>> 24) +\n                       pshared.ll * ((pshared.cLL & ALPHA_MASK) >>> 24) +\n                       pshared.ur * ((pshared.cUR & ALPHA_MASK) >>> 24) +\n                       pshared.lr * ((pshared.cLR & ALPHA_MASK) >>> 24)) << PREC_ALPHA_SHIFT) & ALPHA_MASK;\n\n          blendedColor = blendFunc(destColor, (pshared.a | pshared.r | pshared.g | pshared.b));\n\n          destPixels[idx]     = (blendedColor & RED_MASK) >>> 16;\n          destPixels[idx + 1] = (blendedColor & GREEN_MASK) >>> 8;\n          destPixels[idx + 2] = (blendedColor & BLUE_MASK);\n          destPixels[idx + 3] = (blendedColor & ALPHA_MASK) >>> 24;\n\n          pshared.sX += dx;\n        }\n        destOffset += screenW;\n        pshared.srcYOffset += dy;\n      }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Font handling\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * loadFont() Loads a font into a variable of type PFont.\n     *\n     * @param {String} name filename of the font to load\n     * @param {int|float} size option font size (used internally)\n     *\n     * @returns {PFont} new PFont object\n     *\n     * @see #PFont\n     * @see #textFont\n     * @see #text\n     * @see #createFont\n     */\n    p.loadFont = function(name, size) {\n      if (name === undef) {\n        throw(\"font name required in loadFont.\");\n      }\n      if (name.indexOf(\".svg\") === -1) {\n        if (size === undef) {\n          size = curTextFont.size;\n        }\n        return PFont.get(name, size);\n      }\n      // If the font is a glyph, calculate by SVG table\n      var font = p.loadGlyphs(name);\n\n      return {\n        name: name,\n        css: '12px sans-serif',\n        glyph: true,\n        units_per_em: font.units_per_em,\n        horiz_adv_x: 1 / font.units_per_em * font.horiz_adv_x,\n        ascent: font.ascent,\n        descent: font.descent,\n        width: function(str) {\n          var width = 0;\n          var len = str.length;\n          for (var i = 0; i < len; i++) {\n            try {\n              width += parseFloat(p.glyphLook(p.glyphTable[name], str[i]).horiz_adv_x);\n            }\n            catch(e) {\n              Processing.debug(e);\n            }\n          }\n          return width / p.glyphTable[name].units_per_em;\n        }\n      };\n    };\n\n    /**\n     * createFont() Loads a font into a variable of type PFont.\n     * Smooth and charset are ignored in Processing.js.\n     *\n     * @param {String}    name    filename of the font to load\n     * @param {int|float} size    font size in pixels\n     * @param {boolean}   smooth  not used in Processing.js\n     * @param {char[]}    charset not used in Processing.js\n     *\n     * @returns {PFont} new PFont object\n     *\n     * @see #PFont\n     * @see #textFont\n     * @see #text\n     * @see #loadFont\n     */\n    p.createFont = function(name, size) {\n      // because Processing.js only deals with real fonts,\n      // createFont is simply a wrapper for loadFont/2\n      return p.loadFont(name, size);\n    };\n\n    /**\n     * textFont() Sets the current font.\n     *\n     * @param {PFont}     pfont the PFont to load as current text font\n     * @param {int|float} size optional font size in pixels\n     *\n     * @see #createFont\n     * @see #loadFont\n     * @see #PFont\n     * @see #text\n     */\n    p.textFont = function(pfont, size) {\n      if (size !== undef) {\n        // If we're using an SVG glyph font, don't load from cache\n        if (!pfont.glyph) {\n          pfont = PFont.get(pfont.name, size);\n        }\n        curTextSize = size;\n      }\n      curTextFont = pfont;\n      curFontName = curTextFont.name;\n      curTextAscent = curTextFont.ascent;\n      curTextDescent = curTextFont.descent;\n      curTextLeading = curTextFont.leading;\n      var curContext = drawing.$ensureContext();\n      curContext.font = curTextFont.css;\n    };\n\n    /**\n     * textSize() Sets the current font size in pixels.\n     *\n     * @param {int|float} size font size in pixels\n     *\n     * @see #textFont\n     * @see #loadFont\n     * @see #PFont\n     * @see #text\n     */\n    p.textSize = function(size) {\n      curTextFont = PFont.get(curFontName, size);\n      curTextSize = size;\n      // recache metrics\n      curTextAscent = curTextFont.ascent;\n      curTextDescent = curTextFont.descent;\n      curTextLeading = curTextFont.leading;\n      var curContext = drawing.$ensureContext();\n      curContext.font = curTextFont.css;\n    };\n\n    /**\n     * textAscent() returns the maximum height a character extends above the baseline of the\n     * current font at its current size, in pixels.\n     *\n     * @returns {float} height of the current font above the baseline, at its current size, in pixels\n     *\n     * @see #textDescent\n     */\n    p.textAscent = function() {\n      return curTextAscent;\n    };\n\n    /**\n     * textDescent() returns the maximum depth a character will protrude below the baseline of\n     * the current font at its current size, in pixels.\n     *\n     * @returns {float} depth of the current font below the baseline, at its current size, in pixels\n     *\n     * @see #textAscent\n     */\n    p.textDescent = function() {\n      return curTextDescent;\n    };\n\n    /**\n     * textLeading() Sets the current font's leading, which is the distance\n     * from baseline to baseline over consecutive lines, with additional vertical\n     * spacing taking into account. Usually this value is 1.2 or 1.25 times the\n     * textsize, but this value can be changed to effect vertically compressed\n     * or stretched text.\n     *\n     * @param {int|float} the desired baseline-to-baseline size in pixels\n     */\n    p.textLeading = function(leading) {\n      curTextLeading = leading;\n    };\n\n    /**\n     * textAlign() Sets the current alignment for drawing text.\n     *\n     * @param {int} ALIGN  Horizontal alignment, either LEFT, CENTER, or RIGHT\n     * @param {int} YALIGN optional vertical alignment, either TOP, BOTTOM, CENTER, or BASELINE\n     *\n     * @see #loadFont\n     * @see #PFont\n     * @see #text\n     */\n    p.textAlign = function(xalign, yalign) {\n      horizontalTextAlignment = xalign;\n      verticalTextAlignment = yalign || PConstants.BASELINE;\n    };\n\n    /**\n     * toP5String converts things with arbitrary data type into\n     * string values, for text rendering.\n     *\n     * @param {any} any object that can be converted into a string\n     *\n     * @return {String} the string representation of the input\n     */\n    function toP5String(obj) {\n      if(obj instanceof String) {\n        return obj;\n      }\n      if(typeof obj === 'number') {\n        // check if an int\n        if(obj === (0 | obj)) {\n          return obj.toString();\n        }\n        return p.nf(obj, 0, 3);\n      }\n      if(obj === null || obj === undef) {\n        return \"\";\n      }\n      return obj.toString();\n    }\n\n    /**\n     * textWidth() Calculates and returns the width of any character or text string in pixels.\n     *\n     * @param {char|String} str char or String to be measured\n     *\n     * @return {float} width of char or String in pixels\n     *\n     * @see #loadFont\n     * @see #PFont\n     * @see #text\n     * @see #textFont\n     */\n    Drawing2D.prototype.textWidth = function(str) {\n      var lines = toP5String(str).split(/\\r?\\n/g), width = 0;\n      var i, linesCount = lines.length;\n\n      curContext.font = curTextFont.css;\n      for (i = 0; i < linesCount; ++i) {\n        width = Math.max(width, curTextFont.measureTextWidth(lines[i]));\n      }\n      return width | 0;\n    };\n\n    Drawing3D.prototype.textWidth = function(str) {\n      var lines = toP5String(str).split(/\\r?\\n/g), width = 0;\n      var i, linesCount = lines.length;\n      if (textcanvas === undef) {\n        textcanvas = document.createElement(\"canvas\");\n      }\n\n      var textContext = textcanvas.getContext(\"2d\");\n      textContext.font = curTextFont.css;\n\n      for (i = 0; i < linesCount; ++i) {\n        width = Math.max(width, textContext.measureText(lines[i]).width);\n      }\n      return width | 0;\n    };\n\n    // A lookup table for characters that can not be referenced by Object\n    p.glyphLook = function(font, chr) {\n      try {\n        switch (chr) {\n        case \"1\":\n          return font.one;\n        case \"2\":\n          return font.two;\n        case \"3\":\n          return font.three;\n        case \"4\":\n          return font.four;\n        case \"5\":\n          return font.five;\n        case \"6\":\n          return font.six;\n        case \"7\":\n          return font.seven;\n        case \"8\":\n          return font.eight;\n        case \"9\":\n          return font.nine;\n        case \"0\":\n          return font.zero;\n        case \" \":\n          return font.space;\n        case \"$\":\n          return font.dollar;\n        case \"!\":\n          return font.exclam;\n        case '\"':\n          return font.quotedbl;\n        case \"#\":\n          return font.numbersign;\n        case \"%\":\n          return font.percent;\n        case \"&\":\n          return font.ampersand;\n        case \"'\":\n          return font.quotesingle;\n        case \"(\":\n          return font.parenleft;\n        case \")\":\n          return font.parenright;\n        case \"*\":\n          return font.asterisk;\n        case \"+\":\n          return font.plus;\n        case \",\":\n          return font.comma;\n        case \"-\":\n          return font.hyphen;\n        case \".\":\n          return font.period;\n        case \"/\":\n          return font.slash;\n        case \"_\":\n          return font.underscore;\n        case \":\":\n          return font.colon;\n        case \";\":\n          return font.semicolon;\n        case \"<\":\n          return font.less;\n        case \"=\":\n          return font.equal;\n        case \">\":\n          return font.greater;\n        case \"?\":\n          return font.question;\n        case \"@\":\n          return font.at;\n        case \"[\":\n          return font.bracketleft;\n        case \"\\\\\":\n          return font.backslash;\n        case \"]\":\n          return font.bracketright;\n        case \"^\":\n          return font.asciicircum;\n        case \"`\":\n          return font.grave;\n        case \"{\":\n          return font.braceleft;\n        case \"|\":\n          return font.bar;\n        case \"}\":\n          return font.braceright;\n        case \"~\":\n          return font.asciitilde;\n          // If the character is not 'special', access it by object reference\n        default:\n          return font[chr];\n        }\n      } catch(e) {\n        Processing.debug(e);\n      }\n    };\n\n    // Print some text to the Canvas\n    Drawing2D.prototype.text$line = function(str, x, y, z, align) {\n      var textWidth = 0, xOffset = 0;\n      // If the font is a standard Canvas font...\n      if (!curTextFont.glyph) {\n        if (str && (\"fillText\" in curContext)) {\n          if (isFillDirty) {\n            curContext.fillStyle = p.color.toString(currentFillColor);\n            isFillDirty = false;\n          }\n\n          // horizontal offset/alignment\n          if(align === PConstants.RIGHT || align === PConstants.CENTER) {\n            textWidth = curTextFont.measureTextWidth(str);\n\n            if(align === PConstants.RIGHT) {\n              xOffset = -textWidth;\n            } else { // if(align === PConstants.CENTER)\n              xOffset = -textWidth/2;\n            }\n          }\n\n          curContext.fillText(str, x+xOffset, y);\n        }\n      } else {\n        // If the font is a Batik SVG font...\n        var font = p.glyphTable[curFontName];\n        saveContext();\n        curContext.translate(x, y + curTextSize);\n\n        // horizontal offset/alignment\n        if(align === PConstants.RIGHT || align === PConstants.CENTER) {\n          textWidth = font.width(str);\n\n          if(align === PConstants.RIGHT) {\n            xOffset = -textWidth;\n          } else { // if(align === PConstants.CENTER)\n            xOffset = -textWidth/2;\n          }\n        }\n\n        var upem   = font.units_per_em,\n          newScale = 1 / upem * curTextSize;\n\n        curContext.scale(newScale, newScale);\n\n        for (var i=0, len=str.length; i < len; i++) {\n          // Test character against glyph table\n          try {\n            p.glyphLook(font, str[i]).draw();\n          } catch(e) {\n            Processing.debug(e);\n          }\n        }\n        restoreContext();\n      }\n    };\n\n    Drawing3D.prototype.text$line = function(str, x, y, z, align) {\n      // handle case for 3d text\n      if (textcanvas === undef) {\n        textcanvas = document.createElement(\"canvas\");\n      }\n      var oldContext = curContext;\n      curContext = textcanvas.getContext(\"2d\");\n      curContext.font = curTextFont.css;\n      var textWidth = curTextFont.measureTextWidth(str);\n      textcanvas.width = textWidth;\n      textcanvas.height = curTextSize;\n      curContext = textcanvas.getContext(\"2d\"); // refreshes curContext\n      curContext.font = curTextFont.css;\n      curContext.textBaseline=\"top\";\n\n      // paint on 2D canvas\n      Drawing2D.prototype.text$line(str,0,0,0,PConstants.LEFT);\n\n      // use it as a texture\n      var aspect = textcanvas.width/textcanvas.height;\n      curContext = oldContext;\n\n      curContext.bindTexture(curContext.TEXTURE_2D, textTex);\n      curContext.texImage2D(curContext.TEXTURE_2D, 0, curContext.RGBA, curContext.RGBA, curContext.UNSIGNED_BYTE, textcanvas);\n      curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MAG_FILTER, curContext.LINEAR);\n      curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MIN_FILTER, curContext.LINEAR);\n      curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_WRAP_T, curContext.CLAMP_TO_EDGE);\n      curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_WRAP_S, curContext.CLAMP_TO_EDGE);\n      // If we don't have a power of two texture, we can't mipmap it.\n      // curContext.generateMipmap(curContext.TEXTURE_2D);\n\n      // horizontal offset/alignment\n      var xOffset = 0;\n      if (align === PConstants.RIGHT) {\n        xOffset = -textWidth;\n      } else if(align === PConstants.CENTER) {\n        xOffset = -textWidth/2;\n      }\n      var model = new PMatrix3D();\n      var scalefactor = curTextSize * 0.5;\n      model.translate(x+xOffset-scalefactor/2, y-scalefactor, z);\n      model.scale(-aspect*scalefactor, -scalefactor, scalefactor);\n      model.translate(-1, -1, -1);\n      model.transpose();\n\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.transpose();\n\n      curContext.useProgram(programObject2D);\n      vertexAttribPointer(\"aVertex2d\", programObject2D, \"aVertex\", 3, textBuffer);\n      vertexAttribPointer(\"aTextureCoord2d\", programObject2D, \"aTextureCoord\", 2, textureBuffer);\n      uniformi(\"uSampler2d\", programObject2D, \"uSampler\", [0]);\n\n      uniformi(\"uIsDrawingText2d\", programObject2D, \"uIsDrawingText\", true);\n\n      uniformMatrix(\"uModel2d\", programObject2D, \"uModel\", false,  model.array());\n      uniformMatrix(\"uView2d\", programObject2D, \"uView\", false, view.array());\n      uniformf(\"uColor2d\", programObject2D, \"uColor\", fillStyle);\n      curContext.bindBuffer(curContext.ELEMENT_ARRAY_BUFFER, indexBuffer);\n      curContext.drawElements(curContext.TRIANGLES, 6, curContext.UNSIGNED_SHORT, 0);\n    };\n\n\n    /**\n    * unbounded text function (z is an optional argument)\n    */\n    function text$4(str, x, y, z) {\n      var lines, linesCount;\n      if(str.indexOf('\\n') < 0) {\n        lines = [str];\n        linesCount = 1;\n      } else {\n        lines = str.split(/\\r?\\n/g);\n        linesCount = lines.length;\n      }\n      // handle text line-by-line\n\n      var yOffset = 0;\n      if(verticalTextAlignment === PConstants.TOP) {\n        yOffset = curTextAscent + curTextDescent;\n      } else if(verticalTextAlignment === PConstants.CENTER) {\n        yOffset = curTextAscent/2 - (linesCount-1)*curTextLeading/2;\n      } else if(verticalTextAlignment === PConstants.BOTTOM) {\n        yOffset = -(curTextDescent + (linesCount-1)*curTextLeading);\n      }\n\n      for(var i=0;i<linesCount;++i) {\n        var line = lines[i];\n        drawing.text$line(line, x, y + yOffset, z, horizontalTextAlignment);\n        yOffset += curTextLeading;\n      }\n    }\n\n\n    /**\n    * box-bounded text function (z is an optional argument)\n    */\n    function text$6(str, x, y, width, height, z) {\n      // 'fail' on 0-valued dimensions\n      if (str.length === 0 || width === 0 || height === 0) {\n        return;\n      }\n      // also 'fail' if the text height is larger than the bounding height\n      if(curTextSize > height) {\n        return;\n      }\n\n      var spaceMark = -1;\n      var start = 0;\n      var lineWidth = 0;\n      var drawCommands = [];\n\n      // run through text, character-by-character\n      for (var charPos=0, len=str.length; charPos < len; charPos++)\n      {\n        var currentChar = str[charPos];\n        var spaceChar = (currentChar === \" \");\n        var letterWidth = curTextFont.measureTextWidth(currentChar);\n\n        // if we aren't looking at a newline, and the text still fits, keep processing\n        if (currentChar !== \"\\n\" && (lineWidth + letterWidth <= width)) {\n          if (spaceChar) { spaceMark = charPos; }\n          lineWidth += letterWidth;\n        }\n\n        // if we're looking at a newline, or the text no longer fits, push the section that fit into the drawcommand list\n        else\n        {\n          if (spaceMark + 1 === start) {\n            if(charPos>0) {\n              // Whole line without spaces so far.\n              spaceMark = charPos;\n            } else {\n              // 'fail', because the line can't even fit the first character\n              return;\n            }\n          }\n\n          if (currentChar === \"\\n\") {\n            drawCommands.push({text:str.substring(start, charPos), width: lineWidth});\n            start = charPos + 1;\n          } else {\n            // current is not a newline, which means the line doesn't fit in box. push text.\n            // In Processing 1.5.1, the space is also pushed, so we push up to spaceMark+1,\n            // rather than up to spaceMark, as was the case for Processing 1.5 and earlier.\n            drawCommands.push({text:str.substring(start, spaceMark+1), width: lineWidth});\n            start = spaceMark + 1;\n          }\n\n          // newline + return\n          lineWidth = 0;\n          charPos = start - 1;\n        }\n      }\n\n      // push the remaining text\n      if (start < len) {\n        drawCommands.push({text:str.substring(start), width: lineWidth});\n      }\n\n      // resolve horizontal alignment\n      var xOffset = 1,\n          yOffset = curTextAscent;\n      if (horizontalTextAlignment === PConstants.CENTER) {\n        xOffset = width/2;\n      } else if (horizontalTextAlignment === PConstants.RIGHT) {\n        xOffset = width;\n      }\n\n      // resolve vertical alignment\n      var linesCount = drawCommands.length,\n          visibleLines = Math.min(linesCount, Math.floor(height/curTextLeading));\n      if(verticalTextAlignment === PConstants.TOP) {\n        yOffset = curTextAscent + curTextDescent;\n      } else if(verticalTextAlignment === PConstants.CENTER) {\n        yOffset = (height/2) - curTextLeading * (visibleLines/2 - 1);\n      } else if(verticalTextAlignment === PConstants.BOTTOM) {\n        yOffset = curTextDescent + curTextLeading;\n      }\n\n      var command,\n          drawCommand,\n          leading;\n      for (command = 0; command < linesCount; command++) {\n        leading = command * curTextLeading;\n        // stop if not enough space for one more line draw\n        if (yOffset + leading > height - curTextDescent) {\n          break;\n        }\n        drawCommand = drawCommands[command];\n        drawing.text$line(drawCommand.text, x + xOffset, y + yOffset + leading, z, horizontalTextAlignment);\n      }\n    }\n\n    /**\n     * text() Draws text to the screen.\n     *\n     * @param {String|char|int|float} data       the alphanumeric symbols to be displayed\n     * @param {int|float}             x          x-coordinate of text\n     * @param {int|float}             y          y-coordinate of text\n     * @param {int|float}             z          optional z-coordinate of text\n     * @param {String}                stringdata optional letters to be displayed\n     * @param {int|float}             width      optional width of text box\n     * @param {int|float}             height     optional height of text box\n     *\n     * @see #textAlign\n     * @see #textMode\n     * @see #loadFont\n     * @see #PFont\n     * @see #textFont\n     */\n    p.text = function() {\n      if (textMode === PConstants.SHAPE) {\n        // TODO: requires beginRaw function\n        return;\n      }\n      if (arguments.length === 3) { // for text( str, x, y)\n        text$4(toP5String(arguments[0]), arguments[1], arguments[2], 0);\n      } else if (arguments.length === 4) { // for text( str, x, y, z)\n        text$4(toP5String(arguments[0]), arguments[1], arguments[2], arguments[3]);\n      } else if (arguments.length === 5) { // for text( str, x, y , width, height)\n        text$6(toP5String(arguments[0]), arguments[1], arguments[2], arguments[3], arguments[4], 0);\n      } else if (arguments.length === 6) { // for text( stringdata, x, y , width, height, z)\n        text$6(toP5String(arguments[0]), arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);\n      }\n    };\n\n    /**\n     * Sets the way text draws to the screen. In the default configuration (the MODEL mode), it's possible to rotate,\n     * scale, and place letters in two and three dimensional space. <br /><br /> Changing to SCREEN mode draws letters\n     * directly to the front of the window and greatly increases rendering quality and speed when used with the P2D and\n     * P3D renderers. textMode(SCREEN) with OPENGL and JAVA2D (the default) renderers will generally be slower, though\n     * pixel accurate with P2D and P3D. With textMode(SCREEN), the letters draw at the actual size of the font (in pixels)\n     * and therefore calls to <b>textSize()</b> will not affect the size of the letters. To create a font at the size you\n     * desire, use the \"Create font...\" option in the Tools menu, or use the createFont() function. When using textMode(SCREEN),\n     * any z-coordinate passed to a text() command will be ignored, because your computer screen is...flat!\n     *\n     * @param {int} MODE Either MODEL, SCREEN or SHAPE (not yet supported)\n     *\n     * @see loadFont\n     * @see PFont\n     * @see text\n     * @see textFont\n     * @see createFont\n     */\n    p.textMode = function(mode){\n      textMode = mode;\n    };\n\n    // Load Batik SVG Fonts and parse to pre-def objects for quick rendering\n    p.loadGlyphs = function(url) {\n      var x, y, cx, cy, nx, ny, d, a, lastCom, lenC, horiz_adv_x, getXY = '[0-9\\\\-]+', path;\n\n      // Return arrays of SVG commands and coords\n      // get this to use p.matchAll() - will need to work around the lack of null return\n      var regex = function(needle, hay) {\n        var i = 0,\n          results = [],\n          latest, regexp = new RegExp(needle, \"g\");\n        latest = results[i] = regexp.exec(hay);\n        while (latest) {\n          i++;\n          latest = results[i] = regexp.exec(hay);\n        }\n        return results;\n      };\n\n      var buildPath = function(d) {\n        var c = regex(\"[A-Za-z][0-9\\\\- ]+|Z\", d);\n        var beforePathDraw = function() {\n          saveContext();\n          return drawing.$ensureContext();\n        };\n        var afterPathDraw = function() {\n          executeContextFill();\n          executeContextStroke();\n          restoreContext();\n        };\n\n        // Begin storing path object\n        path = \"return {draw:function(){var curContext=beforePathDraw();curContext.beginPath();\";\n\n        x = 0;\n        y = 0;\n        cx = 0;\n        cy = 0;\n        nx = 0;\n        ny = 0;\n        d = 0;\n        a = 0;\n        lastCom = \"\";\n        lenC = c.length - 1;\n\n        // Loop through SVG commands translating to canvas eqivs functions in path object\n        for (var j = 0; j < lenC; j++) {\n          var com = c[j][0], xy = regex(getXY, com);\n\n          switch (com[0]) {\n            case \"M\":\n              //curContext.moveTo(x,-y);\n              x = parseFloat(xy[0][0]);\n              y = parseFloat(xy[1][0]);\n              path += \"curContext.moveTo(\" + x + \",\" + (-y) + \");\";\n              break;\n\n            case \"L\":\n              //curContext.lineTo(x,-y);\n              x = parseFloat(xy[0][0]);\n              y = parseFloat(xy[1][0]);\n              path += \"curContext.lineTo(\" + x + \",\" + (-y) + \");\";\n              break;\n\n            case \"H\":\n              //curContext.lineTo(x,-y)\n              x = parseFloat(xy[0][0]);\n              path += \"curContext.lineTo(\" + x + \",\" + (-y) + \");\";\n              break;\n\n            case \"V\":\n              //curContext.lineTo(x,-y);\n              y = parseFloat(xy[0][0]);\n              path += \"curContext.lineTo(\" + x + \",\" + (-y) + \");\";\n              break;\n\n            case \"T\":\n              //curContext.quadraticCurveTo(cx,-cy,nx,-ny);\n              nx = parseFloat(xy[0][0]);\n              ny = parseFloat(xy[1][0]);\n\n              if (lastCom === \"Q\" || lastCom === \"T\") {\n                d = Math.sqrt(Math.pow(x - cx, 2) + Math.pow(cy - y, 2));\n                a = Math.PI + Math.atan2(cx - x, cy - y);\n                cx = x + (Math.sin(a) * (d));\n                cy = y + (Math.cos(a) * (d));\n              } else {\n                cx = x;\n                cy = y;\n              }\n\n              path += \"curContext.quadraticCurveTo(\" + cx + \",\" + (-cy) + \",\" + nx + \",\" + (-ny) + \");\";\n              x = nx;\n              y = ny;\n              break;\n\n            case \"Q\":\n              //curContext.quadraticCurveTo(cx,-cy,nx,-ny);\n              cx = parseFloat(xy[0][0]);\n              cy = parseFloat(xy[1][0]);\n              nx = parseFloat(xy[2][0]);\n              ny = parseFloat(xy[3][0]);\n              path += \"curContext.quadraticCurveTo(\" + cx + \",\" + (-cy) + \",\" + nx + \",\" + (-ny) + \");\";\n              x = nx;\n              y = ny;\n              break;\n\n            case \"Z\":\n              //curContext.closePath();\n              path += \"curContext.closePath();\";\n              break;\n          }\n          lastCom = com[0];\n        }\n\n        path += \"afterPathDraw();\";\n        path += \"curContext.translate(\" + horiz_adv_x + \",0);\";\n        path += \"}}\";\n\n        return ((new Function(\"beforePathDraw\", \"afterPathDraw\", path))(beforePathDraw, afterPathDraw));\n      };\n\n      // Parse SVG font-file into block of Canvas commands\n      var parseSVGFont = function(svg) {\n        // Store font attributes\n        var font = svg.getElementsByTagName(\"font\");\n        p.glyphTable[url].horiz_adv_x = font[0].getAttribute(\"horiz-adv-x\");\n\n        var font_face = svg.getElementsByTagName(\"font-face\")[0];\n        p.glyphTable[url].units_per_em = parseFloat(font_face.getAttribute(\"units-per-em\"));\n        p.glyphTable[url].ascent = parseFloat(font_face.getAttribute(\"ascent\"));\n        p.glyphTable[url].descent = parseFloat(font_face.getAttribute(\"descent\"));\n\n        var glyph = svg.getElementsByTagName(\"glyph\"),\n          len = glyph.length;\n\n        // Loop through each glyph in the SVG\n        for (var i = 0; i < len; i++) {\n          // Store attributes for this glyph\n          var unicode = glyph[i].getAttribute(\"unicode\");\n          var name = glyph[i].getAttribute(\"glyph-name\");\n          horiz_adv_x = glyph[i].getAttribute(\"horiz-adv-x\");\n          if (horiz_adv_x === null) {\n            horiz_adv_x = p.glyphTable[url].horiz_adv_x;\n          }\n          d = glyph[i].getAttribute(\"d\");\n          // Split path commands in glpyh\n          if (d !== undef) {\n            path = buildPath(d);\n            // Store glyph data to table object\n            p.glyphTable[url][name] = {\n              name: name,\n              unicode: unicode,\n              horiz_adv_x: horiz_adv_x,\n              draw: path.draw\n            };\n          }\n        } // finished adding glyphs to table\n      };\n\n      // Load and parse Batik SVG font as XML into a Processing Glyph object\n      var loadXML = function() {\n        var xmlDoc;\n\n        try {\n          xmlDoc = document.implementation.createDocument(\"\", \"\", null);\n        }\n        catch(e_fx_op) {\n          Processing.debug(e_fx_op.message);\n          return;\n        }\n\n        try {\n          xmlDoc.async = false;\n          xmlDoc.load(url);\n          parseSVGFont(xmlDoc.getElementsByTagName(\"svg\")[0]);\n        }\n        catch(e_sf_ch) {\n          // Google Chrome, Safari etc.\n          Processing.debug(e_sf_ch);\n          try {\n            var xmlhttp = new window.XMLHttpRequest();\n            xmlhttp.open(\"GET\", url, false);\n            xmlhttp.send(null);\n            parseSVGFont(xmlhttp.responseXML.documentElement);\n          }\n          catch(e) {\n            Processing.debug(e_sf_ch);\n          }\n        }\n      };\n\n      // Create a new object in glyphTable to store this font\n      p.glyphTable[url] = {};\n\n      // Begin loading the Batik SVG font...\n      loadXML(url);\n\n      // Return the loaded font for attribute grabbing\n      return p.glyphTable[url];\n    };\n\n    /**\n     * Gets the sketch parameter value. The parameter can be defined as the canvas attribute with\n     * the \"data-processing-\" prefix or provided in the pjs directive (e.g. param-test=\"52\").\n     * The function tries the canvas attributes, then the pjs directive content.\n     *\n     * @param   {String}    name          The name of the param to read.\n     *\n     * @returns {String}    The parameter value, or null if parameter is not defined.\n     */\n    p.param = function(name) {\n      // trying attribute that was specified in CANVAS\n      var attributeName = \"data-processing-\" + name;\n      if (curElement.hasAttribute(attributeName)) {\n        return curElement.getAttribute(attributeName);\n      }\n      // trying child PARAM elements of the CANVAS\n      for (var i = 0, len = curElement.childNodes.length; i < len; ++i) {\n        var item = curElement.childNodes.item(i);\n        if (item.nodeType !== 1 || item.tagName.toLowerCase() !== \"param\") {\n          continue;\n        }\n        if (item.getAttribute(\"name\") === name) {\n          return item.getAttribute(\"value\");\n        }\n      }\n      // fallback to default params\n      if (curSketch.params.hasOwnProperty(name)) {\n        return curSketch.params[name];\n      }\n      return null;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // 2D/3D methods wiring utils\n    ////////////////////////////////////////////////////////////////////////////\n    function wireDimensionalFunctions(mode) {\n      // Drawing2D/Drawing3D\n      if (mode === '3D') {\n        drawing = new Drawing3D();\n      } else if (mode === '2D') {\n        drawing = new Drawing2D();\n      } else {\n        drawing = new DrawingPre();\n      }\n\n      // Wire up functions (Use DrawingPre properties names)\n      for (var i in DrawingPre.prototype) {\n        if (DrawingPre.prototype.hasOwnProperty(i) && i.indexOf(\"$\") < 0) {\n          p[i] = drawing[i];\n        }\n      }\n\n      // Run initialization\n      drawing.$init();\n    }\n\n    function createDrawingPreFunction(name) {\n      return function() {\n        wireDimensionalFunctions(\"2D\");\n        return drawing[name].apply(this, arguments);\n      };\n    }\n    DrawingPre.prototype.translate = createDrawingPreFunction(\"translate\");\n    DrawingPre.prototype.transform = createDrawingPreFunction(\"transform\");\n    DrawingPre.prototype.scale = createDrawingPreFunction(\"scale\");\n    DrawingPre.prototype.pushMatrix = createDrawingPreFunction(\"pushMatrix\");\n    DrawingPre.prototype.popMatrix = createDrawingPreFunction(\"popMatrix\");\n    DrawingPre.prototype.resetMatrix = createDrawingPreFunction(\"resetMatrix\");\n    DrawingPre.prototype.applyMatrix = createDrawingPreFunction(\"applyMatrix\");\n    DrawingPre.prototype.rotate = createDrawingPreFunction(\"rotate\");\n    DrawingPre.prototype.rotateZ = createDrawingPreFunction(\"rotateZ\");\n    DrawingPre.prototype.shearX = createDrawingPreFunction(\"shearX\");\n    DrawingPre.prototype.shearY = createDrawingPreFunction(\"shearY\");\n    DrawingPre.prototype.redraw = createDrawingPreFunction(\"redraw\");\n    DrawingPre.prototype.toImageData = createDrawingPreFunction(\"toImageData\");\n    DrawingPre.prototype.ambientLight = createDrawingPreFunction(\"ambientLight\");\n    DrawingPre.prototype.directionalLight = createDrawingPreFunction(\"directionalLight\");\n    DrawingPre.prototype.lightFalloff = createDrawingPreFunction(\"lightFalloff\");\n    DrawingPre.prototype.lightSpecular = createDrawingPreFunction(\"lightSpecular\");\n    DrawingPre.prototype.pointLight = createDrawingPreFunction(\"pointLight\");\n    DrawingPre.prototype.noLights = createDrawingPreFunction(\"noLights\");\n    DrawingPre.prototype.spotLight = createDrawingPreFunction(\"spotLight\");\n    DrawingPre.prototype.beginCamera = createDrawingPreFunction(\"beginCamera\");\n    DrawingPre.prototype.endCamera = createDrawingPreFunction(\"endCamera\");\n    DrawingPre.prototype.frustum = createDrawingPreFunction(\"frustum\");\n    DrawingPre.prototype.box = createDrawingPreFunction(\"box\");\n    DrawingPre.prototype.sphere = createDrawingPreFunction(\"sphere\");\n    DrawingPre.prototype.ambient = createDrawingPreFunction(\"ambient\");\n    DrawingPre.prototype.emissive = createDrawingPreFunction(\"emissive\");\n    DrawingPre.prototype.shininess = createDrawingPreFunction(\"shininess\");\n    DrawingPre.prototype.specular = createDrawingPreFunction(\"specular\");\n    DrawingPre.prototype.fill = createDrawingPreFunction(\"fill\");\n    DrawingPre.prototype.stroke = createDrawingPreFunction(\"stroke\");\n    DrawingPre.prototype.strokeWeight = createDrawingPreFunction(\"strokeWeight\");\n    DrawingPre.prototype.smooth = createDrawingPreFunction(\"smooth\");\n    DrawingPre.prototype.noSmooth = createDrawingPreFunction(\"noSmooth\");\n    DrawingPre.prototype.point = createDrawingPreFunction(\"point\");\n    DrawingPre.prototype.vertex = createDrawingPreFunction(\"vertex\");\n    DrawingPre.prototype.endShape = createDrawingPreFunction(\"endShape\");\n    DrawingPre.prototype.bezierVertex = createDrawingPreFunction(\"bezierVertex\");\n    DrawingPre.prototype.curveVertex = createDrawingPreFunction(\"curveVertex\");\n    DrawingPre.prototype.curve = createDrawingPreFunction(\"curve\");\n    DrawingPre.prototype.line = createDrawingPreFunction(\"line\");\n    DrawingPre.prototype.bezier = createDrawingPreFunction(\"bezier\");\n    DrawingPre.prototype.rect = createDrawingPreFunction(\"rect\");\n    DrawingPre.prototype.ellipse = createDrawingPreFunction(\"ellipse\");\n    DrawingPre.prototype.background = createDrawingPreFunction(\"background\");\n    DrawingPre.prototype.image = createDrawingPreFunction(\"image\");\n    DrawingPre.prototype.textWidth = createDrawingPreFunction(\"textWidth\");\n    DrawingPre.prototype.text$line = createDrawingPreFunction(\"text$line\");\n    DrawingPre.prototype.$ensureContext = createDrawingPreFunction(\"$ensureContext\");\n    DrawingPre.prototype.$newPMatrix = createDrawingPreFunction(\"$newPMatrix\");\n\n    DrawingPre.prototype.size = function(aWidth, aHeight, aMode) {\n      wireDimensionalFunctions(aMode === PConstants.WEBGL ? \"3D\" : \"2D\");\n      p.size(aWidth, aHeight, aMode);\n    };\n\n    DrawingPre.prototype.$init = noop;\n\n    Drawing2D.prototype.$init = function() {\n      // Setup default 2d canvas context.\n      // Moving this here removes the number of times we need to check the 3D variable\n      p.size(p.width, p.height);\n\n      curContext.lineCap = 'round';\n\n      // Set default stroke and fill color\n      p.noSmooth();\n      p.disableContextMenu();\n    };\n    Drawing3D.prototype.$init = function() {\n      // For ref/perf test compatibility until those are fixed\n      p.use3DContext = true;\n      p.disableContextMenu();\n    };\n\n    DrawingShared.prototype.$ensureContext = function() {\n      return curContext;\n    };\n\n    //////////////////////////////////////////////////////////////////////////\n    // Keyboard Events\n    //////////////////////////////////////////////////////////////////////////\n\n    // In order to catch key events in a canvas, it needs to be \"specially focusable\",\n    // by assigning it a tabindex. If no tabindex is specified on-page, set this to 0.\n    if (!curElement.getAttribute(\"tabindex\")) {\n      curElement.setAttribute(\"tabindex\", 0);\n    }\n\n    function getKeyCode(e) {\n      var code = e.which || e.keyCode;\n      switch (code) {\n        case 13: // ENTER\n          return 10;\n        case 91: // META L (Saf/Mac)\n        case 93: // META R (Saf/Mac)\n        case 224: // META (FF/Mac)\n          return 157;\n        case 57392: // CONTROL (Op/Mac)\n          return 17;\n        case 46: // DELETE\n          return 127;\n        case 45: // INSERT\n          return 155;\n      }\n      return code;\n    }\n\n    function getKeyChar(e) {\n      var c = e.which || e.keyCode;\n      var anyShiftPressed = e.shiftKey || e.ctrlKey || e.altKey || e.metaKey;\n      switch (c) {\n        case 13:\n          c = anyShiftPressed ? 13 : 10; // RETURN vs ENTER (Mac)\n          break;\n        case 8:\n          c = anyShiftPressed ? 127 : 8; // DELETE vs BACKSPACE (Mac)\n          break;\n      }\n      return new Char(c);\n    }\n\n    function suppressKeyEvent(e) {\n      if (typeof e.preventDefault === \"function\") {\n        e.preventDefault();\n      } else if (typeof e.stopPropagation === \"function\") {\n        e.stopPropagation();\n      }\n      return false;\n    }\n\n    function updateKeyPressed() {\n      var ch;\n      for (ch in pressedKeysMap) {\n        if (pressedKeysMap.hasOwnProperty(ch)) {\n          p.__keyPressed = true;\n          return;\n        }\n      }\n      p.__keyPressed = false;\n    }\n\n    function resetKeyPressed() {\n      p.__keyPressed = false;\n      pressedKeysMap = [];\n      lastPressedKeyCode = null;\n    }\n\n    function simulateKeyTyped(code, c) {\n      pressedKeysMap[code] = c;\n      lastPressedKeyCode = null;\n      p.key = c;\n      p.keyCode = code;\n      p.keyPressed();\n      p.keyCode = 0;\n      p.keyTyped();\n      updateKeyPressed();\n    }\n\n    function handleKeydown(e) {\n      var code = getKeyCode(e);\n      if (code === PConstants.DELETE) {\n        simulateKeyTyped(code, new Char(127));\n        return;\n      }\n      if (codedKeys.indexOf(code) < 0) {\n        lastPressedKeyCode = code;\n        return;\n      }\n      var c = new Char(PConstants.CODED);\n      p.key = c;\n      p.keyCode = code;\n      pressedKeysMap[code] = c;\n      p.keyPressed();\n      lastPressedKeyCode = null;\n      updateKeyPressed();\n      return suppressKeyEvent(e);\n    }\n\n    function handleKeypress(e) {\n      if (lastPressedKeyCode === null) {\n        return; // processed in handleKeydown\n      }\n      var code = lastPressedKeyCode, c = getKeyChar(e);\n      simulateKeyTyped(code, c);\n      return suppressKeyEvent(e);\n    }\n\n    function handleKeyup(e) {\n      var code = getKeyCode(e), c = pressedKeysMap[code];\n      if (c === undef) {\n        return; // no keyPressed event was generated.\n      }\n      p.key = c;\n      p.keyCode = code;\n      p.keyReleased();\n      delete pressedKeysMap[code];\n      updateKeyPressed();\n    }\n\n    // Send aCode Processing syntax to be converted to JavaScript\n    if (!pgraphicsMode) {\n      if (aCode instanceof Processing.Sketch) {\n        // Use sketch as is\n        curSketch = aCode;\n      } else if (typeof aCode === \"function\") {\n        // Wrap function with default sketch parameters\n        curSketch = new Processing.Sketch(aCode);\n      } else if (!aCode) {\n        // Empty sketch\n        curSketch = new Processing.Sketch(function (){});\n      } else {\n  //#if PARSER\n        // Compile the code\n        curSketch = Processing.compile(aCode);\n  //#else\n  //      throw \"PJS compile is not supported\";\n  //#endif\n      }\n\n      // Expose internal field for diagnostics and testing\n      p.externals.sketch = curSketch;\n\n      wireDimensionalFunctions();\n\n      // the onfocus and onblur events are handled in two parts.\n      // 1) the p.focused property is handled per sketch\n      curElement.onfocus = function() {\n        p.focused = true;\n      };\n\n      curElement.onblur = function() {\n        p.focused = false;\n        if (!curSketch.options.globalKeyEvents) {\n          resetKeyPressed();\n        }\n      };\n\n      // 2) looping status is handled per page, based on the pauseOnBlur @pjs directive\n      if (curSketch.options.pauseOnBlur) {\n        attachEventHandler(window, 'focus', function() {\n          if (doLoop) {\n            p.loop();\n          }\n        });\n\n        attachEventHandler(window, 'blur', function() {\n          if (doLoop && loopStarted) {\n            p.noLoop();\n            doLoop = true; // make sure to keep this true after the noLoop call\n          }\n          resetKeyPressed();\n        });\n      }\n\n      // if keyboard events should be handled globally, the listeners should\n      // be bound to the document window, rather than to the current canvas\n      var keyTrigger = curSketch.options.globalKeyEvents ? window : curElement;\n      attachEventHandler(keyTrigger, \"keydown\", handleKeydown);\n      attachEventHandler(keyTrigger, \"keypress\", handleKeypress);\n      attachEventHandler(keyTrigger, \"keyup\", handleKeyup);\n\n      // Step through the libraries that were attached at doc load...\n      for (var i in Processing.lib) {\n        if (Processing.lib.hasOwnProperty(i)) {\n          if(Processing.lib[i].hasOwnProperty(\"attach\")) {\n            // use attach function if present\n            Processing.lib[i].attach(p);\n          } else if(Processing.lib[i] instanceof Function)  {\n            // Init the libraries in the context of this p_instance (legacy)\n            Processing.lib[i].call(this);\n          }\n        }\n      }\n\n      // sketch execute test interval, used to reschedule\n      // an execute when preloads have not yet finished.\n      var retryInterval = 100;\n\n      var executeSketch = function(processing) {\n        // Don't start until all specified images and fonts in the cache are preloaded\n        if (!(curSketch.imageCache.pending || PFont.preloading.pending(retryInterval))) {\n          // the opera preload cache can only be cleared once we start\n          if (window.opera) {\n            var link,\n                element,\n                operaCache=curSketch.imageCache.operaCache;\n            for (link in operaCache) {\n              if(operaCache.hasOwnProperty(link)) {\n                element = operaCache[link];\n                if (element !== null) {\n                  document.body.removeChild(element);\n                }\n                delete(operaCache[link]);\n              }\n            }\n          }\n\n          curSketch.attach(processing, defaultScope);\n\n          // pass a reference to the p instance for this sketch.\n          curSketch.onLoad(processing);\n\n          // Run void setup()\n          if (processing.setup) {\n            processing.setup();\n            // if any transforms were performed in setup reset to identity matrix\n            // so draw loop is unpolluted\n            processing.resetMatrix();\n            curSketch.onSetup();\n          }\n\n          // some pixels can be cached, flushing\n          resetContext();\n\n          if (processing.draw) {\n            if (!doLoop) {\n              processing.redraw();\n            } else {\n              processing.loop();\n            }\n          }\n        } else {\n          window.setTimeout(function() { executeSketch(processing); }, retryInterval);\n        }\n      };\n\n      // Only store an instance of non-createGraphics instances.\n      addInstance(this);\n\n      // The parser adds custom methods to the processing context\n      // this renames p to processing so these methods will run\n      executeSketch(p);\n    } else {\n      // No executable sketch was specified\n      // or called via createGraphics\n      curSketch = new Processing.Sketch();\n\n      wireDimensionalFunctions();\n\n      // Hack to make PGraphics work again after splitting size()\n      p.size = function(w, h, render) {\n        if (render && render === PConstants.WEBGL) {\n          wireDimensionalFunctions('3D');\n        } else {\n          wireDimensionalFunctions('2D');\n        }\n\n        p.size(w, h, render);\n      };\n    }\n  };\n\n  // Place-holder for overridable debugging function\n  Processing.debug = (function() {\n    if (\"console\" in window) {\n      return function(msg) {\n        window.console.log('Processing.js: ' + msg);\n      };\n    }\n    return noop;\n  }());\n\n  // bind prototype\n  Processing.prototype = defaultScope;\n\n  /**\n   * instance store and lookup\n   */\n  Processing.instances = processingInstances;\n  Processing.getInstanceById = function(name) {\n    return processingInstances[processingInstanceIds[name]];\n  };\n\n  // Unsupported Processing File and I/O operations.\n  (function(Processing) {\n    var unsupportedP5 = (\"open() createOutput() createInput() BufferedReader selectFolder() \" +\n                         \"dataPath() createWriter() selectOutput() beginRecord() \" +\n                         \"saveStream() endRecord() selectInput() saveBytes() createReader() \" +\n                         \"beginRaw() endRaw() PrintWriter delay()\").split(\" \"),\n        count = unsupportedP5.length,\n        prettyName,\n        p5Name;\n\n    function createUnsupportedFunc(n) {\n      return function() {\n        throw \"Processing.js does not support \" + n + \".\";\n      };\n    }\n\n    while (count--) {\n      prettyName = unsupportedP5[count];\n      p5Name = prettyName.replace(\"()\", \"\");\n      Processing[p5Name] = createUnsupportedFunc(prettyName);\n    }\n  }(defaultScope));\n\n  // we're done. Return our object.\n  return Processing;\n};\n\n},{}],28:[function(require,module,exports){\n// Base source files\nvar source = {\n  virtEquals: require(\"./Helpers/virtEquals\"),\n  virtHashCode: require(\"./Helpers/virtHashCode\"),\n  ObjectIterator: require(\"./Helpers/ObjectIterator\"),\n  PConstants: require(\"./Helpers/PConstants\"),\n  ArrayList: require(\"./Objects/ArrayList\"),\n  HashMap: require(\"./Objects/HashMap\"),\n  PVector: require(\"./Objects/PVector\"),\n  PFont: require(\"./Objects/PFont\"),\n  Char: require(\"./Objects/Char\"),\n  XMLAttribute: require(\"./Objects/XMLAttribute\"),\n  XMLElement: require(\"./Objects/XMLElement\"),\n  PMatrix2D: require(\"./Objects/PMatrix2D\"),\n  PMatrix3D: require(\"./Objects/PMatrix3D\"),\n  PShape: require(\"./Objects/PShape\"),\n  colors: require(\"./Objects/webcolors\"),\n  PShapeSVG:  require(\"./Objects/PShapeSVG\"),\n  CommonFunctions: require(\"./P5Functions/commonFunctions\"),\n  defaultScope: require(\"./Helpers/defaultScope\"),\n  Processing: require(\"./Processing\"),\n  setupParser: require(\"./Parser/Parser\"),\n  finalize: require(\"./Helpers/finalizeProcessing\")\n};\n\n// Additional code that gets tacked onto \"p\" during\n// instantiation of a Processing sketch.\nsource.extend = {\n  withMath: require(\"./P5Functions/Math.js\"),\n  withProxyFunctions: require(\"./P5Functions/JavaProxyFunctions\")(source.virtHashCode, source.virtEquals),\n  withTouch: require(\"./P5Functions/touchmouse\"),\n  withCommonFunctions: source.CommonFunctions.withCommonFunctions\n};\n\n/**\n * Processing.js building function\n */\nmodule.exports = function buildProcessingJS(Browser, testHarness) {\n  var noop = function(){},\n      virtEquals = source.virtEquals,\n      virtHashCode = source.virtHashCode,\n      PConstants = source.PConstants,\n      CommonFunctions = source.CommonFunctions,\n      ObjectIterator = source.ObjectIterator,\n      Char = source.Char,\n      XMLAttribute = source.XMLAttribute(),\n\n      ArrayList = source.ArrayList({\n        virtHashCode: virtHashCode,\n        virtEquals: virtEquals\n      }),\n\n      HashMap = source.HashMap({\n        virtHashCode: virtHashCode,\n        virtEquals: virtEquals\n      }),\n\n      PVector = source.PVector({\n        PConstants: PConstants\n      }),\n\n      PFont = source.PFont({\n        Browser: Browser,\n        noop: noop\n      }),\n\n      XMLElement = source.XMLElement({\n        Browser: Browser,\n        XMLAttribute: XMLAttribute\n      }),\n\n      PMatrix2D = source.PMatrix2D({\n        p:CommonFunctions\n      }),\n\n      PMatrix3D = source.PMatrix3D({\n        p:CommonFunctions\n      }),\n\n      PShape = source.PShape({\n        PConstants: PConstants,\n        PMatrix2D: PMatrix2D,\n        PMatrix3D: PMatrix3D\n      }),\n\n      PShapeSVG = source.PShapeSVG({\n        CommonFunctions: CommonFunctions,\n        PConstants: PConstants,\n        PShape: PShape,\n        XMLElement: XMLElement,\n        colors: source.colors\n      }),\n\n      defaultScope = source.defaultScope({\n        ArrayList: ArrayList,\n        HashMap: HashMap,\n        PVector: PVector,\n        PFont: PFont,\n        PShapeSVG: PShapeSVG,\n        ObjectIterator: ObjectIterator,\n        PConstants: PConstants,\n        Char: Char,\n        XMLElement: XMLElement,\n        XML: XMLElement\n      }),\n\n      Processing = source.Processing({\n        defaultScope: defaultScope,\n        Browser: Browser,\n        extend: source.extend,\n        noop: noop\n      });\n\n  // set up the Processing syntax parser\n  Processing = source.setupParser(Processing, {\n    Browser: Browser,\n    aFunctions: testHarness,\n    defaultScope: defaultScope\n  });\n\n  // finalise the Processing object\n  Processing = source.finalize(Processing, {\n    version: require('../package.json').version,\n    isDomPresent: false || Browser.isDomPresent,\n    window: Browser.window,\n    document: Browser.document,\n    noop: noop\n  });\n\n  // done.\n  return Processing;\n};\n\n},{\"../package.json\":2,\"./Helpers/ObjectIterator\":3,\"./Helpers/PConstants\":4,\"./Helpers/defaultScope\":6,\"./Helpers/finalizeProcessing\":7,\"./Helpers/virtEquals\":8,\"./Helpers/virtHashCode\":9,\"./Objects/ArrayList\":10,\"./Objects/Char\":11,\"./Objects/HashMap\":12,\"./Objects/PFont\":13,\"./Objects/PMatrix2D\":14,\"./Objects/PMatrix3D\":15,\"./Objects/PShape\":16,\"./Objects/PShapeSVG\":17,\"./Objects/PVector\":18,\"./Objects/XMLAttribute\":19,\"./Objects/XMLElement\":20,\"./Objects/webcolors\":21,\"./P5Functions/JavaProxyFunctions\":22,\"./P5Functions/Math.js\":23,\"./P5Functions/commonFunctions\":24,\"./P5Functions/touchmouse\":25,\"./Parser/Parser\":26,\"./Processing\":27}]},{},[1]);\n"],"names":["r","e","n","t1","o","i","f","c","require","undefined","u","a","Error","code","p","exports","call","length","require1","module","Browser","isDomPresent","navigator","window","document","ajax","url","xhr","XMLHttpRequest","open","overrideMimeType","setRequestHeader","send","status","responseText","Processing","obj","Array","index","hasNext","next","iterator","Function","X","Y","Z","R","G","B","A","U","V","NX","NY","NZ","EDGE","SR","SG","SB","SA","SW","TX","TY","TZ","VX","VY","VZ","VW","AR","AG","AB","DR","DG","DB","DA","SPR","SPG","SPB","SHINE","ER","EG","EB","BEEN_LIT","VERTEX_FIELD_COUNT","P2D","JAVA2D","WEBGL","P3D","OPENGL","PDF","DXF","OTHER","WINDOWS","MACOSX","LINUX","EPSILON","MAX_FLOAT","MIN_FLOAT","MAX_INT","MIN_INT","PI","Math","TWO_PI","TAU","HALF_PI","THIRD_PI","QUARTER_PI","DEG_TO_RAD","RAD_TO_DEG","WHITESPACE","RGB","ARGB","HSB","ALPHA","CMYK","TIFF","TARGA","JPEG","GIF","BLUR","GRAY","INVERT","OPAQUE","POSTERIZE","THRESHOLD","ERODE","DILATE","REPLACE","BLEND","ADD","SUBTRACT","LIGHTEST","DARKEST","DIFFERENCE","EXCLUSION","MULTIPLY","SCREEN","OVERLAY","HARD_LIGHT","SOFT_LIGHT","DODGE","BURN","ALPHA_MASK","RED_MASK","GREEN_MASK","BLUE_MASK","CUSTOM","ORTHOGRAPHIC","PERSPECTIVE","POINT","POINTS","LINE","LINES","TRIANGLE","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","QUAD","QUADS","QUAD_STRIP","POLYGON","PATH","RECT","ELLIPSE","ARC","SPHERE","BOX","CHORD","PIE","GROUP","PRIMITIVE","GEOMETRY","VERTEX","BEZIER_VERTEX","CURVE_VERTEX","BREAK","CLOSESHAPE","OPEN","CLOSE","CORNER","CORNERS","RADIUS","CENTER_RADIUS","CENTER","DIAMETER","CENTER_DIAMETER","BASELINE","TOP","BOTTOM","NORMAL","NORMALIZED","IMAGE","MODEL","SHAPE","SQUARE","ROUND","PROJECT","MITER","BEVEL","AMBIENT","DIRECTIONAL","SPOT","BACKSPACE","TAB","ENTER","RETURN","ESC","DELETE","CODED","SHIFT","CONTROL","ALT","CAPSLK","PGUP","PGDN","END","HOME","LEFT","UP","RIGHT","DOWN","F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12","NUMLK","META","INSERT","ARROW","CROSS","HAND","MOVE","TEXT","WAIT","NOCURSOR","DISABLE_OPENGL_2X_SMOOTH","ENABLE_OPENGL_2X_SMOOTH","ENABLE_OPENGL_4X_SMOOTH","ENABLE_NATIVE_FONTS","DISABLE_DEPTH_TEST","ENABLE_DEPTH_TEST","ENABLE_DEPTH_SORT","DISABLE_DEPTH_SORT","DISABLE_OPENGL_ERROR_REPORT","ENABLE_OPENGL_ERROR_REPORT","ENABLE_ACCURATE_TEXTURES","DISABLE_ACCURATE_TEXTURES","HINT_COUNT","SINCOS_LENGTH","PRECISIONB","PRECISIONF","PREC_MAXVAL","PREC_ALPHA_SHIFT","PREC_RED_SHIFT","NORMAL_MODE_AUTO","NORMAL_MODE_SHAPE","NORMAL_MODE_VERTEX","MAX_LIGHTS","document1","BufferMax","style","createElement","added","textContent","wrapper","classList","add","dragger","closer","innerHTML","javaconsole","setAttribute","appendChild","onmousedown","divheight","height","selection","empty","getSelection","removeAllRanges","screenY","onmousemove","parseFloat","onmouseup","BufferArray","print","log","body","args","prototype","slice","arguments","t","map","idx","join","push","showconsole","println","apply","splice","scrollTop","scrollHeight","remove","hideconsole","onclick","options","DefaultScope","PConstants","defaultScope1","extendClass","subClass","baseClass","properties","propertyName","overloadBaseClassFunction","object","name","basefn","hasOwnProperty","overloads","defaultOverload","fn","$defaultOverload","$overloads","hubfn","$methodArgsIndex","charAt","extendGetterSetter","defineProperty","get","set","v","enumerable","shift","$super","Object","keys","forEach","prop","desc","__defineGetter__","__defineSetter__","extendClassChain","base","path","self","$upcast","pop","$self","extendStaticMembers","derived","extendInterfaceMembers","addMethod","hasMethodArgs","existingfn","createJavaArray","type","bounds","result","defaultValue","indexOf","itemsCount","newBounds","j","innerWidth","innerHeight","Processing1","undef","window1","XMLHttpRequest1","noop","isDOMPresent","version","lib","registerLibrary","library","init","defaultScope","Sketch","attachFunction","pauseOnBlur","globalKeyEvents","onLoad","onSetup","onPause","onLoop","onFrameStart","onFrameEnd","onExit","params","imageCache","pending","images","operaCache","href","img","owner","Image","onload","src","opera","div","position","opacity","width","sourceCode","attach","processing","func","toString","value","loadSketchFromSources","canvas","sources","onComplete","errors","sourcesCount","loaded","loadBlock","filename","callback","block","error","sketch","scriptElement","getElementById","substring","text","onreadystatechange","readyState","withCredentials","location","protocol","removeEventListener","instances","exit","filenames","getElementsByTagName","l","processingSources","getAttribute","split","s","last","nodelist","scripts","script","toLowerCase","target","nextSibling","nodeType","nodeName","addEventListener","reload","disableInit","other","equals","hash","charCodeAt","hashCode","$id","floor","random","virtHashCode","virtEquals","Iterator","array","ArrayList","toArray","contains","item","len","lastIndexOf","arg0","addAll","arg1","arg2","it","ObjectIterator","size","clear","removeAll","x","newList","isEmpty","clone","charMap","Char1","chr","NaN","String","fromCharCode","valueOf","HashMap","initialCapacity","loadFactor","buckets","count","hashMap","getBucketIndex","key","ensureLoad","allEntries","concat","newBucketsLength","bucket","conversion","removeItem","currentItem","bucketIndex","itemIndex","endOfBuckets","findNext","Set","isIn","containsAll","retainAll","toRemove","entry","Entry","pair","_isIn","removed","getKey","getValue","setValue","old","putAll","containsKey","containsValue","entrySet","keySet","values","removeByValue","put","previous","m","ilen","PFont1","glyph","ascent","descent","leading","illegalIndicator","italicsIndicator","weight","boldIndicator","family","context2d","computeFontMetrics","pfont","correctionFactor","cfmFont","getCSSDefinition","emQuad","ctx","getContext","font","protrusions","measureText","leadDiv","fontFamily","fontSize","w","h","baseline","fillStyle","fillRect","fillText","pixelData","getImageData","data","w4","round","defaultView","getComputedStyle","leadDivHeight","getPropertyValue","replace","removeChild","caching","css","lineHeight","components","measureTextWidth","string","measureTextWidthFallback","PFontCache","fontName","cache","getFallback","list","preloading","template","initialized","initialize","fontface","encoded","input","substr","head","element","cssText","getElementWidth","timeAttempted","intervallength","computedWidthFont","computedWidthRef","fontList","addedList","fontSrc","fontFace","fontUrl","PMatrix2D","reset","elements","outgoing","translate","tx","ty","invTranslate","transpose","mult","source","y","PVector","z","multX","multY","skewX","angle","skewY","shearX","tan","shearY","determinant","invert","d","abs","old00","old01","old02","old10","old11","old12","scale","sx","sy","invScale","row","col","preApply","rotate","cos","sin","temp1","temp2","rotateZ","invRotateZ","digits","printMatrixHelper","output","nfs","PMatrix3D","tz","temp","v0","v1","v2","invApply","inverseCopy","rotateX","rotateY","sz","multZ","multW","fA0","fA1","fA2","fA3","fA4","fA5","fB0","fB1","fB2","fB3","fB4","fB5","fDet","kInv","fInvDet","str","invRotateX","invRotateY","PConstants1","PShape","visible","children","nameTable","image","matrix","kind","close","parent","isVisible","setVisible","disableStyle","enableStyle","getFamily","getWidth","getHeight","setName","getName","draw","renderContext","pre","drawImpl","post","drawGroup","drawPrimitive","drawGeometry","drawPath","vertices","beginShape","vertexCodes","vertex","moveTo","breakShape","bezierVertex","curveVertex","vertArray","endShape","vert","point","line","triangle","quad","imMode","imageModeConvert","imageMode","rcMode","curRectMode","rectMode","rect","elMode","curEllipseMode","ellipseMode","ellipse","eMode","arc","box","sphere","pushMatrix","transform","pushStyle","styles","popMatrix","popStyle","stroke","strokeColor","strokeWeight","strokeCap","strokeJoin","noStroke","fill","fillColor","noFill","getChild","child","found","getChildCount","addChild","addName","shape","checkMatrix","dimensions","resetMatrix","applyMatrix","CommonFunctions","XMLElement1","XMLElement","colors","PShapeSVG1","strokeGradient","strokeGradientPaint","strokeName","strokeOpacity","fillGradient","fillGradientPaint","fillName","fillOpacity","getStringAttribute","displayStr","parseMatrix","viewBoxStr","viewBox","unitWidth","unitHeight","parseUnitSize","parseColors","parseChildren","pieces","all","trim","getCoords","radians","newelement","getChildren","kid","parseChild","elem","parseLine","parseEllipse","parseRect","parsePoly","parsePath","unimplemented","lastInstruction","command","k","pathData","cx","cy","ctrlX","ctrlY","ctrlX1","ctrlX2","ctrlY1","ctrlY2","endX","endY","ppx","ppy","px","py","valOf","tmpArray","flag","parsePathMoveto","parsePathLineto","parsePathCurveto","parsePathQuadto","x1","y1","x2","y2","parsePathCode","parsePathVertex","x3","y3","verts","what","val","pointsAttr","pointsBuffer","getFloatAttribute","rx","ry","hasAttribute","setOpacity","setStroke","setStrokeWeight","setStrokeJoin","setStrokeCap","setFill","styleTokens","styleText","tokens","setFillOpacity","setStrokeOpacity","opacityText","opacityMask","parseInt","parseRGB","strokeText","linejoin","linecap","color","sub","PVector1","method","fromAngle","random2D","random3D","vz","sqrt","vx","vy","dist","dot","cross","angleBetween","acos","magSq","lerp","amt","retval","mag","setMag","v_or_len","normalize","prev_x","dx","dy","dz","v_or_x","amt_or_y","lerp_val","start","stop","limit","high","heading","atan2","heading2D","createPVectorMethod","XMLAttribute","fname","nameSpace","fullName","namespace","getFullName","getNamespace","getType","newval","DOMParser","selector","uri","sysid","attributes","content","lineNr","systemID","parse","systemId","textstring","stringIsURI","xmlDoc","parseFromString","documentElement","parseChildrenRecursive","elementpath","xmlelement","xmlattribute","tmpattrib","localName","createPCDataElement","createCDataElement","getname","namespaceURI","nodeValue","childNodes","node","fullname","namespaceuri","isCDATA","pcdata","cdata","entity","htmlentities","RegExp","attr_name","attr_ns","attr_other","child1","child2","getAttributeCount","findAttribute","getContent","attribute","getString","attributeName","getFloat","getIntAttribute","getInt","hasChildren","insertChild","getLocalName","lastChild","setContent","getChildRecursive","kidName","getChildrenRecursive","matches","items","offset","matchName","kidMatches","isLeaf","listChildren","arr","removeAttribute","removeChildAtIndex","attr","setString","setInt","setFloat","debug","tagstring","xmlstring","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgrey","lightgreen","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","snow","springgreen","steelblue","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","removeFirstArgument","__contains","subject","subStr","__replaceAll","regex","replacement","replaceAll","__replaceFirst","replaceFirst","__replace","__equals","__equalsIgnoreCase","equalsIgnoreCase","__toCharArray","toCharArray","chars","Char","__split","pattern","pos","currSubject","search","match","exec","__codePointAt","hi","low","__matches","regexp","test","__startsWith","prefix","toffset","startsWith","__endsWith","suffix","endsWith","suffixLen","__hashCode","__printStackTrace","internalRandomGenerator","Marsaglia","i1","i2","intGenerator","doubleGenerator","PerlinNoise","seed","rnd","createRandomized","perm","Uint8Array","grad3d","grad2d","noise3d","fx","fy","fz","p0","p00","p01","p1","p10","p11","b","noise2d","noise1d","ceil","exp","pow","asin","atan","constrain","aNumber","aMin","aMax","value1","value2","istart","istop","ostart","ostop","max","numbers","min","norm","sq","degrees","aAngle","ir","now","Date","randomSeed","haveNextNextGaussian","randomGaussian","nextNextGaussian","multiplier","noiseProfile","generator","octaves","fallout","noise","effect","sum","noiseDetail","noiseSeed","nfCoreScalar","plus","minus","leftDigits","rightDigits","group","sign","rightDigitsOfDefault","absValue","number","doubled","floored","buffer","totalDigits","nfCore","nf","nfp","nfc","withCommonFunctions","curElement","attachEventHandler","detachEventHandlersByType","enabled","contextMenu","mouseTypes","calculateOffset","event","stylePaddingLeft","stylePaddingTop","styleBorderLeft","styleBorderTop","offsetX","offsetY","pmouseX","mouseX","pmouseY","mouseY","offsetParent","offsetLeft","offsetTop","scrollLeft","parentNode","paddingLeft","paddingTop","borderLeftWidth","borderTopWidth","pageXOffset","pageYOffset","updateMousePosition","pageX","pageY","addTouchEventOffset","changedTouches","touches","touch","targetTouches","targetTouch","changedTouch","touchStart","touchMove","touchEnd","touchCancel","preventDefault","__mousePressed","mouseDragging","mouseButton","mousePressed","mouseMoved","mouseDragged","mouseClicked","mouseReleased","stopPropagation","disableContextMenu","enableContextMenu","detachEventHandler","mouseOut","mouseOver","focus","which","mouseWheelHandler","delta","wheelDelta","detail","mouseScroll","mouseScrolled","aFunctions","compile","pdeCode","compiledPde","parseProcessing","statements","transformClassBody","transformInterfaceBody","transformStatementsBlock","transformStatements","transformExpression","globalMembers","getGlobalMembers","names","members","exportedNames","trimSpaces","m1","left","middle","right","m2","untrim","appendToLookupTable","table","getAtomIndex","templ","codeWoExtraCr","strings","codeWoStrings","quoted","aposed","regexCtx","singleComment","comment","codeWoGenerics","hexCode","replaceFunc","before","types","after","genericsWereRemoved","replaceContext","currentClassId","atoms","splitToAtoms","stack","unshift","declaredClasses","classIdSeed","addAtom","lastIndex","generateClassId","appendClass","class_","classId","scopeId","classesRegex","methodsRegex","fieldTest","cstrsRegex","attrAndTypeRegex","functionsRegex","extractClassesAndMethods","extractConstructors","className","throws_","AstParam","AstParams","methodArgsParam","transformParams","paramsWoPars","paramList","param","AstInlineClass","baseInterfaceName","AstFunction","transformFunction","AstInlineObject","AstExpression","expr","transforms","AstVarDefinition","isDefault","transformVarDefinition","def","defaultTypeValue","eqIndex","getDefaultValueForType","AstVar","definitions","varType","AstStatement","expression","transformStatement","statement","attrAndType","AstForExpression","initStatement","condition","step","AstForInExpression","container","AstForEachExpression","sortByWeight","sort","AstInnerInterface","isStatic","AstInnerClass","transformInnerClass","innerClass","oldClassId","newClassId","AstClassMethod","transformClassMethod","AstClassField","fieldType","transformClassField","AstConstructor","AstInterfaceBody","interfacesNames","methodsNames","fields","innerClasses","misc","AstClassBody","baseClassName","functions","methods","cstrs","AstInterface","AstClass","transformGlobalClass","globalClass","AstMethod","transformGlobalMethod","AstForStatement","argument","AstCatchStatement","AstPrefixStatement","AstSwitchCase","AstLabel","label","getLocalNames","localNames","getNames","AstStatementsBlock","AstRoot","prependMethodArgs","oldContext","memberAccessSign","identifier","subMember","callSign","member","expandExpression","trimmed","preExpressionTransform","repeatJavaReplacement","replacePrototypeMethods","atomIndex","atom","createArrayArgs","indexParts","arg","numberWo0","intPart","toUpperCase","indexOrLength","equalsPart","rightSide","replaceInstanceof","uniqueClassName","inlineClass","transformInlineObject","iteratorId","variableName","paramNames","methodId","thisPrefix","staticDeclarations","definition","staticName","declaration","getMembers","classFields","classMethods","classInners","fieldNames","getScopeLevel","scope","staticDefinitions","metadata","interfaces","resolvedInterface","resolvedInterfaces","field","baseInterfaces","baseInterfaceNames","declarations","classes","tail","selfId","thisClassFields","thisClassMethods","thisClassInners","resolvedBaseClassName","fieldName","methodOverloads","overload","cstrsIfs","paramsLength","methodArgsPresent","baseName","transformConstructor","cstr","transformMethod","transformClass","nextStatement","res","space","statementsPrefix","transformForExpression","statementsTail","isLookupTableEmpty","otherStatements","transformed","generateMetadata","ast","globalScope","id","inScope","findInScopes","parts","currentScope","interface_","setWeight","queue","tocheck","dependsOn","removeDependentAndCheck","targetId","from","redendered","preprocessCode","aCode","dm","jsonItems","directives","clean","dl","jl","imageName","xl","PFont","JSON","PjsConsole","logger","localStorage","extend","navigator1","PShapeSVG","Character","XML","HTMLCanvasElement","HTMLImageElement","Float32Array","setupTypedArray","Int32Array","Uint16Array","Uint8Array1","fallback","documentMode","doctype","processingInstances","processingInstanceIds","addInstance","externals","removeInstance","aCanvas","size3DCalled","pgraphicsMode","eventHandlers","attachEvent","detachEventHandler1","eventHandler","detachEvent","withMath","withProxyFunctions","withTouch","context","use3DContext","focused","glyphTable","keyCode","keyPressed","keyReleased","keyTyped","setup","__keyPressed","__frameRate","frameCount","curContext","curSketch","drawing","textcanvas","curveBasisMatrix","curveToBezierMatrix","curveDrawMatrix","bezierDrawMatrix","bezierBasisInverse","bezierBasisMatrix","programObject3D","programObject2D","programObjectUnlitShape","boxBuffer","boxNormBuffer","boxOutlineBuffer","rectBuffer","rectNormBuffer","sphereBuffer","lineBuffer","fillBuffer","fillColorBuffer","strokeColorBuffer","pointBuffer","shapeTexVBO","canTex","textTex","textBuffer","textureBuffer","indexBuffer","originalContext","setPixelsCached","sphereVerts","cam","cameraInv","modelView","modelViewInv","userMatrixStack","userReverseMatrixStack","inverseCopy1","projection","doFill","currentFillColor","isFillDirty","doStroke","strokeStyle","currentStrokeColor","isStrokeDirty","lineWidth","loopStarted","renderSmooth","doLoop","looping","curEllipseMode1","normalX","normalY","normalZ","normalMode","curMsPerFrame","oldCursor","cursor","curShape","curTightness","curveDet","curveInited","backgroundObj","bezDetail","colorModeA","colorModeX","colorModeY","colorModeZ","pmouseXLastFrame","pmouseYLastFrame","curColorMode","curTint","curTint3d","timeSinceLastFPS","framesSinceLastFPS","curContextCache","locations","curTexture","curTextureMode","usingTexture","horizontalTextAlignment","verticalTextAlignment","textMode","curFontName","curTextSize","curTextAscent","curTextDescent","curTextLeading","curTextFont","proxyContext","isContextReplaced","maxPixelsCached","pressedKeysMap","lastPressedKeyCode","codedKeys","lightCount","sphereDetailV","sphereDetailU","sphereX","sphereY","sphereZ","sinLUT","cosLUT","manipulatingCamera","cameraFOV","cameraX","cameraY","cameraZ","cameraNear","cameraFar","cameraAspect","vertArray1","curveVertArray","curveVertCount","isCurve","isBezier","firstVert","curShapeMode","styleArray","boxVerts","boxOutlineVerts","boxNorms","rectVerts","rectNorms","vertexShaderSrc3D","webglMaxTempsWorkaround","userAgent","uniformf","cacheId","programObj","varName","varValue","varLocation","getUniformLocation","uniform4fv","uniform3fv","uniform2fv","uniform1f","uniformi","uniform4iv","uniform3iv","uniform2iv","uniform1i","uniformMatrix","uniformMatrix4fv","uniformMatrix3fv","uniformMatrix2fv","vertexAttribPointer","VBO","getAttribLocation","bindBuffer","ARRAY_BUFFER","FLOAT","enableVertexAttribArray","disableVertexAttribPointer","disableVertexAttribArray","createProgramObject","vetexShaderSource","fragmentShaderSource","vertexShaderObject","createShader","VERTEX_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","fragmentShaderObject","FRAGMENT_SHADER","programObject","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","imageModeCorner","whAreSizes","imageModeConvert1","imageModeCorners","imageModeCenter","DrawingShared","Drawing2D","Drawing3D","DrawingPre","constructor","a3DOnlyFunction","shapeMode","mode","loadShape","loadXML","parseXML","printMatrixHelper1","big","PMatrixStack","matrixStack","color$4","aValue1","aValue2","aValue3","aValue4","g","rgb","toRGB","colorToHSB","colorInt","hue","saturation","saveContext","save","restoreContext","restore","redrawHelper","sec","fps","load","tmpMatrix","$newPMatrix","peek","delim","splitTokens","tokenized","append","array1","array2","numElem","ret","elemsToCopy","subset","end","seperator","shorten","ary","newary","expand","targetSize","newSize","arrayCopy","dest","srcPos","destPos","reverse","mix","peg","modes","applyMode","c1","ar","ag","ab","br","bg","bb","cr","cg","cb","c2","blend","subtract","lightest","darkest","difference","exclusion","multiply","screen","hard_light","soft_light","overlay","dodge","burn","color$1","toInt","toGLArray","q","brightness","colInt","aColor","alpha","lerpColor","r1","g1","b1","a1","r2","g2","b2","a2","hsb1","hsb2","colorBits1","colorBits2","colorMode","blendColor","printMatrix","pmatrix","transformm","pmatrix3d","setTransform","cnt","angleInRadians","newState","oldState","year","getFullYear","month","getMonth","day","getDate","hour","getHours","minute","getMinutes","second","getSeconds","millis","redraw","pmouseXLastEvent","pmouseYLastEvent","DEPTH_BUFFER_BIT","noLights","lightFalloff","shininess","ambient","specular","emissive","camera","noLoop","clearInterval","loop","setInterval","e_loop","frameRate","aRate","detach","PImage","toDataURL","noCursor","link","beginDraw","endDraw","toImageData","createImageData","uBuff","readPixels","RGBA","UNSIGNED_BYTE","ul","obj_data","binary","num","numBits","bit","unbinary","binaryString","mask","ch","decimalToHex","padding","hex","Number","unhexScalar","booleanScalar","floatScalar","intScalar","radix","unhex","loadStrings","filecontent","saveStrings","loadBytes","matchAll","aString","aRegExp","latest","results","parseBoolean","parseByte","bytes","parseChar","__int_cast","__instanceof","objType","$isInterface","$interfaces","$base","aWidth","aHeight","aMode","savedProperties","lineCap","lineJoin","removeProperty","textFont","background","getGLContext","gl","ctxNames","antialias","preserveDrawingBuffer","createTexture","e_size","viewport","enable","DEPTH_TEST","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","useProgram","createBuffer","bufferData","STATIC_DRAW","ELEMENT_ARRAY_BUFFER","perspective","ambientLight","view","normalizedCol","directionalLight","nx","ny","nz","mvm","dir","constant","linear","quadratic","lightSpecular","lights","pointLight","spotLight","concentration","beginCamera","endCamera","eyeX","eyeY","eyeZ","centerX","centerY","centerZ","upX","upY","upZ","xX","xY","xZ","yX","yY","yZ","zX","zY","zZ","fov","aspect","near","far","yMax","yMin","xMax","xMin","frustum","bottom","top","proj","ortho","printProjection","printCamera","model","POLYGON_OFFSET_FILL","polygonOffset","normalMatrix","drawArrays","disable","initSphere","v11","voff","executeContextFill","executeContextStroke","sphereDetail","ures","vres","cz","vertCount","currVert","angle_step","curradius","currY","sRad","LINE_STRIP","modelX","mv","ci","ax","ay","az","aw","ox","ow","modelY","oy","modelZ","oz","v3","shine","screenX","pj","screenZ","$ensureContext","smooth","setProperty","mozImageSmoothingEnabled","noSmooth","beginPath","isVert","point3D","vArray","cArray","STREAM_DRAW","line3D","ctxMode","LINE_LOOP","fill3D","tArray","fillStrokeClose","closePath","cachedVertArray","closeShape","fillVertArray","colorVertArray","strokeVertArray","texVertArray","vertArrayLength","bezierCurveTo","lineTo","lineVertArray","splineForward","segments","ff","fff","curveInit","lastPoint","z1","xplot1","xplot2","xplot3","yplot1","yplot2","yplot3","zplot1","zplot2","zplot3","texture","pimage","__texture","bindTexture","TEXTURE_2D","texImage2D","texParameteri","TEXTURE_MAG_FILTER","LINEAR","TEXTURE_MIN_FILTER","generateMipmap","pot","cvs","cvsTextureCtx","drawImage","sourceImg","LINEAR_MIPMAP_LINEAR","TEXTURE_WRAP_T","CLAMP_TO_EDGE","TEXTURE_WRAP_S","textureMode","curveVertexSegment","z2","z3","x4","y4","z4","x0","y0","z0","curve","curveTightness","tightness","curveDetail","aRectMode","aEllipseMode","hr","vr","drawSlice","closed","savedStroke","savedFill","swap","drawCrisp","currentModelView","identityMatrix","lineVerts","bezier","bezierDetail","bezierPoint","bezierTangent","curvePoint","curveTangent","roundedRect$2d","tl","tr","bl","halfWidth","halfHeight","quadraticCurveTo","c_x","C","c_y","xAv","yAv","normal","file","saveNumber","saveFrame","frameFilename","utilityContext2d","canvasDataCache","getCanvasData","canvasData","putImageData","clearRect","aFormat","__isDirty","fromHTMLImageData","aImg","imageData","format","updatePixels","pixels","getLength","isRemote","getPixel","setPixel","aL","get$4","fromImageData","get$5","cData","imgWidth","imgHeight","imgData","startRow","startColumn","stopRow","stopColumn","sourceOffset","targetOffset","resetContext","SetPixelContextWrapper","wrapFunction","newContext","wrapProperty","__isPImage","htmlImg","srcImg","dwidth","dheight","MODE","copy","swidth","sheight","filter","resize","loadPixels","canvasImg","createImage","loadImage","pimg","aPImage","requestImage","get$3","get$2","createGraphics","render","pg","set$4","hint","depthMask","backgroundHelper","arg3","arg4","clearColor","COLOR_BUFFER_BIT","htmlElement","tint","a3","a4","tintColor","noTint","sw","sh","dw","dh","pimgdest","sx2","sy2","dx2","dy2","intersect","blit_resize","buildBlurKernel","radius","shared","blurRadius","blurKernelSize","blurKernel","sharedBlurKernal","sharedBlurKernelSize","radiusiSquared","blurARGB","ca","read","ri","ym","ymi","bk0","wh","yi","aImgHeight","aImgWidth","sharedBlurRadius","pix","dilate","isInverted","currRowIdx","maxRowIdx","colOrig","colOut","currLum","idxRight","idxLeft","idxUp","idxDown","colRight","colLeft","colUp","colDown","lumRight","lumLeft","lumUp","lumDown","currIdx","maxIdx","out","lum","imglen","levels","levels1","rlevel","glevel","blevel","thresh","fracU","ifU","fracV","ifV","u1","u2","sX","sY","iw","iw1","ih1","ll","ur","lr","cUL","cLL","cUR","cLR","srcXOffset","srcYOffset","srcBuffer","sx1","sy1","dx1","dy1","blendFuncs","toP5String","text$4","lines","linesCount","yOffset","text$line","text$6","drawCommand","spaceMark","drawCommands","charPos","currentChar","spaceChar","letterWidth","xOffset","visibleLines","wireDimensionalFunctions","$init","createDrawingPreFunction","getKeyCode","suppressKeyEvent","updateKeyPressed","resetKeyPressed","simulateKeyTyped","srcX1","srcY1","srcX2","srcY2","destPixels","screenW","screenH","destX1","destY1","destX2","destY2","srcW","srcH","destW","destH","pshared","destOffset","filter_bilinear","filter_new_scanline","destColor","blendedColor","cULoffset","cURoffset","cLLoffset","cLRoffset","loadFont","loadGlyphs","units_per_em","horiz_adv_x","glyphLook","createFont","textSize","textAscent","textDescent","textLeading","textAlign","xalign","yalign","textWidth","textContext","one","two","three","four","five","six","seven","eight","nine","zero","dollar","exclam","quotedbl","numbersign","percent","ampersand","quotesingle","parenleft","parenright","asterisk","comma","hyphen","period","slash","underscore","colon","semicolon","less","equal","greater","question","at","bracketleft","backslash","bracketright","asciicircum","grave","braceleft","bar","braceright","asciitilde","align","newScale","textBaseline","scalefactor","drawElements","UNSIGNED_SHORT","lastCom","lenC","needle","hay","buildPath","com","xy","parseSVGFont","svg","font_face","unicode","implementation","createDocument","e_fx_op","message","async","e_sf_ch","xmlhttp","responseXML","tagName","onfocus","onblur","keyTrigger","getKeyChar","anyShiftPressed","shiftKey","ctrlKey","altKey","metaKey","executeSketch","setTimeout","msg","console","getInstanceById","prettyName","unsupportedP5","createUnsupportedFunc","setupParser","finalize","testHarness","ObjectIterator1"],"version":3,"file":"index.0da534d9.js.map"}