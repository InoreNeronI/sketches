{"mappings":"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","sources":["<anon>","src/bullet-hell/template/bosses.js"],"sourcesContent":["const BOSS = {};\nBOSS.boss1 = {\n    // AI\n    nextStage: \"enter\",\n    stages: {\n        enter: {\n            nextStage: \"ricochet\",\n            ai (b) {\n                // Force player back\n                if (pl.pos.y < MAP_HEIGHT * 3 / 4) pl.pos.y = lerp(pl.pos.y, MAP_HEIGHT * 3 / 4, 0.05 * dt());\n                // Move to next stage once positioned correctly\n                if (b.pos.y >= MAP_HEIGHT / 8) {\n                    b.pos.y = MAP_HEIGHT / 8;\n                    b.vel.y = 0;\n                    b.switchStage();\n                }\n            },\n            init (b) {\n                b.speed = 1;\n                b.vel = createVector(0, b.speed);\n                // Whether to do needle stage next\n                b.needleStage = random() < 0.5;\n            }\n        },\n        ricochet: {\n            nextStage: \"wait\",\n            timeLimit: 720,\n            ai (b) {\n                b.speed = lerp(b.speed, 3, 0.05 * dt());\n                b.vel.setMag(b.speed);\n                // Destroy player's bullets that go above wall\n                for(let i = 0; i < bullets.length; i++){\n                    let e = bullets[i];\n                    if (e.fromPlayer) e.mapTop = MAP_HEIGHT / 4;\n                }\n                // Fire ricochet bullets\n                b.fire();\n            },\n            attack (b) {\n                emitBullets(b.pos.x, b.pos.y, 90, [\n                    -45,\n                    0,\n                    45\n                ], 5, 5, BULLET.ricochet);\n            },\n            init (b) {\n                b.fireRate = 35;\n                b.vel = createVector(randSign(), 0);\n                pl.mapTop = MAP_HEIGHT / 4;\n                // Create a lightning wall\n                walls.push(new Wall(MAP_HEIGHT / 4, 20, true));\n            },\n            finish (b) {\n                b.vel.x = 0;\n                pl.mapTop = 0;\n                // Clear lightning walls\n                walls = [];\n            }\n        },\n        wait: {\n            nextStage: \"center\",\n            timeLimit: 120,\n            ai (b) {\n                b.pos.x = lerp(b.pos.x, width / 2, 0.05 * dt());\n            }\n        },\n        center: {\n            ai (b) {\n                if (b.pos.y >= MAP_HEIGHT / 2) {\n                    b.pos.y = MAP_HEIGHT / 2;\n                    b.vel.y = 0;\n                    b.nextStage = b.needleStage ? \"needle\" : \"spiral\";\n                    b.needleStage = !b.needleStage;\n                    b.switchStage();\n                }\n            },\n            init (b) {\n                b.vel.y = b.speed;\n            }\n        },\n        spiral: {\n            healthLimit: 0.3,\n            nextStage: \"up\",\n            timeLimit: 1200,\n            ai (b) {\n                b.fire();\n            },\n            attack (b) {\n                for(let i = 0; i < b.emitters.length; i++)b.emitters[i].fire();\n            },\n            finish (b) {\n                // Kill emitters\n                for(let i = 0; i < b.emitters.length; i++)b.emitters[i].dead = true;\n                b.emitters = [];\n            },\n            init (b) {\n                // Make cooldown 0\n                b.fireRate = 0;\n                // Create emitters\n                let e1 = new Emitter(-200, 0, b);\n                let e2 = new Emitter(200, 0, b);\n                applyTemplate(e1, {\n                    // Misc\n                    bulletTemplate: BULLET.basic,\n                    fireRate: 60,\n                    angles: [\n                        0,\n                        60,\n                        120,\n                        180,\n                        240,\n                        300\n                    ],\n                    angVel: 10,\n                    maxSpeed: 2,\n                    minSpeed: 2\n                });\n                let angles = [];\n                for(let i = 0; i < 6; i++){\n                    let a = 60 * i;\n                    for(let j = 0; j < 3; j++)angles.push(a + 15 * j);\n                }\n                applyTemplate(e2, {\n                    // Misc\n                    bulletTemplate: BULLET.basic,\n                    fireRate: 60,\n                    angles: angles,\n                    angVel: -10,\n                    maxSpeed: 1,\n                    minSpeed: 1\n                });\n                b.emitters = [\n                    e1,\n                    e2\n                ];\n            }\n        },\n        up: {\n            nextStage: \"clear\",\n            ai (b) {\n                if (b.pos.y <= MAP_HEIGHT / 8) {\n                    b.pos.y = MAP_HEIGHT / 8;\n                    b.vel.y = 0;\n                    b.switchStage();\n                }\n            },\n            init (b) {\n                b.vel = createVector(0, -b.speed / 4);\n            }\n        },\n        clear: {\n            nextStage: \"ricochet\",\n            timeLimit: 60,\n            ai (b) {\n                // Force player back\n                if (pl.pos.y < MAP_HEIGHT * 3 / 4) pl.pos.y = lerp(pl.pos.y, MAP_HEIGHT * 3 / 4, 0.05 * dt());\n            }\n        },\n        needle: {\n            healthLimit: 0.2,\n            nextStage: \"up\",\n            timeLimit: 1000,\n            ai (b) {\n                b.fire();\n            },\n            attack (b) {\n                let a = random(360);\n                emitBullets(b.pos.x, b.pos.y, a, [\n                    0,\n                    120,\n                    240\n                ], 3, 4, BULLET.twoStage);\n            },\n            init (b) {\n                b.fireRate = 50;\n            }\n        }\n    },\n    // Display\n    color: \"#009B90\",\n    model: MODEL.ship.boss1,\n    // Stats\n    hp: 380,\n    points: 2000,\n    // Methods\n    onHitLeft () {\n        this.pos.x = this.mapLeft + this.r * this.edgeRadius;\n        this.vel.x *= -1;\n    },\n    onHitRight () {\n        this.pos.x = this.mapRight - this.r * this.edgeRadius;\n        this.vel.x *= -1;\n    }\n};\nBOSS.heavyBomber = {\n    // AI\n    nextStage: \"enter\",\n    stages: {\n        enter: {\n            nextStage: \"bombs\",\n            ai (b) {\n                // Move to next stage once positioned correctly\n                if (b.pos.y >= MAP_HEIGHT / 6) {\n                    b.pos.y = MAP_HEIGHT / 6;\n                    b.vel.y = 0;\n                    b.switchStage();\n                }\n            },\n            init (b) {\n                b.speed = 1;\n                b.vel = createVector(0, b.speed);\n            }\n        },\n        bombs: {\n            nextStage: \"center\",\n            healthLimit: 0.2,\n            timeLimit: 900,\n            ai (b) {\n                b.speed = lerp(b.speed, 2, 0.05 * dt());\n                b.vel.setMag(b.speed);\n                if (random() < 0.003) b.vel.x *= -1;\n                // Fire large bombs\n                b.fire();\n            },\n            attack (b) {\n                let a = random() < 0.5 ? 0 : 180;\n                emitBullets(b.pos.x, b.pos.y, a, [\n                    0\n                ], 3, 5, BULLET.largeBomb);\n            },\n            init (b) {\n                b.fireRate = 70;\n                b.vel = createVector(randSign(), 0);\n            },\n            finish (b) {\n                b.vel.x = 0;\n            }\n        },\n        center: {\n            nextStage: \"repel\",\n            timeLimit: 260,\n            ai (b) {\n                b.pos.x = lerp(b.pos.x, width / 2, 0.05 * dt());\n            }\n        },\n        repel: {\n            nextStage: \"enemies\",\n            timeLimit: 60,\n            ai (b) {\n                // Force player back\n                if (pl.pos.y < MAP_HEIGHT * 3 / 4) pl.pos.y = lerp(pl.pos.y, MAP_HEIGHT * 3 / 4, 0.05 * dt());\n            }\n        },\n        enemies: {\n            nextStage: \"wait\",\n            timeLimit: 1200,\n            ai (b) {\n                // Destroy player's bullets that go above wall\n                for(let i = 0; i < bullets.length; i++){\n                    let e = bullets[i];\n                    if (e.fromPlayer) e.mapTop = MAP_HEIGHT / 3;\n                }\n                // Spawn enemies\n                b.fire();\n            },\n            attack (b) {\n                spawnEnemy();\n            },\n            init (b) {\n                b.fireRate = 80;\n                pl.mapTop = MAP_HEIGHT / 3;\n                // Create a lightning wall\n                walls.push(new Wall(MAP_HEIGHT / 3, 20, true));\n            }\n        },\n        wait: {\n            nextStage: \"delay\",\n            ai (b) {\n                // Destroy player's bullets that go above wall\n                for(let i = 0; i < bullets.length; i++){\n                    let e = bullets[i];\n                    if (e.fromPlayer) e.mapTop = MAP_HEIGHT / 3;\n                }\n                if (enemies.length === 0) b.switchStage();\n            },\n            finish (b) {\n                pl.mapTop = 0;\n                // Clear lightning walls\n                walls = [];\n            }\n        },\n        delay: {\n            nextStage: \"bullets\",\n            timeLimit: 60\n        },\n        bullets: {\n            nextStage: \"bombs\",\n            healthLimit: 0.2,\n            timeLimit: 1200,\n            ai (b) {\n                b.fire();\n            },\n            attack (b) {\n                let a = random(30, 150);\n                emitBullets(b.pos.x, b.pos.y, a, [\n                    0\n                ], 4, 5, BULLET.large);\n                if (random() < 0.1) {\n                    let a = random(30, 150);\n                    emitBullets(b.pos.x, b.pos.y, a, [\n                        0\n                    ], 0, 3, BULLET.bomb);\n                }\n            },\n            init (b) {\n                b.fireRate = 50;\n            },\n            finish (b) {}\n        }\n    },\n    // Display\n    color: \"#009C41\",\n    model: MODEL.ship.heavyBomber,\n    // Physics\n    r: 54,\n    // Stats\n    hp: 440,\n    points: 2000,\n    // Methods\n    onHitLeft () {\n        this.pos.x = this.mapLeft + this.r * this.edgeRadius;\n        this.vel.x *= -1;\n    },\n    onHitRight () {\n        this.pos.x = this.mapRight - this.r * this.edgeRadius;\n        this.vel.x *= -1;\n    }\n};\n\n//# sourceMappingURL=index.9edf6f20.js.map\n","const BOSS = {};\n\nBOSS.boss1 = {\n  // AI\n  nextStage: 'enter',\n  stages: {\n    enter: {\n      nextStage: 'ricochet',\n      ai(b) {\n        // Force player back\n        if (pl.pos.y < (MAP_HEIGHT * 3) / 4) {\n          pl.pos.y = lerp(pl.pos.y, (MAP_HEIGHT * 3) / 4, 0.05 * dt());\n        }\n\n        // Move to next stage once positioned correctly\n        if (b.pos.y >= MAP_HEIGHT / 8) {\n          b.pos.y = MAP_HEIGHT / 8;\n          b.vel.y = 0;\n          b.switchStage();\n        }\n      },\n      init(b) {\n        b.speed = 1;\n        b.vel = createVector(0, b.speed);\n        // Whether to do needle stage next\n        b.needleStage = random() < 0.5;\n      },\n    },\n    ricochet: {\n      nextStage: 'wait',\n      timeLimit: 720,\n      ai(b) {\n        b.speed = lerp(b.speed, 3, 0.05 * dt());\n        b.vel.setMag(b.speed);\n\n        // Destroy player's bullets that go above wall\n        for (let i = 0; i < bullets.length; i++) {\n          let e = bullets[i];\n          if (e.fromPlayer) e.mapTop = MAP_HEIGHT / 4;\n        }\n\n        // Fire ricochet bullets\n        b.fire();\n      },\n      attack(b) {\n        emitBullets(b.pos.x, b.pos.y, 90, [-45, 0, 45], 5, 5, BULLET.ricochet);\n      },\n      init(b) {\n        b.fireRate = 35;\n        b.vel = createVector(randSign(), 0);\n        pl.mapTop = MAP_HEIGHT / 4;\n\n        // Create a lightning wall\n        walls.push(new Wall(MAP_HEIGHT / 4, 20, true));\n      },\n      finish(b) {\n        b.vel.x = 0;\n        pl.mapTop = 0;\n\n        // Clear lightning walls\n        walls = [];\n      },\n    },\n    wait: {\n      nextStage: 'center',\n      timeLimit: 120,\n      ai(b) {\n        b.pos.x = lerp(b.pos.x, width / 2, 0.05 * dt());\n      },\n    },\n    center: {\n      ai(b) {\n        if (b.pos.y >= MAP_HEIGHT / 2) {\n          b.pos.y = MAP_HEIGHT / 2;\n          b.vel.y = 0;\n          b.nextStage = b.needleStage ? 'needle' : 'spiral';\n          b.needleStage = !b.needleStage;\n          b.switchStage();\n        }\n      },\n      init(b) {\n        b.vel.y = b.speed;\n      },\n    },\n    spiral: {\n      healthLimit: 0.3,\n      nextStage: 'up',\n      timeLimit: 1200,\n      ai(b) {\n        b.fire();\n      },\n      attack(b) {\n        for (let i = 0; i < b.emitters.length; i++) {\n          b.emitters[i].fire();\n        }\n      },\n      finish(b) {\n        // Kill emitters\n        for (let i = 0; i < b.emitters.length; i++) {\n          b.emitters[i].dead = true;\n        }\n        b.emitters = [];\n      },\n      init(b) {\n        // Make cooldown 0\n        b.fireRate = 0;\n\n        // Create emitters\n        let e1 = new Emitter(-200, 0, b);\n        let e2 = new Emitter(200, 0, b);\n        applyTemplate(e1, {\n          // Misc\n          bulletTemplate: BULLET.basic,\n          fireRate: 60,\n          angles: [0, 60, 120, 180, 240, 300],\n          angVel: 10,\n          maxSpeed: 2,\n          minSpeed: 2,\n        });\n        let angles = [];\n        for (let i = 0; i < 6; i++) {\n          let a = 60 * i;\n          for (let j = 0; j < 3; j++) {\n            angles.push(a + 15 * j);\n          }\n        }\n        applyTemplate(e2, {\n          // Misc\n          bulletTemplate: BULLET.basic,\n          fireRate: 60,\n          angles: angles,\n          angVel: -10,\n          maxSpeed: 1,\n          minSpeed: 1,\n        });\n        b.emitters = [e1, e2];\n      },\n    },\n    up: {\n      nextStage: 'clear',\n      ai(b) {\n        if (b.pos.y <= MAP_HEIGHT / 8) {\n          b.pos.y = MAP_HEIGHT / 8;\n          b.vel.y = 0;\n          b.switchStage();\n        }\n      },\n      init(b) {\n        b.vel = createVector(0, -b.speed / 4);\n      },\n    },\n    clear: {\n      nextStage: 'ricochet',\n      timeLimit: 60,\n      ai(b) {\n        // Force player back\n        if (pl.pos.y < (MAP_HEIGHT * 3) / 4) {\n          pl.pos.y = lerp(pl.pos.y, (MAP_HEIGHT * 3) / 4, 0.05 * dt());\n        }\n      },\n    },\n    needle: {\n      healthLimit: 0.2,\n      nextStage: 'up',\n      timeLimit: 1000,\n      ai(b) {\n        b.fire();\n      },\n      attack(b) {\n        let a = random(360);\n        emitBullets(b.pos.x, b.pos.y, a, [0, 120, 240], 3, 4, BULLET.twoStage);\n      },\n      init(b) {\n        b.fireRate = 50;\n      },\n    },\n  },\n  // Display\n  color: '#009B90',\n  model: MODEL.ship.boss1,\n  // Stats\n  hp: 380,\n  points: 2000,\n  // Methods\n  onHitLeft() {\n    this.pos.x = this.mapLeft + this.r * this.edgeRadius;\n    this.vel.x *= -1;\n  },\n  onHitRight() {\n    this.pos.x = this.mapRight - this.r * this.edgeRadius;\n    this.vel.x *= -1;\n  },\n};\n\nBOSS.heavyBomber = {\n  // AI\n  nextStage: 'enter',\n  stages: {\n    enter: {\n      nextStage: 'bombs',\n      ai(b) {\n        // Move to next stage once positioned correctly\n        if (b.pos.y >= MAP_HEIGHT / 6) {\n          b.pos.y = MAP_HEIGHT / 6;\n          b.vel.y = 0;\n          b.switchStage();\n        }\n      },\n      init(b) {\n        b.speed = 1;\n        b.vel = createVector(0, b.speed);\n      },\n    },\n    bombs: {\n      nextStage: 'center',\n      healthLimit: 0.2,\n      timeLimit: 900,\n      ai(b) {\n        b.speed = lerp(b.speed, 2, 0.05 * dt());\n        b.vel.setMag(b.speed);\n        if (random() < 0.003) b.vel.x *= -1;\n\n        // Fire large bombs\n        b.fire();\n      },\n      attack(b) {\n        let a = random() < 0.5 ? 0 : 180;\n        emitBullets(b.pos.x, b.pos.y, a, [0], 3, 5, BULLET.largeBomb);\n      },\n      init(b) {\n        b.fireRate = 70;\n        b.vel = createVector(randSign(), 0);\n      },\n      finish(b) {\n        b.vel.x = 0;\n      },\n    },\n    center: {\n      nextStage: 'repel',\n      timeLimit: 260,\n      ai(b) {\n        b.pos.x = lerp(b.pos.x, width / 2, 0.05 * dt());\n      },\n    },\n    repel: {\n      nextStage: 'enemies',\n      timeLimit: 60,\n      ai(b) {\n        // Force player back\n        if (pl.pos.y < (MAP_HEIGHT * 3) / 4) {\n          pl.pos.y = lerp(pl.pos.y, (MAP_HEIGHT * 3) / 4, 0.05 * dt());\n        }\n      },\n    },\n    enemies: {\n      nextStage: 'wait',\n      timeLimit: 1200,\n      ai(b) {\n        // Destroy player's bullets that go above wall\n        for (let i = 0; i < bullets.length; i++) {\n          let e = bullets[i];\n          if (e.fromPlayer) e.mapTop = MAP_HEIGHT / 3;\n        }\n\n        // Spawn enemies\n        b.fire();\n      },\n      attack(b) {\n        spawnEnemy();\n      },\n      init(b) {\n        b.fireRate = 80;\n        pl.mapTop = MAP_HEIGHT / 3;\n\n        // Create a lightning wall\n        walls.push(new Wall(MAP_HEIGHT / 3, 20, true));\n      },\n    },\n    wait: {\n      nextStage: 'delay',\n      ai(b) {\n        // Destroy player's bullets that go above wall\n        for (let i = 0; i < bullets.length; i++) {\n          let e = bullets[i];\n          if (e.fromPlayer) e.mapTop = MAP_HEIGHT / 3;\n        }\n\n        if (enemies.length === 0) b.switchStage();\n      },\n      finish(b) {\n        pl.mapTop = 0;\n\n        // Clear lightning walls\n        walls = [];\n      },\n    },\n    delay: {\n      nextStage: 'bullets',\n      timeLimit: 60,\n    },\n    bullets: {\n      nextStage: 'bombs',\n      healthLimit: 0.2,\n      timeLimit: 1200,\n      ai(b) {\n        b.fire();\n      },\n      attack(b) {\n        let a = random(30, 150);\n        emitBullets(b.pos.x, b.pos.y, a, [0], 4, 5, BULLET.large);\n\n        if (random() < 0.1) {\n          let a = random(30, 150);\n          emitBullets(b.pos.x, b.pos.y, a, [0], 0, 3, BULLET.bomb);\n        }\n      },\n      init(b) {\n        b.fireRate = 50;\n      },\n      finish(b) {},\n    },\n  },\n  // Display\n  color: '#009C41',\n  model: MODEL.ship.heavyBomber,\n  // Physics\n  r: 54,\n  // Stats\n  hp: 440,\n  points: 2000,\n  // Methods\n  onHitLeft() {\n    this.pos.x = this.mapLeft + this.r * this.edgeRadius;\n    this.vel.x *= -1;\n  },\n  onHitRight() {\n    this.pos.x = this.mapRight - this.r * this.edgeRadius;\n    this.vel.x *= -1;\n  },\n};\n"],"names":["BOSS","boss1","nextStage","stages","enter","ai","b","pl","pos","y","MAP_HEIGHT","lerp","dt","vel","switchStage","init","speed","createVector","needleStage","random","ricochet","timeLimit","setMag","i","bullets","length","e","fromPlayer","mapTop","fire","attack","emitBullets","x","BULLET","fireRate","randSign","walls","push","Wall","finish","wait","width","center","spiral","healthLimit","emitters","dead","e1","Emitter","e2","applyTemplate","bulletTemplate","basic","angles","angVel","maxSpeed","minSpeed","a","j","up","clear","needle","twoStage","color","model","MODEL","ship","hp","points","onHitLeft","mapLeft","r","edgeRadius","onHitRight","mapRight","heavyBomber","bombs","largeBomb","repel","enemies","spawnEnemy","delay","large","bomb"],"version":3,"file":"index.9edf6f20.js.map"}