{"mappings":"","sources":["src/supratetris/js/Grid.js"],"sourcesContent":["class Grid {\n  constructor(w, h, cellSize) {\n    this.w = w;\n    this.h = h;\n    this.cellSize = cellSize;\n\n    this.grid = [];\n\n    this.targetColour = -1;\n  }\n\n  createGrid() {\n    for (let i = 0; i < this.w; i++) {\n      let col = [];\n\n      for (let j = 0; j < this.h; j++) {\n        col.push(new Cell(i, j, this.cellSize));\n      }\n\n      this.grid.push(col);\n    }\n\n    let lastRow = [];\n\n    for (let i = 0; i < this.w; i++) {\n      if (i > this.w * 0.55) lastRow.push(true);\n      else lastRow.push(false);\n    }\n\n    shuffle(lastRow, true);\n\n    for (let i = 0; i < this.w; i++) {\n      this.grid[i][this.h - 1].dead = lastRow[i];\n    }\n  }\n\n  update() {}\n\n  validate() {\n    let numberSelected = 0;\n\n    for (let i = 0; i < this.w; i++) {\n      for (let j = 0; j < this.h; j++) {\n        if (this.grid[i][j].selected) numberSelected++;\n      }\n    }\n\n    if (numberSelected != 4) return false;\n\n    for (let i = 0; i < targets.length; i++) {\n      if (this.gridContains(targets[i].shape)) {\n        this.targetColour = targets[i].colour;\n        targets[i].newShape();\n        return true;\n      }\n    }\n\n    playSoundFromArray('incompleteShape');\n    return false;\n  }\n\n  gridContains(shape) {\n    let firstGridCell = -1;\n\n    dance: for (let j = 0; j < this.h; j++) {\n      for (let i = 0; i < this.w; i++) {\n        if (this.grid[i][j].selected) {\n          firstGridCell = [i, j];\n          break dance;\n        }\n      }\n    }\n\n    let firstTargetCell = -1;\n    let targetShapeCount = 0;\n\n    for (let i = 0; i < shape[0].length; i++) {\n      for (let j = 0; j < shape.length; j++) {\n        if (shape[i][j]) {\n          targetShapeCount++;\n\n          if (firstTargetCell == -1) {\n            firstTargetCell = [j, i];\n          } else {\n            if (firstGridCell[0] + j - firstTargetCell[0] >= this.w || firstGridCell[0] + j - firstTargetCell[0] < 0) return false;\n            let cell = this.grid[firstGridCell[0] + j - firstTargetCell[0]][firstGridCell[1] + i - firstTargetCell[1]];\n\n            if (cell instanceof Cell && !cell.selected) {\n              return false;\n            }\n          }\n\n          let potentialX = firstGridCell[0] + j - firstTargetCell[0];\n          let potentialY = firstGridCell[1] + i - firstTargetCell[1];\n\n          let cellBelow = this.grid[potentialX][potentialY + 1];\n\n          if (cellBelow instanceof Cell && !cellBelow.selected && !cellBelow.dead) {\n            return false;\n          }\n\n          if (targetShapeCount == 4) return true;\n        }\n      }\n    }\n  }\n\n  dropSelected() {\n    for (let i = 0; i < this.w; i++) {\n      for (let j = 0; j < this.h; j++) {\n        if (this.grid[i][j].selected) {\n          this.grid[i][j].selected = false;\n          this.grid[i][j].dead = true;\n          fallingCells.push(new FallingCell(this.grid[i][j].xPos, this.grid[i][j].yPos, this.cellSize, this.targetColour));\n        }\n      }\n    }\n  }\n\n  addNewRow() {\n    for (let i = 0; i < this.w; i++) {\n      for (let j = 0; j < this.h; j++) {\n        if (this.grid[i][j].dead) {\n          if (random() < 0.5) this.grid[i][j].dead = false;\n          break;\n        }\n      }\n    }\n  }\n\n  hover() {\n    let numberSelected = 0;\n\n    for (let i = 0; i < this.w; i++) {\n      for (let j = 0; j < this.h; j++) {\n        if (this.grid[i][j].selected) numberSelected++;\n      }\n    }\n\n    for (let i = 0; i < this.w; i++) {\n      for (let j = 0; j < this.h; j++) {\n        if (this.grid[i][j].hover()) {\n          if (numberSelected >= 4 && !this.grid[i][j].selected) {\n            return false;\n          } else {\n            this.grid[i][j].selected = !this.grid[i][j].selected;\n            if (this.grid[i][j].selected && numberSelected <= 2) sounds.selectBlock[numberSelected].play();\n            if (!this.grid[i][j].selected) playSoundFromArray('deselectBlock');\n\n            if (!interacted) {\n              interacted = true;\n              sounds.music.play();\n            }\n\n            return true;\n          }\n        }\n      }\n    }\n  }\n\n  clearSelected() {\n    for (let i = 0; i < this.w; i++) {\n      for (let j = 0; j < this.h; j++) {\n        if (this.grid[i][j].selected) this.grid[i][j].selected = false;\n      }\n    }\n  }\n\n  updateScore() {\n    let actualScore = 0;\n\n    for (let i = 0; i < this.w; i++) {\n      for (let j = 0; j < this.h; j++) {\n        if (!this.grid[i][j].dead) actualScore++;\n      }\n    }\n\n    if (score == -1 || actualScore < score) {\n      score = actualScore;\n    }\n  }\n\n  display() {\n    push();\n    translate(width / 2, height / 2);\n    translate((-this.cellSize * this.w) / 2, (-this.cellSize * this.h) / 2);\n\n    fill(palette.blacker);\n    strokeWeight(5);\n    stroke(palette.blackest);\n    rectMode(CORNER);\n    rect(-this.cellSize / 2, -this.cellSize / 2, this.w * this.cellSize + this.cellSize, height, 40);\n    rectMode(CENTER);\n    strokeWeight(1);\n\n    translate(this.cellSize / 2, this.cellSize / 2);\n\n    for (let i = 0; i < this.w; i++) {\n      for (let j = 0; j < this.h; j++) {\n        this.grid[i][j].display();\n      }\n    }\n\n    pop();\n  }\n}\n"],"names":[],"version":3,"file":"index.ea5d79a7.js.map"}